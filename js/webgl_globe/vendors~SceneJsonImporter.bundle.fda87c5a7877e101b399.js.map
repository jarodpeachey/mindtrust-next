{"version":3,"sources":["webpack:///./node_modules/@polygonjs/polygonjs/src/engine/scene/utils/CamerasController.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/scene/utils/Cooker.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/scene/utils/CookController.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/core/graph/CoreGraph.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/core/performance/PerformanceNode.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/core/performance/CorePerformance.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/scene/utils/events/SceneEventsController.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/scene/utils/DispatchController.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/scene/utils/ExpressionsController.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/scene/utils/LifeCycleController.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/scene/utils/events/_BaseEventsController.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/scene/utils/LoadingController.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/expressions/MissingReference.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/scene/utils/MissingReferencesController.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/nodes/manager/_Base.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/scene/utils/ObjectsController.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/nodes/manager/ObjectsManager.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/scene/utils/NodesController.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/scene/utils/Serializer.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/scene/utils/events/MouseEventsController.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/nodes/event/_BaseInput.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/nodes/event/Mouse.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/scene/utils/events/PointerEventsController.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/nodes/event/Pointer.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/nodes/event/Scene.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/scene/utils/events/KeyboardEventsController.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/nodes/event/Keyboard.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/scene/utils/events/EventsDispatcher.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/poly/SceneEvent.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/scene/utils/ReferencesController.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/scene/utils/TimeController.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/scene/utils/UniformsController.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/scene/utils/ViewersRegister.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/scene/utils/WebGLController.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/scene/utils/AssetsController.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/scene/PolyScene.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/io/json/import/Param.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/io/json/import/OptimizedNodes.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/io/json/import/Nodes.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/io/json/import/Node.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/io/json/import/param/Multiple.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/io/json/import/param/String.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/io/json/import/param/Ramp.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/io/json/import/nodes/Poly.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/io/json/import/Dispatcher.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/io/json/import/ImportReport.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/io/json/import/Scene.ts"],"names":["CamerasController","scene","_masterCameraNodePath","camera_node_path","this","masterCameraNodePath","path","_find_any_camera","node","console","warn","root","nodesByType","Cooker","_scene","_queue","Map","_block_level","_process_item_bound","_process_item","bind","process_queue","original_trigger_graph_node","set","graphNodeId","blocked","forEach","id","graph","node_from_id","delete","dirtyController","run_post_dirty_hooks","CookController","_cooking_nodes_by_id","_resolves","size","flush","callback","pop","Promise","resolve","reject","push","CoreGraph","_next_id","_successors","_predecessors","_nodes_by_id","_nodesCount","_debugging","_addedNodesDuringDebugging","log","nodeId","graphPredecessors","graphSuccessors","ids","nodes","get","src","dest","check_if_graph_may_have_cycle","src_id","dest_id","has_node","loadingController","isLoading","graph_would_have_cycle","_has_predecessor","_create_connection","clear_successors_cache_with_predecessors","_remove_connection","predecessors","predecessor","disconnect","successors","successor","map","bool","predecessor_ids","nodes_from_ids","successor_ids","all_next_ids","all_predecessor_ids","all_successor_ids","node_successors","Set","has","add","node_predecessors","method","ids_by_id","next_ids","length","next_next_ids","next_id","next_next_id","includes","PerformanceNode","_node","_cooks_count","_total_cook_time","_total_inputs_time","_total_params_time","performance_data","cook_time","inputs_time","params_time","fullPath","cooks_count","total_time","total_cook_time","cook_time_per_iteration","inputs_time_per_iteration","params_time_per_iteration","params_time_per_iteration2","_started","_start_time","_previous_timestamp","_nodes_cook_data","_durations_by_name","_durations_count_by_name","name","start_time","performance","now","reset","update_cook_data","started","start","current_timestamp","print_node_cook_data","print_recordings","performance_nodes","Object","values","ArrayUtils","sortBy","performance_node","print_objects","print_object","table_entries","sorted_print_objects","table","durations_by_name","ObjectUtils","clone","durations_count_by_name","durations","names_by_duration","keys","duration","sort","a","b","sorted_durations","uniq","names","count","entry","duration_per_iteration","SceneEventType","DispatchController","events_listener","_events_listener","run_on_add_listener_callbacks","_on_add_listener_callbacks","undefined","emitter","event_name","data","process_events","loaded","autoUpdating","ExpressionsController","_params_by_id","param","nameController","graph_node","setSuccessorsDirty","LifeCycleController","_lifecycle_on_create_allowed","BaseSceneEventsController","dispatcher","_nodes_by_graph_node_id","_require_canvas_event_listeners","_active_event_types","updateViewerEventListeners","event_context","process_event","_update_active_event_types","viewersRegister","traverseViewers","viewer","eventsController","updateEvents","active_node_event_types_state","parent","node_active_event_names","active_event_names","state","ACCEPTED_SCENE_EVENT_TYPES","LOADED","PLAY","PAUSE","TICK","n","_loading_state","_auto_updating","_first_object_loaded","_LOADED_EVENT_CONTEXT","event","Event","_set_loading_state","missingExpressionReferencesController","resolve_missing_references","trigger_loaded_event","globalThis","eventsDispatcher","sceneEventsController","processEvent","LOADED_EVENT_CONTEXT","set_auto_update","new_state","processQueue","loader","document","getElementById","parentElement","removeChild","make_absolute_path","absolute_path","expressionController","update_from_method_dependency_name_change","input","rawInputSerialized","defaultValue","references","jsep_node","path_argument","missing_expression_reference","MapUtils","push_on_array_at_entry","resolved_references","reference","_is_reference_resolvable","resolve_missing_dependencies","paths","split_parent_child","child","parent_node","params","_check_for_missing_references_for_node","all","_check_for_missing_references_for_param","missing_references","node_id","match_found","ref","matches_path","NodeContext","MANAGER","mask","findObjectByMaskInObject","threejsScene","object","objectPath","children","childName","_removeTrailingOrHeadingSlash","matchMask","grandChild","objectsByMaskInObject","list","objectName","substr","params_config","_object","Group","_queued_nodes_by_id","_children_controller_context","OBJ","matrixAutoUpdate","lifecycle","add_on_child_add_hook","_on_child_add","add_on_child_remove_hook","_on_child_remove","node_class","params_init_value_overrides","super","createNode","type","queued_nodes_by_path","renderOrder","clear","path_id","_addToScene","_addToQueue","attachableToHierarchy","node_input","io","inputs","children_group","parent_object","getParentForNode","usedInScene","childrenDisplayController","request_display_node_container","addObjectToParent","removeObjectFromParent","cookController","isCooking","isDisplayNodeCooking","_update_object","_removeFromScene","_node_context_signatures","_instanciated_nodes_by_context_and_type","_root","initialize_base_and_node","initDefaultScene","childrenController","_traverseNode","removeNode","current_parents","cmptr","current_parent","childrenAllowed","flat","concat","allNodes","matching_nodes","node_context_signature","s","toLowerCase","context","nodeContext","node_type","nodes_for_context","nodes_by_ids","include_node_param_components","nodes_by_graph_node_id","params_by_graph_node_id","nodesController","node_serializer","toJSON","MouseEventType","ACCEPTED_MOUSE_EVENT_TYPES","auxclick","click","contextmenu","dblclick","mousedown","mouseenter","mouseleave","mousemove","mouseover","mouseout","mouseup","pointerlockchange","pointerlockerror","select","wheel","EVENT_PARAM_OPTIONS","visibleIf","active","BaseInputEventNodeClass","PARAM_CALLBACK_update_register","_active_event_names","initializeBaseNode","add_on_add_hook","registerEventNode","add_delete_hook","unregisterEventNode","onParamsCreated","_update_register","pv","dispatch_event_to_output","_update_active_event_names","accepted_event_types","value","BOOLEAN","sep","SEPARATOR","outputs","setNamedOutputConnectionPoints","event_type","MOUSE","PointerEventType","ACCEPTED_POINTER_EVENT_TYPES","pointerdown","pointermove","pointerup","POINTER","SceneNodeInput","SceneNodeOutput","sceneLoaded","play","pause","tick","sep0","treachedTime","PARAM_CALLBACK_update_time_dependency","reachedTime","INTEGER","range","sep1","setFrameValue","setFrame","BUTTON","PARAM_CALLBACK_setFrame","dispose","setNamedInputConnectionPoints","SET_FRAME","BASE","onSetFrame","out_connection_points","TIME_REACHED","update_time_dependency","time","CoreGraphNode","addGraphInput","timeController","graphNode","addPostDirtyHook","on_frame_update","graphDisconnectPredecessors","KeyboardEventType","ACCEPTED_KEYBOARD_EVENT_TYPES","keydown","keypress","keyup","KEYBOARD","_controllers","controller","_find_or_create_controller_for_node","registerNode","unregisterNode","keyboardEventsController","mouseEventsController","pointerEventsController","_keyboard_events_controller","_create_controller","_mouse_events_controller","_pointer_events_controller","_scene_events_controller","event_constructor","SceneEvent","_referenced_nodes_by_src_param_id","_referencing_params_by_referenced_node_id","_referencing_params_by_all_named_node_ids","src_param","referenced_node","named_nodes","decomposed_path","named_node","pop_from_array_at_entry","node_by_node_id","path_param_types","ParamType","OPERATOR_PATH","NODE_PATH","path_params","nodes_by_id","path_param","_check_param","OperatorPath","found_node","found_param","referencing_params","referencing_param","notify_path_rebuild_required","options","is_selecting_param","notify_target_param_owner_params_updated","_frame","_time","_prev_performance_now","_realtimeState","_maxFrame","_maxFrameLocked","_playing","_graph_node","_PLAY_EVENT_CONTEXT","_PAUSE_EVENT_CONTEXT","_TICK_EVENT_CONTEXT","maxFrame","Math","floor","dispatchController","dispatch","MAX_FRAME_UPDATED","REALTIME_STATUS_UPDATED","update_frame","new_frame","bounded_frame","_ensureFrameWithinBounds","FRAME_UPDATED","uniforms_controller","update_time_dependent_uniform_owners","cooker","block","unblock","TICK_EVENT_CONTEXT","frame","update_time","setTime","START_FRAME","areChildrenCooking","incrementTime","performance_now","delta","new_time","PLAY_STATE_UPDATED","PAUSE_EVENT_CONTEXT","PLAY_EVENT_CONTEXT","playing","_time_dependent_uniform_owners","_time_dependent_uniform_owners_ids","_resolution","Vector2","_resolution_dependent_uniform_owners","_resolution_dependent_uniform_owners_ids","uniforms","index","indexOf","splice","update_resolution_dependent_uniforms","resolution","copy","x","window","devicePixelRatio","y","ViewersRegister","_viewers_by_id","_require_webgl2","Poly","renderersController","setRequireWebGL2","SceneAssetsController","_assets_root","url","_threejsScene","Scene","_cameras_controller","_cooker","_graph","_missing_expression_references_controller","_expressions_controller","_nodes_controller","_objects_controller","_references_controller","_time_controller","_read_only","set_scene","init","uuid","_uuid","_name","camerasController","masterCameraNode","_assets_controller","waitForCooksCompleted","_dispatch_controller","_events_dispatcher","_lifecycle_controller","_loading_controller","findObjectByMask","objectsByMask","_performance","_viewers_register","setFrameToStart","_serializer","serializer","requester","_read_only_requester","_uniforms_controller","_webgl_controller","ParamJsonImporter","_param","raw_input","add_main","params_data","params_data_value","spare","non_spare_params_data","param_names","param_data","param_name","overriden_options","complex_data","simple_data","_nodes","_optimized_root_node_names","_operation_containers_by_name","_node_inputs","scene_importer","optimized_names","child_names_by_optimized_state","node_name","is_optimized_root_node","node_data","setName","flags","display","operation_container","_create_operation_container","set_output_operation_container","output_operation_container","_add_optimized_node_inputs","setCount","i","setInput","current_operation_container","inputs_data","input_data","isString","input_node_data","is_node_optimized","add_input","input_node","node_input_index","add_input_config","operation_input_index","current_input_index","increment_input_index","cloned_state_overriden","override_input_clone_state","node_names","non_optimized_names","playerMode","outputs_count","non_optimized_count","current_node_name","output_names","node_outputs","is_optimized_root_node_generic","optimize","output_nodes","connections","outputConnections","c","node_dest","output_node","output_node_names","non_spare_params_data_value","operation_type","create_operation_container","path_param_resolve_required","add_operation_container_with_path_param_resolve_required","add_operations_composer_node_with_path_param_resolve_required","is_node_bypassed","node_flags","nonOptimizedNodes","e","error","nodeType","camelCase","report","add_warning","optimized_nodes_importer","process_data","SOP","nodeNames","nodeNameWithDisplayFlag","nodeName","existingNodeNames","optimizedNodes","optimizedNode","message","importers_by_node_name","importer","dispatch_node","process_inputs_data","COMPLEX_PARAM_DATA_KEYS","set_connection_points","create_nodes","set_selection","overrideClonedStateAllowed","override","overrideClonedState","set_flags","set_params","persisted_config","set_persisted_config","from_data_custom","maxInputsCount","setInputs","ui_data","uiData","pos","vector","fromArray","setPosition","comment","setComment","process_nodes_ui_data","selected_nodes","selection","bypass","connection_points_data","saved_connection_points_data","set_in","set_out","has_connection_points_controller","connection_points","update_signature_if_required","input_node_name","nodeSibbling","input_index","process_ui_data","params_update_options","param_type","has_param_and_same_type","has_param","_is_param_data_complex","_process_param_data_complex","_process_param_data_simple","names_to_delete","to_add","init_value","params_delete_required","params_add_required","update_params","spare_param","parent_param","runOnSceneLoadHooks","dispatch_param","isNumber","isArray","isBoolean","isObject","complex_key","persisted_config_data","load","LINE_BREAK_REGEXP","replace","polyNodeController","createChildNodesFromDefinition","Ramp","ImportReport","_scene_importer","_warnings","_data","markAsLoading","properties","setMaxFrame","maxFrameLocked","setMaxFrameLocked","realtimeState","setRealtimeState","setMasterCameraNodePath","_base_operations_composer_nodes_with_resolve_required","_resolve_operation_containers_with_path_param_resolve","markAsLoaded","operations_composer_node","resolve_operation_containers_path_params"],"mappings":"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","file":"vendors~SceneJsonImporter.bundle.fda87c5a7877e101b399.js","sourcesContent":["import {PolyScene} from '../PolyScene';\nimport {BaseCameraObjNodeType} from '../../nodes/obj/_BaseCamera';\n\nexport class CamerasController {\n\tconstructor(private scene: PolyScene) {}\n\n\t_masterCameraNodePath: string | null = null;\n\n\tsetMasterCameraNodePath(camera_node_path: string) {\n\t\tthis._masterCameraNodePath = camera_node_path;\n\t}\n\tmasterCameraNodePath() {\n\t\treturn this._masterCameraNodePath;\n\t}\n\tmasterCameraNode(): BaseCameraObjNodeType | null {\n\t\tif (this.masterCameraNodePath) {\n\t\t\tconst path = this.masterCameraNodePath();\n\t\t\tif (!path) {\n\t\t\t\treturn this._find_any_camera();\n\t\t\t}\n\t\t\tconst camera_node = this.scene.node(path) as BaseCameraObjNodeType | null;\n\t\t\treturn camera_node;\n\t\t} else {\n\t\t\tconsole.warn('master camera node not found');\n\t\t\treturn this._find_any_camera();\n\t\t}\n\t}\n\n\tprivate _find_any_camera(): BaseCameraObjNodeType | null {\n\t\tconst root = this.scene.root();\n\t\treturn root.nodesByType('perspectiveCamera')[0] || root.nodesByType('orthographicCamera')[0];\n\t}\n}\n","// import {CoreGraphNode} from './CoreGraphNode';\n// import { CoreGraphNodeScene } from './CoreGraphNodeScene';\nimport {CoreGraphNodeId} from '../../../core/graph/CoreGraph';\nimport {CoreGraphNode} from '../../../core/graph/CoreGraphNode';\nimport {PolyScene} from '../PolyScene';\n\n// interface CookerQueue {\n// \t[propName: string]: CoreGraphNodeSceneNamed;\n// }\n\nexport class Cooker {\n\tprivate _queue: Map<CoreGraphNodeId, CoreGraphNode | undefined> = new Map();\n\tprivate _block_level: number = 0;\n\tprivate _process_item_bound = this._process_item.bind(this);\n\n\tconstructor(private _scene: PolyScene) {\n\t\tthis._block_level = 0;\n\t}\n\n\tblock() {\n\t\tthis._block_level += 1;\n\t}\n\tunblock() {\n\t\tthis._block_level -= 1;\n\t\tif (this._block_level < 0) {\n\t\t\tthis._block_level = 0;\n\t\t}\n\n\t\tthis.process_queue();\n\t}\n\t// unblock_later: ->\n\t// \tsetTimeout( this.unblock.bind(this), 0 )\n\tget blocked() {\n\t\treturn this._block_level > 0;\n\t}\n\n\tenqueue(node: CoreGraphNode, original_trigger_graph_node?: CoreGraphNode) {\n\t\tthis._queue.set(node.graphNodeId(), original_trigger_graph_node);\n\t}\n\n\tprocess_queue() {\n\t\tif (this.blocked) {\n\t\t\treturn;\n\t\t}\n\t\t// let node: CoreGraphNode;\n\t\t// console.warn('FLUSH', Object.keys(this._queue).length);\n\n\t\tthis._queue.forEach(this._process_item_bound);\n\t\t// for (let id of Object.keys(this._queue)) {\n\t\t// \tnode = this._queue[id];\n\t\t// \tif (node) {\n\t\t// \t\tdelete this._queue[id];\n\t\t// \t\tnode.dirtyController.run_post_dirty_hooks();\n\t\t// \t}\n\t\t// }\n\t}\n\tprivate _process_item(original_trigger_graph_node: CoreGraphNode | undefined, id: CoreGraphNodeId) {\n\t\tconst node = this._scene.graph.node_from_id(id);\n\t\tif (node) {\n\t\t\tthis._queue.delete(id);\n\t\t\tnode.dirtyController.run_post_dirty_hooks(original_trigger_graph_node);\n\t\t}\n\t}\n}\n","import {BaseNodeType} from '../../nodes/_Base';\nimport {CoreGraphNodeId} from '../../../core/graph/CoreGraph';\n\ntype Callback = (value: void) => void;\n\nexport class CookController {\n\tprivate _cooking_nodes_by_id: Map<CoreGraphNodeId, BaseNodeType> = new Map();\n\tprivate _resolves: Callback[] = [];\n\tconstructor() {}\n\n\tadd_node(node: BaseNodeType) {\n\t\tthis._cooking_nodes_by_id.set(node.graphNodeId(), node);\n\t}\n\tremove_node(node: BaseNodeType) {\n\t\tthis._cooking_nodes_by_id.delete(node.graphNodeId());\n\n\t\tif (this._cooking_nodes_by_id.size == 0) {\n\t\t\tthis.flush();\n\t\t}\n\t}\n\n\tprivate flush() {\n\t\tlet callback: Callback | undefined;\n\t\twhile ((callback = this._resolves.pop())) {\n\t\t\tcallback();\n\t\t}\n\t}\n\n\tasync waitForCooksCompleted(): Promise<void> {\n\t\tif (this._cooking_nodes_by_id.size == 0) {\n\t\t\treturn;\n\t\t} else {\n\t\t\treturn new Promise((resolve, reject) => {\n\t\t\t\tthis._resolves.push(resolve);\n\t\t\t});\n\t\t}\n\t}\n}\n","import {PolyScene} from '../../engine/scene/PolyScene';\nimport {CoreGraphNode} from './CoreGraphNode';\n\nexport type CoreGraphNodeId = number;\n\nexport class CoreGraph {\n\tprivate _next_id: CoreGraphNodeId = 0;\n\tprivate _scene: PolyScene | undefined;\n\tprivate _successors: Map<CoreGraphNodeId, Set<CoreGraphNodeId>> = new Map();\n\tprivate _predecessors: Map<CoreGraphNodeId, Set<CoreGraphNodeId>> = new Map();\n\tprivate _nodes_by_id: Map<number, CoreGraphNode> = new Map();\n\tprivate _nodesCount = 0;\n\n\tprivate _debugging = false;\n\tprivate _addedNodesDuringDebugging: Map<CoreGraphNodeId, CoreGraphNode> = new Map();\n\tstartDebugging() {\n\t\tthis._debugging = true;\n\t\tconsole.log('CoreGraph.startDebugging', this._next_id);\n\t}\n\tstopDebugging() {\n\t\tthis._debugging = false;\n\t\tconsole.log('CoreGraph.stopDebugging', this._next_id);\n\t}\n\tprintDebug() {\n\t\tthis._addedNodesDuringDebugging.forEach((node, nodeId) => {\n\t\t\tconsole.log(nodeId, node, node.graphPredecessors(), node.graphSuccessors());\n\t\t});\n\t}\n\n\tset_scene(scene: PolyScene) {\n\t\tthis._scene = scene;\n\t}\n\tscene() {\n\t\treturn this._scene;\n\t}\n\n\tnext_id(): CoreGraphNodeId {\n\t\tthis._next_id += 1;\n\t\treturn this._next_id;\n\t}\n\n\tnodes_from_ids(ids: number[]) {\n\t\tconst nodes: CoreGraphNode[] = [];\n\t\tfor (let id of ids) {\n\t\t\tconst node = this.node_from_id(id);\n\t\t\tif (node) {\n\t\t\t\tnodes.push(node);\n\t\t\t}\n\t\t}\n\t\treturn nodes;\n\t}\n\tnode_from_id(id: number): CoreGraphNode | undefined {\n\t\treturn this._nodes_by_id.get(id);\n\t}\n\thas_node(node: CoreGraphNode): boolean {\n\t\treturn this._nodes_by_id.get(node.graphNodeId()) != null;\n\t}\n\tadd_node(node: CoreGraphNode) {\n\t\tthis._nodes_by_id.set(node.graphNodeId(), node);\n\t\tthis._nodesCount += 1;\n\t\tif (this._debugging) {\n\t\t\tthis._addedNodesDuringDebugging.set(node.graphNodeId(), node);\n\t\t}\n\t}\n\tremove_node(node: CoreGraphNode) {\n\t\tthis._nodes_by_id.delete(node.graphNodeId());\n\t\tthis._successors.delete(node.graphNodeId());\n\t\tthis._predecessors.delete(node.graphNodeId());\n\t\tthis._nodesCount -= 1;\n\n\t\tif (this._debugging) {\n\t\t\tthis._addedNodesDuringDebugging.delete(node.graphNodeId());\n\t\t}\n\t}\n\tnodesCount() {\n\t\treturn this._nodesCount;\n\t}\n\tconnect(src: CoreGraphNode, dest: CoreGraphNode, check_if_graph_may_have_cycle = true): boolean {\n\t\tconst src_id = src.graphNodeId();\n\t\tconst dest_id = dest.graphNodeId();\n\n\t\tif (this.has_node(src) && this.has_node(dest)) {\n\t\t\t// this._graph.setEdge(src_id, dest_id);\n\n\t\t\t// if check_if_graph_may_have_cycle is passed as false, that means we never check.\n\t\t\t// this can be useful when we know that the connection will not create a cycle,\n\t\t\t// such as when connecting params or inputs to a node\n\t\t\tif (check_if_graph_may_have_cycle) {\n\t\t\t\tconst scene_loading = this._scene ? this._scene.loadingController.isLoading() : true;\n\t\t\t\tcheck_if_graph_may_have_cycle = !scene_loading;\n\t\t\t}\n\t\t\tlet graph_would_have_cycle = false;\n\t\t\tif (check_if_graph_may_have_cycle) {\n\t\t\t\t// graph_has_cycle = !alg.isAcyclic(this._graph);\n\t\t\t\tgraph_would_have_cycle = this._has_predecessor(src_id, dest_id);\n\t\t\t}\n\n\t\t\tif (graph_would_have_cycle) {\n\t\t\t\t// this._graph.removeEdge(src_id, dest_id);\n\t\t\t\treturn false;\n\t\t\t} else {\n\t\t\t\tthis._create_connection(src_id, dest_id);\n\t\t\t\tsrc.dirtyController.clear_successors_cache_with_predecessors();\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t} else {\n\t\t\tconsole.warn(`attempt to connect non existing node ${src_id} or ${dest_id}`);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tdisconnect(src: CoreGraphNode, dest: CoreGraphNode) {\n\t\t// const src_id_s = src.graphNodeId();\n\t\t// const dest_id_s = dest.graphNodeId();\n\t\t// this._graph.removeEdge(src_id_s, dest_id_s);\n\t\tthis._remove_connection(src.graphNodeId(), dest.graphNodeId());\n\n\t\tsrc.dirtyController.clear_successors_cache_with_predecessors();\n\t}\n\tdisconnect_predecessors(node: CoreGraphNode) {\n\t\tconst predecessors = this.predecessors(node);\n\t\tfor (let predecessor of predecessors) {\n\t\t\tthis.disconnect(predecessor, node);\n\t\t}\n\t}\n\tdisconnect_successors(node: CoreGraphNode) {\n\t\tconst successors = this.successors(node);\n\t\tfor (let successor of successors) {\n\t\t\tthis.disconnect(node, successor);\n\t\t}\n\t}\n\n\tpredecessor_ids(id: CoreGraphNodeId): CoreGraphNodeId[] {\n\t\tconst map = this._predecessors.get(id);\n\t\tif (map) {\n\t\t\tconst ids: CoreGraphNodeId[] = [];\n\t\t\tmap.forEach((bool, id) => {\n\t\t\t\tids.push(id);\n\t\t\t});\n\t\t\treturn ids;\n\t\t}\n\t\treturn [];\n\t}\n\tpredecessors(node: CoreGraphNode) {\n\t\tconst ids = this.predecessor_ids(node.graphNodeId());\n\t\treturn this.nodes_from_ids(ids);\n\t}\n\tsuccessor_ids(id: CoreGraphNodeId): CoreGraphNodeId[] {\n\t\tconst map = this._successors.get(id);\n\t\tif (map) {\n\t\t\tconst ids: CoreGraphNodeId[] = [];\n\t\t\tmap.forEach((bool, id) => {\n\t\t\t\tids.push(id);\n\t\t\t});\n\t\t\treturn ids;\n\t\t}\n\t\treturn [];\n\t}\n\tsuccessors(node: CoreGraphNode): CoreGraphNode[] {\n\t\tconst ids = this.successor_ids(node.graphNodeId()) || [];\n\t\treturn this.nodes_from_ids(ids);\n\t}\n\tall_predecessor_ids(node: CoreGraphNode): CoreGraphNodeId[] {\n\t\treturn this.all_next_ids(node, 'predecessor_ids');\n\t}\n\tall_successor_ids(node: CoreGraphNode): CoreGraphNodeId[] {\n\t\treturn this.all_next_ids(node, 'successor_ids');\n\t}\n\tall_predecessors(node: CoreGraphNode): CoreGraphNode[] {\n\t\tconst ids = this.all_predecessor_ids(node);\n\t\treturn this.nodes_from_ids(ids);\n\t}\n\tall_successors(node: CoreGraphNode): CoreGraphNode[] {\n\t\tconst ids = this.all_successor_ids(node);\n\t\treturn this.nodes_from_ids(ids);\n\t}\n\tprivate _create_connection(src_id: CoreGraphNodeId, dest_id: CoreGraphNodeId) {\n\t\t// set successors\n\t\tlet node_successors = this._successors.get(src_id);\n\t\tif (!node_successors) {\n\t\t\tnode_successors = new Set();\n\t\t\tthis._successors.set(src_id, node_successors);\n\t\t}\n\t\tif (node_successors.has(dest_id)) {\n\t\t\treturn;\n\t\t}\n\t\tnode_successors.add(dest_id);\n\n\t\t// set predecessors\n\t\tlet node_predecessors = this._predecessors.get(dest_id);\n\t\tif (!node_predecessors) {\n\t\t\tnode_predecessors = new Set();\n\t\t\tthis._predecessors.set(dest_id, node_predecessors);\n\t\t}\n\t\tnode_predecessors.add(src_id);\n\t}\n\tprivate _remove_connection(src_id: CoreGraphNodeId, dest_id: CoreGraphNodeId) {\n\t\t// remove successors\n\t\tlet node_successors = this._successors.get(src_id);\n\t\tif (node_successors) {\n\t\t\tnode_successors.delete(dest_id);\n\t\t\tif (node_successors.size == 0) {\n\t\t\t\tthis._successors.delete(src_id);\n\t\t\t}\n\t\t}\n\t\t// remove predecessors\n\t\tlet node_predecessors = this._predecessors.get(dest_id);\n\t\tif (node_predecessors) {\n\t\t\tnode_predecessors.delete(src_id);\n\t\t\tif (node_predecessors.size == 0) {\n\t\t\t\tthis._predecessors.delete(dest_id);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate all_next_ids(node: CoreGraphNode, method: 'successor_ids' | 'predecessor_ids'): CoreGraphNodeId[] {\n\t\tconst ids_by_id: Map<CoreGraphNodeId, boolean> = new Map();\n\t\tconst ids: CoreGraphNodeId[] = [];\n\t\tlet next_ids = this[method](node.graphNodeId());\n\n\t\twhile (next_ids.length > 0) {\n\t\t\tconst next_next_ids = [];\n\t\t\tfor (let next_id of next_ids) {\n\t\t\t\tfor (let next_next_id of this[method](next_id)) {\n\t\t\t\t\tnext_next_ids.push(next_next_id);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (let id of next_ids) {\n\t\t\t\tids_by_id.set(id, true);\n\t\t\t}\n\t\t\tfor (let id of next_next_ids) {\n\t\t\t\tnext_ids.push(id);\n\t\t\t}\n\t\t\tnext_ids = next_next_ids;\n\t\t}\n\t\tids_by_id.forEach((bool, id) => {\n\t\t\tids.push(id);\n\t\t});\n\t\treturn ids;\n\t}\n\n\tprivate _has_predecessor(src_id: CoreGraphNodeId, dest_id: CoreGraphNodeId): boolean {\n\t\tconst ids = this.predecessor_ids(src_id);\n\t\tif (ids) {\n\t\t\tif (ids.includes(dest_id)) {\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\tfor (let id of ids) {\n\t\t\t\t\treturn this._has_predecessor(id, dest_id);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n}\n","import {BaseNodeType} from '../../engine/nodes/_Base';\n\nexport interface PerformancePrintObject {\n\tfullPath: string;\n\tcooks_count: number;\n\ttotal_time: number;\n\ttotal_cook_time: number;\n\tcook_time_per_iteration: number;\n\t// cook_time_total_with_inputs: number;\n\t// cook_time_total_with_inputs_per_iteration: number;\n\tinputs_time_per_iteration: number;\n\tparams_time_per_iteration: number;\n}\n\nimport {NodePerformanceData} from '../../engine/nodes/utils/cook/PerformanceController';\nexport class PerformanceNode {\n\t_cooks_count: number = 0;\n\t_total_cook_time: number = 0;\n\t_total_inputs_time: number = 0;\n\t_total_params_time: number = 0;\n\tconstructor(private _node: BaseNodeType) {}\n\n\tupdate_cook_data(performance_data: NodePerformanceData): void {\n\t\tthis._cooks_count += 1;\n\t\tthis._total_cook_time += performance_data.cook_time;\n\t\tthis._total_inputs_time += performance_data.inputs_time;\n\t\tthis._total_params_time += performance_data.params_time;\n\t}\n\ttotal_time(): number {\n\t\treturn this._total_cook_time + this._total_inputs_time + this._total_params_time;\n\t}\n\ttotal_cook_time(): number {\n\t\treturn this._total_cook_time;\n\t}\n\tcook_time_per_iteration(): number {\n\t\tif (this._cooks_count > 0) {\n\t\t\treturn this._total_cook_time / this._cooks_count;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\ttotal_inputs_time(): number {\n\t\treturn this._total_inputs_time;\n\t}\n\tinputs_time_per_iteration(): number {\n\t\tif (this._cooks_count > 0) {\n\t\t\treturn this._total_inputs_time / this._cooks_count;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\ttotal_params_time2(): number {\n\t\treturn this._total_params_time;\n\t}\n\tparams_time_per_iteration2(): number {\n\t\tif (this._cooks_count > 0) {\n\t\t\treturn this._total_params_time / this._cooks_count;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tcooks_count(): number {\n\t\treturn this._cooks_count;\n\t}\n\n\tprint_object(): PerformancePrintObject {\n\t\treturn {\n\t\t\tfullPath: this._node.fullPath(),\n\t\t\tcooks_count: this.cooks_count(),\n\t\t\ttotal_time: this.total_time(),\n\t\t\ttotal_cook_time: this.total_cook_time(),\n\t\t\tcook_time_per_iteration: this.cook_time_per_iteration(),\n\t\t\t// cook_time_total_with_inputs: this.cook_time_total_with_inputs,\n\t\t\t// cook_time_total_with_inputs_per_iteration: this.cook_time_total_with_inputs_per_iteration,\n\t\t\tinputs_time_per_iteration: this.inputs_time_per_iteration(),\n\t\t\tparams_time_per_iteration: this.params_time_per_iteration2(),\n\t\t};\n\t}\n}\n","import {PerformanceNode} from './PerformanceNode';\nimport {NodePerformanceData} from '../../engine/nodes/utils/cook/PerformanceController';\nimport {BaseNodeType} from '../../engine/nodes/_Base';\nimport {ArrayUtils} from '../ArrayUtils';\nimport {ObjectUtils} from '../ObjectUtils';\nimport {PolyDictionary} from '../../types/GlobalTypes';\n\nexport class CorePerformance {\n\tprivate _started: boolean = false;\n\t_start_time: number | null = 0;\n\t_previous_timestamp: number = 0;\n\t_nodes_cook_data: PolyDictionary<PerformanceNode> = {};\n\t_durations_by_name: PolyDictionary<number> = {};\n\t_durations_count_by_name: PolyDictionary<number> = {};\n\n\tprofile(name: string, method: (args?: any) => any) {\n\t\tconst start_time = performance.now();\n\t\tmethod();\n\t\tconst total_time = performance.now() - start_time;\n\t\tconsole.log(`${name}: ${total_time}`);\n\t}\n\n\tstart() {\n\t\tif (!this._started) {\n\t\t\tthis.reset();\n\t\t\tthis._started = true;\n\t\t\tthis._start_time = performance.now();\n\t\t\tthis._nodes_cook_data = {};\n\t\t\tthis._previous_timestamp = this._start_time;\n\t\t}\n\t}\n\tstop() {\n\t\tthis.reset();\n\t}\n\treset() {\n\t\tthis._started = false;\n\t\tthis._start_time = null;\n\t\tthis._durations_by_name = {};\n\t\tthis._durations_count_by_name = {};\n\t\tthis._nodes_cook_data = {};\n\t}\n\n\tstarted(): boolean {\n\t\treturn this._started;\n\t}\n\n\trecord_node_cook_data(node: BaseNodeType, performance_data: NodePerformanceData) {\n\t\tconst id = node.graphNodeId();\n\t\tif (this._nodes_cook_data[id] == null) {\n\t\t\tthis._nodes_cook_data[id] = new PerformanceNode(node);\n\t\t}\n\t\tthis._nodes_cook_data[id].update_cook_data(performance_data);\n\t}\n\n\trecord(name: string) {\n\t\tif (!this.started()) {\n\t\t\tthis.start();\n\t\t}\n\n\t\tconst current_timestamp = performance.now();\n\n\t\tif (this._durations_by_name[name] == null) {\n\t\t\tthis._durations_by_name[name] = 0;\n\t\t}\n\t\tthis._durations_by_name[name] += current_timestamp - this._previous_timestamp;\n\t\tif (this._durations_count_by_name[name] == null) {\n\t\t\tthis._durations_count_by_name[name] = 0;\n\t\t}\n\t\tthis._durations_count_by_name[name] += 1;\n\n\t\treturn (this._previous_timestamp = current_timestamp);\n\t}\n\n\tprint() {\n\t\tthis.print_node_cook_data();\n\t\tthis.print_recordings();\n\t}\n\n\tprint_node_cook_data() {\n\t\tlet performance_nodes = Object.values(this._nodes_cook_data);\n\t\tperformance_nodes = ArrayUtils.sortBy(performance_nodes, (performance_node) =>\n\t\t\tperformance_node.total_cook_time()\n\t\t);\n\n\t\tconst print_objects = performance_nodes.map((performance_node) => performance_node.print_object());\n\n\t\tconsole.log('--------------- NODES COOK TIME -----------');\n\n\t\tconst table_entries = [];\n\t\tconst sorted_print_objects = ArrayUtils.sortBy(print_objects, (print_object) => -print_object.total_cook_time);\n\t\tfor (let print_object of sorted_print_objects) {\n\t\t\ttable_entries.push(print_object);\n\t\t}\n\n\t\tconsole.table(table_entries);\n\n\t\treturn print_objects;\n\t}\n\n\tprint_recordings() {\n\t\tconst durations_by_name = ObjectUtils.clone(this._durations_by_name);\n\t\tconst durations_count_by_name = ObjectUtils.clone(this._durations_count_by_name);\n\n\t\tconst durations = [];\n\t\tconst names_by_duration: PolyDictionary<string[]> = {};\n\n\t\tfor (let name of Object.keys(durations_by_name)) {\n\t\t\tconst duration = durations_by_name[name];\n\n\t\t\tdurations.push(duration);\n\t\t\tif (names_by_duration[duration] == null) {\n\t\t\t\tnames_by_duration[duration] = [];\n\t\t\t}\n\t\t\tnames_by_duration[duration].push(name);\n\t\t}\n\n\t\tdurations.sort((a, b) => a - b);\n\t\tconst sorted_durations = ArrayUtils.uniq(durations);\n\n\t\tconsole.log('--------------- PERF RECORDINGS -----------');\n\t\tconst table_entries = [];\n\t\tfor (let duration of sorted_durations) {\n\t\t\tconst names = names_by_duration[duration];\n\t\t\tfor (let name of names) {\n\t\t\t\tconst count = durations_count_by_name[name];\n\t\t\t\tconst duration_per_iteration = duration / count;\n\n\t\t\t\tconst entry = {duration, name, count, duration_per_iteration};\n\t\t\t\ttable_entries.push(entry);\n\t\t\t}\n\t\t}\n\n\t\tconsole.table(table_entries);\n\t\treturn table_entries;\n\t}\n}\n","import {BaseSceneEventsController} from './_BaseEventsController';\nimport {SceneEventNode} from '../../../nodes/event/Scene';\n\nexport enum SceneEventType {\n\tLOADED = 'sceneLoaded',\n\tPLAY = 'play',\n\tPAUSE = 'pause',\n\tTICK = 'tick',\n}\nexport const ACCEPTED_SCENE_EVENT_TYPES: SceneEventType[] = [\n\tSceneEventType.LOADED,\n\tSceneEventType.PLAY,\n\tSceneEventType.PAUSE,\n\tSceneEventType.TICK,\n];\n\nexport class SceneEventsController extends BaseSceneEventsController<Event, SceneEventNode> {\n\ttype() {\n\t\treturn 'scene';\n\t}\n\tacceptedEventTypes() {\n\t\treturn ACCEPTED_SCENE_EVENT_TYPES.map((n) => `${n}`);\n\t}\n}\n","import {PolyScene} from '../PolyScene';\n\nimport {CoreGraphNode} from '../../../core/graph/CoreGraphNode';\nimport '../../Poly';\nimport {SceneEvent} from '../../poly/SceneEvent';\nimport {NodeEvent} from '../../poly/NodeEvent';\nimport {ParamEvent} from '../../poly/ParamEvent';\n\n// type Callback = (emitter: CoreGraphNodeScene) => void; // TODO: typescript: maybe arg should be an event instead of the emitter\ninterface EventsListener {\n\tprocess_events: (emitter: CoreGraphNode, event_name: SceneEvent | NodeEvent | ParamEvent, data?: any) => void;\n}\ntype OnAddListenerCallback = () => void;\n\nexport class DispatchController {\n\tprivate _on_add_listener_callbacks: OnAddListenerCallback[] | undefined;\n\tconstructor(private scene: PolyScene) {}\n\n\tprivate _events_listener: EventsListener | undefined;\n\n\tsetListener(events_listener: EventsListener) {\n\t\t// let's have a single listener for now\n\t\t// which is a constraint I've added when adding on_add_listener\n\t\tif (!this._events_listener) {\n\t\t\tthis._events_listener = events_listener;\n\t\t\tthis.run_on_add_listener_callbacks();\n\t\t} else {\n\t\t\tconsole.warn('scene already has a listener');\n\t\t}\n\t\t// this._store.scene = this;\n\t}\n\tonAddListener(callback: OnAddListenerCallback) {\n\t\tif (this._events_listener) {\n\t\t\tcallback();\n\t\t} else {\n\t\t\tthis._on_add_listener_callbacks = this._on_add_listener_callbacks || [];\n\t\t\tthis._on_add_listener_callbacks.push(callback);\n\t\t}\n\t}\n\tprivate run_on_add_listener_callbacks() {\n\t\tif (this._on_add_listener_callbacks) {\n\t\t\tlet callback: OnAddListenerCallback | undefined;\n\t\t\twhile ((callback = this._on_add_listener_callbacks.pop())) {\n\t\t\t\tcallback();\n\t\t\t}\n\t\t\tthis._on_add_listener_callbacks = undefined;\n\t\t}\n\t}\n\tget eventsListener() {\n\t\treturn this._events_listener;\n\t}\n\tdispatch(emitter: CoreGraphNode, event_name: SceneEvent | NodeEvent | ParamEvent, data?: any) {\n\t\tthis._events_listener?.process_events(emitter, event_name, data);\n\t}\n\temitAllowed(): boolean {\n\t\treturn (\n\t\t\tthis._events_listener != null &&\n\t\t\tthis.scene.loadingController.loaded() &&\n\t\t\tthis.scene.loadingController.autoUpdating() //&&\n\t\t\t// !Poly.playerMode() // TODO: typecript: maybe I should still be able to emit events in player mode? - check how the Event Sop works\n\t\t);\n\t}\n\t// store_commit(event_name: string, payload: any = this) {\n\t// \tif (this._store) {\n\t// \t\tthis._store.commit(`engine/${event_name}`, payload);\n\t// \t}\n\t// }\n}\n","import {BaseParamType} from '../../params/_Base';\nimport {BaseNodeType} from '../../nodes/_Base';\nimport {CoreGraphNodeId} from '../../../core/graph/CoreGraph';\n\nexport class ExpressionsController {\n\tprivate _params_by_id: Map<CoreGraphNodeId, BaseParamType> = new Map();\n\tconstructor() {}\n\n\tregister_param(param: BaseParamType) {\n\t\tthis._params_by_id.set(param.graphNodeId(), param);\n\t}\n\tderegister_param(param: BaseParamType) {\n\t\tthis._params_by_id.delete(param.graphNodeId());\n\t}\n\n\t//\n\t//\n\t//\n\t//\n\tregenerate_referring_expressions(node: BaseNodeType) {\n\t\tnode.nameController.graph_node.setSuccessorsDirty(node);\n\t}\n}\n","import {PolyScene} from '../PolyScene';\n\n// TODO: considerer removing this module\n// since now the on create hooks should all be in the editor\nexport class LifeCycleController {\n\tconstructor(private scene: PolyScene) {}\n\n\tprivate _lifecycle_on_create_allowed: boolean = true;\n\n\tonCreateHookAllowed(): boolean {\n\t\treturn this.scene.loadingController.loaded() && this._lifecycle_on_create_allowed;\n\t}\n\n\tonCreatePrevent(callback: () => void) {\n\t\tthis._lifecycle_on_create_allowed = false;\n\t\tcallback();\n\t\tthis._lifecycle_on_create_allowed = true;\n\t}\n}\n","import {BaseCameraObjNodeType} from '../../../nodes/obj/_BaseCamera';\nimport {BaseInputEventNodeType} from '../../../nodes/event/_BaseInput';\nimport {SceneEventsDispatcher} from './EventsDispatcher';\nimport {BaseNodeType} from '../../../nodes/_Base';\nimport {Intersection} from 'three/src/core/Raycaster';\nimport {CoreGraphNodeId} from '../../../../core/graph/CoreGraph';\nimport {BaseViewerType} from '../../../viewers/_Base';\n\ninterface EventContextValue {\n\tnode?: BaseNodeType; // for node_cook\n\tintersect?: Intersection; // for raycast\n}\n\nexport interface EventContext<E extends Event> {\n\tviewer?: Readonly<BaseViewerType>;\n\tevent?: Readonly<E>;\n\tcameraNode?: Readonly<BaseCameraObjNodeType>;\n\tvalue?: EventContextValue;\n}\n\nexport abstract class BaseSceneEventsController<E extends Event, T extends BaseInputEventNodeType> {\n\tprotected _nodes_by_graph_node_id: Map<CoreGraphNodeId, T> = new Map();\n\tprotected _require_canvas_event_listeners: boolean = false;\n\tconstructor(private dispatcher: SceneEventsDispatcher) {}\n\n\tregisterNode(node: T) {\n\t\tthis._nodes_by_graph_node_id.set(node.graphNodeId(), node);\n\t\tthis.updateViewerEventListeners();\n\t}\n\tunregisterNode(node: T) {\n\t\tthis._nodes_by_graph_node_id.delete(node.graphNodeId());\n\t\tthis.updateViewerEventListeners();\n\t}\n\tabstract type(): string;\n\tabstract acceptedEventTypes(): string[];\n\t// abstract accepts_event(event: Event): boolean;\n\n\tprocessEvent(event_context: EventContext<E>) {\n\t\tif (this._active_event_types.length == 0) {\n\t\t\treturn;\n\t\t}\n\t\tthis._nodes_by_graph_node_id.forEach((node) => node.process_event(event_context));\n\t}\n\n\tupdateViewerEventListeners() {\n\t\tthis._update_active_event_types();\n\n\t\tif (this._require_canvas_event_listeners) {\n\t\t\tthis.dispatcher.scene.viewersRegister.traverseViewers((viewer) => {\n\t\t\t\tviewer.eventsController.updateEvents(this);\n\t\t\t});\n\t\t}\n\t}\n\n\tprivate _active_event_types: string[] = [];\n\tactiveEventTypes() {\n\t\treturn this._active_event_types;\n\t}\n\tprivate _update_active_event_types() {\n\t\tconst active_node_event_types_state: Map<string, boolean> = new Map();\n\n\t\tthis._nodes_by_graph_node_id.forEach((node) => {\n\t\t\tif (node.parent()) {\n\t\t\t\tconst node_active_event_names = node.active_event_names();\n\t\t\t\tfor (let name of node_active_event_names) {\n\t\t\t\t\tactive_node_event_types_state.set(name, true);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\tthis._active_event_types = [];\n\t\tactive_node_event_types_state.forEach((state, name) => {\n\t\t\tthis._active_event_types.push(name);\n\t\t});\n\t}\n}\n\nexport type BaseSceneEventsControllerType = BaseSceneEventsController<Event, BaseInputEventNodeType>;\nexport class BaseSceneEventsControllerClass extends BaseSceneEventsController<Event, BaseInputEventNodeType> {\n\ttype() {\n\t\treturn '';\n\t}\n\tacceptedEventTypes(): string[] {\n\t\treturn [];\n\t}\n}\n","import {PolyScene} from '../PolyScene';\nimport {SceneEventType} from './events/SceneEventsController';\nimport {EventContext} from './events/_BaseEventsController';\n\nexport class LoadingController {\n\tconstructor(private scene: PolyScene) {}\n\n\tprivate _LOADED_EVENT_CONTEXT: EventContext<Event> | undefined;\n\tget LOADED_EVENT_CONTEXT() {\n\t\treturn (this._LOADED_EVENT_CONTEXT = this._LOADED_EVENT_CONTEXT || {event: new Event(SceneEventType.LOADED)});\n\t}\n\n\t_loading_state: boolean = false;\n\t_auto_updating: boolean = true;\n\t_first_object_loaded: boolean = false;\n\n\tmarkAsLoading() {\n\t\tthis._set_loading_state(true);\n\t}\n\tasync markAsLoaded() {\n\t\tthis.scene.missingExpressionReferencesController.resolve_missing_references();\n\t\tawait this._set_loading_state(false);\n\t\tthis.trigger_loaded_event();\n\t}\n\ttrigger_loaded_event() {\n\t\t// we only dispatch events in the browser. If this is run from nodejs, we do not.\n\t\tif (globalThis.Event) {\n\t\t\tthis.scene.eventsDispatcher.sceneEventsController.processEvent(this.LOADED_EVENT_CONTEXT);\n\t\t}\n\t}\n\n\tprivate async _set_loading_state(state: boolean) {\n\t\tthis._loading_state = state;\n\t\tawait this.set_auto_update(!this._loading_state);\n\t}\n\tisLoading() {\n\t\treturn this._loading_state;\n\t}\n\tloaded() {\n\t\treturn !this._loading_state;\n\t}\n\tautoUpdating() {\n\t\treturn this._auto_updating;\n\t}\n\tasync set_auto_update(new_state: boolean) {\n\t\tif (this._auto_updating !== new_state) {\n\t\t\tthis._auto_updating = new_state;\n\t\t\tif (this._auto_updating) {\n\t\t\t\t// if this.env_is_development()\n\t\t\t\t// \tthis.performance().start()\n\n\t\t\t\tconst root = this.scene.root();\n\t\t\t\tif (root) {\n\t\t\t\t\tawait root.processQueue();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\ton_first_object_loaded() {\n\t\tif (!this._first_object_loaded) {\n\t\t\tthis._first_object_loaded = true;\n\n\t\t\tconst loader = document.getElementById('scene_loading_container');\n\t\t\tif (loader) {\n\t\t\t\tloader.parentElement?.removeChild(loader);\n\t\t\t}\n\t\t}\n\t}\n\n\t// on_all_objects_loaded() {\n\t// \t// POLY.viewer_loaders_manager().dipose_loaders()\n\t// }\n}\n","import {BaseParamType} from '../params/_Base';\nimport {CoreWalker} from '../../core/Walker';\n\nexport class MissingExpressionReference {\n\tconstructor(private param: BaseParamType, public readonly path: string) {}\n\n\tabsolute_path() {\n\t\treturn CoreWalker.make_absolute_path(this.param.node, this.path);\n\t}\n\tmatches_path(path: string): boolean {\n\t\treturn this.absolute_path() == path;\n\t}\n\n\tupdate_from_method_dependency_name_change() {\n\t\tthis.param.expressionController?.update_from_method_dependency_name_change();\n\t}\n\n\tresolve_missing_dependencies() {\n\t\tconst input = this.param.rawInputSerialized();\n\t\tthis.param.set(this.param.defaultValue());\n\t\tthis.param.set(input);\n\t}\n}\n","import {BaseNodeType} from '../../nodes/_Base';\nimport {BaseParamType} from '../../params/_Base';\nimport {MissingExpressionReference} from '../../expressions/MissingReference';\nimport jsep from 'jsep';\nimport {MapUtils} from '../../../core/MapUtils';\nimport {PolyScene} from '../PolyScene';\nimport {CoreWalker} from '../../../core/Walker';\nimport {CoreGraphNodeId} from '../../../core/graph/CoreGraph';\n\nexport class MissingReferencesController {\n\tprivate references: Map<CoreGraphNodeId, MissingExpressionReference[]> = new Map();\n\n\tconstructor(private scene: PolyScene) {}\n\n\tregister(param: BaseParamType, jsep_node: jsep.Expression, path_argument: string): MissingExpressionReference {\n\t\tconst missing_expression_reference = new MissingExpressionReference(param, path_argument);\n\n\t\tMapUtils.push_on_array_at_entry(this.references, param.graphNodeId(), missing_expression_reference);\n\n\t\treturn missing_expression_reference;\n\t}\n\tderegister_param(param: BaseParamType) {\n\t\tthis.references.delete(param.graphNodeId());\n\t}\n\n\t//\n\t//\n\t// MISSING REFERENCES\n\t//\n\t//\n\tresolve_missing_references() {\n\t\tconst resolved_references: MissingExpressionReference[] = [];\n\t\tthis.references.forEach((references) => {\n\t\t\tfor (let reference of references) {\n\t\t\t\tif (this._is_reference_resolvable(reference)) {\n\t\t\t\t\tresolved_references.push(reference);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\tfor (let reference of resolved_references) {\n\t\t\treference.resolve_missing_dependencies();\n\t\t}\n\t}\n\tprivate _is_reference_resolvable(reference: MissingExpressionReference) {\n\t\tconst absolute_path = reference.absolute_path();\n\t\tif (absolute_path) {\n\t\t\tconst node = this.scene.node(absolute_path);\n\t\t\t// try and find a node first\n\t\t\tif (node) {\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\t// if no node, try and find a param, via a parent first\n\t\t\t\tconst paths = CoreWalker.split_parent_child(absolute_path);\n\t\t\t\tif (paths.child) {\n\t\t\t\t\tconst parent_node = this.scene.node(paths.parent);\n\t\t\t\t\tif (parent_node) {\n\t\t\t\t\t\tconst param = parent_node.params.get(paths.child);\n\t\t\t\t\t\tif (param) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// call this from node.create and node.rename\n\tcheck_for_missing_references(node: BaseNodeType) {\n\t\tthis._check_for_missing_references_for_node(node);\n\t\tfor (let param of node.params.all) {\n\t\t\tthis._check_for_missing_references_for_param(param);\n\t\t}\n\t}\n\tprivate _check_for_missing_references_for_node(node: BaseNodeType) {\n\t\tconst id = node.graphNodeId();\n\n\t\tthis.references.forEach((missing_references, node_id) => {\n\t\t\tlet match_found = false;\n\t\t\tfor (let ref of missing_references) {\n\t\t\t\tif (ref.matches_path(node.fullPath())) {\n\t\t\t\t\tmatch_found = true;\n\t\t\t\t\tref.resolve_missing_dependencies();\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (match_found) {\n\t\t\t\tthis.references.delete(id);\n\t\t\t}\n\t\t});\n\t}\n\tprivate _check_for_missing_references_for_param(param: BaseParamType) {\n\t\tconst id = param.graphNodeId();\n\n\t\tthis.references.forEach((missing_references, node_id) => {\n\t\t\tlet match_found = false;\n\t\t\tfor (let ref of missing_references) {\n\t\t\t\tif (ref.matches_path(param.fullPath())) {\n\t\t\t\t\tmatch_found = true;\n\t\t\t\t\tref.resolve_missing_dependencies();\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (match_found) {\n\t\t\t\tthis.references.delete(id);\n\t\t\t}\n\t\t});\n\t}\n}\n","import {TypedNode} from '../_Base';\nimport {NodeContext} from '../../poly/NodeContext';\nimport {NodeParamsConfig} from '../utils/params/ParamsConfig';\nexport class TypedBaseManagerNode<K extends NodeParamsConfig> extends TypedNode<NodeContext.MANAGER, K> {\n\tstatic nodeContext(): NodeContext {\n\t\treturn NodeContext.MANAGER;\n\t}\n}\n\nexport type BaseManagerNodeType = TypedBaseManagerNode<any>;\nexport class BaseManagerNodeClass extends TypedBaseManagerNode<any> {}\n","import {PolyScene} from '../PolyScene';\nimport {CoreString} from '../../../core/String';\nimport {Object3D} from 'three/src/core/Object3D';\n\nexport const ROOT_NAME = '/';\n\nexport class ObjectsController {\n\tconstructor(private scene: PolyScene) {}\n\n\tfindObjectByMask(mask: string): Object3D | undefined {\n\t\treturn this.findObjectByMaskInObject(mask, this.scene.threejsScene());\n\t}\n\tfindObjectByMaskInObject(mask: string, object: Object3D, objectPath: string = ''): Object3D | undefined {\n\t\tfor (let child of object.children) {\n\t\t\tconst childName = this._removeTrailingOrHeadingSlash(child.name);\n\t\t\tobjectPath = this._removeTrailingOrHeadingSlash(objectPath);\n\t\t\tconst path = `${objectPath}/${childName}`;\n\t\t\tif (CoreString.matchMask(path, mask)) {\n\t\t\t\treturn child;\n\t\t\t}\n\t\t\tconst grandChild = this.findObjectByMaskInObject(mask, child, path);\n\t\t\tif (grandChild) {\n\t\t\t\treturn grandChild;\n\t\t\t}\n\t\t}\n\t}\n\n\tobjectsByMask(mask: string): Object3D[] {\n\t\treturn this.objectsByMaskInObject(mask, this.scene.threejsScene(), [], '');\n\t}\n\tobjectsByMaskInObject(mask: string, object: Object3D, list: Object3D[] = [], objectPath: string = '') {\n\t\tfor (let child of object.children) {\n\t\t\tconst childName = this._removeTrailingOrHeadingSlash(child.name);\n\t\t\tobjectPath = this._removeTrailingOrHeadingSlash(objectPath);\n\t\t\tconst path = `${objectPath}/${childName}`;\n\t\t\tif (CoreString.matchMask(path, mask)) {\n\t\t\t\tlist.push(child);\n\t\t\t}\n\t\t\tthis.objectsByMaskInObject(mask, child, list, path);\n\t\t}\n\t\treturn list;\n\t}\n\n\tprivate _removeTrailingOrHeadingSlash(objectName: string) {\n\t\tif (objectName[0] == '/') {\n\t\t\tobjectName = objectName.substr(1);\n\t\t}\n\t\tif (objectName[objectName.length - 1] == '/') {\n\t\t\tobjectName = objectName.substr(0, objectName.length - 1);\n\t\t}\n\t\treturn objectName;\n\t}\n}\n","import {Group} from 'three/src/objects/Group';\nimport {TypedBaseManagerNode} from './_Base';\nimport {BaseObjNodeType} from '../obj/_Base';\nimport {NodeContext} from '../../poly/NodeContext';\nimport {ObjNodeChildrenMap} from '../../poly/registers/nodes/Obj';\nimport {NodeParamsConfig} from '../utils/params/ParamsConfig';\nimport {BaseNodeType} from '../_Base';\nimport {HierarchyObjNode} from '../obj/utils/HierarchyController';\nimport {ParamsInitData} from '../utils/io/IOController';\nimport {Constructor, valueof} from '../../../types/GlobalTypes';\nimport {ROOT_NAME} from '../../scene/utils/ObjectsController';\nclass ObjectsManagerParamsConfig extends NodeParamsConfig {}\nconst ParamsConfig = new ObjectsManagerParamsConfig();\n\nexport class ObjectsManagerNode extends TypedBaseManagerNode<ObjectsManagerParamsConfig> {\n\tparams_config = ParamsConfig;\n\tstatic type() {\n\t\treturn 'obj';\n\t}\n\n\tprivate _object: Group = new Group();\n\tprivate _queued_nodes_by_id: Map<number, BaseObjNodeType> = new Map();\n\t// private _expected_geo_nodes: PolyDictionary<GeoObjNode> = {};\n\t// private _process_queue_start: number = -1;\n\n\tprotected _children_controller_context = NodeContext.OBJ;\n\tinitializeNode() {\n\t\t// this.children_controller?.init({dependent: false});\n\t\tthis._object.matrixAutoUpdate = false;\n\n\t\tthis.lifecycle.add_on_child_add_hook(this._on_child_add.bind(this));\n\t\tthis.lifecycle.add_on_child_remove_hook(this._on_child_remove.bind(this));\n\t}\n\n\tinitDefaultScene() {\n\t\tthis._object.name = ROOT_NAME;\n\t\tthis._scene.threejsScene().add(this._object);\n\t}\n\n\tobject() {\n\t\treturn this._object;\n\t}\n\tcreateNode<S extends keyof ObjNodeChildrenMap>(\n\t\tnode_class: S,\n\t\tparams_init_value_overrides?: ParamsInitData\n\t): ObjNodeChildrenMap[S];\n\tcreateNode<K extends valueof<ObjNodeChildrenMap>>(\n\t\tnode_class: Constructor<K>,\n\t\tparams_init_value_overrides?: ParamsInitData\n\t): K;\n\tcreateNode<K extends valueof<ObjNodeChildrenMap>>(\n\t\tnode_class: Constructor<K>,\n\t\tparams_init_value_overrides?: ParamsInitData\n\t): K {\n\t\treturn super.createNode(node_class, params_init_value_overrides) as K;\n\t}\n\tchildren() {\n\t\treturn super.children() as BaseObjNodeType[];\n\t}\n\tnodesByType<K extends keyof ObjNodeChildrenMap>(type: K): ObjNodeChildrenMap[K][] {\n\t\treturn super.nodesByType(type) as ObjNodeChildrenMap[K][];\n\t}\n\n\t// multiple_display_flags_allowed() {\n\t// \treturn true;\n\t// }\n\n\tprivate _addToQueue(node: BaseObjNodeType) {\n\t\tconst id = node.graphNodeId();\n\t\tif (!this._queued_nodes_by_id.has(id)) {\n\t\t\tthis._queued_nodes_by_id.set(id, node);\n\t\t}\n\t\treturn node;\n\t}\n\n\tasync processQueue() {\n\t\tconst queued_nodes_by_path: Map<string, BaseObjNodeType> = new Map();\n\t\tconst paths: string[] = [];\n\t\tthis._queued_nodes_by_id.forEach((node, id) => {\n\t\t\tconst fullPath = `_____${node.renderOrder}__${node.fullPath()}`;\n\t\t\tpaths.push(fullPath);\n\t\t\tqueued_nodes_by_path.set(fullPath, node);\n\t\t});\n\t\tthis._queued_nodes_by_id.clear();\n\n\t\t// const promises = [];\n\t\tfor (let path_id of paths) {\n\t\t\tconst node = queued_nodes_by_path.get(path_id);\n\t\t\tif (node) {\n\t\t\t\tqueued_nodes_by_path.delete(path_id);\n\t\t\t\tthis._addToScene(node);\n\t\t\t\t// promises.push();\n\t\t\t}\n\t\t}\n\n\t\t// this._expected_geo_nodes = this._expected_geo_nodes || (await this.expected_loading_geo_nodes_by_id());\n\n\t\t// this._process_queue_start = performance.now();\n\t\t// Promise.all(promises).then(() => {\n\t\t// \t// Poly.log(`SCENE LOADED '${this.scene.name}`);\n\t\t// \t// `SCENE LOADED '${this.scene.name}' in ${performance.now() - this._process_queue_start}`\n\t\t// \t// this.scene().performance().print()\n\t\t// \t// do the update here if there are no objects to load\n\t\t// \t// otherwise an empty scene will have a loader that never gets removed\n\t\t// \t// if (Object.keys(this._expected_geo_nodes).length == 0) {\n\t\t// \t// \tthis.update_on_all_objects_loaded();\n\t\t// \t// }\n\t\t// });\n\t}\n\n\tprivate _update_object(node: BaseObjNodeType) {\n\t\tif (!this.scene().loadingController.autoUpdating()) {\n\t\t\treturn this._addToQueue(node);\n\t\t} else {\n\t\t\treturn this._addToScene(node);\n\t\t}\n\t}\n\n\t//\n\t//\n\t// OBJ PARENTING\n\t//\n\t//\n\tgetParentForNode(node: BaseObjNodeType) {\n\t\tif (node.attachableToHierarchy()) {\n\t\t\tconst node_input = node.io.inputs.input(0);\n\t\t\tif (node_input) {\n\t\t\t\treturn node_input.children_group;\n\t\t\t} else {\n\t\t\t\treturn this._object;\n\t\t\t}\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tprivate _addToScene(node: BaseObjNodeType): void {\n\t\tif (node.attachableToHierarchy()) {\n\t\t\tconst parent_object = this.getParentForNode(node);\n\t\t\tif (parent_object) {\n\t\t\t\t// await node.params.eval_all().then((params_eval_key) => {\n\t\t\t\t// \tnode.requestContainer();\n\t\t\t\t// });\n\n\t\t\t\tif (node.usedInScene()) {\n\t\t\t\t\t// I need to query the displayNodeController here,\n\t\t\t\t\t// for geo obj whose display_node is a node without inputs.\n\t\t\t\t\t// Since that node will not be made dirty, it seems that there is\n\t\t\t\t\t// nothing triggering the obj to request it itself.\n\t\t\t\t\t// TODO: investigate if it has a performance cost, or if it could be done\n\t\t\t\t\t// only when scene loads. Or if the displayNodeController itself could be improved\n\t\t\t\t\t// to take care of it itself.\n\t\t\t\t\t// node.requestContainer();\n\t\t\t\t\tnode.childrenDisplayController?.request_display_node_container();\n\t\t\t\t\tnode.addObjectToParent(parent_object);\n\t\t\t\t} else {\n\t\t\t\t\tnode.removeObjectFromParent();\n\t\t\t\t\t// parent_object.remove(node.object);\n\t\t\t\t}\n\n\t\t\t\t// node.request_display_node();\n\t\t\t} else {\n\t\t\t\t// node.requestContainer().then(() => {\n\t\t\t\t// \t// force events and mat to cook and remove the dirty state\n\t\t\t\t// \t// ensure that pickers are cooked\n\t\t\t\t// \t// TODO: although there has been cases with two picker and\n\t\t\t\t// \t// one referencing the other with an expression, and that\n\t\t\t\t// \t// expression be evaluated before the second was created\n\t\t\t\t// \t// which led to an error. This should not happen\n\t\t\t\t// \tnode.children_controller.traverse_children((child) => child.setDirty());\n\t\t\t\t// });\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate _removeFromScene(node: BaseObjNodeType) {\n\t\tnode.removeObjectFromParent();\n\t}\n\tareChildrenCooking(): boolean {\n\t\tconst children = this.children();\n\t\tfor (let child of children) {\n\t\t\tif (child.cookController.isCooking() || child.isDisplayNodeCooking()) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t// private async expected_loading_geo_nodes_by_id() {\n\t// \tconst geo_nodes = this.nodesByType('geo');\n\t// \tconst node_by_id: PolyDictionary<GeoObjNode> = {};\n\t// \tfor (let geo_node of geo_nodes) {\n\t// \t\tconst isDisplayed = await geo_node.isDisplayed();\n\t// \t\tif (isDisplayed) {\n\t// \t\t\tnode_by_id[geo_node.graphNodeId()] = geo_node;\n\t// \t\t}\n\t// \t}\n\t// \treturn node_by_id;\n\t// }\n\n\taddToParentTransform(node: HierarchyObjNode) {\n\t\tthis._update_object(node);\n\t}\n\n\tremoveFromParentTransform(node: HierarchyObjNode) {\n\t\tthis._update_object(node);\n\t}\n\n\tprivate _on_child_add(node?: BaseNodeType) {\n\t\tif (node) {\n\t\t\tthis._update_object(node as BaseObjNodeType);\n\t\t}\n\t}\n\tprivate _on_child_remove(node?: BaseNodeType) {\n\t\tif (node) {\n\t\t\tthis._removeFromScene(node as BaseObjNodeType);\n\t\t}\n\t}\n}\n","import {PolyDictionary} from '../../../types/GlobalTypes';\nimport {PolyScene} from '../PolyScene';\nimport {ObjectsManagerNode} from '../../nodes/manager/ObjectsManager';\nimport {CoreString} from '../../../core/String';\nimport {BaseNodeType} from '../../nodes/_Base';\nimport {NodeContext} from '../../poly/NodeContext';\nimport {NodeChildrenMapByContext} from '../../poly/registers/nodes/All';\n\nexport class NodesController {\n\tconstructor(private scene: PolyScene) {}\n\n\t_root!: ObjectsManagerNode;\n\t_node_context_signatures: PolyDictionary<boolean> = {};\n\t_instanciated_nodes_by_context_and_type: PolyDictionary<PolyDictionary<PolyDictionary<BaseNodeType>>> = {};\n\n\tinit() {\n\t\tthis._root = new ObjectsManagerNode(this.scene);\n\t\tthis._root.initialize_base_and_node();\n\t\t// this._root.set_scene(this.scene);\n\t\tthis._root.initDefaultScene();\n\t}\n\n\troot() {\n\t\treturn this._root;\n\t}\n\tprivate _traverseNode(parent: BaseNodeType, callback: (node: BaseNodeType) => void) {\n\t\tconst nodes = parent.children();\n\t\tif (!nodes || nodes.length == 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tfor (let node of nodes) {\n\t\t\tcallback(node);\n\n\t\t\tif (node.childrenController) {\n\t\t\t\tthis._traverseNode(node, callback);\n\t\t\t}\n\t\t}\n\t}\n\n\t// objectsFromMask(mask: string): Object3D[] {\n\t// \tconst masks = mask.split(' ');\n\t// \tconst child_nodes = this.root.children() as BaseObjNodeType[];\n\t// \tconst objects: Object3D[] = [];\n\t// \tfor (let child_node of child_nodes) {\n\t// \t\tif (CoreString.matchesOneMask(child_node.name, masks)) {\n\t// \t\t\tif (child_node.object) {\n\t// \t\t\t\tobjects.push(child_node.object);\n\t// \t\t\t}\n\t// \t\t}\n\t// \t}\n\t// \treturn objects;\n\t// }\n\tclear() {\n\t\tconst children = this.root().children();\n\t\tfor (let child of children) {\n\t\t\tthis.root().childrenController?.removeNode(child);\n\t\t}\n\t\t// return children.forEach(child=> {\n\t\t// \treturn this.root().removeNode(child);\n\t\t// });\n\t}\n\n\tnode(path: string) {\n\t\tif (path === '/') {\n\t\t\treturn this.root();\n\t\t} else {\n\t\t\treturn this.root().node(path);\n\t\t}\n\t}\n\tallNodes() {\n\t\tlet nodes: BaseNodeType[] = [this.root()];\n\t\tlet current_parents: BaseNodeType[] = [this.root()];\n\t\tlet cmptr = 0;\n\t\twhile (current_parents.length > 0 && cmptr < 10) {\n\t\t\tconst children = current_parents\n\t\t\t\t.map((current_parent) => {\n\t\t\t\t\tif (current_parent.childrenAllowed()) {\n\t\t\t\t\t\treturn current_parent.children();\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn [];\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.flat();\n\t\t\tnodes = nodes.concat(children);\n\t\t\tcurrent_parents = children;\n\t\t\tcmptr += 1;\n\t\t}\n\t\treturn nodes.flat();\n\t}\n\tnodesFromMask(mask: string) {\n\t\tconst nodes = this.allNodes();\n\t\tconst matching_nodes: BaseNodeType[] = [];\n\t\tfor (let node of nodes) {\n\t\t\tconst path = node.fullPath();\n\t\t\tif (CoreString.matchMask(path, mask)) {\n\t\t\t\tmatching_nodes.push(node);\n\t\t\t}\n\t\t}\n\t\treturn matching_nodes;\n\t}\n\n\treset_node_context_signatures() {\n\t\tthis._node_context_signatures = {};\n\t}\n\tregister_node_context_signature(node: BaseNodeType) {\n\t\tif (node.childrenAllowed() && node.childrenController) {\n\t\t\tthis._node_context_signatures[node.childrenController.node_context_signature()] = true;\n\t\t}\n\t}\n\tnode_context_signatures() {\n\t\treturn Object.keys(this._node_context_signatures)\n\t\t\t.sort()\n\t\t\t.map((s) => s.toLowerCase());\n\t}\n\n\taddToInstanciatedNode(node: BaseNodeType) {\n\t\tconst context = node.nodeContext();\n\t\tconst node_type = node.type();\n\t\tthis._instanciated_nodes_by_context_and_type[context] =\n\t\t\tthis._instanciated_nodes_by_context_and_type[context] || {};\n\t\tthis._instanciated_nodes_by_context_and_type[context][node_type] =\n\t\t\tthis._instanciated_nodes_by_context_and_type[context][node_type] || {};\n\t\tthis._instanciated_nodes_by_context_and_type[context][node_type][node.graphNodeId()] = node;\n\t}\n\n\tremoveFromInstanciatedNode(node: BaseNodeType) {\n\t\tconst context = node.nodeContext();\n\t\tconst node_type = node.type();\n\t\tdelete this._instanciated_nodes_by_context_and_type[context][node_type][node.graphNodeId()];\n\t}\n\tnodesByType(type: string): BaseNodeType[] {\n\t\tconst list: BaseNodeType[] = [];\n\n\t\tthis._traverseNode(this.scene.root(), (node) => {\n\t\t\tif (node.type() == type) {\n\t\t\t\tlist.push(node);\n\t\t\t}\n\t\t});\n\n\t\treturn list;\n\t}\n\n\tnodesByContextAndType<T extends keyof NodeChildrenMapByContext[NodeContext.ANIM]>(\n\t\tcontext: NodeContext.ANIM,\n\t\tnode_type: T\n\t): NodeChildrenMapByContext[NodeContext.ANIM][T][];\n\tnodesByContextAndType<T extends keyof NodeChildrenMapByContext[NodeContext.COP]>(\n\t\tcontext: NodeContext.COP,\n\t\tnode_type: T\n\t): NodeChildrenMapByContext[NodeContext.COP][T][];\n\tnodesByContextAndType<T extends keyof NodeChildrenMapByContext[NodeContext.EVENT]>(\n\t\tcontext: NodeContext.EVENT,\n\t\tnode_type: T\n\t): NodeChildrenMapByContext[NodeContext.EVENT][T][];\n\tnodesByContextAndType<T extends keyof NodeChildrenMapByContext[NodeContext.GL]>(\n\t\tcontext: NodeContext.GL,\n\t\tnode_type: T\n\t): NodeChildrenMapByContext[NodeContext.GL][T][];\n\tnodesByContextAndType<T extends keyof NodeChildrenMapByContext[NodeContext.JS]>(\n\t\tcontext: NodeContext.JS,\n\t\tnode_type: T\n\t): NodeChildrenMapByContext[NodeContext.JS][T][];\n\tnodesByContextAndType<T extends keyof NodeChildrenMapByContext[NodeContext.MAT]>(\n\t\tcontext: NodeContext.MAT,\n\t\tnode_type: T\n\t): NodeChildrenMapByContext[NodeContext.MAT][T][];\n\tnodesByContextAndType<T extends keyof NodeChildrenMapByContext[NodeContext.OBJ]>(\n\t\tcontext: NodeContext.OBJ,\n\t\tnode_type: T\n\t): NodeChildrenMapByContext[NodeContext.OBJ][T][];\n\tnodesByContextAndType<T extends keyof NodeChildrenMapByContext[NodeContext.POST]>(\n\t\tcontext: NodeContext.POST,\n\t\tnode_type: T\n\t): NodeChildrenMapByContext[NodeContext.POST][T][];\n\tnodesByContextAndType<T extends keyof NodeChildrenMapByContext[NodeContext.ROP]>(\n\t\tcontext: NodeContext.ROP,\n\t\tnode_type: T\n\t): NodeChildrenMapByContext[NodeContext.ROP][T][];\n\tnodesByContextAndType<T extends keyof NodeChildrenMapByContext[NodeContext.SOP]>(\n\t\tcontext: NodeContext.SOP,\n\t\tnode_type: T\n\t): NodeChildrenMapByContext[NodeContext.SOP][T][];\n\tnodesByContextAndType<NC extends NodeContext>(context: NC, node_type: string) {\n\t\tconst nodes = [];\n\t\tconst nodes_for_context = this._instanciated_nodes_by_context_and_type[context];\n\t\tif (nodes_for_context) {\n\t\t\tconst nodes_by_ids = nodes_for_context[node_type];\n\t\t\tif (nodes_by_ids) {\n\t\t\t\tfor (let id of Object.keys(nodes_by_ids)) {\n\t\t\t\t\tnodes.push(nodes_by_ids[id]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn nodes;\n\t}\n}\n","import {PolyScene} from '../PolyScene';\nimport {NodeSerializer} from '../../../engine/nodes/utils/Serializer';\nimport {PolyDictionary} from '../../../types/GlobalTypes';\n\nexport class PolySceneSerializer {\n\tconstructor(private scene: PolyScene) {}\n\n\ttoJSON(include_node_param_components: boolean = false) {\n\t\tconst nodes_by_graph_node_id: PolyDictionary<object> = {};\n\t\tconst params_by_graph_node_id: PolyDictionary<object> = {};\n\n\t\tfor (let node of this.scene.nodesController.allNodes()) {\n\t\t\tconst node_serializer = new NodeSerializer(node);\n\t\t\tnodes_by_graph_node_id[node.graphNodeId()] = node_serializer.toJSON(include_node_param_components);\n\n\t\t\tconst params = node.params.all;\n\t\t\tfor (let param of params) {\n\t\t\t\tparams_by_graph_node_id[param.graphNodeId()] = param.toJSON();\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tnodes_by_graph_node_id,\n\t\t\tparams_by_graph_node_id,\n\t\t};\n\t}\n}\n","import {BaseSceneEventsController} from './_BaseEventsController';\nimport {MouseEventNode} from '../../../nodes/event/Mouse';\n\n// https://developer.mozilla.org/en-US/docs/Web/Events\nenum MouseEventType {\n\tauxclick = 'auxclick',\n\tclick = 'click',\n\tcontextmenu = 'contextmenu',\n\tdblclick = 'dblclick',\n\tmousedown = 'mousedown',\n\tmouseenter = 'mouseenter',\n\tmouseleave = 'mouseleave',\n\tmousemove = 'mousemove',\n\tmouseover = 'mouseover',\n\tmouseout = 'mouseout',\n\tmouseup = 'mouseup',\n\tpointerlockchange = 'pointerlockchange',\n\tpointerlockerror = 'pointerlockerror',\n\tselect = 'select',\n\twheel = 'wheel',\n}\nexport const ACCEPTED_MOUSE_EVENT_TYPES: MouseEventType[] = [\n\tMouseEventType.auxclick,\n\tMouseEventType.click,\n\tMouseEventType.contextmenu,\n\tMouseEventType.dblclick,\n\tMouseEventType.mousedown,\n\tMouseEventType.mouseenter,\n\tMouseEventType.mouseleave,\n\tMouseEventType.mousemove,\n\tMouseEventType.mouseover,\n\tMouseEventType.mouseout,\n\tMouseEventType.mouseup,\n\tMouseEventType.pointerlockchange,\n\tMouseEventType.pointerlockerror,\n\tMouseEventType.select,\n\tMouseEventType.wheel,\n];\n\nexport class MouseEventsController extends BaseSceneEventsController<MouseEvent, MouseEventNode> {\n\tprotected _require_canvas_event_listeners: boolean = true;\n\ttype() {\n\t\treturn 'mouse';\n\t}\n\tacceptedEventTypes() {\n\t\treturn ACCEPTED_MOUSE_EVENT_TYPES.map((n) => `${n}`);\n\t}\n\t// accepts_event(event: MouseEvent) {\n\t// \treturn ACCEPTED_MOUSE_EVENT_TYPES.includes(event.type as MouseEventType);\n\t// }\n}\n","import {TypedEventNode} from './_Base';\nimport {EventContext} from '../../scene/utils/events/_BaseEventsController';\nimport {NodeParamsConfig} from '../utils/params/ParamsConfig';\nimport {ParamOptions} from '../../params/utils/OptionsController';\nimport {BaseNodeType} from '../_Base';\n\nexport const EVENT_PARAM_OPTIONS: ParamOptions = {\n\tvisibleIf: {active: 1},\n\tcallback: (node: BaseNodeType) => {\n\t\tBaseInputEventNodeClass.PARAM_CALLBACK_update_register(node as BaseInputEventNodeType);\n\t},\n};\n\nexport abstract class TypedInputEventNode<K extends NodeParamsConfig> extends TypedEventNode<K> {\n\tinitializeBaseNode() {\n\t\tsuper.initializeBaseNode();\n\n\t\tconst register = () => {\n\t\t\tthis.scene().eventsDispatcher.registerEventNode(this);\n\t\t};\n\t\tconst unregister = () => {\n\t\t\tthis.scene().eventsDispatcher.unregisterEventNode(this);\n\t\t};\n\t\tthis.lifecycle.add_on_add_hook(register);\n\t\t// this.lifecycle.add_on_creation_completed_hook(register);\n\t\tthis.lifecycle.add_delete_hook(unregister);\n\n\t\tthis.params.onParamsCreated('update_register', () => {\n\t\t\tthis._update_register();\n\t\t});\n\t}\n\n\tprocess_event(event_context: EventContext<Event>) {\n\t\tif (!this.pv.active) {\n\t\t\treturn;\n\t\t}\n\t\tif (!event_context.event) {\n\t\t\treturn;\n\t\t}\n\t\tthis.dispatch_event_to_output(event_context.event.type, event_context);\n\t}\n\n\tstatic PARAM_CALLBACK_update_register(node: BaseInputEventNodeType) {\n\t\tnode._update_register();\n\t}\n\tprivate _update_register() {\n\t\tthis._update_active_event_names();\n\t\tthis.scene().eventsDispatcher.updateViewerEventListeners(this);\n\t}\n\n\tprivate _active_event_names: string[] = [];\n\tprivate _update_active_event_names() {\n\t\tthis._active_event_names = [];\n\t\tif (this.pv.active) {\n\t\t\tconst list = this.accepted_event_types();\n\t\t\tfor (let name of list) {\n\t\t\t\tconst param = this.params.get(name);\n\t\t\t\tif (param && param.value) {\n\t\t\t\t\tthis._active_event_names.push(name);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprotected abstract accepted_event_types(): string[];\n\tactive_event_names() {\n\t\treturn this._active_event_names;\n\t}\n}\n\nexport type BaseInputEventNodeType = TypedInputEventNode<any>;\nexport class BaseInputEventNodeClass extends TypedInputEventNode<any> {\n\taccepted_event_types() {\n\t\treturn [];\n\t}\n}\n","/**\n * Allows to trigger mouse events.\n *\n *\n */\nimport {EventConnectionPoint, EventConnectionPointType} from '../utils/io/connections/Event';\nimport {ACCEPTED_MOUSE_EVENT_TYPES} from '../../scene/utils/events/MouseEventsController';\nimport {BaseNodeType} from '../_Base';\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {TypedInputEventNode, EVENT_PARAM_OPTIONS} from './_BaseInput';\nclass MouseEventParamsConfig extends NodeParamsConfig {\n\t/** @param toggle on to allow any event to be listened to */\n\tactive = ParamConfig.BOOLEAN(true, {\n\t\tcallback: (node: BaseNodeType) => {\n\t\t\tMouseEventNode.PARAM_CALLBACK_update_register(node as MouseEventNode);\n\t\t},\n\t});\n\tsep = ParamConfig.SEPARATOR(null, {visibleIf: {active: true}});\n\t/** @param toggle on to listen to auxclick events */\n\tauxclick = ParamConfig.BOOLEAN(0, EVENT_PARAM_OPTIONS);\n\t/** @param toggle on to listen to click events */\n\tclick = ParamConfig.BOOLEAN(0, EVENT_PARAM_OPTIONS);\n\t/** @param toggle on to listen to contextmenu events */\n\tcontextmenu = ParamConfig.BOOLEAN(0, EVENT_PARAM_OPTIONS);\n\t/** @param toggle on to listen to dblclick events */\n\tdblclick = ParamConfig.BOOLEAN(0, EVENT_PARAM_OPTIONS);\n\t/** @param toggle on to listen to mousedown events */\n\tmousedown = ParamConfig.BOOLEAN(1, EVENT_PARAM_OPTIONS);\n\t/** @param toggle on to listen to mouseenter events */\n\tmouseenter = ParamConfig.BOOLEAN(0, EVENT_PARAM_OPTIONS);\n\t/** @param toggle on to listen to mouseleave events */\n\tmouseleave = ParamConfig.BOOLEAN(0, EVENT_PARAM_OPTIONS);\n\t/** @param toggle on to listen to mousemove events */\n\tmousemove = ParamConfig.BOOLEAN(1, EVENT_PARAM_OPTIONS);\n\t/** @param toggle on to listen to mouseover events */\n\tmouseover = ParamConfig.BOOLEAN(0, EVENT_PARAM_OPTIONS);\n\t/** @param toggle on to listen to mouseout events */\n\tmouseout = ParamConfig.BOOLEAN(0, EVENT_PARAM_OPTIONS);\n\t/** @param toggle on to listen to mouseup events */\n\tmouseup = ParamConfig.BOOLEAN(1, EVENT_PARAM_OPTIONS);\n\t/** @param toggle on to listen to pointerlockchange events */\n\tpointerlockchange = ParamConfig.BOOLEAN(0, EVENT_PARAM_OPTIONS);\n\t/** @param toggle on to listen to pointerlockerror events */\n\tpointerlockerror = ParamConfig.BOOLEAN(0, EVENT_PARAM_OPTIONS);\n\t/** @param toggle on to listen to select events */\n\tselect = ParamConfig.BOOLEAN(0, EVENT_PARAM_OPTIONS);\n\t/** @param toggle on to listen to wheel events */\n\twheel = ParamConfig.BOOLEAN(0, EVENT_PARAM_OPTIONS);\n}\nconst ParamsConfig = new MouseEventParamsConfig();\n\nexport class MouseEventNode extends TypedInputEventNode<MouseEventParamsConfig> {\n\tparams_config = ParamsConfig;\n\tstatic type() {\n\t\treturn 'mouse';\n\t}\n\tprotected accepted_event_types() {\n\t\treturn ACCEPTED_MOUSE_EVENT_TYPES.map((n) => `${n}`);\n\t}\n\tinitializeNode() {\n\t\tthis.io.outputs.setNamedOutputConnectionPoints(\n\t\t\tACCEPTED_MOUSE_EVENT_TYPES.map((event_type) => {\n\t\t\t\treturn new EventConnectionPoint(event_type, EventConnectionPointType.MOUSE);\n\t\t\t})\n\t\t);\n\t}\n}\n","import {BaseSceneEventsController} from './_BaseEventsController';\nimport {PointerEventNode} from '../../../nodes/event/Pointer';\n\n// https://developer.mozilla.org/en-US/docs/Web/Events\nenum PointerEventType {\n\tpointerdown = 'pointerdown',\n\tpointermove = 'pointermove',\n\tpointerup = 'pointerup',\n}\nexport const ACCEPTED_POINTER_EVENT_TYPES: PointerEventType[] = [\n\tPointerEventType.pointerdown,\n\tPointerEventType.pointermove,\n\tPointerEventType.pointerup,\n];\n\nexport class PointerEventsController extends BaseSceneEventsController<MouseEvent, PointerEventNode> {\n\tprotected _require_canvas_event_listeners: boolean = true;\n\ttype() {\n\t\treturn 'pointer';\n\t}\n\tacceptedEventTypes() {\n\t\treturn ACCEPTED_POINTER_EVENT_TYPES.map((n) => `${n}`);\n\t}\n}\n","/**\n * Allows to trigger pointer events.\n *\n *\n */\nimport {EventConnectionPoint, EventConnectionPointType} from '../utils/io/connections/Event';\nimport {ACCEPTED_POINTER_EVENT_TYPES} from '../../scene/utils/events/PointerEventsController';\nimport {BaseNodeType} from '../_Base';\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {TypedInputEventNode, EVENT_PARAM_OPTIONS} from './_BaseInput';\nclass PointerEventParamsConfig extends NodeParamsConfig {\n\t/** @param toggle on to allow any event to be listened to */\n\tactive = ParamConfig.BOOLEAN(true, {\n\t\tcallback: (node: BaseNodeType) => {\n\t\t\tPointerEventNode.PARAM_CALLBACK_update_register(node as PointerEventNode);\n\t\t},\n\t});\n\tsep = ParamConfig.SEPARATOR(null, {visibleIf: {active: true}});\n\t/** @param toggle on to listen to click events */\n\tpointerdown = ParamConfig.BOOLEAN(1, EVENT_PARAM_OPTIONS);\n\t/** @param toggle on to listen to pointermove events */\n\tpointermove = ParamConfig.BOOLEAN(0, EVENT_PARAM_OPTIONS);\n\t/** @param toggle on to listen to pointerup events */\n\tpointerup = ParamConfig.BOOLEAN(0, EVENT_PARAM_OPTIONS);\n}\nconst ParamsConfig = new PointerEventParamsConfig();\n\nexport class PointerEventNode extends TypedInputEventNode<PointerEventParamsConfig> {\n\tparams_config = ParamsConfig;\n\tstatic type() {\n\t\treturn 'pointer';\n\t}\n\tprotected accepted_event_types() {\n\t\treturn ACCEPTED_POINTER_EVENT_TYPES.map((n) => `${n}`);\n\t}\n\tinitializeNode() {\n\t\tthis.io.outputs.setNamedOutputConnectionPoints(\n\t\t\tACCEPTED_POINTER_EVENT_TYPES.map((event_type) => {\n\t\t\t\treturn new EventConnectionPoint(event_type, EventConnectionPointType.POINTER);\n\t\t\t})\n\t\t);\n\t}\n}\n","/**\n * Sends events related to the scene\n *\n *\n */\nimport {ACCEPTED_SCENE_EVENT_TYPES} from '../../scene/utils/events/SceneEventsController';\nimport {BaseNodeType} from '../_Base';\nimport {BaseParamType} from '../../params/_Base';\nimport {EventConnectionPoint, EventConnectionPointType, BaseEventConnectionPoint} from '../utils/io/connections/Event';\nimport {TypedInputEventNode, EVENT_PARAM_OPTIONS} from './_BaseInput';\nimport {EventContext} from '../../scene/utils/events/_BaseEventsController';\n\nenum SceneNodeInput {\n\tSET_FRAME = 'setFrame',\n}\nenum SceneNodeOutput {\n\tTIME_REACHED = 'timeReached',\n}\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {CoreGraphNode} from '../../../core/graph/CoreGraphNode';\nclass SceneEventParamsConfig extends NodeParamsConfig {\n\t/** @param toggle on to allow any event to be listened to */\n\tactive = ParamConfig.BOOLEAN(true, {\n\t\tcallback: (node: BaseNodeType, param: BaseParamType) => {\n\t\t\tSceneEventNode.PARAM_CALLBACK_update_register(node as SceneEventNode);\n\t\t},\n\t});\n\tsep = ParamConfig.SEPARATOR(null, {visibleIf: {active: true}});\n\t/** @param toggle on to trigger an event when the scene has loaded. This can be useful to initialize other nodes */\n\tsceneLoaded = ParamConfig.BOOLEAN(1, EVENT_PARAM_OPTIONS);\n\t/** @param toggle on to trigger an event when the scene starts playing */\n\tplay = ParamConfig.BOOLEAN(1, EVENT_PARAM_OPTIONS);\n\t/** @param toggle on to trigger an event when the scene pauses */\n\tpause = ParamConfig.BOOLEAN(1, EVENT_PARAM_OPTIONS);\n\t/** @param toggle on to trigger an event on every tick */\n\ttick = ParamConfig.BOOLEAN(1, EVENT_PARAM_OPTIONS);\n\tsep0 = ParamConfig.SEPARATOR();\n\t/** @param toggle on to trigger an event on every tick */\n\ttreachedTime = ParamConfig.BOOLEAN(0, {\n\t\tcallback: (node: BaseNodeType) => {\n\t\t\tSceneEventNode.PARAM_CALLBACK_update_time_dependency(node as SceneEventNode);\n\t\t},\n\t});\n\t/** @param time to trigger an event */\n\treachedTime = ParamConfig.INTEGER(10, {\n\t\tvisibleIf: {treachedTime: 1},\n\t\trange: [0, 100],\n\t});\n\tsep1 = ParamConfig.SEPARATOR();\n\t/** @param frame to set */\n\tsetFrameValue = ParamConfig.INTEGER(1, {\n\t\trange: [0, 100],\n\t});\n\t/** @param button to set a specific frame */\n\tsetFrame = ParamConfig.BUTTON(null, {\n\t\tcallback: (node: BaseNodeType) => {\n\t\t\tSceneEventNode.PARAM_CALLBACK_setFrame(node as SceneEventNode);\n\t\t},\n\t});\n}\nconst ParamsConfig = new SceneEventParamsConfig();\n\nexport class SceneEventNode extends TypedInputEventNode<SceneEventParamsConfig> {\n\tparams_config = ParamsConfig;\n\tstatic type() {\n\t\treturn 'scene';\n\t}\n\n\tprivate graph_node: CoreGraphNode | undefined;\n\n\tprotected accepted_event_types() {\n\t\treturn ACCEPTED_SCENE_EVENT_TYPES.map((n) => `${n}`);\n\t}\n\n\tdispose() {\n\t\tthis.graph_node?.dispose();\n\t\tsuper.dispose();\n\t}\n\n\tinitializeNode() {\n\t\tthis.io.inputs.setNamedInputConnectionPoints([\n\t\t\tnew EventConnectionPoint(\n\t\t\t\tSceneNodeInput.SET_FRAME,\n\t\t\t\tEventConnectionPointType.BASE,\n\t\t\t\tthis.onSetFrame.bind(this)\n\t\t\t),\n\t\t]);\n\t\tconst out_connection_points: BaseEventConnectionPoint[] = ACCEPTED_SCENE_EVENT_TYPES.map((event_type) => {\n\t\t\treturn new EventConnectionPoint(event_type, EventConnectionPointType.BASE);\n\t\t});\n\t\tout_connection_points.push(\n\t\t\tnew EventConnectionPoint(SceneNodeOutput.TIME_REACHED, EventConnectionPointType.BASE)\n\t\t);\n\t\tthis.io.outputs.setNamedOutputConnectionPoints(out_connection_points);\n\n\t\tthis.params.onParamsCreated('update_time_dependency', () => {\n\t\t\tthis.update_time_dependency();\n\t\t});\n\t}\n\n\tprivate onSetFrame(event_context: EventContext<Event>) {\n\t\tthis.scene().setFrame(this.pv.setFrameValue);\n\t}\n\n\tprivate on_frame_update() {\n\t\tif (this.scene().time() >= this.pv.reachedTime) {\n\t\t\tthis.dispatch_event_to_output(SceneNodeOutput.TIME_REACHED, {});\n\t\t}\n\t}\n\tprivate update_time_dependency() {\n\t\tif (this.pv.treachedTime) {\n\t\t\tthis.graph_node = this.graph_node || new CoreGraphNode(this.scene(), 'scene_node_time_graph_node');\n\t\t\tthis.graph_node.addGraphInput(this.scene().timeController.graphNode);\n\t\t\tthis.graph_node.addPostDirtyHook('time_update', this.on_frame_update.bind(this));\n\t\t} else {\n\t\t\tif (this.graph_node) {\n\t\t\t\tthis.graph_node.graphDisconnectPredecessors();\n\t\t\t}\n\t\t}\n\t}\n\tstatic PARAM_CALLBACK_setFrame(node: SceneEventNode) {\n\t\tnode.onSetFrame({});\n\t}\n\tstatic PARAM_CALLBACK_update_time_dependency(node: SceneEventNode) {\n\t\tnode.update_time_dependency();\n\t}\n}\n","import {BaseSceneEventsController} from './_BaseEventsController';\nimport {KeyboardEventNode} from '../../../nodes/event/Keyboard';\n\n// https://developer.mozilla.org/en-US/docs/Web/Events\nenum KeyboardEventType {\n\tkeydown = 'keydown',\n\tkeypress = 'keypress',\n\tkeyup = 'keyup',\n}\nexport const ACCEPTED_KEYBOARD_EVENT_TYPES: KeyboardEventType[] = [\n\tKeyboardEventType.keydown,\n\tKeyboardEventType.keypress,\n\tKeyboardEventType.keyup,\n];\n\nexport class KeyboardEventsController extends BaseSceneEventsController<KeyboardEvent, KeyboardEventNode> {\n\tprotected _require_canvas_event_listeners: boolean = true;\n\ttype() {\n\t\treturn 'keyboard';\n\t}\n\tacceptedEventTypes() {\n\t\treturn ACCEPTED_KEYBOARD_EVENT_TYPES.map((n) => `${n}`);\n\t}\n\t// accepts_event(event: MouseEvent) {\n\t// \treturn ACCEPTED_KEYBOARD_EVENT_TYPES.includes(event.type as KeyboardEventType);\n\t// }\n}\n","/**\n * Allows to trigger keyboard events.\n *\n *\n */\nimport {EventConnectionPoint, EventConnectionPointType} from '../utils/io/connections/Event';\nimport {BaseNodeType} from '../_Base';\nimport {BaseParamType} from '../../params/_Base';\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {TypedInputEventNode, EVENT_PARAM_OPTIONS} from './_BaseInput';\nimport {ACCEPTED_KEYBOARD_EVENT_TYPES} from '../../scene/utils/events/KeyboardEventsController';\nclass KeyboardEventParamsConfig extends NodeParamsConfig {\n\t/** @param toggle on to allow any event to be listened to */\n\tactive = ParamConfig.BOOLEAN(true, {\n\t\tcallback: (node: BaseNodeType, param: BaseParamType) => {\n\t\t\tKeyboardEventNode.PARAM_CALLBACK_update_register(node as KeyboardEventNode);\n\t\t},\n\t});\n\tsep = ParamConfig.SEPARATOR(null, {visibleIf: {active: true}});\n\t/** @param toggle on to listen to keydown events */\n\tkeydown = ParamConfig.BOOLEAN(1, EVENT_PARAM_OPTIONS);\n\t/** @param toggle on to listen to keypress events */\n\tkeypress = ParamConfig.BOOLEAN(0, EVENT_PARAM_OPTIONS);\n\t/** @param toggle on to listen to keyup events */\n\tkeyup = ParamConfig.BOOLEAN(0, EVENT_PARAM_OPTIONS);\n}\nconst ParamsConfig = new KeyboardEventParamsConfig();\n\nexport class KeyboardEventNode extends TypedInputEventNode<KeyboardEventParamsConfig> {\n\tparams_config = ParamsConfig;\n\tstatic type() {\n\t\treturn 'keyboard';\n\t}\n\tprotected accepted_event_types() {\n\t\treturn ACCEPTED_KEYBOARD_EVENT_TYPES.map((n) => `${n}`);\n\t}\n\tinitializeNode() {\n\t\tthis.io.outputs.setNamedOutputConnectionPoints(\n\t\t\tACCEPTED_KEYBOARD_EVENT_TYPES.map((event_type) => {\n\t\t\t\treturn new EventConnectionPoint(event_type, EventConnectionPointType.KEYBOARD);\n\t\t\t})\n\t\t);\n\t}\n}\n","import {Constructor} from '../../../../types/GlobalTypes';\nimport {PolyScene} from '../../PolyScene';\nimport {BaseEventNodeType} from '../../../nodes/event/_Base';\nimport {MouseEventNode} from '../../../nodes/event/Mouse';\nimport {PointerEventNode} from '../../../nodes/event/Pointer';\nimport {SceneEventNode} from '../../../nodes/event/Scene';\nimport {KeyboardEventNode} from '../../../nodes/event/Keyboard';\nimport {BaseInputEventNodeType} from '../../../nodes/event/_BaseInput';\n\nimport {BaseSceneEventsController, BaseSceneEventsControllerClass} from './_BaseEventsController';\nimport {SceneEventsController} from './SceneEventsController';\nimport {KeyboardEventsController} from './KeyboardEventsController';\nimport {MouseEventsController} from './MouseEventsController';\nimport {PointerEventsController} from './PointerEventsController';\n\nexport class SceneEventsDispatcher {\n\tprivate _keyboard_events_controller: KeyboardEventsController | undefined;\n\tprivate _mouse_events_controller: MouseEventsController | undefined;\n\tprivate _pointer_events_controller: PointerEventsController | undefined;\n\tprivate _scene_events_controller: SceneEventsController | undefined;\n\tprivate _controllers: BaseSceneEventsController<Event, BaseInputEventNodeType>[] = [];\n\tconstructor(public scene: PolyScene) {}\n\n\tregisterEventNode(node: BaseInputEventNodeType) {\n\t\tconst controller = this._find_or_create_controller_for_node(node);\n\t\tif (controller) {\n\t\t\tcontroller.registerNode(node);\n\t\t}\n\t}\n\tunregisterEventNode(node: BaseInputEventNodeType) {\n\t\tconst controller = this._find_or_create_controller_for_node(node);\n\t\tif (controller) {\n\t\t\tcontroller.unregisterNode(node);\n\t\t}\n\t}\n\tupdateViewerEventListeners(node: BaseInputEventNodeType) {\n\t\tconst controller = this._find_or_create_controller_for_node(node);\n\t\tif (controller) {\n\t\t\tcontroller.updateViewerEventListeners();\n\t\t}\n\t}\n\ttraverseControllers(callback: (controller: BaseSceneEventsController<Event, BaseInputEventNodeType>) => void) {\n\t\tfor (let controller of this._controllers) {\n\t\t\tcallback(controller);\n\t\t}\n\t}\n\n\t// process_event(event_content: EventContext<Event>) {\n\t// \tif (!event_content.event) {\n\t// \t\treturn;\n\t// \t}\n\t// \tfor (let controller of this._controllers) {\n\t// \t\tif (controller.accepts_event(event_content.event)) {\n\t// \t\t\tcontroller.process_event(event_content);\n\t// \t\t\treturn;\n\t// \t\t}\n\t// \t}\n\t// }\n\n\tprivate _find_or_create_controller_for_node<T extends BaseEventNodeType>(\n\t\tnode: T\n\t): BaseSceneEventsController<Event, BaseInputEventNodeType> | undefined {\n\t\tswitch (node.type()) {\n\t\t\tcase KeyboardEventNode.type():\n\t\t\t\treturn this.keyboardEventsController;\n\t\t\tcase MouseEventNode.type():\n\t\t\t\treturn this.mouseEventsController;\n\t\t\tcase PointerEventNode.type():\n\t\t\t\treturn this.pointerEventsController;\n\t\t\tcase SceneEventNode.type():\n\t\t\t\treturn this.sceneEventsController;\n\t\t}\n\t}\n\n\tget keyboardEventsController() {\n\t\treturn (this._keyboard_events_controller =\n\t\t\tthis._keyboard_events_controller || this._create_controller(KeyboardEventsController));\n\t}\n\tget mouseEventsController() {\n\t\treturn (this._mouse_events_controller =\n\t\t\tthis._mouse_events_controller || this._create_controller(MouseEventsController));\n\t}\n\tget pointerEventsController() {\n\t\treturn (this._pointer_events_controller =\n\t\t\tthis._pointer_events_controller || this._create_controller(PointerEventsController));\n\t}\n\tget sceneEventsController() {\n\t\treturn (this._scene_events_controller =\n\t\t\tthis._scene_events_controller || this._create_controller(SceneEventsController));\n\t}\n\tprivate _create_controller<T extends BaseSceneEventsControllerClass>(event_constructor: Constructor<T>): T {\n\t\tconst controller = new event_constructor(this);\n\t\tif (!this._controllers.includes(controller)) {\n\t\t\tthis._controllers.push(controller);\n\t\t}\n\t\treturn controller;\n\t}\n}\n","export enum SceneEvent {\n\tMAX_FRAME_UPDATED = 'scene_maxFrameUpdated',\n\tREALTIME_STATUS_UPDATED = 'scene_realtime_status_updated',\n\tFRAME_UPDATED = 'scene_frame_updated',\n\tPLAY_STATE_UPDATED = 'scene_play_state_updated',\n}\n","import {PolyScene} from '../PolyScene';\nimport {BaseNodeType} from '../../nodes/_Base';\nimport {TypedPathParam} from '../../params/_BasePath';\nimport {MapUtils} from '../../../core/MapUtils';\nimport {ParamType} from '../../poly/ParamType';\nimport {BaseParamType} from '../../params/_Base';\nimport {CoreGraphNodeId} from '../../../core/graph/CoreGraph';\nimport {OperatorPathParam} from '../../params/OperatorPath';\n\ntype BasePathParam = TypedPathParam<any>;\n// class BasePathParam extends Typ\n\nexport class ReferencesController {\n\tprivate _referenced_nodes_by_src_param_id: Map<CoreGraphNodeId, BaseNodeType | BaseParamType> = new Map();\n\tprivate _referencing_params_by_referenced_node_id: Map<CoreGraphNodeId, BasePathParam[]> = new Map();\n\tprivate _referencing_params_by_all_named_node_ids: Map<CoreGraphNodeId, BasePathParam[]> = new Map();\n\tconstructor(protected scene: PolyScene) {}\n\n\tset_reference_from_param(src_param: BasePathParam, referenced_node: BaseNodeType | BaseParamType) {\n\t\tthis._referenced_nodes_by_src_param_id.set(src_param.graphNodeId(), referenced_node);\n\t\tMapUtils.push_on_array_at_entry(\n\t\t\tthis._referencing_params_by_referenced_node_id,\n\t\t\treferenced_node.graphNodeId(),\n\t\t\tsrc_param\n\t\t);\n\t}\n\tset_named_nodes_from_param(src_param: BasePathParam) {\n\t\tconst named_nodes: BaseNodeType[] = src_param.decomposed_path.named_nodes();\n\t\tfor (let named_node of named_nodes) {\n\t\t\tMapUtils.push_on_array_at_entry(\n\t\t\t\tthis._referencing_params_by_all_named_node_ids,\n\t\t\t\tnamed_node.graphNodeId(),\n\t\t\t\tsrc_param\n\t\t\t);\n\t\t}\n\t}\n\treset_reference_from_param(src_param: BasePathParam) {\n\t\tconst referenced_node = this._referenced_nodes_by_src_param_id.get(src_param.graphNodeId());\n\t\tif (referenced_node) {\n\t\t\tMapUtils.pop_from_array_at_entry(\n\t\t\t\tthis._referencing_params_by_referenced_node_id,\n\t\t\t\treferenced_node.graphNodeId(),\n\t\t\t\tsrc_param\n\t\t\t);\n\t\t\tconst named_nodes: BaseNodeType[] = src_param.decomposed_path.named_nodes();\n\t\t\tfor (let named_node of named_nodes) {\n\t\t\t\tMapUtils.pop_from_array_at_entry(\n\t\t\t\t\tthis._referencing_params_by_all_named_node_ids,\n\t\t\t\t\tnamed_node.graphNodeId(),\n\t\t\t\t\tsrc_param\n\t\t\t\t);\n\t\t\t}\n\t\t\tthis._referenced_nodes_by_src_param_id.delete(src_param.graphNodeId());\n\t\t}\n\t}\n\n\treferencing_params(node: BaseNodeType) {\n\t\treturn this._referencing_params_by_referenced_node_id.get(node.graphNodeId());\n\t}\n\treferencing_nodes(node: BaseNodeType) {\n\t\tconst params = this._referencing_params_by_referenced_node_id.get(node.graphNodeId());\n\t\tif (params) {\n\t\t\tconst node_by_node_id: Map<CoreGraphNodeId, BaseNodeType> = new Map();\n\t\t\tfor (let param of params) {\n\t\t\t\tconst node = param.node;\n\t\t\t\tnode_by_node_id.set(node.graphNodeId(), node);\n\t\t\t}\n\t\t\tconst nodes: BaseNodeType[] = [];\n\t\t\tnode_by_node_id.forEach((node) => {\n\t\t\t\tnodes.push(node);\n\t\t\t});\n\t\t\treturn nodes;\n\t\t}\n\t}\n\tnodes_referenced_by(node: BaseNodeType) {\n\t\tconst path_param_types: Readonly<Set<ParamType>> = new Set([ParamType.OPERATOR_PATH, ParamType.NODE_PATH]);\n\t\tconst path_params: BasePathParam[] = [];\n\t\tfor (let param of node.params.all) {\n\t\t\tif (path_param_types.has(param.type())) {\n\t\t\t\tpath_params.push(param as BasePathParam);\n\t\t\t}\n\t\t}\n\t\tconst nodes_by_id: Map<CoreGraphNodeId, BaseNodeType> = new Map();\n\t\tconst params: BaseParamType[] = [];\n\t\tfor (let path_param of path_params) {\n\t\t\tthis._check_param(path_param, nodes_by_id, params);\n\t\t}\n\t\tfor (let param of params) {\n\t\t\tnodes_by_id.set(param.node.graphNodeId(), param.node);\n\t\t}\n\t\tconst nodes: BaseNodeType[] = [];\n\t\tnodes_by_id.forEach((node) => {\n\t\t\tnodes.push(node);\n\t\t});\n\t\treturn nodes;\n\t}\n\tprivate _check_param(\n\t\tparam: BasePathParam,\n\t\tnodes_by_id: Map<CoreGraphNodeId, BaseNodeType>,\n\t\tparams: BaseParamType[]\n\t) {\n\t\tif (param instanceof OperatorPathParam) {\n\t\t\tconst found_node = param.found_node();\n\t\t\tconst found_param = param.found_param();\n\t\t\tif (found_node) {\n\t\t\t\tnodes_by_id.set(found_node.graphNodeId(), found_node);\n\t\t\t}\n\t\t\tif (found_param) {\n\t\t\t\tparams.push(found_param);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t}\n\n\t//\n\t//\n\t// TRACK NAME CHANGES\n\t//\n\t//\n\tnotify_name_updated(node: BaseNodeType) {\n\t\tconst referencing_params = this._referencing_params_by_all_named_node_ids.get(node.graphNodeId());\n\t\tif (referencing_params) {\n\t\t\tfor (let referencing_param of referencing_params) {\n\t\t\t\treferencing_param.notify_path_rebuild_required(node);\n\t\t\t}\n\t\t}\n\t}\n\n\t//\n\t//\n\t// TRACK NODE DELETIONS/ADDITIONS\n\t//\n\t//\n\n\t//\n\t//\n\t// TRACK PARAM DELETIONS/ADDITIONS\n\t//\n\t//\n\tnotify_params_updated(node: BaseNodeType) {\n\t\tconst referencing_params = this._referencing_params_by_all_named_node_ids.get(node.graphNodeId());\n\t\tif (referencing_params) {\n\t\t\tfor (let referencing_param of referencing_params) {\n\t\t\t\tif (referencing_param.options.is_selecting_param()) {\n\t\t\t\t\treferencing_param.notify_target_param_owner_params_updated(node);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n","import {PolyScene} from '../PolyScene';\nimport {CoreGraphNode} from '../../../core/graph/CoreGraphNode';\nimport {SceneEvent} from '../../poly/SceneEvent';\nimport {SceneEventType} from './events/SceneEventsController';\nimport {EventContext} from './events/_BaseEventsController';\n\n// ensure that FPS remains a float\n// to have divisions and multiplications also give a float\nconst FPS = 60.0;\n\nexport class TimeController {\n\tstatic START_FRAME: Readonly<number> = 0;\n\tprivate _frame: number = 0;\n\tprivate _time: number = 0;\n\tprivate _prev_performance_now: number = 0;\n\tprivate _graph_node: CoreGraphNode;\n\tprivate _realtimeState = true;\n\tprivate _maxFrame = 600;\n\tprivate _maxFrameLocked = false;\n\tprivate _playing: boolean = false;\n\n\tprivate _PLAY_EVENT_CONTEXT: EventContext<Event> | undefined;\n\tprivate _PAUSE_EVENT_CONTEXT: EventContext<Event> | undefined;\n\tprivate _TICK_EVENT_CONTEXT: EventContext<Event> | undefined;\n\tget PLAY_EVENT_CONTEXT() {\n\t\treturn (this._PLAY_EVENT_CONTEXT = this._PLAY_EVENT_CONTEXT || {event: new Event(SceneEventType.PLAY)});\n\t}\n\tget PAUSE_EVENT_CONTEXT() {\n\t\treturn (this._PAUSE_EVENT_CONTEXT = this._PAUSE_EVENT_CONTEXT || {event: new Event(SceneEventType.PAUSE)});\n\t}\n\tget TICK_EVENT_CONTEXT() {\n\t\treturn (this._TICK_EVENT_CONTEXT = this._TICK_EVENT_CONTEXT || {event: new Event(SceneEventType.TICK)});\n\t}\n\n\tconstructor(private scene: PolyScene) {\n\t\tthis._graph_node = new CoreGraphNode(scene, 'time controller');\n\t}\n\tget graphNode() {\n\t\treturn this._graph_node;\n\t}\n\n\tframe(): number {\n\t\treturn this._frame;\n\t}\n\ttime(): number {\n\t\treturn this._time;\n\t}\n\tmaxFrame() {\n\t\treturn this._maxFrame;\n\t}\n\tmaxFrameLocked() {\n\t\treturn this._maxFrameLocked;\n\t}\n\trealtimeState() {\n\t\treturn this._realtimeState;\n\t}\n\tsetMaxFrame(maxFrame: number) {\n\t\tthis._maxFrame = Math.floor(maxFrame);\n\t\tthis.scene.dispatchController.dispatch(this._graph_node, SceneEvent.MAX_FRAME_UPDATED);\n\t}\n\tsetMaxFrameLocked(state: boolean) {\n\t\tthis._maxFrameLocked = state;\n\t\tthis.scene.dispatchController.dispatch(this._graph_node, SceneEvent.MAX_FRAME_UPDATED);\n\t}\n\tsetRealtimeState(state: boolean) {\n\t\tthis._realtimeState = state;\n\t\tthis.scene.dispatchController.dispatch(this._graph_node, SceneEvent.REALTIME_STATUS_UPDATED);\n\t}\n\t// set_fps(fps: number) {\n\t// \tthis._fps = Math.floor(fps);\n\t// \tthis._frame_interval = 1000 / this._fps;\n\t// \tthis.scene.events_controller.dispatch(this._graph_node, SceneEvent.FRAME_RANGE_UPDATED);\n\t// }\n\tsetTime(time: number, update_frame = true) {\n\t\tif (time != this._time) {\n\t\t\tthis._time = time;\n\n\t\t\tif (update_frame) {\n\t\t\t\tconst new_frame = Math.floor(this._time * FPS);\n\t\t\t\tconst bounded_frame = this._ensureFrameWithinBounds(new_frame);\n\t\t\t\tif (new_frame != bounded_frame) {\n\t\t\t\t\tthis.setFrame(bounded_frame, true);\n\t\t\t\t} else {\n\t\t\t\t\tthis._frame = new_frame;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// update time dependents\n\t\t\tthis.scene.dispatchController.dispatch(this._graph_node, SceneEvent.FRAME_UPDATED);\n\t\t\tthis.scene.uniforms_controller.update_time_dependent_uniform_owners();\n\n\t\t\t// we block updates here, so that dependent nodes only cook once\n\t\t\tthis.scene.cooker.block();\n\t\t\tthis.graphNode.setSuccessorsDirty();\n\t\t\tthis.scene.cooker.unblock();\n\n\t\t\t// dispatch events after nodes have cooked\n\t\t\tthis.scene.eventsDispatcher.sceneEventsController.processEvent(this.TICK_EVENT_CONTEXT);\n\t\t}\n\t}\n\n\tsetFrame(frame: number, update_time = true) {\n\t\tif (frame != this._frame) {\n\t\t\tframe = this._ensureFrameWithinBounds(frame);\n\t\t\tif (frame != this._frame) {\n\t\t\t\tthis._frame = frame;\n\t\t\t\tif (update_time) {\n\t\t\t\t\tthis.setTime(this._frame / FPS, false);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tsetFrameToStart() {\n\t\tthis.setFrame(TimeController.START_FRAME, true);\n\t}\n\tincrementTimeIfPlaying() {\n\t\tif (this._playing) {\n\t\t\tif (!this.scene.root().areChildrenCooking()) {\n\t\t\t\tthis.incrementTime();\n\t\t\t}\n\t\t}\n\t}\n\tincrementTime() {\n\t\tif (this._realtimeState) {\n\t\t\tconst performance_now = performance.now();\n\t\t\tconst delta = (performance_now - this._prev_performance_now) / 1000.0;\n\t\t\tconst new_time = this._time + delta;\n\t\t\tthis._prev_performance_now = performance_now;\n\t\t\tthis.setTime(new_time);\n\t\t} else {\n\t\t\tthis.setFrame(this.frame() + 1);\n\t\t}\n\t}\n\n\t_ensureFrameWithinBounds(frame: number): number {\n\t\tif (this._playing) {\n\t\t\tif (this._maxFrameLocked && frame > this._maxFrame) {\n\t\t\t\treturn TimeController.START_FRAME;\n\t\t\t}\n\t\t} else {\n\t\t\tif (this._maxFrameLocked && frame > this._maxFrame) {\n\t\t\t\treturn this._maxFrame;\n\t\t\t}\n\t\t\tif (frame < TimeController.START_FRAME) {\n\t\t\t\treturn TimeController.START_FRAME;\n\t\t\t}\n\t\t}\n\t\treturn frame;\n\t}\n\tplaying() {\n\t\treturn this._playing === true;\n\t}\n\tpause() {\n\t\tif (this._playing == true) {\n\t\t\tthis._playing = false;\n\t\t\t// TODO: try and unify the dispatch controller and events dispatcher\n\t\t\tthis.scene.dispatchController.dispatch(this._graph_node, SceneEvent.PLAY_STATE_UPDATED);\n\t\t\tthis.scene.eventsDispatcher.sceneEventsController.processEvent(this.PAUSE_EVENT_CONTEXT);\n\t\t}\n\t}\n\tplay() {\n\t\tif (this._playing !== true) {\n\t\t\tthis._playing = true;\n\t\t\tthis._prev_performance_now = performance.now();\n\t\t\tthis.scene.dispatchController.dispatch(this._graph_node, SceneEvent.PLAY_STATE_UPDATED);\n\t\t\tthis.scene.eventsDispatcher.sceneEventsController.processEvent(this.PLAY_EVENT_CONTEXT);\n\t\t}\n\t}\n\ttogglePlayPause() {\n\t\tif (this.playing()) {\n\t\t\tthis.pause();\n\t\t} else {\n\t\t\tthis.play();\n\t\t}\n\t}\n}\n","import {PolyDictionary, Vector2Like} from '../../../types/GlobalTypes';\nimport {PolyScene} from '../PolyScene';\nimport {Vector2} from 'three/src/math/Vector2';\nimport {IUniform} from 'three/src/renderers/shaders/UniformsLib';\n\ntype IUniforms = PolyDictionary<IUniform>;\nexport interface IUniformsWithTime extends IUniforms {\n\ttime: IUniform;\n}\nexport interface IUniformsWithResolution extends IUniforms {\n\tresolution: {\n\t\tvalue: Vector2Like;\n\t};\n}\n\nexport class UniformsController {\n\tconstructor(private scene: PolyScene) {}\n\n\tprivate _time_dependent_uniform_owners: PolyDictionary<IUniformsWithTime> = {}; //new Map()\n\tprivate _time_dependent_uniform_owners_ids: string[] | null = null;\n\n\tprivate _resolution: Vector2 = new Vector2(1, 1);\n\tprivate _resolution_dependent_uniform_owners: PolyDictionary<IUniformsWithResolution> = {};\n\tprivate _resolution_dependent_uniform_owners_ids: string[] = [];\n\n\t// time\n\tadd_time_dependent_uniform_owner(id: string, uniforms: IUniformsWithTime) {\n\t\tthis._time_dependent_uniform_owners[id] = uniforms;\n\t\t// this._update_time_dependent_uniform_owners_ids();\n\t\tif (!this._time_dependent_uniform_owners_ids) {\n\t\t\tthis._time_dependent_uniform_owners_ids = [];\n\t\t}\n\t\tif (!this._time_dependent_uniform_owners_ids.includes(id)) {\n\t\t\tthis._time_dependent_uniform_owners_ids.push(id);\n\t\t}\n\t}\n\tremove_time_dependent_uniform_owner(id: string) {\n\t\tdelete this._time_dependent_uniform_owners[id];\n\t\t// this._update_time_dependent_uniform_owners_ids();\n\t\tif (this._time_dependent_uniform_owners_ids) {\n\t\t\tconst index = this._time_dependent_uniform_owners_ids.indexOf(id);\n\t\t\tif (index >= 0) {\n\t\t\t\tthis._time_dependent_uniform_owners_ids.splice(index, 1);\n\t\t\t}\n\t\t}\n\t}\n\t// private _update_time_dependent_uniform_owners_ids() {\n\t// \tthis._time_dependent_uniform_owners_ids = Object.keys(this._time_dependent_uniform_owners);\n\t// }\n\tpublic update_time_dependent_uniform_owners() {\n\t\tconst time = this.scene.time();\n\t\tif (this._time_dependent_uniform_owners_ids) {\n\t\t\tfor (let id of this._time_dependent_uniform_owners_ids) {\n\t\t\t\tconst uniforms = this._time_dependent_uniform_owners[id];\n\t\t\t\tuniforms.time.value = time;\n\t\t\t}\n\t\t}\n\t}\n\n\t// resolution\n\tadd_resolution_dependent_uniform_owner(id: string, uniforms: IUniformsWithResolution) {\n\t\tthis._resolution_dependent_uniform_owners[id] = uniforms;\n\t\t// this._update_resolution_dependent_uniform_owners_ids();\n\t\tif (!this._resolution_dependent_uniform_owners_ids) {\n\t\t\tthis._resolution_dependent_uniform_owners_ids = [];\n\t\t}\n\t\tif (!this._resolution_dependent_uniform_owners_ids.includes(id)) {\n\t\t\tthis._resolution_dependent_uniform_owners_ids.push(id);\n\t\t}\n\n\t\tif (this._resolution) {\n\t\t\tthis.update_resolution_dependent_uniforms(uniforms);\n\t\t}\n\t}\n\tremove_resolution_dependent_uniform_owner(id: string) {\n\t\tdelete this._resolution_dependent_uniform_owners[id];\n\t\t// this._update_resolution_dependent_uniform_owners_ids();\n\t\tif (this._resolution_dependent_uniform_owners_ids) {\n\t\t\tconst index = this._resolution_dependent_uniform_owners_ids.indexOf(id);\n\t\t\tif (index >= 0) {\n\t\t\t\tthis._resolution_dependent_uniform_owners_ids.splice(index, 1);\n\t\t\t}\n\t\t}\n\t}\n\t// private _update_resolution_dependent_uniform_owners_ids() {\n\t// \tthis._resolution_dependent_uniform_owners_ids = Object.keys(this._resolution_dependent_uniform_owners);\n\t// }\n\tupdate_resolution_dependent_uniform_owners(resolution: Vector2) {\n\t\tthis._resolution.copy(resolution);\n\t\tfor (let id of this._resolution_dependent_uniform_owners_ids) {\n\t\t\tconst uniforms = this._resolution_dependent_uniform_owners[id];\n\t\t\tthis.update_resolution_dependent_uniforms(uniforms);\n\t\t}\n\t}\n\tupdate_resolution_dependent_uniforms(uniforms: IUniformsWithResolution) {\n\t\tuniforms.resolution.value.x = this._resolution.x * window.devicePixelRatio;\n\t\tuniforms.resolution.value.y = this._resolution.y * window.devicePixelRatio;\n\t}\n}\n","import {BaseViewerType} from '../../viewers/_Base';\nimport {PolyScene} from '../../scene/PolyScene';\n\nexport class ViewersRegister {\n\tprivate _viewers_by_id: Map<number, BaseViewerType> = new Map();\n\tconstructor(protected scene: PolyScene) {}\n\n\tregisterViewer(viewer: BaseViewerType) {\n\t\tthis._viewers_by_id.set(viewer.id(), viewer);\n\t}\n\tunregisterViewer(viewer: BaseViewerType) {\n\t\tthis._viewers_by_id.delete(viewer.id());\n\t}\n\ttraverseViewers(callback: (viewer: BaseViewerType) => void) {\n\t\tthis._viewers_by_id.forEach(callback);\n\t}\n}\n","import {Poly} from '../../Poly';\n\n// import {PolyScene} from '../PolyScene';\n\nexport class WebGLController {\n\tconstructor() {}\n\n\t_require_webgl2: boolean = false;\n\n\trequire_webgl2() {\n\t\treturn this._require_webgl2;\n\t}\n\tset_require_webgl2() {\n\t\tif (!this._require_webgl2) {\n\t\t\tthis._require_webgl2 = true;\n\t\t\tPoly.renderersController.setRequireWebGL2();\n\t\t}\n\t}\n}\n","import {StringParam} from '../../params/String';\nimport {CoreGraphNodeId} from '../../../core/graph/CoreGraph';\n\nexport class SceneAssetsController {\n\tprivate _params_by_id: Map<CoreGraphNodeId, StringParam> = new Map();\n\tprivate _assets_root: string | null = null;\n\n\t//\n\t//\n\t// REGISTER PARAMS\n\t//\n\t//\n\tregister_param(param: StringParam) {\n\t\tthis._params_by_id.set(param.graphNodeId(), param);\n\t}\n\n\tderegister_param(param: StringParam) {\n\t\tthis._params_by_id.delete(param.graphNodeId());\n\t}\n\n\ttraverse_params(callback: (param: StringParam) => void) {\n\t\tthis._params_by_id.forEach((param, id) => {\n\t\t\tcallback(param);\n\t\t});\n\t}\n\n\t//\n\t//\n\t// ASSETS ROOT\n\t//\n\t//\n\troot() {\n\t\treturn this._assets_root;\n\t}\n\tsetRoot(url: string | null) {\n\t\tif (url == '') {\n\t\t\turl = null;\n\t\t}\n\t\tthis._assets_root = url;\n\t}\n}\n","import {CamerasController} from './utils/CamerasController';\nimport {Cooker} from './utils/Cooker';\nimport {CookController} from './utils/CookController';\nimport {CoreGraph} from '../../core/graph/CoreGraph';\nimport {CorePerformance} from '../../core/performance/CorePerformance';\nimport {DispatchController} from './utils/DispatchController';\nimport {ExpressionsController} from './utils/ExpressionsController';\nimport {LifeCycleController} from './utils/LifeCycleController';\nimport {LoadingController} from './utils/LoadingController';\nimport {MissingReferencesController} from './utils/MissingReferencesController';\nimport {NodesController} from './utils/NodesController';\nimport {PolySceneSerializer} from './utils/Serializer';\nimport {SceneEventsDispatcher} from './utils/events/EventsDispatcher';\nimport {ObjectsController} from './utils/ObjectsController';\nimport {ReferencesController} from './utils/ReferencesController';\nimport {TimeController} from './utils/TimeController';\nimport {UniformsController} from './utils/UniformsController';\nimport {ViewersRegister} from './utils/ViewersRegister';\nimport {WebGLController} from './utils/WebGLController';\n\nimport {Scene} from 'three/src/scenes/Scene';\nimport {SceneAssetsController} from './utils/AssetsController';\nimport {BaseNodeType} from '../nodes/_Base';\n\nexport class PolyScene {\n\tprotected _threejsScene = new Scene();\n\tthreejsScene() {\n\t\treturn this._threejsScene;\n\t}\n\t_uuid!: string;\n\tsetUuid(uuid: string) {\n\t\treturn (this._uuid = uuid);\n\t}\n\tget uuid() {\n\t\treturn this._uuid;\n\t}\n\t_name: string | undefined;\n\tsetName(name: string) {\n\t\treturn (this._name = name);\n\t}\n\tname() {\n\t\treturn this._name;\n\t}\n\n\tprotected _cameras_controller = new CamerasController(this);\n\tget camerasController() {\n\t\treturn this._cameras_controller;\n\t}\n\tmasterCameraNode() {\n\t\treturn this.camerasController.masterCameraNode();\n\t}\n\n\tprivate _cooker = new Cooker(this);\n\tget cooker() {\n\t\treturn this._cooker;\n\t}\n\n\t// private _cube_cameras_controller: CubeCamerasController;\n\t// get cube_cameras_controller() {\n\t// \treturn (this._cube_cameras_controller = this._cube_cameras_controller || new CubeCamerasController(this));\n\t// }\n\tprivate _assets_controller: SceneAssetsController | undefined;\n\tget assets() {\n\t\treturn (this._assets_controller = this._assets_controller || new SceneAssetsController());\n\t}\n\n\tpublic readonly cookController = new CookController();\n\tasync waitForCooksCompleted() {\n\t\treturn this.cookController.waitForCooksCompleted();\n\t}\n\n\tprivate _dispatch_controller: DispatchController | undefined;\n\tget dispatchController() {\n\t\treturn (this._dispatch_controller = this._dispatch_controller || new DispatchController(this));\n\t}\n\tprivate _events_dispatcher: SceneEventsDispatcher | undefined;\n\tget eventsDispatcher() {\n\t\treturn (this._events_dispatcher = this._events_dispatcher || new SceneEventsDispatcher(this));\n\t}\n\n\tprivate _graph = new CoreGraph();\n\tget graph() {\n\t\treturn this._graph;\n\t}\n\n\tprivate _lifecycle_controller: LifeCycleController | undefined;\n\tget lifecycleController() {\n\t\treturn (this._lifecycle_controller = this._lifecycle_controller || new LifeCycleController(this));\n\t}\n\tprivate _loading_controller: LoadingController | undefined;\n\tget loadingController() {\n\t\treturn (this._loading_controller = this._loading_controller || new LoadingController(this));\n\t}\n\n\tprivate _missing_expression_references_controller: MissingReferencesController = new MissingReferencesController(\n\t\tthis\n\t);\n\tget missingExpressionReferencesController() {\n\t\treturn this._missing_expression_references_controller;\n\t}\n\tprivate _expressions_controller: ExpressionsController = new ExpressionsController();\n\tget expressionsController() {\n\t\treturn this._expressions_controller;\n\t}\n\n\tprotected _nodes_controller = new NodesController(this);\n\tget nodesController() {\n\t\treturn this._nodes_controller;\n\t}\n\tnodesByType(type: string) {\n\t\treturn this.nodesController.nodesByType(type);\n\t}\n\tprotected _objects_controller = new ObjectsController(this);\n\tget objectsController() {\n\t\treturn this._objects_controller;\n\t}\n\tfindObjectByMask(mask: string) {\n\t\treturn this._objects_controller.findObjectByMask(mask);\n\t}\n\tobjectsByMask(mask: string) {\n\t\treturn this._objects_controller.objectsByMask(mask);\n\t}\n\n\tprotected _references_controller = new ReferencesController(this);\n\tget referencesController() {\n\t\treturn this._references_controller;\n\t}\n\n\tprotected _performance: CorePerformance | undefined;\n\tget performance() {\n\t\treturn (this._performance = this._performance || new CorePerformance());\n\t}\n\n\tprotected _viewers_register: ViewersRegister | undefined;\n\tget viewersRegister() {\n\t\treturn (this._viewers_register = this._viewers_register || new ViewersRegister(this));\n\t}\n\n\t//\n\t//\n\t// time\n\t//\n\t//\n\tprotected _time_controller = new TimeController(this);\n\tget timeController() {\n\t\treturn this._time_controller;\n\t}\n\tsetFrame(frame: number) {\n\t\tthis.timeController.setFrame(frame);\n\t}\n\tsetFrameToStart() {\n\t\tthis.timeController.setFrameToStart();\n\t}\n\n\tframe() {\n\t\treturn this.timeController.frame();\n\t}\n\ttime() {\n\t\treturn this.timeController.time();\n\t}\n\tmaxFrame() {\n\t\treturn this.timeController.maxFrame();\n\t}\n\tplay() {\n\t\tthis.timeController.play();\n\t}\n\tpause() {\n\t\tthis.timeController.pause();\n\t}\n\n\t//\n\t//\n\t// serializer\n\t//\n\t//\n\tprivate _serializer: PolySceneSerializer | undefined;\n\tprivate get serializer() {\n\t\treturn (this._serializer = this._serializer || new PolySceneSerializer(this));\n\t}\n\ttoJSON() {\n\t\treturn this.serializer.toJSON();\n\t}\n\tprivate _read_only = false;\n\tprivate _read_only_requester: BaseNodeType | undefined;\n\tmarkAsReadOnly(requester: BaseNodeType) {\n\t\tif (this._read_only) {\n\t\t\treturn;\n\t\t}\n\t\tthis._read_only_requester = requester;\n\t\tthis._read_only = true;\n\t}\n\treadOnly() {\n\t\treturn this._read_only;\n\t}\n\treadOnlyRequester() {\n\t\treturn this._read_only_requester;\n\t}\n\n\t//\n\t//\n\t// uniforms\n\t//\n\t//\n\tprivate _uniforms_controller: UniformsController | undefined;\n\tget uniforms_controller() {\n\t\treturn (this._uniforms_controller = this._uniforms_controller || new UniformsController(this));\n\t}\n\n\t//\n\t//\n\t// webgl\n\t//\n\t//\n\tprivate _webgl_controller: WebGLController | undefined;\n\tget webgl_controller() {\n\t\treturn (this._webgl_controller = this._webgl_controller || new WebGLController());\n\t}\n\n\t//\n\t//\n\t// constructor\n\t//\n\t//\n\tconstructor() {\n\t\tthis._threejsScene.name = 'defaultScene';\n\t\tthis._threejsScene.matrixAutoUpdate = false;\n\t\t// this.mark_as_loaded()\n\t\tthis._graph.set_scene(this);\n\t\t// this.time_controller.init();\n\t\tthis.nodesController.init();\n\t}\n\n\t//\n\t//\n\t// cooker\n\t//\n\t//\n\tbatchUpdates(callback: () => void) {\n\t\tthis._cooker.block();\n\n\t\tcallback();\n\n\t\tthis._cooker.unblock();\n\t}\n\n\t//\n\t//\n\t// nodes\n\t//\n\t//\n\tnode(path: string) {\n\t\treturn this.nodesController.node(path);\n\t}\n\troot() {\n\t\treturn this.nodesController.root();\n\t}\n}\n","import {BaseParamType} from '../../../params/_Base';\nimport {\n\tComplexParamJsonExporterData,\n\tParamJsonExporterData,\n\tParamsJsonExporterData,\n\tSimpleParamJsonExporterData,\n\tParamsInitData,\n} from '../../../nodes/utils/io/IOController';\nimport {ParamType} from '../../../poly/ParamType';\n\nexport class ParamJsonImporter<T extends BaseParamType> {\n\tconstructor(protected _param: T) {}\n\n\tprocess_data(data: ComplexParamJsonExporterData<ParamType>) {\n\t\tconst raw_input = data['raw_input'];\n\t\t// const expression = data['expression'];\n\t\t// const components = data['components'];\n\t\t// if (expression !== undefined) {\n\t\t// \tthis._param.set(expression);\n\t\t// }\n\t\tif (raw_input !== undefined) {\n\t\t\tthis._param.set(raw_input);\n\t\t}\n\n\t\t// const referenced_asset = data['referenced_asset']\n\t\t// if(referenced_asset){\n\t\t// \tthis._param.mark_as_referencing_asset(referenced_asset)\n\t\t// }\n\n\t\tthis.add_main(data);\n\t}\n\n\tadd_main(data: ComplexParamJsonExporterData<ParamType>) {}\n\n\tstatic spare_params_data(params_data?: ParamsJsonExporterData) {\n\t\treturn this.params_data(true, params_data);\n\t}\n\t// static non_spare_params_value(params_data?: PolyDictionary<ParamJsonExporterData<ParamType>>) {\n\t// \treturn this.params_data(false, params_data);\n\t// }\n\t// static spare_params_data_value(params_data?: PolyDictionary<ParamJsonExporterData<ParamType>>) {\n\t// \treturn this.params_data_value(true, params_data);\n\t// }\n\tstatic non_spare_params_data_value(params_data?: ParamsJsonExporterData): ParamsInitData | undefined {\n\t\treturn this.params_data_value(false, params_data);\n\t}\n\tstatic params_data(spare: boolean, params_data?: ParamsJsonExporterData): ParamsJsonExporterData | undefined {\n\t\tlet non_spare_params_data: ParamsJsonExporterData | undefined;\n\t\tif (params_data) {\n\t\t\tnon_spare_params_data = {};\n\t\t\tconst param_names = Object.keys(params_data);\n\t\t\tlet param_data: ParamJsonExporterData<ParamType>;\n\t\t\tfor (let param_name of param_names) {\n\t\t\t\tparam_data = params_data[param_name];\n\t\t\t\tif (param_data) {\n\t\t\t\t\tnon_spare_params_data[param_name] = params_data;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn non_spare_params_data;\n\t}\n\tprivate static params_data_value(spare: boolean, params_data?: ParamsJsonExporterData): ParamsInitData | undefined {\n\t\tlet non_spare_params_data: ParamsInitData | undefined;\n\t\tif (params_data) {\n\t\t\tnon_spare_params_data = {};\n\t\t\tconst param_names = Object.keys(params_data);\n\t\t\tlet param_data: ParamJsonExporterData<ParamType>;\n\t\t\tfor (let param_name of param_names) {\n\t\t\t\tparam_data = params_data[param_name];\n\t\t\t\tif (param_data != null) {\n\t\t\t\t\tconst options = (param_data as ComplexParamJsonExporterData<ParamType>).options;\n\t\t\t\t\tconst overriden_options = (param_data as ComplexParamJsonExporterData<ParamType>).overriden_options;\n\t\t\t\t\tif (options || overriden_options) {\n\t\t\t\t\t\tconst complex_data = param_data as ComplexParamJsonExporterData<ParamType>;\n\t\t\t\t\t\tif (options && options.spare == spare) {\n\t\t\t\t\t\t\tif (complex_data.raw_input != null) {\n\t\t\t\t\t\t\t\tnon_spare_params_data[param_name] = {complex_data: complex_data};\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// TODO: THIS IS A MESS\n\t\t\t\t\t\t\tif (overriden_options) {\n\t\t\t\t\t\t\t\tnon_spare_params_data[param_name] = {complex_data: complex_data};\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// TODO: THIS IS A MESS\n\t\t\t\t\t\tconst simple_data = param_data as SimpleParamJsonExporterData<ParamType>;\n\t\t\t\t\t\tif (overriden_options || simple_data != null) {\n\t\t\t\t\t\t\tnon_spare_params_data[param_name] = {\n\t\t\t\t\t\t\t\tsimple_data: simple_data,\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn non_spare_params_data;\n\t}\n}\n","import {TypedNode, BaseNodeType} from '../../../nodes/_Base';\nimport {SceneJsonImporter} from '../../../io/json/import/Scene';\nimport {NodeContext} from '../../../poly/NodeContext';\nimport {NodeJsonExporterData} from '../export/Node';\nimport {ParamJsonImporter} from './Param';\nimport {Poly} from '../../../Poly';\nimport {OperationsComposerSopNode} from '../../../nodes/sop/OperationsComposer';\nimport {SopOperationContainer} from '../../../../engine/operations/container/sop';\nimport {OPERATIONS_COMPOSER_NODE_TYPE} from '../../../operations/_Base';\nimport {CoreType} from '../../../../core/Type';\nimport {PolyDictionary} from '../../../../types/GlobalTypes';\n\ntype BaseNodeTypeWithIO = TypedNode<NodeContext, any>;\n\ninterface RootNodeGenericData {\n\toutputs_count: number;\n\tnon_optimized_count: number;\n}\n\nexport class OptimizedNodesJsonImporter<T extends BaseNodeTypeWithIO> {\n\tconstructor(protected _node: T) {}\n\n\tprivate _nodes: BaseNodeTypeWithIO[] = [];\n\tprivate _optimized_root_node_names: Set<string> = new Set();\n\tprivate _operation_containers_by_name: Map<string, SopOperationContainer> = new Map();\n\tnodes() {\n\t\treturn this._nodes;\n\t}\n\n\tprocess_data(scene_importer: SceneJsonImporter, data?: PolyDictionary<NodeJsonExporterData>) {\n\t\tif (!data) {\n\t\t\treturn;\n\t\t}\n\t\tif (!(this._node.childrenAllowed() && this._node.childrenController)) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst {optimized_names} = OptimizedNodesJsonImporter.child_names_by_optimized_state(data);\n\n\t\tthis._nodes = [];\n\t\tthis._optimized_root_node_names = new Set();\n\t\tfor (let node_name of optimized_names) {\n\t\t\tif (OptimizedNodesJsonImporter.is_optimized_root_node(data, node_name)) {\n\t\t\t\tthis._optimized_root_node_names.add(node_name);\n\t\t\t}\n\t\t}\n\n\t\tfor (let node_name of this._optimized_root_node_names) {\n\t\t\tconst node_data = data[node_name];\n\t\t\tconst node = this._node.createNode(OPERATIONS_COMPOSER_NODE_TYPE);\n\t\t\tif (node) {\n\t\t\t\tnode.setName(node_name);\n\t\t\t\tthis._nodes.push(node);\n\n\t\t\t\t// ensure the display flag is set accordingly\n\t\t\t\tif (node_data.flags?.display) {\n\t\t\t\t\tnode.flags?.display?.set(true);\n\t\t\t\t}\n\t\t\t\tconst operation_container = this._create_operation_container(\n\t\t\t\t\tscene_importer,\n\t\t\t\t\tnode as OperationsComposerSopNode,\n\t\t\t\t\tnode_data,\n\t\t\t\t\tnode.name()\n\t\t\t\t);\n\t\t\t\t(node as OperationsComposerSopNode).set_output_operation_container(\n\t\t\t\t\toperation_container as SopOperationContainer\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\tfor (let node of this._nodes) {\n\t\t\tconst operation_container = (node as OperationsComposerSopNode).output_operation_container();\n\t\t\tif (operation_container) {\n\t\t\t\tthis._node_inputs = [];\n\t\t\t\tthis._add_optimized_node_inputs(\n\t\t\t\t\tscene_importer,\n\t\t\t\t\tnode as OperationsComposerSopNode,\n\t\t\t\t\tdata,\n\t\t\t\t\tnode.name(),\n\t\t\t\t\toperation_container\n\t\t\t\t);\n\t\t\t\tnode.io.inputs.setCount(this._node_inputs.length);\n\t\t\t\tfor (let i = 0; i < this._node_inputs.length; i++) {\n\t\t\t\t\tnode.setInput(i, this._node_inputs[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate _node_inputs: BaseNodeType[] = [];\n\tprivate _add_optimized_node_inputs(\n\t\tscene_importer: SceneJsonImporter,\n\t\tnode: OperationsComposerSopNode,\n\t\tdata: PolyDictionary<NodeJsonExporterData>,\n\t\tnode_name: string,\n\t\tcurrent_operation_container: SopOperationContainer\n\t) {\n\t\tconst node_data: NodeJsonExporterData = data[node_name];\n\t\tconst inputs_data = node_data['inputs'];\n\t\tif (!inputs_data) {\n\t\t\treturn;\n\t\t}\n\t\tfor (let input_data of inputs_data) {\n\t\t\tif (CoreType.isString(input_data)) {\n\t\t\t\tconst input_node_data = data[input_data];\n\t\t\t\tif (input_node_data) {\n\t\t\t\t\tif (\n\t\t\t\t\t\tOptimizedNodesJsonImporter.is_node_optimized(input_node_data) &&\n\t\t\t\t\t\t!this._optimized_root_node_names.has(input_data) // ensure it is not a root\n\t\t\t\t\t) {\n\t\t\t\t\t\t// ensure we do not create multiple operation containers from the same node\n\t\t\t\t\t\tlet operation_container = this._operation_containers_by_name.get(input_data);\n\t\t\t\t\t\tif (!operation_container) {\n\t\t\t\t\t\t\t// if the input is an optimized node, we create an operation and go recursive\n\t\t\t\t\t\t\toperation_container = this._create_operation_container(\n\t\t\t\t\t\t\t\tscene_importer,\n\t\t\t\t\t\t\t\tnode,\n\t\t\t\t\t\t\t\tinput_node_data,\n\t\t\t\t\t\t\t\tinput_data\n\t\t\t\t\t\t\t) as SopOperationContainer;\n\t\t\t\t\t\t\tif (operation_container) {\n\t\t\t\t\t\t\t\tthis._add_optimized_node_inputs(\n\t\t\t\t\t\t\t\t\tscene_importer,\n\t\t\t\t\t\t\t\t\tnode,\n\t\t\t\t\t\t\t\t\tdata,\n\t\t\t\t\t\t\t\t\tinput_data,\n\t\t\t\t\t\t\t\t\toperation_container\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcurrent_operation_container.add_input(operation_container);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// if the input is NOT an optimized node, we set the input to the node\n\t\t\t\t\t\tconst input_node = node.parent()?.node(input_data);\n\t\t\t\t\t\tif (input_node) {\n\t\t\t\t\t\t\tthis._node_inputs.push(input_node);\n\t\t\t\t\t\t\tconst node_input_index = this._node_inputs.length - 1;\n\t\t\t\t\t\t\t// node.setInput(node_input_index, input_node as BaseSopNodeType);\n\t\t\t\t\t\t\tnode.add_input_config(current_operation_container, {\n\t\t\t\t\t\t\t\toperation_input_index: current_operation_container.current_input_index(),\n\t\t\t\t\t\t\t\tnode_input_index: node_input_index,\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tcurrent_operation_container.increment_input_index();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// once the inputs have been set, we can initialize the inputs_clone_state\n\t\tif (node_data.cloned_state_overriden == true) {\n\t\t\tcurrent_operation_container.override_input_clone_state(node_data.cloned_state_overriden);\n\t\t}\n\t}\n\n\tstatic child_names_by_optimized_state(data: PolyDictionary<NodeJsonExporterData>) {\n\t\tconst node_names = Object.keys(data);\n\t\tconst optimized_names: string[] = [];\n\t\tconst non_optimized_names: string[] = [];\n\t\tfor (let node_name of node_names) {\n\t\t\tconst node_data = data[node_name];\n\t\t\tconst optimized_state = Poly.playerMode() && this.is_node_optimized(node_data);\n\t\t\tif (optimized_state) {\n\t\t\t\toptimized_names.push(node_name);\n\t\t\t} else {\n\t\t\t\tnon_optimized_names.push(node_name);\n\t\t\t}\n\t\t}\n\t\treturn {optimized_names, non_optimized_names};\n\t}\n\n\t// private _optimized_names_for_root(\n\t// \tdata: PolyDictionary<NodeJsonExporterData>,\n\t// \tcurrent_node_name: string,\n\t// \tcurrent_node_data: NodeJsonExporterData,\n\t// \tinput_names: string[] = []\n\t// ) {\n\t// \tinput_names.push(current_node_name);\n\t// \tconst inputs = current_node_data['inputs'];\n\t// \tif (inputs) {\n\t// \t\tfor (let input_data of inputs) {\n\t// \t\t\tif (CoreType.isString(input_data)) {\n\t// \t\t\t\tconst input_node_name = input_data;\n\t// \t\t\t\t// if (input_node_name != current_node_name) {\n\t// \t\t\t\tconst input_node_data = data[input_node_name];\n\n\t// \t\t\t\tif (input_node_data) {\n\t// \t\t\t\t\tif (\n\t// \t\t\t\t\t\tOptimizedNodesJsonImporter.is_node_optimized(input_node_data) &&\n\t// \t\t\t\t\t\t!this._is_optimized_root_node(data, input_node_name, input_node_data)\n\t// \t\t\t\t\t) {\n\t// \t\t\t\t\t\tthis._optimized_names_for_root(data, input_node_name, input_node_data, input_names);\n\t// \t\t\t\t\t}\n\t// \t\t\t\t}\n\t// \t\t\t\t// }\n\t// \t\t\t}\n\t// \t\t}\n\t// \t}\n\t// \treturn input_names;\n\t// }\n\n\t// a node will be considered optimized root node if:\n\t// - it has no output\n\t// - at least one output is not optimized (as it if it has 2 outputs, and only 1 is optimized, it will not be considered root)\n\tstatic is_optimized_root_node_generic(data: RootNodeGenericData): boolean {\n\t\tif (data.outputs_count == 0) {\n\t\t\treturn true;\n\t\t}\n\t\tif (data.non_optimized_count > 0) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\tstatic is_optimized_root_node(data: PolyDictionary<NodeJsonExporterData>, current_node_name: string) {\n\t\tconst output_names = this.node_outputs(data, current_node_name);\n\n\t\tlet non_optimized_count = 0;\n\t\toutput_names.forEach((node_name) => {\n\t\t\tconst node_data = data[node_name];\n\t\t\tif (!this.is_node_optimized(node_data)) {\n\t\t\t\tnon_optimized_count++;\n\t\t\t}\n\t\t});\n\n\t\treturn this.is_optimized_root_node_generic({\n\t\t\toutputs_count: output_names.size,\n\t\t\tnon_optimized_count: non_optimized_count,\n\t\t});\n\t}\n\t// same algo as is_optimized_root_node, but for a node\n\tstatic is_optimized_root_node_from_node<NC extends NodeContext>(node: TypedNode<NC, any>) {\n\t\tif (!node.flags?.optimize?.active()) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst output_nodes = node.io.connections.outputConnections().map((c) => c.node_dest);\n\t\tlet non_optimized_count = 0;\n\t\tfor (let output_node of output_nodes) {\n\t\t\tif (!output_node.flags?.optimize?.active()) {\n\t\t\t\tnon_optimized_count++;\n\t\t\t}\n\t\t}\n\t\treturn this.is_optimized_root_node_generic({\n\t\t\toutputs_count: output_nodes.length,\n\t\t\tnon_optimized_count: non_optimized_count,\n\t\t});\n\t}\n\n\tstatic node_outputs(\n\t\tdata: PolyDictionary<NodeJsonExporterData>,\n\t\tcurrent_node_name: string\n\t\t// current_node_data: NodeJsonExporterData\n\t) {\n\t\tconst node_names = Object.keys(data);\n\t\tconst output_node_names: Set<string> = new Set();\n\t\tfor (let node_name of node_names) {\n\t\t\tif (node_name != current_node_name) {\n\t\t\t\tconst node_data = data[node_name];\n\t\t\t\tconst inputs = node_data['inputs'];\n\t\t\t\tif (inputs) {\n\t\t\t\t\tfor (let input_data of inputs) {\n\t\t\t\t\t\tif (CoreType.isString(input_data)) {\n\t\t\t\t\t\t\tconst input_node_name = input_data;\n\t\t\t\t\t\t\tif (input_node_name == current_node_name) {\n\t\t\t\t\t\t\t\toutput_node_names.add(node_name);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn output_node_names;\n\t}\n\n\tprivate _create_operation_container(\n\t\tscene_importer: SceneJsonImporter,\n\t\tnode: OperationsComposerSopNode,\n\t\tnode_data: NodeJsonExporterData,\n\t\tnode_name: string\n\t) {\n\t\tconst non_spare_params_data = ParamJsonImporter.non_spare_params_data_value(node_data['params']);\n\t\tconst operation_type = OptimizedNodesJsonImporter.operation_type(node_data);\n\t\tconst operation_container = this._node.create_operation_container(\n\t\t\toperation_type,\n\t\t\tnode_name,\n\t\t\tnon_spare_params_data\n\t\t) as SopOperationContainer;\n\t\tif (operation_container) {\n\t\t\t// ensure we do not create another operation container from the same node\n\t\t\tthis._operation_containers_by_name.set(node_name, operation_container);\n\n\t\t\t// store for path_param resolve when all nodes are created\n\t\t\tif (operation_container.path_param_resolve_required()) {\n\t\t\t\tnode.add_operation_container_with_path_param_resolve_required(operation_container);\n\t\t\t\tscene_importer.add_operations_composer_node_with_path_param_resolve_required(node);\n\t\t\t}\n\t\t}\n\n\t\treturn operation_container;\n\t}\n\n\tstatic operation_type(node_data: NodeJsonExporterData) {\n\t\tif (OptimizedNodesJsonImporter.is_node_bypassed(node_data)) {\n\t\t\treturn 'null';\n\t\t}\n\t\treturn node_data['type'];\n\t}\n\n\tstatic is_node_optimized(node_data: NodeJsonExporterData) {\n\t\tconst node_flags = node_data['flags'];\n\t\tif (node_flags && node_flags['optimize']) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\tstatic is_node_bypassed(node_data: NodeJsonExporterData) {\n\t\tconst node_flags = node_data['flags'];\n\t\tif (node_flags && node_flags['bypass']) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n}\n","import {TypedNode, BaseNodeType} from '../../../nodes/_Base';\nimport {JsonImportDispatcher} from './Dispatcher';\nimport {SceneJsonImporter} from '../../../io/json/import/Scene';\nimport {NodeContext} from '../../../poly/NodeContext';\nimport {NodeJsonExporterData} from '../export/Node';\nimport {ParamJsonImporter} from './Param';\nimport {OptimizedNodesJsonImporter} from './OptimizedNodes';\nimport {PolyNodeJsonImporter} from './nodes/Poly';\nimport {Poly} from '../../../Poly';\nimport {NodeJsonImporter} from './Node';\nimport {CoreString} from '../../../../core/String';\nimport {PolyDictionary} from '../../../../types/GlobalTypes';\n\ntype BaseNodeTypeWithIO = TypedNode<NodeContext, any>;\nexport class NodesJsonImporter<T extends BaseNodeTypeWithIO> {\n\tconstructor(protected _node: T) {}\n\n\tprocess_data(scene_importer: SceneJsonImporter, data?: PolyDictionary<NodeJsonExporterData>) {\n\t\tif (!data) {\n\t\t\treturn;\n\t\t}\n\t\tif (!(this._node.childrenAllowed() && this._node.childrenController)) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst {optimized_names, non_optimized_names} = OptimizedNodesJsonImporter.child_names_by_optimized_state(data);\n\t\tconst nonOptimizedNodes: BaseNodeTypeWithIO[] = [];\n\t\tfor (let node_name of non_optimized_names) {\n\t\t\tconst node_data = data[node_name];\n\t\t\tlet node_type = node_data['type'].toLowerCase();\n\t\t\tconst non_spare_params_data = ParamJsonImporter.non_spare_params_data_value(node_data['params']);\n\n\t\t\ttry {\n\t\t\t\t// try with current type\n\t\t\t\tconst node = this._node.createNode(node_type, non_spare_params_data);\n\t\t\t\tif (node) {\n\t\t\t\t\tnode.setName(node_name);\n\t\t\t\t\tnonOptimizedNodes.push(node);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\tconsole.error(`error importing node: cannot create with type ${node_type}`, e);\n\t\t\t\tconst nodeType = CoreString.camelCase(node_type);\n\t\t\t\ttry {\n\t\t\t\t\t// try with camelCased type\n\t\t\t\t\tconst node = this._node.createNode(nodeType, non_spare_params_data);\n\t\t\t\t\tif (node) {\n\t\t\t\t\t\tnode.setName(node_name);\n\t\t\t\t\t\tnonOptimizedNodes.push(node);\n\t\t\t\t\t}\n\t\t\t\t} catch (e) {\n\t\t\t\t\tscene_importer.report.add_warning(\n\t\t\t\t\t\t`failed to create node with type '${node_type}' or '${nodeType}'`\n\t\t\t\t\t);\n\t\t\t\t\tPoly.warn('failed to create node with type', node_type, 'or', nodeType, e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (optimized_names.length > 0) {\n\t\t\tconst optimized_nodes_importer = new OptimizedNodesJsonImporter(this._node);\n\t\t\toptimized_nodes_importer.process_data(scene_importer, data);\n\n\t\t\t// ensure that the display node is still created\n\t\t\t// as it may not be if the display flag is set to a node that will\n\t\t\t// be part of an optimized series of nodes\n\t\t\t// for instance\n\t\t\t// A -> B > C\n\t\t\t// D -> E\n\t\t\t// if A, B and C are optimized,\n\t\t\t// and D, E are not\n\t\t\t// And B has the display flag,\n\t\t\t// what will happen is that B will not exist anymore\n\t\t\t// and the display flag will end up in either C, D or E\n\t\t\t// which can lead to unexpected display in the player\n\t\t\tif (this._node.childrenController.context == NodeContext.SOP) {\n\t\t\t\tconst nodeNames = Object.keys(data);\n\t\t\t\tlet nodeNameWithDisplayFlag: string | undefined = undefined;\n\t\t\t\tfor (let nodeName of nodeNames) {\n\t\t\t\t\tconst nodeData = data[nodeName];\n\t\t\t\t\tif (nodeData.flags?.display) {\n\t\t\t\t\t\tnodeNameWithDisplayFlag = nodeName;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (nodeNameWithDisplayFlag) {\n\t\t\t\t\tconst existingNodeNames = nonOptimizedNodes.map((n) => n.name());\n\t\t\t\t\tconst optimizedNodes = optimized_nodes_importer.nodes();\n\t\t\t\t\tfor (let optimizedNode of optimizedNodes) {\n\t\t\t\t\t\texistingNodeNames.push(optimizedNode.name());\n\t\t\t\t\t}\n\t\t\t\t\tif (!existingNodeNames.includes(nodeNameWithDisplayFlag)) {\n\t\t\t\t\t\tconst parentFullPath = this._node.fullPath();\n\t\t\t\t\t\tconst nodeFullPath = `${parentFullPath}/${nodeNameWithDisplayFlag}`;\n\t\t\t\t\t\tconst message = `node '${nodeFullPath}' with display flag has been optimized and does not exist in player mode`;\n\t\t\t\t\t\tconsole.error(message);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst importers_by_node_name: Map<string, PolyNodeJsonImporter | NodeJsonImporter<BaseNodeType>> = new Map();\n\t\tfor (let node of nonOptimizedNodes) {\n\t\t\tconst child_data = data[node.name()];\n\t\t\tif (child_data) {\n\t\t\t\tconst importer = JsonImportDispatcher.dispatch_node(node);\n\t\t\t\timporters_by_node_name.set(node.name(), importer);\n\t\t\t\timporter.process_data(scene_importer, data[node.name()]);\n\t\t\t} else {\n\t\t\t\tPoly.warn(`possible import error for node ${node.name()}`);\n\t\t\t}\n\t\t}\n\t\tfor (let node of nonOptimizedNodes) {\n\t\t\tconst importer = importers_by_node_name.get(node.name());\n\t\t\tif (importer) {\n\t\t\t\timporter.process_inputs_data(data[node.name()]);\n\t\t\t}\n\t\t}\n\t}\n}\n","import {TypedNode} from '../../../nodes/_Base';\nimport {Vector2} from 'three/src/math/Vector2';\nimport {JsonImportDispatcher} from './Dispatcher';\nimport {ParamType} from '../../../poly/ParamType';\nimport {ParamsUpdateOptions} from '../../../nodes/utils/params/ParamsController';\nimport {SceneJsonImporter} from '../../../io/json/import/Scene';\nimport {NodeContext} from '../../../poly/NodeContext';\nimport {NodeJsonExporterData, NodeJsonExporterUIData, InputData, IoConnectionPointsData} from '../export/Node';\nimport {\n\tParamJsonExporterData,\n\tSimpleParamJsonExporterData,\n\tComplexParamJsonExporterData,\n} from '../../../nodes/utils/io/IOController';\nimport {NodesJsonImporter} from './Nodes';\nimport {Poly} from '../../../Poly';\nimport {CoreType} from '../../../../core/Type';\nimport {CoreString} from '../../../../core/String';\nimport {PolyDictionary} from '../../../../types/GlobalTypes';\n\nconst COMPLEX_PARAM_DATA_KEYS: Readonly<string[]> = ['overriden_options', 'type'];\n\ntype BaseNodeTypeWithIO = TypedNode<NodeContext, any>;\nexport class NodeJsonImporter<T extends BaseNodeTypeWithIO> {\n\tconstructor(protected _node: T) {}\n\n\tprocess_data(scene_importer: SceneJsonImporter, data: NodeJsonExporterData) {\n\t\tthis.set_connection_points(data['connection_points']);\n\n\t\t// rather than having the children creation dependent on the persisted config and player mode, use the childrenAllowed() method\n\t\t// const skip_create_children = Poly.playerMode() && data.persisted_config;\n\t\tif (this._node.childrenAllowed()) {\n\t\t\tthis.create_nodes(scene_importer, data['nodes']);\n\t\t}\n\t\tthis.set_selection(data['selection']);\n\n\t\t// inputs clone\n\t\tif (this._node.io.inputs.overrideClonedStateAllowed()) {\n\t\t\tconst override = data['cloned_state_overriden'];\n\t\t\tif (override) {\n\t\t\t\tthis._node.io.inputs.overrideClonedState(override);\n\t\t\t}\n\t\t}\n\n\t\tthis.set_flags(data);\n\n\t\t// params\n\t\t// const spare_params_data = ParamJsonImporter.spare_params_data(data['params']);\n\t\t// this.set_params(spare_params_data);\n\t\tthis.set_params(data['params']);\n\n\t\tif (data.persisted_config) {\n\t\t\tthis.set_persisted_config(data.persisted_config);\n\t\t}\n\n\t\tthis.from_data_custom(data);\n\n\t\t// already called in create_node()\n\t\t// this._node.lifecycle.set_creation_completed();\n\t}\n\tprocess_inputs_data(data: NodeJsonExporterData) {\n\t\tconst maxInputsCount = data.maxInputsCount;\n\t\tif (maxInputsCount != null) {\n\t\t\tthis._node.io.inputs.setCount(1, maxInputsCount);\n\t\t}\n\n\t\tthis.setInputs(data['inputs']);\n\t}\n\n\tprocess_ui_data(scene_importer: SceneJsonImporter, data: NodeJsonExporterUIData) {\n\t\tif (!data) {\n\t\t\treturn;\n\t\t}\n\t\tif (Poly.playerMode()) {\n\t\t\treturn;\n\t\t}\n\t\tconst ui_data = this._node.uiData;\n\t\tconst pos = data['pos'];\n\t\tif (pos) {\n\t\t\tconst vector = new Vector2().fromArray(pos);\n\t\t\tui_data.setPosition(vector);\n\t\t}\n\t\tconst comment = data['comment'];\n\t\tif (comment) {\n\t\t\tui_data.setComment(comment);\n\t\t}\n\t\tif (this._node.childrenAllowed()) {\n\t\t\tthis.process_nodes_ui_data(scene_importer, data['nodes']);\n\t\t}\n\t}\n\n\tcreate_nodes(scene_importer: SceneJsonImporter, data?: PolyDictionary<NodeJsonExporterData>) {\n\t\tif (!data) {\n\t\t\treturn;\n\t\t}\n\t\tconst nodes_importer = new NodesJsonImporter(this._node);\n\t\tnodes_importer.process_data(scene_importer, data);\n\t}\n\tset_selection(data?: string[]) {\n\t\tif (this._node.childrenAllowed() && this._node.childrenController) {\n\t\t\tif (data && data.length > 0) {\n\t\t\t\tconst selected_nodes: BaseNodeTypeWithIO[] = [];\n\t\t\t\tdata.forEach((node_name) => {\n\t\t\t\t\tconst node = this._node.node(node_name);\n\t\t\t\t\tif (node) {\n\t\t\t\t\t\tselected_nodes.push(node);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tthis._node.childrenController.selection.set(selected_nodes);\n\t\t\t}\n\t\t}\n\t}\n\n\tset_flags(data: NodeJsonExporterData) {\n\t\tconst flags = data['flags'];\n\t\tif (flags) {\n\t\t\tconst bypass = flags['bypass'];\n\t\t\tif (bypass != null) {\n\t\t\t\tthis._node.flags?.bypass?.set(bypass);\n\t\t\t}\n\t\t\tconst display = flags['display'];\n\t\t\tif (display != null) {\n\t\t\t\tthis._node.flags?.display?.set(display);\n\t\t\t}\n\t\t\tconst optimize = flags['optimize'];\n\t\t\tif (optimize != null) {\n\t\t\t\tthis._node.flags?.optimize?.set(optimize);\n\t\t\t}\n\t\t}\n\t}\n\n\tset_connection_points(connection_points_data: IoConnectionPointsData | undefined) {\n\t\tif (!connection_points_data) {\n\t\t\treturn;\n\t\t}\n\t\tif (connection_points_data['in']) {\n\t\t\tthis._node.io.saved_connection_points_data.set_in(connection_points_data['in']);\n\t\t}\n\t\tif (connection_points_data['out']) {\n\t\t\tthis._node.io.saved_connection_points_data.set_out(connection_points_data['out']);\n\t\t}\n\n\t\tif (this._node.io.has_connection_points_controller) {\n\t\t\tthis._node.io.connection_points.update_signature_if_required();\n\t\t}\n\t}\n\n\tprivate setInputs(inputs_data?: InputData[]) {\n\t\tif (!inputs_data) {\n\t\t\treturn;\n\t\t}\n\n\t\tlet input_data: InputData;\n\t\tfor (let i = 0; i < inputs_data.length; i++) {\n\t\t\tinput_data = inputs_data[i];\n\t\t\tif (input_data && this._node.parent()) {\n\t\t\t\tif (CoreType.isString(input_data)) {\n\t\t\t\t\tconst input_node_name = input_data;\n\t\t\t\t\tconst input_node = this._node.nodeSibbling(input_node_name);\n\t\t\t\t\tthis._node.setInput(i, input_node);\n\t\t\t\t} else {\n\t\t\t\t\tconst input_node = this._node.nodeSibbling(input_data['node']);\n\t\t\t\t\tconst input_index = input_data['index'];\n\t\t\t\t\tthis._node.setInput(input_index, input_node, input_data['output']);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprocess_nodes_ui_data(scene_importer: SceneJsonImporter, data: PolyDictionary<NodeJsonExporterUIData>) {\n\t\tif (!data) {\n\t\t\treturn;\n\t\t}\n\t\tif (Poly.playerMode()) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst node_names = Object.keys(data);\n\t\tfor (let node_name of node_names) {\n\t\t\tconst node = this._node.node(node_name);\n\t\t\tif (node) {\n\t\t\t\tconst node_data = data[node_name];\n\t\t\t\tJsonImportDispatcher.dispatch_node(node).process_ui_data(scene_importer, node_data);\n\t\t\t\t// node.visit(JsonImporterVisitor).process_ui_data(node_data);\n\t\t\t}\n\t\t}\n\t}\n\n\t//\n\t//\n\t// PARAMS\n\t//\n\t//\n\tset_params(data?: PolyDictionary<ParamJsonExporterData<ParamType>>) {\n\t\tif (!data) {\n\t\t\treturn;\n\t\t}\n\t\tconst param_names = Object.keys(data);\n\n\t\tconst params_update_options: ParamsUpdateOptions = {};\n\t\tfor (let param_name of param_names) {\n\t\t\tconst param_data = data[param_name] as ComplexParamJsonExporterData<ParamType>;\n\t\t\tconst options = param_data['options'];\n\t\t\t// const is_spare = options && options['spare'] === true;\n\n\t\t\t// make camelCase if required\n\t\t\tif (false && param_name.includes('_')) {\n\t\t\t\tparam_name = CoreString.camelCase(param_name);\n\t\t\t}\n\n\t\t\tconst param_type = param_data['type']!;\n\t\t\tconst has_param = this._node.params.has_param(param_name);\n\t\t\tlet has_param_and_same_type = false;\n\t\t\tlet param;\n\t\t\tif (has_param) {\n\t\t\t\tparam = this._node.params.get(param_name);\n\t\t\t\t// we can safely consider same type if param_type is not mentioned\n\t\t\t\tif ((param && param.type() == param_type) || param_type == null) {\n\t\t\t\t\thas_param_and_same_type = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (has_param_and_same_type) {\n\t\t\t\tif (this._is_param_data_complex(param_data)) {\n\t\t\t\t\tthis._process_param_data_complex(param_name, param_data);\n\t\t\t\t} else {\n\t\t\t\t\tthis._process_param_data_simple(param_name, param_data as SimpleParamJsonExporterData<ParamType>);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// it the param is a spare one,\n\t\t\t\t// we check if it is currently exists with same type first.\n\t\t\t\t// - if it is, we only update the value\n\t\t\t\t// - if it's not, we delete it and add it again\n\t\t\t\tparams_update_options.names_to_delete = params_update_options.names_to_delete || [];\n\t\t\t\tparams_update_options.names_to_delete.push(param_name);\n\t\t\t\tparams_update_options.to_add = params_update_options.to_add || [];\n\t\t\t\tparams_update_options.to_add.push({\n\t\t\t\t\tname: param_name,\n\t\t\t\t\ttype: param_type,\n\t\t\t\t\tinit_value: param_data['default_value'] as any,\n\t\t\t\t\traw_input: param_data['raw_input'] as any,\n\t\t\t\t\toptions: options,\n\t\t\t\t});\n\n\t\t\t\t// if (options && param_type) {\n\t\t\t\t// \tif (param_data['default_value']) {\n\t\t\t\t// \t\tif (has_param) {\n\t\t\t\t// \t\t\tthis._node.params.delete_param(param_name);\n\t\t\t\t// \t\t}\n\t\t\t\t// \t\tparam = this._node.add_param(param_type, param_name, param_data['default_value'], options);\n\t\t\t\t// \t\tif (param) {\n\t\t\t\t// \t\t\tJsonImportDispatcher.dispatch_param(param).process_data(param_data);\n\t\t\t\t// \t\t}\n\t\t\t\t// \t}\n\t\t\t\t// }\n\t\t\t}\n\t\t}\n\n\t\t// delete and create the spare params we need to\n\t\tconst params_delete_required =\n\t\t\tparams_update_options.names_to_delete && params_update_options.names_to_delete.length > 0;\n\t\tconst params_add_required = params_update_options.to_add && params_update_options.to_add.length > 0;\n\n\t\tif (params_delete_required || params_add_required) {\n\t\t\tthis._node.params.update_params(params_update_options);\n\t\t\t// update them based on the imported data\n\t\t\tfor (let spare_param of this._node.params.spare) {\n\t\t\t\tconst param_data = data[spare_param.name()] as ComplexParamJsonExporterData<ParamType>;\n\t\t\t\t// JsonImportDispatcher.dispatch_param(spare_param).process_data(param_data);\n\t\t\t\tif (!spare_param.parent_param && param_data) {\n\t\t\t\t\tif (this._is_param_data_complex(param_data)) {\n\t\t\t\t\t\tthis._process_param_data_complex(spare_param.name(), param_data);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis._process_param_data_simple(\n\t\t\t\t\t\t\tspare_param.name(),\n\t\t\t\t\t\t\tparam_data as SimpleParamJsonExporterData<ParamType>\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// those hooks are useful for some gl nodes,\n\t\t// such as the constant, which needs to update its connections\n\t\t// based on another parameter, which will be set just before\n\t\tthis._node.params.runOnSceneLoadHooks();\n\t}\n\n\tprivate _process_param_data_simple(param_name: string, param_data: SimpleParamJsonExporterData<ParamType>) {\n\t\tthis._node.params.get(param_name)?.set(param_data);\n\t}\n\n\tprivate _process_param_data_complex(param_name: string, param_data: ComplexParamJsonExporterData<ParamType>) {\n\t\tconst param = this._node.params.get(param_name);\n\t\tif (param) {\n\t\t\tJsonImportDispatcher.dispatch_param(param).process_data(param_data);\n\t\t}\n\t\t// return\n\t\t// const has_param = this._node.params.has_param(param_name);\n\t\t// const param_type = param_data['type']!;\n\n\t\t// let has_param_and_same_type = false;\n\t\t// let param;\n\t\t// if (has_param) {\n\t\t// \tparam = this._node.params.get(param_name);\n\t\t// \t// we can safely consider same type if param_type is not mentioned\n\t\t// \tif ((param && param.type == param_type) || param_type == null) {\n\t\t// \t\thas_param_and_same_type = true;\n\t\t// \t}\n\t\t// }\n\t\t// if (has_param_and_same_type) {\n\t\t// \tparam = this._node.params.get(param_name);\n\t\t// \tif (param) {\n\t\t// \t\tJsonImportDispatcher.dispatch_param(param).process_data(param_data);\n\t\t// \t\t// param.visit(JsonImporterVisitor).process_data(param_data);\n\t\t// \t}\n\t\t// } else {\n\t\t// \tconst options = param_data['options'];\n\t\t// \tif (options && param_type) {\n\t\t// \t\tconst is_spare = options['spare'] === true;\n\t\t// \t\tif (is_spare && param_data['default_value']) {\n\t\t// \t\t\tif (has_param) {\n\t\t// \t\t\t\tthis._node.params.delete_param(param_name);\n\t\t// \t\t\t}\n\t\t// \t\t\tparam = this._node.add_param(param_type, param_name, param_data['default_value'], options);\n\t\t// \t\t\tif (param) {\n\t\t// \t\t\t\tJsonImportDispatcher.dispatch_param(param).process_data(param_data);\n\t\t// \t\t\t}\n\t\t// \t\t}\n\t\t// \t}\n\t\t// }\n\t}\n\n\tprivate _is_param_data_complex(param_data: ParamJsonExporterData<ParamType>): boolean {\n\t\t// we can test here most param value serialized, except for ramp\n\t\tif (\n\t\t\tCoreType.isString(param_data) ||\n\t\t\tCoreType.isNumber(param_data) ||\n\t\t\tCoreType.isArray(param_data) ||\n\t\t\tCoreType.isBoolean(param_data)\n\t\t) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (CoreType.isObject(param_data)) {\n\t\t\tconst keys = Object.keys(param_data);\n\t\t\tfor (let complex_key of COMPLEX_PARAM_DATA_KEYS) {\n\t\t\t\tif (keys.includes(complex_key)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tset_persisted_config(persisted_config_data: object) {\n\t\tif (this._node.persisted_config) {\n\t\t\tthis._node.persisted_config.load(persisted_config_data);\n\t\t}\n\t}\n\n\tfrom_data_custom(data: NodeJsonExporterData) {}\n}\n","import {ParamJsonImporter} from '../Param';\nimport {ComplexParamJsonExporterData} from '../../../../nodes/utils/io/IOController';\nimport {TypedMultipleParam} from '../../../../params/_Multiple';\nimport {ParamType} from '../../../../poly/ParamType';\n\nexport class ParamMultipleJsonImporter extends ParamJsonImporter<TypedMultipleParam<ParamType>> {\n\tadd_main(data: ComplexParamJsonExporterData<ParamType>) {\n\t\t// const components = data['components'];\n\t\t// if (components) {\n\t\t// \tObject.keys(components).forEach((component_name) => {\n\t\t// \t\tconst param_name = `${this._param.name}${component_name}`;\n\t\t// \t\tconst component_param = this._param.node.params\n\t\t// \t\t\t.get(this._param.name)\n\t\t// \t\t\t?.components?.filter((c) => c.name == param_name)[0];\n\t\t// \t\tif (component_param) {\n\t\t// \t\t\tconst component_data = components[component_name];\n\t\t// \t\t\tJsonImportDispatcher.dispatch_param(component_param as FloatParam).process_data(component_data);\n\t\t// \t\t}\n\t\t// \t});\n\t\t// }\n\t}\n}\n","import {ParamJsonImporter} from '../Param';\nimport {ComplexParamJsonExporterData} from '../../../../nodes/utils/io/IOController';\nimport {StringParam} from '../../../../params/String';\nimport {ParamType} from '../../../../poly/ParamType';\n\nconst LINE_BREAK_REGEXP = /\\\\n+/g;\n\nexport class ParamStringJsonImporter extends ParamJsonImporter<StringParam> {\n\tadd_main(data: ComplexParamJsonExporterData<ParamType.STRING>) {\n\t\tlet raw_input = data['raw_input'];\n\t\tif (raw_input !== undefined) {\n\t\t\t// if (CoreType.isString(value)) {\n\t\t\traw_input = raw_input.replace(LINE_BREAK_REGEXP, '\\n');\n\t\t\tthis._param.set(raw_input);\n\t\t\t// }\n\t\t}\n\t}\n}\n","import {ParamJsonImporter} from '../Param';\n// import {RampValueJson} from '../../../../params/ramp/RampValue';\nimport {ComplexParamJsonExporterData} from '../../../../nodes/utils/io/IOController';\nimport {RampParam} from '../../../../params/Ramp';\nimport {ParamType} from '../../../../poly/ParamType';\n\nexport class ParamRampJsonImporter extends ParamJsonImporter<RampParam> {\n\tadd_main(data: ComplexParamJsonExporterData<ParamType.RAMP>) {\n\t\tconst raw_input = data['raw_input']; // as RampValueJson;\n\t\tif (raw_input) {\n\t\t\t// const ramp_value = RampValue.from_json(value);\n\t\t\tthis._param.set(raw_input);\n\t\t}\n\t}\n}\n","import {NodeJsonImporter} from '../Node';\nimport {NodeJsonExporterData} from '../../export/Node';\nimport {SceneJsonImporter} from '../Scene';\nimport {PolyDictionary} from '../../../../../types/GlobalTypes';\nimport {PolyNodeController} from '../../../../nodes/utils/poly/PolyNodeController';\n\nexport class PolyNodeJsonImporter extends NodeJsonImporter<any> {\n\tcreate_nodes(scene_importer: SceneJsonImporter, data: PolyDictionary<NodeJsonExporterData>) {\n\t\tconst node = this._node;\n\t\tconst polyNodeController = node.polyNodeController as PolyNodeController;\n\t\tif (polyNodeController) {\n\t\t\tpolyNodeController.createChildNodesFromDefinition();\n\t\t}\n\t}\n}\n","import {BaseNodeType} from '../../../nodes/_Base';\nimport {BaseParamType} from '../../../params/_Base';\n\nimport {NodeJsonImporter} from './Node';\n// import {BaseNodeObjJsonImporter} from './node/Obj';\n// import {BaseNodeSopSubnetworkJsonImporter} from './node/Subnetwork';\n\nimport {ParamJsonImporter} from './Param';\nimport {ParamMultipleJsonImporter} from './param/Multiple';\nimport {ParamStringJsonImporter} from './param/String';\nimport {ParamRampJsonImporter} from './param/Ramp';\n// import {TypedObjNode} from '../../../nodes/obj/_Base';\nimport {TypedMultipleParam} from '../../../params/_Multiple';\nimport {StringParam} from '../../../params/String';\nimport {RampParam} from '../../../params/Ramp';\n// import {PolySopNode} from '../../../nodes/sop/Poly';\n// import {PolyObjNode} from '../../../nodes/obj/Poly';\nimport {PolyNodeJsonImporter} from './nodes/Poly';\n\nexport class JsonImportDispatcher {\n\tstatic dispatch_node(node: BaseNodeType) {\n\t\t// using PolySopNode and PolyObjNode seem to create circular dependency with webpack\n\t\t// if (node instanceof PolySopNode || node instanceof PolyObjNode)\n\t\tif (node.polyNodeController) {\n\t\t\treturn new PolyNodeJsonImporter(node);\n\t\t}\n\t\treturn new NodeJsonImporter(node);\n\t}\n\n\tstatic dispatch_param(param: BaseParamType) {\n\t\tif (param instanceof TypedMultipleParam) {\n\t\t\treturn new ParamMultipleJsonImporter(param);\n\t\t}\n\t\tif (param instanceof StringParam) {\n\t\t\treturn new ParamStringJsonImporter(param);\n\t\t}\n\t\tif (param instanceof RampParam) {\n\t\t\treturn new ParamRampJsonImporter(param);\n\t\t}\n\t\treturn new ParamJsonImporter(param);\n\t}\n}\n\n// export class CodeImporterVisitor {\n// \tstatic node(node: BaseNode): NodeCodeImporter {\n// \t\treturn new NodeCodeImporter(node);\n// \t}\n// \tstatic node_obj(node: BaseNode) {\n// \t\treturn new BaseNodeObjCodeImporter(node);\n// \t}\n// \tstatic node_sop_subnetwork(node: BaseNode) {\n// \t\treturn new BaseNodeSopSubnetworkCodeImporter(node);\n// \t}\n\n// \tstatic visit_param(param: BaseParam) {\n// \t\treturn new ParamCodeImporter(param);\n// \t}\n// \tstatic param_multiple(param: BaseParam) {\n// \t\treturn new ParamMultipleCodeImporter(param);\n// \t}\n// \tstatic param_numeric(param: BaseParam) {\n// \t\treturn new ParamNumericCodeImporter(param);\n// \t}\n// \tstatic param_operator_path(param: BaseParam) {\n// \t\treturn new ParamOperatorPathCodeImporter(param);\n// \t}\n// \tstatic param_string(param: BaseParam) {\n// \t\treturn new ParamStringCodeImporter(param);\n// \t}\n// \tstatic param_ramp(param: BaseParam) {\n// \t\treturn new ParamRampCodeImporter(param);\n// \t}\n// }\n","import {SceneJsonImporter} from './Scene';\n\nexport class ImportReport {\n\tprivate _warnings: string[] = [];\n\tconstructor(_scene_importer: SceneJsonImporter) {}\n\n\twarnings() {\n\t\treturn this._warnings;\n\t}\n\n\treset() {\n\t\tthis._warnings = [];\n\t}\n\tadd_warning(message: string) {\n\t\tthis._warnings.push(message);\n\t}\n}\n","import {PolyScene} from '../../../scene/PolyScene';\n// import {JsonImporterVisitor} from './Visitor'\nimport {SceneJsonExporterData} from '../export/Scene';\nimport {JsonImportDispatcher} from './Dispatcher';\nimport {ImportReport} from './ImportReport';\nimport {OperationsComposerSopNode} from '../../../nodes/sop/OperationsComposer';\nimport {TimeController} from '../../../scene/utils/TimeController';\n\nexport class SceneJsonImporter {\n\tpublic readonly report = new ImportReport(this);\n\tprivate _base_operations_composer_nodes_with_resolve_required: OperationsComposerSopNode[] | undefined;\n\tconstructor(private _data: SceneJsonExporterData) {}\n\n\tstatic async loadData(data: SceneJsonExporterData) {\n\t\tconst importer = new SceneJsonImporter(data);\n\t\treturn await importer.scene();\n\t}\n\n\tasync scene(): Promise<PolyScene> {\n\t\tconst scene = new PolyScene();\n\t\tscene.loadingController.markAsLoading();\n\n\t\t// scene.set_js_version(this._data['__js_version'])\n\t\tconst properties = this._data['properties'];\n\t\tif (properties) {\n\t\t\t// scene.setName(properties['name'])\n\t\t\tconst maxFrame = properties['maxFrame'] || 600;\n\t\t\tscene.timeController.setMaxFrame(maxFrame);\n\t\t\tconst maxFrameLocked = properties['maxFrameLocked'];\n\t\t\tif (maxFrameLocked) {\n\t\t\t\tscene.timeController.setMaxFrameLocked(maxFrameLocked);\n\t\t\t}\n\t\t\tconst realtimeState = properties['realtimeState'];\n\t\t\tif (realtimeState != null) {\n\t\t\t\tscene.timeController.setRealtimeState(realtimeState);\n\t\t\t}\n\t\t\t// set frame after the range has been set, to avoid clamping\n\t\t\tscene.setFrame(properties['frame'] || TimeController.START_FRAME);\n\n\t\t\t// scene.time_controller.set_fps(properties['fps'] || 30);\n\t\t\tif (properties['masterCameraNodePath']) {\n\t\t\t\tscene.camerasController.setMasterCameraNodePath(properties['masterCameraNodePath']);\n\t\t\t}\n\t\t}\n\n\t\t// we block to ensure that nodes will not run their dirty_hooks\n\t\t// which would trigger operator_path params to search for nodes that\n\t\t// may not exist yet\n\t\tscene.cooker.block();\n\n\t\tthis._base_operations_composer_nodes_with_resolve_required = undefined;\n\n\t\tconst importer = JsonImportDispatcher.dispatch_node(scene.root());\n\t\tif (this._data['root']) {\n\t\t\timporter.process_data(this, this._data['root']);\n\t\t}\n\t\tif (this._data['ui']) {\n\t\t\timporter.process_ui_data(this, this._data['ui']);\n\t\t}\n\n\t\tthis._resolve_operation_containers_with_path_param_resolve();\n\n\t\tawait scene.loadingController.markAsLoaded();\n\t\tscene.cooker.unblock();\n\t\t// DO NOT wait for cooks here,\n\t\t// as a viewer will only be created once everything has cooked\n\t\t// which would be a problem for envMap or other nodes relying on the renderer being created\n\t\t// await scene.waitForCooksCompleted();\n\n\t\treturn scene;\n\t}\n\n\t//\n\t//\n\t// OPERATION CONTAINER RESOLVE\n\t//\n\t//\n\tadd_operations_composer_node_with_path_param_resolve_required(operations_composer_node: OperationsComposerSopNode) {\n\t\tif (!this._base_operations_composer_nodes_with_resolve_required) {\n\t\t\tthis._base_operations_composer_nodes_with_resolve_required = [];\n\t\t}\n\t\tthis._base_operations_composer_nodes_with_resolve_required.push(operations_composer_node);\n\t}\n\tprivate _resolve_operation_containers_with_path_param_resolve() {\n\t\tif (!this._base_operations_composer_nodes_with_resolve_required) {\n\t\t\treturn;\n\t\t}\n\t\tfor (let operations_composer_node of this._base_operations_composer_nodes_with_resolve_required) {\n\t\t\toperations_composer_node.resolve_operation_containers_path_params();\n\t\t}\n\t}\n}\n"],"sourceRoot":""}