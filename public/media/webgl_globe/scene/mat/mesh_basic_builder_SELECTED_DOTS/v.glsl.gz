
#include <common>



// /MAT/mesh_basic_builder_SELECTED_DOTS/rotate1


// https://github.com/mattatz/ShibuyaCrowd/blob/master/source/shaders/common/quaternion.glsl
vec4 quat_mult(vec4 q1, vec4 q2)
{
	return vec4(
	q1.w * q2.x + q1.x * q2.w + q1.z * q2.y - q1.y * q2.z,
	q1.w * q2.y + q1.y * q2.w + q1.x * q2.z - q1.z * q2.x,
	q1.w * q2.z + q1.z * q2.w + q1.y * q2.x - q1.x * q2.y,
	q1.w * q2.w - q1.x * q2.x - q1.y * q2.y - q1.z * q2.z
	);
}
// http://glmatrix.net/docs/quat.js.html#line97
//   let ax = a[0], ay = a[1], az = a[2], aw = a[3];

//   let bx = b[0], by = b[1], bz = b[2], bw = b[3];

//   out[0] = ax * bw + aw * bx + ay * bz - az * by;

//   out[1] = ay * bw + aw * by + az * bx - ax * bz;

//   out[2] = az * bw + aw * bz + ax * by - ay * bx;

//   out[3] = aw * bw - ax * bx - ay * by - az * bz;

//   return out



// http://www.neilmendoza.com/glsl-rotation-about-an-arbitrary-axis/
mat4 rotationMatrix(vec3 axis, float angle)
{
	axis = normalize(axis);
	float s = sin(angle);
	float c = cos(angle);
	float oc = 1.0 - c;

 	return mat4(oc * axis.x * axis.x + c, oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s, 0.0, oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c, oc * axis.y * axis.z - axis.x * s,  0.0, oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c, 0.0, 0.0, 0.0, 0.0, 1.0);
}

// https://www.geeks3d.com/20141201/how-to-rotate-a-vertex-by-a-quaternion-in-glsl/
vec4 quat_from_axis_angle(vec3 axis, float angle)
{
	vec4 qr;
	float half_angle = (angle * 0.5); // * 3.14159 / 180.0;
	float sin_half_angle = sin(half_angle);
	qr.x = axis.x * sin_half_angle;
	qr.y = axis.y * sin_half_angle;
	qr.z = axis.z * sin_half_angle;
	qr.w = cos(half_angle);
	return qr;
}
vec3 rotate_with_axis_angle(vec3 position, vec3 axis, float angle)
{
	vec4 q = quat_from_axis_angle(axis, angle);
	vec3 v = position.xyz;
	return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
// vec3 applyQuaternionToVector( vec4 q, vec3 v ){
// 	return v + 2.0 * cross( q.xyz, cross( q.xyz, v ) + q.w * v );
// }
vec3 rotate_with_quat( vec3 v, vec4 q )
{
	// vec4 qv = multQuat( quat, vec4(vec, 0.0) );
	// return multQuat( qv, vec4(-quat.x, -quat.y, -quat.z, quat.w) ).xyz;
	return v + 2.0 * cross( q.xyz, cross( q.xyz, v ) + q.w * v );
}
// https://github.com/glslify/glsl-look-at/blob/gh-pages/index.glsl
// mat3 rotation_matrix(vec3 origin, vec3 target, float roll) {
// 	vec3 rr = vec3(sin(roll), cos(roll), 0.0);
// 	vec3 ww = normalize(target - origin);
// 	vec3 uu = normalize(cross(ww, rr));
// 	vec3 vv = normalize(cross(uu, ww));

// 	return mat3(uu, vv, ww);
// }
// mat3 rotation_matrix(vec3 target, float roll) {
// 	vec3 rr = vec3(sin(roll), cos(roll), 0.0);
// 	vec3 ww = normalize(target);
// 	vec3 uu = normalize(cross(ww, rr));
// 	vec3 vv = normalize(cross(uu, ww));

// 	return mat3(uu, vv, ww);
// }

float vector_angle(vec3 start, vec3 dest){
	start = normalize(start);
	dest = normalize(dest);

	float cosTheta = dot(start, dest);
	vec3 c1 = cross(start, dest);
	// We use the dot product of the cross with the Y axis.
	// This is a little arbitrary, but can still give a good sense of direction
	vec3 y_axis = vec3(0.0, 1.0, 0.0);
	float d1 = dot(c1, y_axis);
	float angle = acos(cosTheta) * sign(d1);
	return angle;
}

// http://www.opengl-tutorial.org/intermediate-tutorials/tutorial-17-quaternions/#i-need-an-equivalent-of-glulookat-how-do-i-orient-an-object-towards-a-point-
vec4 vector_align(vec3 start, vec3 dest){
	start = normalize(start);
	dest = normalize(dest);

	float cosTheta = dot(start, dest);
	vec3 axis;

	// if (cosTheta < -1 + 0.001f){
	// 	// special case when vectors in opposite directions:
	// 	// there is no "ideal" rotation axis
	// 	// So guess one; any will do as long as it's perpendicular to start
	// 	axis = cross(vec3(0.0f, 0.0f, 1.0f), start);
	// 	if (length2(axis) < 0.01 ) // bad luck, they were parallel, try again!
	// 		axis = cross(vec3(1.0f, 0.0f, 0.0f), start);

	// 	axis = normalize(axis);
	// 	return gtx::quaternion::angleAxis(glm::radians(180.0f), axis);
	// }
	if(cosTheta > (1.0 - 0.0001) || cosTheta < (-1.0 + 0.0001) ){
		axis = normalize(cross(start, vec3(0.0, 1.0, 0.0)));
		if (length(axis) < 0.001 ){ // bad luck, they were parallel, try again!
			axis = normalize(cross(start, vec3(1.0, 0.0, 0.0)));
		}
	} else {
		axis = normalize(cross(start, dest));
	}

	float angle = acos(cosTheta);

	return quat_from_axis_angle(axis, angle);
}
vec4 vector_align_with_up(vec3 start, vec3 dest, vec3 up){
	vec4 rot1 = vector_align(start, dest);
	up = normalize(up);

	// Recompute desiredUp so that it's perpendicular to the direction
	// You can skip that part if you really want to force desiredUp
	// vec3 right = normalize(cross(dest, up));
	// up = normalize(cross(right, dest));

	// Because of the 1rst rotation, the up is probably completely screwed up.
	// Find the rotation between the "up" of the rotated object, and the desired up
	vec3 newUp = rotate_with_quat(vec3(0.0, 1.0, 0.0), rot1);//rot1 * vec3(0.0, 1.0, 0.0);
	vec4 rot2 = vector_align(up, newUp);

	// return rot1;
	return rot2;
	// return multQuat(rot1, rot2);
	// return rot2 * rot1;

}

// https://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm
float quat_to_angle(vec4 q){
	return 2.0 * acos(q.w);
}
vec3 quat_to_axis(vec4 q){
	return vec3(
		q.x / sqrt(1.0-q.w*q.w),
		q.y / sqrt(1.0-q.w*q.w),
		q.z / sqrt(1.0-q.w*q.w)
	);
}

vec4 align(vec3 dir, vec3 up){
	vec3 start_dir = vec3(0.0, 0.0, 1.0);
	vec3 start_up = vec3(0.0, 1.0, 0.0);
	vec4 rot1 = vector_align(start_dir, dir);
	up = normalize(up);

	// Recompute desiredUp so that it's perpendicular to the direction
	// You can skip that part if you really want to force desiredUp
	vec3 right = normalize(cross(dir, up));
	if(length(right)<0.001){
		right = vec3(1.0, 0.0, 0.0);
	}
	up = normalize(cross(right, dir));

	// Because of the 1rst rotation, the up is probably completely screwed up.
	// Find the rotation between the "up" of the rotated object, and the desired up
	vec3 newUp = rotate_with_quat(start_up, rot1);//rot1 * vec3(0.0, 1.0, 0.0);
	vec4 rot2 = vector_align(normalize(newUp), up);

	// return rot1;
	return quat_mult(rot1, rot2);
	// return rot2 * rot1;

}

// /MAT/mesh_basic_builder_SELECTED_DOTS/easing1
float exponentialOut(float t) {
  return t == 1.0 ? t : 1.0 - pow(2.0, -10.0 * t);
}



// /MAT/mesh_basic_builder_SELECTED_DOTS/complement2
float complement(float x){return 1.0-x;}
vec2 complement(vec2 x){return vec2(1.0-x.x, 1.0-x.y);}
vec3 complement(vec3 x){return vec3(1.0-x.x, 1.0-x.y, 1.0-x.z);}
vec4 complement(vec4 x){return vec4(1.0-x.x, 1.0-x.y, 1.0-x.z, 1.0-x.w);}








// /MAT/mesh_basic_builder_SELECTED_DOTS/globals2
uniform float time;

// /MAT/mesh_basic_builder_SELECTED_DOTS/param2
uniform float v_POLY_param2_val;

// /MAT/mesh_basic_builder_SELECTED_DOTS/param_threshold
uniform float v_POLY_param_threshold_val;

// /MAT/mesh_basic_builder_SELECTED_DOTS/param_visibles_count
uniform float v_POLY_param_visibles_count_val;

// /MAT/mesh_basic_builder_SELECTED_DOTS/globals2
varying vec3 v_POLY_globals2_cameraPosition;

// /MAT/mesh_basic_builder_SELECTED_DOTS/attribute2
varying float varying_v_POLY_attribute2_val;

// /MAT/mesh_basic_builder_SELECTED_DOTS/attribute1
varying float varying_v_POLY_attribute1_val;

// /MAT/mesh_basic_builder_SELECTED_DOTS/attribute3
attribute vec3 instancePosition;

// /MAT/mesh_basic_builder_SELECTED_DOTS/attribute5
attribute float id;

// /MAT/mesh_basic_builder_SELECTED_DOTS/attribute2
attribute float sphere;

// /MAT/mesh_basic_builder_SELECTED_DOTS/attribute1
attribute float role;




#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

void main() {

	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>



	// /MAT/mesh_basic_builder_SELECTED_DOTS/constant4
	float v_POLY_constant4_val = 1.01;
	
	// /MAT/mesh_basic_builder_SELECTED_DOTS/attribute3
	vec3 v_POLY_attribute3_val = instancePosition;
	
	// /MAT/mesh_basic_builder_SELECTED_DOTS/globals2
	v_POLY_globals2_cameraPosition = vec3(cameraPosition);
	float v_POLY_globals2_time = time;
	
	// /MAT/mesh_basic_builder_SELECTED_DOTS/attribute5
	float v_POLY_attribute5_val = id;
	
	// /MAT/mesh_basic_builder_SELECTED_DOTS/attribute2
	varying_v_POLY_attribute2_val = float(sphere);
	
	// /MAT/mesh_basic_builder_SELECTED_DOTS/attribute1
	varying_v_POLY_attribute1_val = float(role);
	
	// /MAT/mesh_basic_builder_SELECTED_DOTS/normalize3
	vec3 v_POLY_normalize3_normalized = normalize(v_POLY_attribute3_val);
	
	// /MAT/mesh_basic_builder_SELECTED_DOTS/mult_add1
	float v_POLY_mult_add1_val = (v_POLY_param2_val*(v_POLY_globals2_time + 0.0)) + 0.0;
	
	// /MAT/mesh_basic_builder_SELECTED_DOTS/substract1
	float v_POLY_substract1_substract = (v_POLY_param_threshold_val - v_POLY_attribute5_val - 0.0);
	
	// /MAT/mesh_basic_builder_SELECTED_DOTS/mult_add4
	float v_POLY_mult_add4_val = (1.0*(v_POLY_attribute5_val + v_POLY_param_visibles_count_val)) + 0.0;
	
	// /MAT/mesh_basic_builder_SELECTED_DOTS/mult3
	vec3 v_POLY_mult3_product = (v_POLY_constant4_val * v_POLY_normalize3_normalized);
	
	// /MAT/mesh_basic_builder_SELECTED_DOTS/compare4
	bool v_POLY_compare4_val = (v_POLY_param_threshold_val < v_POLY_mult_add4_val);
	
	// /MAT/mesh_basic_builder_SELECTED_DOTS/mult_add3
	float v_POLY_mult_add3_val = (2.0*(v_POLY_substract1_substract + 0.0)) + 0.0;
	
	// /MAT/mesh_basic_builder_SELECTED_DOTS/substract2
	float v_POLY_substract2_substract = (v_POLY_param_threshold_val - v_POLY_mult_add4_val - 0.0);
	
	// /MAT/mesh_basic_builder_SELECTED_DOTS/rotate1
	vec3 v_POLY_rotate1_val = rotate_with_axis_angle(v_POLY_mult3_product, vec3(0.0, 1.0, 0.0), v_POLY_mult_add1_val);
	
	// /MAT/mesh_basic_builder_SELECTED_DOTS/clamp2
	float v_POLY_clamp2_val = clamp(v_POLY_mult_add3_val, 0.0, 1.0);
	
	// /MAT/mesh_basic_builder_SELECTED_DOTS/mult_add5
	float v_POLY_mult_add5_val = (2.0*(v_POLY_substract2_substract + 0.0)) + 0.0;
	
	// /MAT/mesh_basic_builder_SELECTED_DOTS/normalize1
	vec3 v_POLY_normalize1_normalized = normalize(v_POLY_rotate1_val);
	
	// /MAT/mesh_basic_builder_SELECTED_DOTS/easing1
	float v_POLY_easing1_out = exponentialOut(v_POLY_clamp2_val);
	
	// /MAT/mesh_basic_builder_SELECTED_DOTS/clamp3
	float v_POLY_clamp3_val = clamp(v_POLY_mult_add5_val, 0.0, 1.0);
	
	// /MAT/mesh_basic_builder_SELECTED_DOTS/vector_align1
	vec4 v_POLY_vector_align1_val = vector_align_with_up(vec3(0.0, 1.0, 0.0), v_POLY_normalize1_normalized, vec3(0.0, 0.0, 1.0));
	
	// /MAT/mesh_basic_builder_SELECTED_DOTS/complement2
	float v_POLY_complement2_val = complement(v_POLY_clamp3_val);
	
	// /MAT/mesh_basic_builder_SELECTED_DOTS/easing2
	float v_POLY_easing2_out = exponentialOut(v_POLY_complement2_val);
	
	// /MAT/mesh_basic_builder_SELECTED_DOTS/two_way_switch4
	float v_POLY_two_way_switch4_val;
	if(v_POLY_compare4_val){
	v_POLY_two_way_switch4_val = v_POLY_easing1_out;
	} else {
	v_POLY_two_way_switch4_val = v_POLY_easing2_out;
	}
	
	// /MAT/mesh_basic_builder_SELECTED_DOTS/null2
	float v_POLY_null2_val = v_POLY_two_way_switch4_val;
	
	// /MAT/mesh_basic_builder_SELECTED_DOTS/float_to_vec3_1
	vec3 v_POLY_float_to_vec3_1_vec3 = vec3(v_POLY_null2_val, v_POLY_null2_val, v_POLY_null2_val);
	
	// /MAT/mesh_basic_builder_SELECTED_DOTS/instance_transform1
	vec3 v_POLY_instance_transform1_position = vec3(position);
	v_POLY_instance_transform1_position *= v_POLY_float_to_vec3_1_vec3;
	v_POLY_instance_transform1_position = rotate_with_quat( v_POLY_instance_transform1_position, v_POLY_vector_align1_val );
	v_POLY_instance_transform1_position += v_POLY_rotate1_val;
	vec3 v_POLY_instance_transform1_normal = vec3(normal);
	v_POLY_instance_transform1_normal = rotate_with_quat( v_POLY_instance_transform1_normal, v_POLY_vector_align1_val );
	
	// /MAT/mesh_basic_builder_SELECTED_DOTS/output1
	vec3 transformed = v_POLY_instance_transform1_position;
	vec3 objectNormal = v_POLY_instance_transform1_normal;



	#include <skinbase_vertex>

	#ifdef USE_ENVMAP

// removed:
//	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>

	#endif

// removed:
//	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>

	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>

}
