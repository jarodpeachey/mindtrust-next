{"version":3,"sources":["webpack:///./node_modules/@polygonjs/polygonjs/src/engine/params/_BasePath.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/nodes/utils/io/connections/Gl.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/nodes/utils/io/connections/_Base.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/operations/_Base.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/poly/ParamType.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/poly/registers/modules/_BaseRegister.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/poly/registers/assemblers/_BaseRegister.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/expressions/MethodDependency.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/core/geometry/Entity.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/core/math/Easing.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/core/geometry/util/IndexBuilder.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/poly/InputCloneMode.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/nodes/utils/Serializer.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/params/utils/OptionsController.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/expressions/traversers/ParsedTree.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/params/Float.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/core/geometry/Constant.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/params/OperatorPath.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/params/String.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/nodes/event/_Base.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/expressions/traversers/_Base.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/expressions/AttributeRequirementsController.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/expressions/traversers/FunctionGenerator.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/expressions/LiteralConstructsController.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/expressions/traversers/ExpressionStringGenerator.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/expressions/DependenciesController.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/expressions/ExpressionManager.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/params/utils/ExpressionController.ts","webpack:///(webpack)/buildin/global.js","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/poly/RenderersController.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/poly/PolyLibsController.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/poly/registers/nodes/NodesRegister.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/poly/registers/expressions/ExpressionRegister.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/poly/registers/expressions/_BaseRegister.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/poly/registers/modules/DynamicModulesRegister.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/poly/registers/assemblers/AssemblersRegistry.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/poly/registers/plugins/PluginsRegister.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/poly/registers/cameras/CamerasRegister.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/Poly.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/core/Walker.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/core/String.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/core/SetUtils.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/core/ArrayUtils.ts","webpack:///./node_modules/jsep/build/jsep.js","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/poly/NodeEvent.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/poly/Assert.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/core/graph/DirtyController.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/core/graph/CoreGraphNode.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/core/geometry/Attribute.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/poly/ParamEvent.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/nodes/utils/UIData.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/nodes/utils/states/Base.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/nodes/utils/states/TimeDependent.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/nodes/utils/states/Error.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/nodes/utils/StatesController.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/nodes/utils/NameController.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/nodes/utils/hierarchy/ParentController.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/core/NodeSelection.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/operations/container/utils/inputs/ClonedStatesController.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/operations/container/utils/InputsController.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/operations/container/sop.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/operations/container/_Base.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/nodes/utils/hierarchy/ChildrenController.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/nodes/utils/LifeCycleController.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/containers/_Base.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/containers/utils/ContainerMap.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/containers/Animation.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/containers/Texture.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/containers/Event.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/containers/Gl.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/containers/Js.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/containers/Manager.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/containers/Material.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/containers/Object.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/containers/PostProcess.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/containers/Rop.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/containers/Geometry.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/nodes/utils/ContainerController.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/nodes/utils/cook/PerformanceController.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/nodes/utils/CookController.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/params/Boolean.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/params/Button.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/params/Color.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/params/Folder.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/params/Integer.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/params/ParamPath.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/params/NodePath.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/params/Separator.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/params/Vector2.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/params/Vector3.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/params/Vector4.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/params/types/ParamConstructorByType.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/nodes/utils/params/ParamsLabelController.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/nodes/utils/params/ParamsController.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/nodes/utils/params/ParamsValueAccessor.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/nodes/utils/io/NodeConnection.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/nodes/utils/io/utils/ClonedStatesController.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/nodes/utils/io/InputsController.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/nodes/utils/io/OutputsController.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/nodes/utils/io/ConnectionsController.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/nodes/utils/io/SavedConnectionPointsDataController.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/nodes/utils/io/connections/Js.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/nodes/utils/io/connections/ConnectionMap.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/nodes/utils/io/ConnectionPointsSpareParamsController.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/nodes/utils/io/ConnectionPointsController.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/nodes/utils/io/IOController.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/nodes/utils/params/ParamsAccessor.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/nodes/_Base.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/nodes/utils/flags/Base.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/nodes/utils/flags/Bypass.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/nodes/utils/flags/Display.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/nodes/utils/flags/Optimize.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/nodes/utils/FlagsController.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/nodes/utils/params/ParamsConfig.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/core/geometry/Point.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/core/geometry/Face.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/core/geometry/builders/_Base.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/modules/three/examples/jsm/utils/BufferGeometryUtils.js","webpack:///./node_modules/@polygonjs/polygonjs/src/core/geometry/Geometry.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/core/geometry/builders/Merge.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/core/geometry/builders/Mesh.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/core/geometry/builders/Points.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/core/geometry/builders/LineSegments.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/params/utils/EmitController.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/params/utils/Serializer.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/params/utils/states/TimeDependent.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/params/utils/states/Error.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/params/utils/StatesController.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/params/_Base.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/core/MapUtils.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/nodes/utils/io/connections/Event.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/core/math/_Module.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/core/ObjectUtils.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/params/_Multiple.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/core/Type.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/core/geometry/Object.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/params/ramp/RampValue.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/params/Ramp.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/poly/NodeContext.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/core/DecomposedPath.ts","webpack:///(webpack)/buildin/module.js","webpack:///./node_modules/@polygonjs/polygonjs/src/core/geometry/Material.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/params/_Numeric.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/core/Color.ts"],"names":["TypedPathParam","decomposed_path","GlConnectionPointType","BOOL","INT","FLOAT","VEC2","VEC3","VEC4","GlConnectionPointTypeToParamTypeMap","BOOLEAN","INTEGER","VECTOR2","VECTOR3","VECTOR4","SAMPLER_2D","RAMP","GLParamTypeToConnectionPointTypeMap","COLOR","FOLDER","undefined","BUTTON","OPERATOR_PATH","PARAM_PATH","NODE_PATH","SEPARATOR","STRING","GlConnectionPointInitValueMap","DEFAULT_VALUE_JSON","GlConnectionPoint","_name","_type","_init_value","super","this","src_type","dest_type","_json","_create_json","name","type","BaseConnectionPoint","OPERATIONS_COMPOSER_NODE_TYPE","BaseOperation","scene","states","constructor","console","error","context","input_contents","params","DEFAULT_PARAMS","INPUT_CLONED_STATE","ParamType","ModuleName","BaseModulesRegister","_loaded_module_by_name","Map","_promise_by_name","promise","set","loaded_module","get","new_loaded_module","warn","AssemblerName","BaseAssemblersRegister","_controller_assembler_by_name","controller","assembler","delete","MethodDependency","param","path_argument","_update_from_name_change_bound","_update_from_name_change","bind","expressionController","registerMethodDependency","addPostDirtyHook","trigger","node","update_from_name_change","new_path","to_path","literal","jsep_node","value","replace","raw","update_from_method_dependency_name_change","graphDisconnectPredecessors","node_in_path","named_nodes","nameController","addGraphInput","graph_node","resolved_graph_node","path","unresolved_path","index_or_path","is_index","isNumber","instance","set_resolved_graph_node","set_unresolved_path","CoreEntity","_index","ease_i","power","t","Math","pow","ease_o","abs","ease_io","Easing","linear","ease_i2","ease_o2","ease_io2","ease_i3","ease_o3","ease_io3","ease_i4","ease_o4","ease_io4","ease_i_sin","sin","PI","ease_o_sin","ease_io_sin","ease_i_elastic","ease_o_elastic","ease_io_elastic","CoreGeometryIndexBuilder","geometry","index","position","getAttribute","position_array","array","setIndex","range","length","InputCloneMode","NodeSerializer","include_param_components","data","graph_node_id","graphNodeId","is_dirty","isDirty","ui_data_json","uiData","toJSON","error_message","message","children","childrenIds","maxInputsCount","inputs","inputIds","input_connection_output_indices","named_input_connection_points","named_output_connection_points","param_ids","to_json_params","override_cloned_state_allowed","io","overrideClonedStateAllowed","inputs_clone_required_states","cloneRequiredStates","flags","display","active","bypass","optimize","selection","childrenAllowed","childrenController","map","connections","inputConnections","connection","output_index","i","outputs","o","param_names","include_components","param_name","to_json_params_from_names","names","StringParamLanguage","FileType","OptionsController","_param","_programatic_visible_state","_callbackAllowed","_update_visibility_and_remove_dirty_bound","update_visibility_and_remove_dirty","_ui_data_dependency_set","_options","_visibility_graph_node","dispose","options","_default_options","cloneDeep","post_set_options","options_controller","default","current","components","component","set_option","_handle_computeOnDirty","isEqual","overriden","option_names","Object","keys","option_name","cloned_option","assign","overridden_options","computeOnDirty","_computeOnDirty_callback_added","_compute_param","compute","loadingController","loaded","callback","get_callback","parent_param","execute_callback","has_callback","create_callback_from_string","callbackString","callback_function","Function","cook_options","file_browse_option","option","expr_option","menu_options","has_menu","language","node_selection_options","param_selection_options","type_or_boolean","isBoolean","range_locked","texture_options","is_hidden","state","emit","VISIBLE_UPDATED","is_field_hidden","visibility_options","predecessor_names","isArray","uniq","flat","compact","predecessors","visibility_predecessors","predecessor","update_visibility","removeDirtyState","promises","p","Promise","all","options_set","filter","satisfied_values","addUnaryOp","addBinaryOp","ParsedTree","string","reset","e","elements","string_value_elements","nodes","element","push","arguments","callee","v","isString","split","FloatParam","_default_value","_raw_input","valueSerialized","raw_input","parseFloat","raw_input1","raw_input2","val1","val2","raw_val","parsed","result","convert","ensure_in_range","ObjectType","OBJECT_CONSTRUCTOR_BY_OBJECT_TYPE","MESH","POINTS","LINE_SEGMENTS","OBJECT3D","LOD","objectTypeFromConstructor","ObjectTypeByObject","object","ObjectTypes","ObjectTypeMenuEntries","indexOf","materials","MeshStandard","color","side","metalness","roughness","vertexColors","transparent","depthTest","size","linewidth","AttribClass","ATTRIBUTE_CLASSES","VERTEX","OBJECT","AttribClassMenuEntries","AttribType","ATTRIBUTE_TYPES","NUMERIC","AttribTypeMenuEntries","AttribSize","ATTRIBUTE_SIZES","ATTRIBUTE_SIZE_RANGE","CoreConstant","ATTRIB_CLASS","OBJECT_TYPES","CONSTRUCTOR_NAMES_BY_CONSTRUCTOR_NAME","CONSTRUCTORS_BY_NAME","MATERIALS","OperatorPathMode","OperatorPathParam","_found_node","_found_node_with_expected_type","_found_param","_found_param_with_expected_type","_value","fullPath","setDirty","emitController","VALUE_UPDATED","find_target","path_non_empty","mode","PARAM","NODE","referencesController","reset_reference_from_param","find_param","find_node","current_found_entity","newly_found_entity","set_named_nodes_from_param","set_reference_from_param","dependent_on_found_node","removeGraphInput","_assign_found_node","_assign_found_param","_is_node_expected_context","_is_node_expected_type","_expected_node_types","join","nodeContext","_expected_context","_is_param_expected_type","_expected_param_type","type_or_types","found_node_with_context","node_selection_context","expected_context","parent","node_selection_types","param_selection_type","expected_types","includes","StringParam","clear","_value_elements","_expression_controller","expression","set_expression","EXPRESSION_UPDATED","setSuccessorsDirty","requires_entities","expression_result","compute_expression","is_errored","converted","TypedEventNode","_cook_without_inputs_bound","_cook_without_inputs","EVENT","setLayoutHorizontal","set_depends_on_inputs","initInputs","connection_points","spare_params","initializeNode","cookController","cook_main_without_inputs","end_cook","event_context","connection_point","event_listener","process_event","output_name","run_on_dispatch_hook","get_output_index","current_connections","outputConnections","dest_node","node_dest","input_index","process_event_via_connection_point","_on_dispatch_hooks_by_output_name","push_on_array_at_entry","hooks","hook","_set_error_from_error_bound","_set_error_from_error","_error_message","method_name","set_error","traverse_node","left","operator","right","property","test","consequent","alternate","args","body","traversed_args","arg_node","AttributeRequirementsController","_attribute_names","lines","forEach","attribute_name","assign_attribute_line","assign_item_size_line","assign_array_line","var_names","var_name","var_attribute","Set","add","var_attribute_size","var_array","NATIVE_MATH_METHODS_RENAMED","math_random","EASING_METHODS","DIRECT_EXPRESSION_FUNCTIONS","remaped","LITERAL_CONSTRUCT","if","GLOBAL_CONSTANTS","PROPERTY_OFFSETS","x","y","z","w","r","g","b","_attribute_requirements_controller","methods","method_index","method_dependencies","immutable_dependencies","parsed_tree","function_main_string","function","function_body","is_expression_for_entities","assign_attributes_lines","attribute_presence_check_line","assign_arrays_lines","clear_error","Core","String","method_arguments","arg","literal_contruct","arguments_joined","direct_function_name","expressionRegister","Poly","expressionsRegister","getMethod","path_node","function_string","path_argument_function","_create_method_and_dependencies","availableMethods","argument","argument_member_expression","attrib_node","property_node","remap_name","identifier_name_without_dollar_sign","substr","direct_constant_name","timeController","graphNode","_method_centroid","method_constructor","method","require_dependency","method_dependency","find_dependency","set_jsep_node","missingExpressionReferencesController","register","DependenciesController","cyclic_graph_detected","function_generator","connect_immutable_dependencies","handle_method_dependencies","listen_for_name_changes","dependency","handle_method_dependency","node_simple","parse_completed","parse_started","dependencies_controller","Error","parse_expression_for_string_param","parse_expression","parse_tree","update","compute_allowed","resolve","reject","eval_function","eval_allowed","expression_string_generator","new_expression_string","_resetMethodDependencies","_method_dependencies_by_graph_node_id","_expression","_manager","set_dirty","deregister_param","expressionsController","compute_function","entities","set_entities","reset_entities","compute_expression_for_entities","_entities","_entity_callback","window","module","exports","CONTEXT_OPTIONS","WebGLContext","_next_renderer_id","_next_env_map_id","_renderers","_env_maps","_printDebug","_require_webgl2","_resolves","log","_webgl2_available","_set_webgl2_available","canvas","document","createElement","WebGL2RenderingContext","getContext","WEBGL2","gl","_rendering_context_webgl","webgl2","context_name","webgl2Available","WEBGL","printDebugMessage","EXPERIMENTAL_WEBGL2","EXPERIMENTAL_WEBGL","renderer","_polygon_id","flush_callbacks_with_renderer","first_id","values","pop","firstRenderer","width","height","parameters","WebGLMultisampleRenderTarget","WebGLRenderTarget","PolyLibsController","_root","url","NodesRegister","poly","_node_register","_node_register_categories","_node_register_options","tab_menu_category","nodeType","toLowerCase","current_nodes_for_context","current_categories","current_options","pluginsRegister","registerNode","node_type","nodes_for_context","parent_node_type","option_only","option_except","context_and_type","nodesByType","registeredNodesForContextAndParentType","OperationsRegister","_operation_register","operation","current_operations_for_context","operationType","registerOperation","_methods_names","_methods_by_name","pair","unregister","PluginsRegister","_plugins_by_name","_plugin_name_by_node_context_by_type","_plugin_name_by_operation_context_by_type","plugin","_current_plugin","init","pluginName","map_for_context","plugins","operations","plugin_name","CamerasRegister","_camera_types","renderersController","nodesRegister","operationsRegister","modulesRegister","assemblersRegister","camerasRegister","scenesByUuid","_player_mode","_logger","__POLYGONJS_POLY_INSTANCE__","parent_context","registeredNodes","operation_type","registeredOperation","registeredTypes","_libs_controller","env","_env","logger","optionalParams","_instance_","NODE_PATH_DEFAULT","UV","ENV_MAP","TypedNodePathParamValue","_path","_node","node_start","CoreWalker","cloned","set_node","error_state","found_node","node_context","TypedParamPathParamValue","set_param","child_path","child","node_src","first_element","next_node","PARENT","add_path_element","CURRENT","add_node","remainder","slice","path_from_root","root","node_path","src_graph_node","dest_graph_node","closest_common_parent","distance","distanceToParent","up","ups","parent_path_elements","dest_path_elements","remaining_elements","cmptr","dest_path_element","graph_node1","graph_node2","parents1","parents","reverse","concat","parents2","min_depth","min","found_parent","dest","dest_id","path_elements","shift","make_absolute_path","DOT","CURRENT_WITH_SLASH","PARENT_WITH_SLASH","NON_LETTER_PREFIXES","ATTRIB_NAMES_SEPARATOR","TAIL_DIGIT_MATCH_REGEXP","LEADING_ZEROS_MATCH_REGEXP","INDICES_LIST_SEPARATOR","NUM_REGEXP","BooleanString","CoreString","word","TRUE","FALSE","match","parseInt","numbers_as_str","zeros_prefix","leading_zeros_match","digits","substring","str","newWord","upperFirst","toUpperCase","elem","val","decimals","max","frac","padEnd","string_to_pad","pad","num","num_as_string","mask","matchMask","RegExp","masks","matches_one_mask","names_set","trim","Array","indices_string","indices","flatMap","sort","a","range_separator","range_elements","SetUtils","set0","set1","newSet","has","sum","newArray","tmpSet","chunkSize","newSubArray","array0","array1","union","toSet","intersection","difference","count","elementsByValue","valuesSet","MapUtils","sorted_elements","elements_for_value","start","end","step","floor","throwError","description","unary_ops","binary_ops","getMaxKeyLen","obj","len","max_len","key","hasOwnProperty","max_unop_len","max_binop_len","literals","binaryPrecedence","op_val","createBinaryExpression","isDecimalDigit","ch","isIdentifierStart","fromCharCode","isIdentifierPart","jsep","expr","ch_i","charAtFunc","charAt","charCodeAtFunc","charCodeAt","exprI","call","exprICode","gobbleSpaces","gobbleExpression","gobbleBinaryExpression","gobbleBinaryOp","to_check","tc_len","biop","prec","stack","biop_info","cur_biop","gobbleToken","gobbleNumericLiteral","gobbleStringLiteral","gobbleArray","prefix","gobbleVariable","chCode","number","quote","closed","gobbleIdentifier","identifier","gobbleArguments","termination","separator_count","gobbleGroup","computed","version","toString","op_name","precedence","addLiteral","literal_name","literal_value","removeUnaryOp","removeAllUnaryOps","removeBinaryOp","removeAllBinaryOps","removeLiteral","removeAllLiterals","parse","NodeEvent","TypeAssert","DirtyController","_dirty_count","_dirty","_cached_successors","_post_dirty_hooks","_post_dirty_hook_names","_dirty_timestamp","splice","_forbidden_trigger_nodes","n","original_trigger_graph_node","propagate","performance","now","run_post_dirty_hooks","set_successors_dirty","cooker","blocked","enqueue","graphAllSuccessors","successor","dirtyController","clear_successors_cache","graphAllPredecessors","_scene","_dirty_controller","_graph_node_id","graph","next_id","_graph","graphRemove","remove_node","src","check_if_graph_has_cycle","connect","disconnect","disconnect_predecessors","disconnect_successors","predecessor_ids","successors","all_predecessors","all_successors","Attribute","ATTRIB_NAME_MAP","P","N","Cd","CoreAttribute","index_by_value","current_index","mark_as_needs_update","src_array","dest_array","min_length","needsUpdate","ParamEvent","_position","Vector2","_width","_color","Color","_layout_vertical","comment","_comment","UI_DATA_COMMENT_UPDATED","ui_data","copy","new_position","UI_DATA_POSITION_UPDATED","offset","snap","round","BaseState","are_params_time_dependent","are_inputs_time_dependent","time_dependent","input","graphPredecessors","frame_node","_message","on_update","setContainer","ERROR_UPDATED","_graph_node","CoreGraphNode","_on_set_name_hooks","_on_set_fullPath_hooks","base","last_char","isNaN","new_name","set_child_name","request_name_to_parent","_set_core_name","post_setName","run_post_set_fullPath_hooks","child_node","lifecycle","creation_completed","check_for_missing_references","regenerate_referring_expressions","notify_name_updated","NAME_UPDATED","_parent","parentController","base_name","contains","relative_to_parent","separator","parent_fullPath","_on_set_parent_hooks","child_by_name","_node_ids","nodes_from_ids","node_ids","ArrayUtils","send_update_event","nodes_to_add","node_ids_to_add","nodes_to_remove","node_ids_to_remove","SELECTION_UPDATED","id","inputs_controller","_clone_required_states","_overridden","_cloned_states","_cloned_state","_update_clone_required_state","FROM_NODE","clone_required_from_state","ALWAYS","NEVER","unreachable","_get_clone_required_state","max_inputs","inputs_count","operation_container","_cloned_states_controller","init_inputs_cloned_state","clone_required_state","override_cloned_state","init_params","_apply_default_params","_apply_init_params","_init_cloned_states","_path_params","path_param","default_params","param_data","clone_param_data","_convert_param_data","simple_data","_convert_export_param_data","clone","Vector3","Vector4","default_param","set_path","fromArray","_inputs","_inputs_controller","default_cloned_states","clone_required","cook","_current_input_index","setInput","increment_input_index","_compute_result","operation_inputs_map","operation_input_contents","node_inputs_map","node_input_index","operation_input_index","input_operation","input_clone_required","_context","_children","_children_by_type","_children_and_grandchildren_by_context","_selection","removeNode","_output_node_find_method","current_child_with_name","increment","current_name","update_name_from_parent","_add_to_nodesByType","nodesController","addToInstanciatedNode","available_children_classes","node_class_or_string","params_init_value_overrides","node_class","_find_node_class","_create_and_init_node","initialize_base_and_node","set_creation_completed","operation_container_name","operation_class","setParent","onSetParent","CREATED","child_node_json","lifecycleController","onCreateHookAllowed","run_on_create_hooks","run_on_add_hooks","run_on_child_add_hooks","require_webgl2","webgl_controller","set_require_webgl2","remove","first_connection","firstInputConnection","input_connections","output_connections","input_connection","output_connection","old_src","old_output_index","old_dest","old_input_index","_remove_from_nodesByType","removeFromInstanciatedNode","graphDisconnectSuccessors","run_on_child_remove_hooks","run_on_delete_hooks","DELETED","parent_id","node_id","add_to_children_and_grandchildren_by_context","remove_from_children_and_grandchildren_by_context","node_from_id","traverse_children","LifeCycleController","_creation_completed","_on_child_add_hooks","_on_child_remove_hooks","_on_create_hooks","_on_add_hooks","_on_delete_hooks","execute_hooks_with_child_node","execute_hooks","TypedContainer","content","_content","_post_set_content","ContainerClassMap","NodeContext","ANIM","set_content","timeline_builder","COP","texture","image","GL","JS","MANAGER","MAT","material","has_content","OBJ","POST","render_pass","ROP","SOP","objects","firstObject","count_by_type","core_group","core_object","coreObjects","human_type","humanType","names_by_type","firstGeometry","attributes","sizes_by_name","attrib_name","attrib","itemSize","firstCoreObject","attribNames","attribSize","types_by_name","core_geo","attribType","userData","pointsCount","totalPointsCount","objectsData","boundingBox","center","_callbacks","_callbacks_tmp","container_class","_container","requestInputContainer","cook_main","input_node","requestContainer","notify_requesters","container","containerController","NodeCookPerformanceformanceController","_inputs_start","_params_start","_cook_start","_cooks_count","_data","inputs_time","params_time","cook_time","performance_record_started","_cooking","_performance_controller","_inputs_evaluation_required","_core_performance","started","_cooking_dirty_timestamp","dirtyTimestamp","record_cook_start","isCooking","_init_cooking_state","_evaluate_inputs","params_eval_required","_evaluate_params","_start_cook_if_no_errors","_finalize_cook_performance","dirty_timestamp","_terminate_cook_process","_run_on_cook_complete_hooks","record_inputs_start","input_containers","io_inputs","is_any_input_dirty","eval_required_inputs","containers_without_evaluation","input_container","cloneRequired","coreContentCloned","coreContent","record_inputs_end","record_params_start","eval_all","record_params_end","cooks_count","record_cook_end","record_node_cook_data","core_graph_node","_on_cook_complete_hook_ids","_on_cook_complete_hooks","toBoolean","COMPONENT_NAMES_COLOR","_value_pre_conversion","_value_serialized_dirty","_value_serialized","_value_pre_conversion_serialized","_copied_value","toArray","_update_value_serialized_if_required","equals","initComponents","conversion","color_conversion","NONE","GAMMA_TO_LINEAR","convertGammaToLinear","LINEAR_TO_GAMMA","convertLinearToGamma","SRGB_TO_LINEAR","convertSRGBToLinear","LINEAR_TO_SRGB","convertLinearToSRGB","previously_found_node","COMPONENT_NAMES_VECTOR2","COMPONENT_NAMES_VECTOR3","COMPONENT_NAMES_VECTOR4","ParamConstructorByType","Float","OperatorPath","Ramp","_callback","_params","_handle_string_param","_handle_operator_path_param","_handle_node_path_param","_handle_param_path_param","_handle_number_param","_param_create_mode","_params_created","_params_by_name","_params_list","_param_names","_non_spare_params","_spare_params","_non_spare_param_names","_spare_param_names","_params_added_since_last_params_eval","_label_controller","_params_node","_post_create_params_hook_names","_post_create_params_hooks","_on_scene_load_hooks","_on_scene_load_hook_names","init_dependency_node","init_from_params_config","create_params","_post_create_params","_update_caches","init_param_accessors","run_post_create_params_hooks","has_created_a_param","has_deleted_a_param","names_to_delete","delete_param","to_add","addParam","init_value","post_create_spare_params","notify_params_updated","PARAMS_UPDATED","params_config","init_values_used","config","current_names_in_accessor","getOwnPropertyNames","pv","_remove_unneeded_accessors","is_spare","defineProperty","configurable","current_param_names","names_to_remove","current_name_in_accessor","name_to_remove","param_with_type","set_with_type","has_param","value_with_type","_setup_node_dependencies","isMultiple","child_name","default_value","init_data","existing_param","setName","setInitValue","complex_data","overriden_options","_eval_param","eval_params","hook_name","ParamsValueAccessor","TypedNodeConnection","_node_src","_node_dest","_output_index","_input_index","_id","_next_id","addOutputConnection","addInputConnection","removeOutputConnection","removeInputConnection","OVERRIDE_CLONABLE_STATE_UPDATE","_graph_node_inputs","_has_named_inputs","_min_inputs_count","_max_inputs_count","_maxInputsCountOnInput","_depends_on_inputs","_on_update_hooks","_on_update_hook_names","depends_on_inputs","min_inputs_count","max_inputs_count","init_graph_node_inputs","_named_input_connection_points","set_min_inputs_count","set_max_inputs_count","NAMED_INPUTS_UPDATED","_create_graph_node_input","graph_input_node","init_connections_controller_inputs","containers","existing_input_indices","eval_required_input","input_error_message","input_index_or_name","has_named_inputs","get_named_input_index","output_index_or_name","get_input_index","has_named_outputs","cp","old_input_node","old_connection","inputConnection","_run_on_set_input_hooks","INPUTS_UPDATED","input_name","initInputsClonedState","overrideClonedState","cloneRequiredState","_has_outputs","_has_named_outputs","get_named_output_index","_named_output_connection_points","NAMED_OUTPUTS_UPDATED","connections_controller","output_indices","used_output_indices","used_output_names","_output_connections","_input_connections","all_connections_after_are_undefined","connections_by_id","list","SavedConnectionPointsDataController","_in","_out","JsConnectionPointType","JsConnectionPointTypeToParamTypeMap","JsParamTypeToConnectionPointTypeMap","JsConnectionPointInitValueMap","DEFAULT_CONNECTION_POINT_ENUM_MAP","Event","BASE","Gl","create_connection_point","_raw_input_serialized_by_param_name","_default_value_serialized_by_param_name","_initialized","onParamsCreated","create_inputs_from_params","connection_type_map","param_type_to_connection_point_type_map","add_input","_inputless_param_names","connection_type","setNamedInputConnectionPoints","isLoading","spare_names","params_update_options","rawInputSerialized","defaultValueSerialized","param_type","last_param_init_value","default_value_from_name","param_default_value","fill","ObjectUtils","spare","update_params","spare_param","_create_spare_params_from_inputs","_functions_overridden","_input_name_function","_output_name_function","_expected_input_types_function","first_input_connection_type","default_connection_type","_expected_output_types_function","_update_signature_if_required_bound","update_signature_if_required","_spare_params_controller","func","_initialize_if_required","_wrapped_input_name_function","_wrapped_output_name_function","add_on_set_input_hook","addOnSceneLoadHook","initialized","dirty_trigger","_connections_match_inputs","update_connection_types","make_successors_update_signatures","subnet_inputs","INPUT","subnet_outputs","OUTPUT","subnet_input","subnet_output","has_connection_points_controller","expected_input_types","_wrapped_expected_input_types_function","expected_output_types","_wrapped_expected_output_types_function","point","named_output_connect_points","setNamedOutputConnectionPoints","create_spare_parameters","current_input_types","c","current_output_types","in_data","saved_connection_points_data","in","d","out_data","out","input_connection_type","src_connection_point","_connections","_outputs","_connection_points","_saved_connection_points_data","ParamsAccessor","non_spare","other_param","copy_value","_parent_controller","_children_controller_context","_children_controller","_create_children_controller","_ui_data","_states","_lifecycle","_serializer","_cook_controller","_io","_name_controller","_params_controller","displayNodeController","initializeBaseNode","polyNodeController","createNode","create_operation_container","event_name","dispatchController","dispatch","serializer","BaseFlag","_state","_hooks","new_state","_on_update","runHooks","FLAG_BYPASS_UPDATED","FLAG_DISPLAY_UPDATED","FLAG_OPTIMIZE_UPDATED","FlagsController","Display","Base","Bypass","Optimize","FlagsControllerD","FlagsControllerBO","FlagsControllerDBO","ParamTemplate","ParamConfig","DEFAULT_VALUE","NodeParamsConfig","ATTRIB_NAMES","ComponentName","COMPONENT_INDICES","_core_geometry","_geometry","matrix","applyMatrix4","remapped_name","hasAttrib","target","component_name","component_index","remaped_name","isAttribIndexed","indexedAttribValue","start_index","value_index","attribValueIndex","userDataAttrib","_findPosition","setAttribValueVector3","_normal","new_normal","attrib_size","v2","col","v3","new_value_index","_points","_get_points","points","index_array","_positions","_get_positions","_triangle","_get_triangle","positions","Triangle","_deltas","_get_deltas","sub","triangle","getArea","seed","weights","randFloat","deltas","multiplyScalar","barycentric_coordinates","getBarycoord","point_values","attribValue","new_attrib_value","point_value","weighted_value","face","intersect_point","point_indices","position_attrib_array","point_positions","point_index","attrib_array","attrib_values","dist_to_points","distanceTo","distance_total","point_indx","_filter_points","BufferGeometry","core_geometry","first_point","old_geometry","old_core_geometry","new_index_by_old_index","_indices_from_points","userDataAttribs","new_values","new_index_by_value","new_value","new_attrib_indices","new_index","setAttribute","BufferGeometryUtils","computeTangents","mergeBufferGeometries","geometries","useGroups","isIndexed","attributesUsed","morphAttributesUsed","morphAttributes","morphTargetsRelative","mergedGeometry","attributesCount","mergedUserData","addGroup","indexOffset","mergedIndex","j","getX","mergedAttribute","mergeBufferAttributes","numMorphTargets","morphAttributesToMerge","mergedMorphAttribute","TypedArray","normalized","arrayLength","attribute","isInterleavedBufferAttribute","BufferAttribute","interleaveAttributes","stride","l","interleavedBuffer","InterleavedBuffer","res","getters","setters","iba","InterleavedBufferAttribute","k","estimateBytesUsed","mem","attr","BYTES_PER_ELEMENT","getIndex","mergeVertices","tolerance","Number","EPSILON","hashToIndex","vertexCount","nextIndex","attributeNames","attrArrays","morphAttrsArrays","newIndices","morphAttr","decimalShift","log10","shiftMultiplier","hash","newarray","newMorphArrays","getterFunc","m","ml","oldAttribute","buffer","oldMorphAttribute","morphAttribute","toTrianglesDrawMode","drawMode","numberOfTriangles","newGeometry","clearGroups","computeMorphedAttributes","isBufferGeometry","_vA","_vB","_vC","_tempA","_tempB","_tempC","_morphA","_morphB","_morphC","_calculateMorphedAttributeData","modifiedAttributeArray","fromBufferAttribute","morphInfluences","morphTargetInfluences","morphTargets","il","influence","addScaledVector","isSkinnedMesh","boneTransform","jl","group","groupMaterial","positionAttribute","morphPosition","normalAttribute","normal","morphNormal","groups","drawRange","modifiedPosition","Float32Array","modifiedNormal","materialIndex","morphedPositionAttribute","morphedNormalAttribute","uuid","_bounding_box","_create_bounding_box","computeBoundingBox","markedAsInstance","computeVertexNormals","masks_string","matching_attrib_names","h","setIndexedAttributeValues","attribute_added","vec2","vec3","vec4","points_count","attrib_data","addNumericAttrib","old_name","old_attrib","deleteAttribute","src_geometry","src_userData","new_geometry","position_attrib_name","pointsFromGeometry","position_attrib","positionAttribName","object_type","_mesh_builder","from_points","_points_builder","_lines_segment_builder","create_index_if_none","core_geometries","indexed_attribute_names","indexedAttributeNames","new_values_by_attribute_name","indexed_attribute_name","index_by_values","all_geometries_points","geometry_points","setAttribIndex","merged_geometry","merged_core_geometry","merge","chunk","facesFromGeometry","faces_count","points_by_index","filtered_points","index_length","pt0","pt1","pt2","index_attrib","old_indices","new_indices","old_index0","old_index1","old_index2","new_index0","new_index1","new_index2","old_index","EmitController","_blocked_emit","_blocked_parent_emit","_count_by_event_name","emitAllowed","blockEmit","unblockEmit","event","ParamSerializer","rawInput","value_pre_conversion","is_visible","valuePreConversionSerialized","hasExpression","TimeDependentState","frame_graph_node_id","graphPredecessorIds","TYPED_PARAM_DEFAULT_COMPONENT_NAMES","_emit_controller","_is_computing","initialize_param","_copy_value","other_raw_input","are_raw_input_equal","other_val","are_values_equal","_clone_raw_input","_prefilter_invalid_raw_input","RAW_INPUT_UPDATED","processRawInput","_compute_resolves","process_computation","allowCallback","makes_node_dirty_when_dirty","params_node","_parent_param","nodeRelativePath","relativePath","incrementCount","_components","componentNames","new_element","element_to_remove","unshift","new_elements","EventConnectionPointType","EventConnectionPoint","_event_listener","RAD_DEG_RATIO","CoreMath","dest_min","dest_max","fit","src_min","src_max","num0","num1","blend","degrees","radians","deg","degrees_to_radians","rad","radians_to_degrees","randVec2","step_size","steps_count","ceil","_vec","uv","sn","fract","lnglat1","lnglat2","d1","deg2rad","lat","d2","ad1","ad2","lng","cos","atan2","sqrt","margin","getMidpoint","_triangle_mid","_triangle_mid_to_corner","normalize","object0","object1","isObject","keys0","keys1","JSON","stringify","TypedMultipleParam","_components_contructor","isDefault","src_component","default_val","set_parent_param","compute_components","set_value_from_components","number_or_string","block","blockParentEmit","prev_value","component_value","unblock","unblockParentEmit","CoreType","CoreObject","_object","geo","coreGeometry","groupString","attribNameWithPrefix","attribName","_convert_array_to_vector","user_data","addAttribute","current_value","stringAttribValue","attribSizeFromValue","src_object","new_object","sourceLookup","cloneLookup","parallelTraverse","sourceNode","clonedNode","traverse","src_node","mesh_node","src_node_geometry","mesh_node_geometry","apply_custom_materials","material_with_color","src_node_with_animations","animations","animation","skinned_node","clonedMesh","sourceMesh","sourceBones","skeleton","bones","bindMatrix","new_bones","bone","RampInterpolation","RampPoint","other_point","json","json1","json2","_interpolation","LINEAR","_uuid","MathUtils","generateUUID","json_point","from_json","interpolation","ramp","current_point","other_ramp_value","other_points","is_equal","is_equal_json","point1","point2","are_equal_json","_texture_data","Uint8Array","_ramp_texture","DataTexture","are_json_equal","_reset_ramp_interpolant","_update_ramp_texture","_ramp_interpolant","_update_ramp_texture_data","ramp_texture","TEXTURE_WIDTH","value_at_position","interpolated_values","CubicInterpolant","_create_interpolant","sorted_points","sortBy","sorted_point","create_interpolant","interpolant","evaluate","NetworkNodeType","NetworkChildNodeType","CameraNodeType","GlNodeType","CameraControlsNodeType","CAMERA_CONTROLS_NODE_TYPES","DEVICE_ORIENTATION","MAP","ORBIT","FIRST_PERSON","DecomposedPath","_path_elements","_named_nodes","_graph_node_ids","_node_element_by_graph_node_id","path_element","node_name","joined_path","first_char","webpackPolyfill","deprecate","paths","enumerable","CustomMaterialName","EMPTY_RENDER_HOOK","camera","CoreMaterial","src_material","cloned_material","src_uniforms","uniforms","render_hook","onBeforeRender","material_with_custom","custom_materials","mat_name","custom_material","mat","uniform_name","uniform_value","TypedNumericParam","_update_value","ColorConversion"],"mappings":"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","file":"vendors~PolyRegister~SceneJsonImporter.bundle.fda87c5a7877e101b399.js","sourcesContent":["import {BaseParamType, TypedParam} from './_Base';\nimport {BaseNodeType} from '../nodes/_Base';\nimport {ParamType} from '../poly/ParamType';\nimport {DecomposedPath} from '../../core/DecomposedPath';\n\nexport abstract class TypedPathParam<T extends ParamType> extends TypedParam<T> {\n\tpublic readonly decomposed_path = new DecomposedPath();\n\n\tabstract notify_path_rebuild_required(node: BaseNodeType | BaseParamType): void;\n\tabstract notify_target_param_owner_params_updated(node: BaseNodeType | BaseParamType): void;\n}\n","import {ParamInitValuesTypeMap} from '../../../../params/types/ParamInitValuesTypeMap';\n\nimport {ParamType} from '../../../../poly/ParamType';\nimport {RampParam} from '../../../../params/Ramp';\n// import {BaseTypedConnection} from './_Base';\n\n// TODO: simplify GLDataType into one enum\n// http://learnwebgl.brown37.net/12_shader_language/glsl_data_types.html\n\n//\n//\n// GL Data types\n//\n//\n\nexport enum GlConnectionPointType {\n\tBOOL = 'bool',\n\t// BVEC2 = 'bvec2',\n\t// BVEC3 = 'bvec3',\n\t// BVEC4 = 'bvec4',\n\tINT = 'int',\n\t// IVEC2 = 'ivec2',\n\t// IVEC3 = 'ivec3',\n\t// IVEC4 = 'ivec4',\n\tFLOAT = 'float',\n\tVEC2 = 'vec2',\n\tVEC3 = 'vec3',\n\tVEC4 = 'vec4',\n\t// matrices to be used later\n\t// MAT2 = 'mat2',\n\t// MAT3 = 'mat3',\n\t// MAT4 = 'mat4',\n\tSAMPLER_2D = 'sampler2D',\n}\n// interface IGlConnectionPointType {\n// \t[EnumGlConnectionPointType.BOOL]: Readonly<'bool'>;\n// \t// BVEC2 = 'bvec2',\n// \t// BVEC3 = 'bvec3',\n// \t// BVEC4 = 'bvec4',\n// \t[EnumGlConnectionPointType.INT]: Readonly<'int'>;\n// \t// IVEC2 = 'ivec2',\n// \t// IVEC3 = 'ivec3',\n// \t// IVEC4 = 'ivec4',\n// \t[EnumGlConnectionPointType.FLOAT]: Readonly<'float'>;\n// \t[EnumGlConnectionPointType.VEC2]: Readonly<'vec2'>;\n// \t[EnumGlConnectionPointType.VEC3]: Readonly<'vec3'>;\n// \t[EnumGlConnectionPointType.VEC4]: Readonly<'vec4'>;\n// \t// matrices to be used later\n// \t// MAT2 = 'mat2',\n// \t// MAT3 = 'mat3',\n// \t// MAT4 = 'mat4',\n// \t[EnumGlConnectionPointType.SAMPLER_2D]: Readonly<'sampler2D'>;\n// }\n\n// export const GlConnectionPointType: IGlConnectionPointType = {\n// \t[EnumGlConnectionPointType.BOOL]: 'bool',\n// \t// BVEC2 = 'bvec2',\n// \t// BVEC3 = 'bvec3',\n// \t// BVEC4 = 'bvec4',\n// \t[EnumGlConnectionPointType.INT]: 'int',\n// \t// IVEC2 = 'ivec2',\n// \t// IVEC3 = 'ivec3',\n// \t// IVEC4 = 'ivec4',\n// \t[EnumGlConnectionPointType.FLOAT]: 'float',\n// \t[EnumGlConnectionPointType.VEC2]: 'vec2',\n// \t[EnumGlConnectionPointType.VEC3]: 'vec3',\n// \t[EnumGlConnectionPointType.VEC4]: 'vec4',\n// \t// matrices to be used later\n// \t// MAT2 = 'mat2',\n// \t// MAT3 = 'mat3',\n// \t// MAT4 = 'mat4',\n// \t[EnumGlConnectionPointType.SAMPLER_2D]: 'sampler2D',\n// };\n\n//\n//\n// ALL GL Data types in an array\n//\n//\nexport const GL_CONNECTION_POINT_TYPES: Array<GlConnectionPointType> = [\n\tGlConnectionPointType.BOOL,\n\t// ConnectionPointType.BVEC2,\n\t// ConnectionPointType.BVEC3,\n\t// ConnectionPointType.BVEC4,\n\tGlConnectionPointType.INT,\n\t// ConnectionPointType.IVEC2,\n\t// ConnectionPointType.IVEC3,\n\t// ConnectionPointType.IVEC4,\n\tGlConnectionPointType.FLOAT,\n\tGlConnectionPointType.VEC2,\n\tGlConnectionPointType.VEC3,\n\tGlConnectionPointType.VEC4,\n];\n\n//\n//\n// Map to convert from a GL Data type to a ParamType\n//\n//\ntype ConnectionPointTypeToParamTypeMapGeneric = {[key in GlConnectionPointType]: ParamType};\nexport interface IConnectionPointTypeToParamTypeMap extends ConnectionPointTypeToParamTypeMapGeneric {\n\t[GlConnectionPointType.BOOL]: ParamType.BOOLEAN;\n\t// [ConnectionPointType.BVEC2]: [ParamType.BOOLEAN, ParamType.BOOLEAN]\n\t// [ConnectionPointType.BVEC3]: [ParamType.BOOLEAN, ParamType.BOOLEAN, ParamType.BOOLEAN]\n\t// [ConnectionPointType.BVEC4]: [ParamType.BOOLEAN, ParamType.BOOLEAN, ParamType.BOOLEAN, ParamType.BOOLEAN]\n\t[GlConnectionPointType.INT]: ParamType.INTEGER;\n\t// [ConnectionPointType.IVEC2]: [ParamType.INTEGER, ParamType.INTEGER];\n\t// [ConnectionPointType.IVEC3]: [ParamType.INTEGER, ParamType.INTEGER, ParamType.INTEGER];\n\t// [ConnectionPointType.IVEC4]: [ParamType.INTEGER, ParamType.INTEGER, ParamType.INTEGER, ParamType.INTEGER];\n\t[GlConnectionPointType.FLOAT]: ParamType.FLOAT;\n\t[GlConnectionPointType.VEC2]: ParamType.VECTOR2;\n\t[GlConnectionPointType.VEC3]: ParamType.VECTOR3;\n\t[GlConnectionPointType.VEC4]: ParamType.VECTOR4;\n}\nexport const GlConnectionPointTypeToParamTypeMap: IConnectionPointTypeToParamTypeMap = {\n\t[GlConnectionPointType.BOOL]: ParamType.BOOLEAN,\n\t// [ConnectionPointType.BVEC2]: [ParamType.BOOLEAN, ParamType.BOOLEAN]\n\t// [ConnectionPointType.BVEC3]: [ParamType.BOOLEAN, ParamType.BOOLEAN, ParamType.BOOLEAN]\n\t// [ConnectionPointType.BVEC4]: [ParamType.BOOLEAN, ParamType.BOOLEAN, ParamType.BOOLEAN, ParamType.BOOLEAN]\n\t[GlConnectionPointType.INT]: ParamType.INTEGER,\n\t// [ConnectionPointType.IVEC2]: [ParamType.INTEGER, ParamType.INTEGER];\n\t// [ConnectionPointType.IVEC3]: [ParamType.INTEGER, ParamType.INTEGER, ParamType.INTEGER];\n\t// [ConnectionPointType.IVEC4]: [ParamType.INTEGER, ParamType.INTEGER, ParamType.INTEGER, ParamType.INTEGER];\n\t[GlConnectionPointType.FLOAT]: ParamType.FLOAT,\n\t[GlConnectionPointType.VEC2]: ParamType.VECTOR2,\n\t[GlConnectionPointType.VEC3]: ParamType.VECTOR3,\n\t[GlConnectionPointType.VEC4]: ParamType.VECTOR4,\n\n\t[GlConnectionPointType.SAMPLER_2D]: ParamType.RAMP,\n};\n\n//\n//\n// Map to convert from a ParamType to GL Data type\n//\n//\ntype GLParamTypeToConnectionPointTypeMapGeneric = {[key in ParamType]: GlConnectionPointType | undefined};\nexport interface IGLParamTypeToConnectionPointTypeMap extends GLParamTypeToConnectionPointTypeMapGeneric {\n\t[ParamType.BOOLEAN]: GlConnectionPointType.BOOL;\n\t[ParamType.COLOR]: GlConnectionPointType.VEC3;\n\t// [ConnectionPointType.BVEC2]: [ParamType.BOOLEAN, ParamType.BOOLEAN]\n\t// [ConnectionPointType.BVEC3]: [ParamType.BOOLEAN, ParamType.BOOLEAN, ParamType.BOOLEAN]\n\t// [ConnectionPointType.BVEC4]: [ParamType.BOOLEAN, ParamType.BOOLEAN, ParamType.BOOLEAN, ParamType.BOOLEAN]\n\t[ParamType.INTEGER]: GlConnectionPointType.INT;\n\t// [ConnectionPointType.IVEC2]: [ParamType.INTEGER, ParamType.INTEGER];\n\t// [ConnectionPointType.IVEC3]: [ParamType.INTEGER, ParamType.INTEGER, ParamType.INTEGER];\n\t// [ConnectionPointType.IVEC4]: [ParamType.INTEGER, ParamType.INTEGER, ParamType.INTEGER, ParamType.INTEGER];\n\t[ParamType.FLOAT]: GlConnectionPointType.FLOAT;\n\t[ParamType.FOLDER]: undefined;\n\t[ParamType.VECTOR2]: GlConnectionPointType.VEC2;\n\t[ParamType.VECTOR3]: GlConnectionPointType.VEC3;\n\t[ParamType.VECTOR4]: GlConnectionPointType.VEC4;\n\t[ParamType.BUTTON]: undefined;\n\t[ParamType.OPERATOR_PATH]: undefined;\n\t[ParamType.NODE_PATH]: undefined;\n\t[ParamType.PARAM_PATH]: undefined;\n\t[ParamType.RAMP]: undefined;\n\t[ParamType.SEPARATOR]: undefined;\n\t[ParamType.STRING]: undefined;\n}\nexport const GLParamTypeToConnectionPointTypeMap: IGLParamTypeToConnectionPointTypeMap = {\n\t[ParamType.BOOLEAN]: GlConnectionPointType.BOOL,\n\t[ParamType.COLOR]: GlConnectionPointType.VEC3,\n\t// [ConnectionPointType.BVEC2]: [ParamType.BOOLEAN, ParamType.BOOLEAN]\n\t// [ConnectionPointType.BVEC3]: [ParamType.BOOLEAN, ParamType.BOOLEAN, ParamType.BOOLEAN]\n\t// [ConnectionPointType.BVEC4]: [ParamType.BOOLEAN, ParamType.BOOLEAN, ParamType.BOOLEAN, ParamType.BOOLEAN]\n\t[ParamType.INTEGER]: GlConnectionPointType.INT,\n\t// [ConnectionPointType.IVEC2]: [ParamType.INTEGER, ParamType.INTEGER];\n\t// [ConnectionPointType.IVEC3]: [ParamType.INTEGER, ParamType.INTEGER, ParamType.INTEGER];\n\t// [ConnectionPointType.IVEC4]: [ParamType.INTEGER, ParamType.INTEGER, ParamType.INTEGER, ParamType.INTEGER];\n\t[ParamType.FLOAT]: GlConnectionPointType.FLOAT,\n\t[ParamType.FOLDER]: undefined,\n\t[ParamType.VECTOR2]: GlConnectionPointType.VEC2,\n\t[ParamType.VECTOR3]: GlConnectionPointType.VEC3,\n\t[ParamType.VECTOR4]: GlConnectionPointType.VEC4,\n\t[ParamType.BUTTON]: undefined,\n\t[ParamType.OPERATOR_PATH]: undefined,\n\t[ParamType.PARAM_PATH]: undefined,\n\t[ParamType.NODE_PATH]: undefined,\n\t[ParamType.RAMP]: undefined,\n\t[ParamType.SEPARATOR]: undefined,\n\t[ParamType.STRING]: undefined,\n};\n\n//\n//\n// Map of GL Data type default values\n//\n//\nexport type ConnectionPointInitValueMapGeneric = {\n\t[key in GlConnectionPointType]: ParamInitValuesTypeMap[IConnectionPointTypeToParamTypeMap[key]];\n};\nexport const GlConnectionPointInitValueMap: ConnectionPointInitValueMapGeneric = {\n\t[GlConnectionPointType.BOOL]: false,\n\t// [ConnectionPointType.BVEC2]: [ParamType.BOOLEAN, ParamType.BOOLEAN]\n\t// [ConnectionPointType.BVEC3]: [ParamType.BOOLEAN, ParamType.BOOLEAN, ParamType.BOOLEAN]\n\t// [ConnectionPointType.BVEC4]: [ParamType.BOOLEAN, ParamType.BOOLEAN, ParamType.BOOLEAN, ParamType.BOOLEAN]\n\t[GlConnectionPointType.INT]: 0,\n\t// [ConnectionPointType.IVEC2]: [ParamType.INTEGER, ParamType.INTEGER];\n\t// [ConnectionPointType.IVEC3]: [ParamType.INTEGER, ParamType.INTEGER, ParamType.INTEGER];\n\t// [ConnectionPointType.IVEC4]: [ParamType.INTEGER, ParamType.INTEGER, ParamType.INTEGER, ParamType.INTEGER];\n\t[GlConnectionPointType.FLOAT]: 0,\n\t[GlConnectionPointType.VEC2]: [0, 0],\n\t[GlConnectionPointType.VEC3]: [0, 0, 0],\n\t[GlConnectionPointType.VEC4]: [0, 0, 0, 0],\n\n\t[GlConnectionPointType.SAMPLER_2D]: RampParam.DEFAULT_VALUE_JSON,\n};\n\n//\n//\n// Map of GL Data type component counts\n//\n//\nexport type ConnectionPointComponentsCountMapGeneric = {\n\t[key in GlConnectionPointType]: number;\n};\nexport const GlConnectionPointComponentsCountMap: ConnectionPointComponentsCountMapGeneric = {\n\t[GlConnectionPointType.BOOL]: 1,\n\t// [ConnectionPointType.BVEC2]: [ParamType.BOOLEAN, ParamType.BOOLEAN]\n\t// [ConnectionPointType.BVEC3]: [ParamType.BOOLEAN, ParamType.BOOLEAN, ParamType.BOOLEAN]\n\t// [ConnectionPointType.BVEC4]: [ParamType.BOOLEAN, ParamType.BOOLEAN, ParamType.BOOLEAN, ParamType.BOOLEAN]\n\t[GlConnectionPointType.INT]: 1,\n\t// [ConnectionPointType.IVEC2]: [ParamType.INTEGER, ParamType.INTEGER];\n\t// [ConnectionPointType.IVEC3]: [ParamType.INTEGER, ParamType.INTEGER, ParamType.INTEGER];\n\t// [ConnectionPointType.IVEC4]: [ParamType.INTEGER, ParamType.INTEGER, ParamType.INTEGER, ParamType.INTEGER];\n\t[GlConnectionPointType.FLOAT]: 1,\n\t[GlConnectionPointType.VEC2]: 2,\n\t[GlConnectionPointType.VEC3]: 3,\n\t[GlConnectionPointType.VEC4]: 4,\n\t[GlConnectionPointType.SAMPLER_2D]: 1,\n};\n\n// import {\n// ConnectionPointType,\n// ConnectionPointInitValueMapGeneric,\n// ConnectionPointInitValueMap,\n// ConnectionPointTypeToParamTypeMap,\n// IConnectionPointTypeToParamTypeMap,\n// } from '../ConnectionPointType';\n// import {ParamInitValuesTypeMap} from '../params/ParamsController';\n\nexport interface GlConnectionPointData<T extends GlConnectionPointType> {\n\tname: string;\n\ttype: T;\n}\n\nimport {BaseConnectionPoint} from './_Base';\nexport class GlConnectionPoint<T extends GlConnectionPointType> extends BaseConnectionPoint {\n\tprotected _json: GlConnectionPointData<T> | undefined;\n\t// protected _init_value: any;\n\n\tconstructor(\n\t\tprotected _name: string,\n\t\tprotected _type: T,\n\t\tprotected _init_value?: ConnectionPointInitValueMapGeneric[T]\n\t) {\n\t\tsuper(_name, _type);\n\t\t// if (this._init_value === undefined) {\n\t\tthis._init_value = this._init_value || GlConnectionPointInitValueMap[this._type];\n\t\t// }\n\t}\n\ttype() {\n\t\treturn this._type;\n\t}\n\tare_types_matched(src_type: string, dest_type: string): boolean {\n\t\treturn src_type == dest_type;\n\t}\n\tget param_type(): IConnectionPointTypeToParamTypeMap[T] {\n\t\treturn GlConnectionPointTypeToParamTypeMap[this._type];\n\t}\n\tget init_value() {\n\t\treturn this._init_value;\n\t}\n\n\ttoJSON(): GlConnectionPointData<T> {\n\t\treturn (this._json = this._json || this._create_json());\n\t}\n\tprotected _create_json(): GlConnectionPointData<T> {\n\t\treturn {\n\t\t\tname: this._name,\n\t\t\ttype: this._type,\n\t\t};\n\t}\n}\n\nexport type BaseGlConnectionPoint = GlConnectionPoint<GlConnectionPointType>;\n","// import {\n// \tConnectionPointType,\n// \tConnectionPointInitValueMapGeneric,\n// \tConnectionPointInitValueMap,\n// \tConnectionPointTypeToParamTypeMap,\n// \tIConnectionPointTypeToParamTypeMap,\n// } from '../ConnectionPointType';\n// import {ParamInitValuesTypeMap} from '../params/ParamsController';\n\nimport {ParamType} from '../../../../poly/ParamType';\n\nexport interface BaseConnectionPointData {\n\tname: string;\n\ttype: string;\n}\n\nexport abstract class BaseConnectionPoint {\n\tprotected _json: BaseConnectionPointData | undefined;\n\t// protected _init_value: any;\n\n\tconstructor(protected _name: string, protected _type: string, protected _init_value?: any) {\n\t\t// if (this._init_value === undefined) {\n\t\t// this._init_value = ConnectionPointInitValueMap[this._type];\n\t\t// }\n\t}\n\tget init_value() {\n\t\treturn this._init_value;\n\t}\n\tname() {\n\t\treturn this._name;\n\t}\n\ttype() {\n\t\treturn this._type;\n\t}\n\tare_types_matched(src_type: string, dest_type: string): boolean {\n\t\treturn true;\n\t}\n\tabstract get param_type(): ParamType;\n\t// get param_type(): IConnectionPointTypeToParamTypeMap[T] {\n\t// \treturn ConnectionPointTypeToParamTypeMap[this._type];\n\t// }\n\t// get init_value() {\n\t// \treturn this._init_value;\n\t// }\n\n\ttoJSON(): BaseConnectionPointData {\n\t\treturn (this._json = this._json || this._create_json());\n\t}\n\tprotected _create_json(): BaseConnectionPointData {\n\t\treturn {\n\t\t\tname: this._name,\n\t\t\ttype: this._type,\n\t\t};\n\t}\n}\n\n// export type BaseNamedConnectionPointType = TypedNamedConnectionPoint<ConnectionPointType>;\n","import {NodeContext} from '../../engine/poly/NodeContext';\nimport {ParamType} from '../../engine/poly/ParamType';\nimport {ParamValuesTypeMap} from '../../engine/params/types/ParamValuesTypeMap';\nimport {StatesController} from '../../engine/nodes/utils/StatesController';\nimport {PolyScene} from '../../engine/scene/PolyScene';\nimport {InputCloneMode} from '../../engine/poly/InputCloneMode';\nimport {PolyDictionary} from '../../types/GlobalTypes';\n\nexport type DefaultOperationParam<T extends ParamType> = ParamValuesTypeMap[T];\nexport type DefaultOperationParams = PolyDictionary<DefaultOperationParam<ParamType>>;\n\nexport const OPERATIONS_COMPOSER_NODE_TYPE: Readonly<string> = 'operationsComposer';\n\nexport class BaseOperation {\n\tstatic type(): string {\n\t\tthrow 'type to be overriden';\n\t}\n\ttype() {\n\t\tconst c = this.constructor as typeof BaseOperation;\n\t\treturn c.type();\n\t}\n\tstatic context(): NodeContext {\n\t\tconsole.error('operation has no node_context', this);\n\t\tthrow 'context requires override';\n\t}\n\tcontext(): NodeContext {\n\t\tconst c = this.constructor as typeof BaseOperation;\n\t\treturn c.context();\n\t}\n\n\tstatic readonly DEFAULT_PARAMS: DefaultOperationParams = {};\n\tstatic readonly INPUT_CLONED_STATE: InputCloneMode | InputCloneMode[] = [];\n\n\tconstructor(protected scene: PolyScene, protected states?: StatesController) {}\n\n\tcook(input_contents: any[], params: object): any {}\n}\n","export enum ParamType {\n\tBOOLEAN = 'boolean',\n\tBUTTON = 'button',\n\tCOLOR = 'color',\n\tFLOAT = 'float',\n\tFOLDER = 'folder',\n\tINTEGER = 'integer',\n\tOPERATOR_PATH = 'operator_path',\n\tPARAM_PATH = 'param_path',\n\tNODE_PATH = 'node_path',\n\tRAMP = 'ramp',\n\tSEPARATOR = 'separator',\n\tSTRING = 'string',\n\tVECTOR2 = 'vector2',\n\tVECTOR3 = 'vector3',\n\tVECTOR4 = 'vector4',\n}\n// export type ParamTypeKey = ParamType\n// export type ParamTypeKeysArray = Array<ParamTypeKey>\n// const ParamTypeKeysArray: ParamTypeKeysArray = [ParamType.BOOLEAN]\n","export enum ModuleName {\n\tBasisTextureLoader = 'BasisTextureLoader',\n\tDRACOLoader = 'DRACOLoader',\n\tEXRLoader = 'EXRLoader',\n\tFBXLoader = 'FBXLoader',\n\tGLTFLoader = 'GLTFLoader',\n\tOBJLoader = 'OBJLoader',\n\tPDBLoader = 'PDBLoader',\n\tPLYLoader = 'PLYLoader',\n\tRGBELoader = 'RGBELoader',\n\tSVGLoader = 'SVGLoader',\n\tSTLLoader = 'STLLoader',\n\tTTFLoader = 'TTFLoader',\n}\n\nexport class BaseModulesRegister {\n\tprivate _loaded_module_by_name: Map<ModuleName, any> = new Map();\n\tprivate _promise_by_name: Map<ModuleName, Promise<object>> = new Map();\n\n\tregister(name: ModuleName, promise: Promise<object>) {\n\t\tthis._promise_by_name.set(name, promise);\n\t}\n\n\tasync module(name: ModuleName) {\n\t\tconst loaded_module = this._loaded_module_by_name.get(name);\n\t\tif (loaded_module) {\n\t\t\treturn loaded_module;\n\t\t} else {\n\t\t\tconst promise = this._promise_by_name.get(name);\n\t\t\tif (promise) {\n\t\t\t\tconst new_loaded_module = await promise;\n\t\t\t\tif (new_loaded_module) {\n\t\t\t\t\tthis._loaded_module_by_name.set(name, new_loaded_module);\n\t\t\t\t\treturn new_loaded_module;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconsole.warn(`module ${name} not registered`);\n\t\t\t}\n\t\t}\n\t}\n}\n","// import {BaseNodeType} from '../../../nodes/_Base';\n\nexport enum AssemblerName {\n\tGL_MESH_BASIC = 'GL_MESH_BASIC',\n\tGL_MESH_LAMBERT = 'GL_MESH_LAMBERT',\n\tGL_MESH_STANDARD = 'GL_MESH_STANDARD',\n\tGL_PARTICLES = 'GL_PARTICLES',\n\tGL_POINTS = 'GL_POINTS',\n\tGL_TEXTURE = 'GL_TEXTURE',\n\tGL_VOLUME = 'GL_VOLUME',\n}\n\nexport interface ControllerAssemblerPair {\n\tcontroller: any;\n\tassembler: any;\n}\n\nexport class BaseAssemblersRegister {\n\tprotected _controller_assembler_by_name: Map<AssemblerName, ControllerAssemblerPair> = new Map();\n\n\tregister(name: AssemblerName, controller: any, assembler: any) {\n\t\tthis._controller_assembler_by_name.set(name, {\n\t\t\tcontroller: controller,\n\t\t\tassembler: assembler,\n\t\t});\n\t}\n\n\tunregister(name: AssemblerName) {\n\t\tthis._controller_assembler_by_name.delete(name);\n\t}\n}\n","import {DecomposedPath} from '../../core/DecomposedPath';\nimport {CoreGraphNode} from '../../core/graph/CoreGraphNode';\nimport {BaseParamType} from '../params/_Base';\nimport {BaseNodeType} from '../nodes/_Base';\nimport jsep from 'jsep';\nimport {CoreType} from '../../core/Type';\n\nexport class MethodDependency extends CoreGraphNode {\n\tpublic jsep_node: jsep.Expression | undefined;\n\tpublic resolved_graph_node: CoreGraphNode | undefined;\n\tpublic unresolved_path: string | undefined;\n\tprivate _update_from_name_change_bound = this._update_from_name_change.bind(this);\n\n\tconstructor(\n\t\tpublic param: BaseParamType,\n\t\tpublic path_argument: number | string,\n\t\tpublic decomposed_path?: DecomposedPath\n\t) {\n\t\tsuper(param.scene(), 'MethodDependency');\n\n\t\tparam.expressionController?.registerMethodDependency(this);\n\n\t\tthis.addPostDirtyHook('_update_from_name_change', this._update_from_name_change_bound);\n\t}\n\t_update_from_name_change(trigger?: CoreGraphNode) {\n\t\tif (trigger && this.decomposed_path) {\n\t\t\tconst node = trigger as BaseNodeType;\n\t\t\tthis.decomposed_path.update_from_name_change(node);\n\t\t\tconst new_path = this.decomposed_path.to_path();\n\n\t\t\tconst literal = this.jsep_node as jsep.Literal;\n\t\t\tif (literal) {\n\t\t\t\tliteral.value = `${literal.value}`.replace(`${this.path_argument}`, new_path);\n\t\t\t\tliteral.raw = literal.raw.replace(`${this.path_argument}`, new_path);\n\t\t\t}\n\t\t\tif (this.param.expressionController) {\n\t\t\t\tthis.param.expressionController.update_from_method_dependency_name_change();\n\t\t\t}\n\t\t}\n\t}\n\treset() {\n\t\tthis.graphDisconnectPredecessors();\n\t}\n\n\tlisten_for_name_changes() {\n\t\tif (this.jsep_node && this.decomposed_path) {\n\t\t\tfor (let node_in_path of this.decomposed_path.named_nodes()) {\n\t\t\t\tif (node_in_path) {\n\t\t\t\t\tconst node = node_in_path as BaseNodeType;\n\t\t\t\t\tif (node.nameController) {\n\t\t\t\t\t\tthis.addGraphInput(node.nameController.graph_node);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tset_jsep_node(jsep_node: jsep.Expression) {\n\t\tthis.jsep_node = jsep_node;\n\t}\n\tset_resolved_graph_node(node: CoreGraphNode) {\n\t\tthis.resolved_graph_node = node;\n\t}\n\tset_unresolved_path(path: string) {\n\t\tthis.unresolved_path = path;\n\t}\n\n\tstatic create(\n\t\tparam: BaseParamType,\n\t\tindex_or_path: number | string,\n\t\tnode: CoreGraphNode,\n\t\tdecomposed_path?: DecomposedPath\n\t) {\n\t\tconst is_index = CoreType.isNumber(index_or_path);\n\n\t\t// if(!decomposed_path){\n\t\t// \tconsole.log('nodes_in_path', decomposed_path.named_nodes);\n\t\t// \tfor (let node_in_path of decomposed_path.named_nodes) {\n\t\t// \t\tif (node_in_path) {\n\t\t// \t\t\tdecomposed_path.add_node(node_in_path.name, node_in_path);\n\t\t// \t\t}\n\t\t// \t}\n\t\t// }\n\n\t\tconst instance = new MethodDependency(param, index_or_path, decomposed_path);\n\t\tif (node) {\n\t\t\tinstance.set_resolved_graph_node(node);\n\t\t} else {\n\t\t\tif (!is_index) {\n\t\t\t\tconst path = index_or_path as string;\n\t\t\t\tinstance.set_unresolved_path(path);\n\t\t\t}\n\t\t}\n\t\treturn instance;\n\t}\n}\n","import {AttribValue} from '../../types/GlobalTypes';\nimport {Vector4} from 'three/src/math/Vector4';\nimport {Vector3} from 'three/src/math/Vector3';\nimport {Vector2} from 'three/src/math/Vector2';\nexport abstract class CoreEntity {\n\tconstructor(protected _index: number) {}\n\tindex() {\n\t\treturn this._index;\n\t}\n\n\tabstract attribValue(name: string, target?: Vector2 | Vector3 | Vector4): AttribValue | undefined;\n\tabstract stringAttribValue(name: string): string | undefined;\n}\n","// https://gist.github.com/gre/1650294\n\n// const ease_in = function(t:number, power:number){return Math.pow(t, power)}\n// const ease_on = function(t:number, power:number){return 1 - Math.abs(Math.pow(t-1, power))}\n// const ease_ion = function(t:number, power:number){return t<.5 ? ease_i(power)(t*2)/2 : ease_o(power)(t*2 - 1)/2+0.5}\n\nconst ease_i = function(power:number){return function(t:number){return Math.pow(t, power)}};\nconst ease_o = function(power:number){return function(t:number){return 1 - Math.abs(Math.pow(t-1, power))}};\nconst ease_io = function(power:number){return function(t:number){return t<.5 ? ease_i(power)(t*2)/2 : ease_o(power)(t*2 - 1)/2+0.5}}\n\nexport const Easing = {\n  linear: ease_io(1),\n\n  ease_i: function(t:number, power:number){ return ease_i(power)(t) },\n  ease_o: function(t:number, power:number){ return ease_o(power)(t) },\n  ease_io: function(t:number, power:number){ return ease_io(power)(t) },\n\n  ease_i2: ease_i(2),\n  ease_o2: ease_o(2),\n  ease_io2: ease_io(2),\n\n  ease_i3: ease_io(3),\n  ease_o3: ease_io(3),\n  ease_io3: ease_io(3),\n\n  ease_i4: ease_io(4),\n  ease_o4: ease_io(4),\n  ease_io4: ease_io(4),\n  // easeInQuart: EaseIn(4),\n  // easeOutQuart: EaseOut(4),\n  // easeInOutQuart: EaseInOut(4),\n  // easeInQuint: EaseIn(5),\n  // easeOutQuint: EaseOut(5),\n  // easeInOutQuint: EaseInOut(5)\n\n  ease_i_sin: function(t:number){ return 1 + Math.sin(Math.PI / 2 * t - Math.PI / 2); },\n  ease_o_sin: function(t:number){ return Math.sin(Math.PI / 2 * t); },\n  ease_io_sin: function(t:number){ return (1 + Math.sin(Math.PI * t - Math.PI / 2)) / 2; },\n\n  ease_i_elastic: function (t:number) { return (.04 - .04 / t) * Math.sin(25 * t) + 1 },\n  ease_o_elastic: function (t:number) { return .04 * t / (--t) * Math.sin(25 * t) },\n  ease_io_elastic: function (t:number) { return (t -= .5) < 0 ? (.02 + .01 / t) * Math.sin(50 * t) : (.02 - .01 / t) * Math.sin(50 * t) + 1 }\n}\n\n// export class Easing {\n//   // no easing, no acceleration\n//   static linear(t:number):number{ return t }\n//   // accelerating from zero velocity\n//   static easeinquad (t:number):number{ return t*t }\n//   // decelerating to zero velocity\n//   static easeoutquad (t:number):number{ return t*(2-t) }\n//   // acceleration until halfway, then deceleration\n//   static easeinoutquad (t:number):number{ return t<.5 ? 2*t*t : -1+(4-2*t)*t }\n//   // accelerating from zero velocity\n//   static easeincubic (t:number):number{ return t*t*t }\n//   // decelerating to zero velocity\n//   static easeoutcubic (t:number):number{ return (--t)*t*t+1 }\n//   // acceleration until halfway, then deceleration\n//   static easeinoutcubic (t:number):number{ return t<.5 ? 4*t*t*t : (t-1)*(2*t-2)*(2*t-2)+1 }\n//   // accelerating from zero velocity\n//   static easeinquart (t:number):number{ return t*t*t*t }\n//   // decelerating to zero velocity\n//   static easeoutquart (t:number):number{ return 1-(--t)*t*t*t }\n//   // acceleration until halfway, then deceleration\n//   static easeinoutquart (t:number):number{ return t<.5 ? 8*t*t*t*t : 1-8*(--t)*t*t*t }\n//   // accelerating from zero velocity\n//   static easeinquint (t:number):number{ return t*t*t*t*t }\n//   // decelerating to zero velocity\n//   static easeoutquint (t:number):number{ return 1+(--t)*t*t*t*t }\n//   // acceleration until halfway, then deceleration\n//   static easeinoutquint (t:number):number{ return t<.5 ? 16*t*t*t*t*t : 1+16*(--t)*t*t*t*t }\n// }","import {BufferGeometry} from 'three/src/core/BufferGeometry';\nimport { ArrayUtils } from '../../ArrayUtils';\n\nconst POSITION = 'position';\nexport class CoreGeometryIndexBuilder {\n\tstatic create_index_if_none(geometry: BufferGeometry) {\n\t\tif (!geometry.index) {\n\t\t\tconst position = geometry.getAttribute(POSITION);\n\t\t\tif (position) {\n\t\t\t\tconst position_array = position.array;\n\t\t\t\tgeometry.setIndex(ArrayUtils.range(position_array.length / 3));\n\t\t\t}\n\t\t}\n\t}\n}\n","export enum InputCloneMode {\n\tALWAYS = 'always',\n\tNEVER = 'never',\n\tFROM_NODE = 'from_node',\n}\n","import {BaseNodeType} from '../_Base';\nimport {NodeUIDataJson} from './UIData';\nimport {BaseConnectionPointData} from './io/connections/_Base';\nimport {CoreGraphNodeId} from '../../../core/graph/CoreGraph';\n\nexport interface NodeSerializerData {\n\tname: string;\n\ttype: string;\n\tgraph_node_id: CoreGraphNodeId;\n\tis_dirty: boolean;\n\tui_data_json: NodeUIDataJson;\n\terror_message: string | undefined;\n\tchildren: CoreGraphNodeId[];\n\tmaxInputsCount: number;\n\tinputs: Array<CoreGraphNodeId | undefined>;\n\tinput_connection_output_indices: Array<number | undefined> | undefined;\n\tnamed_input_connection_points: BaseConnectionPointData[];\n\tnamed_output_connection_points: BaseConnectionPointData[];\n\tparam_ids: CoreGraphNodeId[];\n\t// spare_params: PolyDictionary<string>;\n\toverride_cloned_state_allowed: boolean;\n\tinputs_clone_required_states: boolean | boolean[];\n\tflags?: {\n\t\t//has_display: this.has_display_flag()\n\t\tdisplay?: boolean;\n\t\tbypass?: boolean;\n\t\toptimize?: boolean;\n\t};\n\tselection?: CoreGraphNodeId[];\n}\n\nexport class NodeSerializer {\n\tconstructor(private node: BaseNodeType) {}\n\n\t// serialize() {\n\t// \treturn this.toJSON();\n\t// }\n\n\t// TODO: find a way to not re-create a json everytime\n\ttoJSON(include_param_components: boolean = false): NodeSerializerData {\n\t\t// const spare_params_json_by_name = {};\n\t\t// lodash_each(this.node.spare_param_names(), param_name=> {\n\t\t// \tconst param = this.node.spare_param(param_name);\n\t\t// \tspare_params_json_by_name[param_name] = param.graphNodeId();\n\t\t// });\n\n\t\tconst data: NodeSerializerData = {\n\t\t\tname: this.node.name(),\n\t\t\ttype: this.node.type(),\n\t\t\tgraph_node_id: this.node.graphNodeId(),\n\t\t\tis_dirty: this.node.isDirty(),\n\t\t\tui_data_json: this.node.uiData.toJSON(),\n\t\t\terror_message: this.node.states.error.message(),\n\t\t\tchildren: this.childrenIds(),\n\t\t\tmaxInputsCount: this.maxInputsCount(),\n\t\t\tinputs: this.inputIds(),\n\t\t\tinput_connection_output_indices: this.input_connection_output_indices(),\n\t\t\tnamed_input_connection_points: this.named_input_connection_points(),\n\t\t\tnamed_output_connection_points: this.named_output_connection_points(),\n\t\t\tparam_ids: this.to_json_params(include_param_components),\n\t\t\t// spare_params: this.to_json_spare_params(include_param_components),\n\t\t\toverride_cloned_state_allowed: this.node.io.inputs.overrideClonedStateAllowed(),\n\t\t\tinputs_clone_required_states: this.node.io.inputs.cloneRequiredStates(),\n\t\t\tflags: {\n\t\t\t\t//has_display: this.has_display_flag()\n\t\t\t\tdisplay: this.node.flags?.display?.active(),\n\t\t\t\tbypass: this.node.flags?.bypass?.active(),\n\t\t\t\toptimize: this.node.flags?.optimize?.active(),\n\t\t\t},\n\t\t\tselection: undefined as CoreGraphNodeId[] | undefined,\n\t\t};\n\n\t\tif (this.node.childrenAllowed() && this.node.childrenController) {\n\t\t\tdata['selection'] = this.node.childrenController.selection.toJSON();\n\t\t}\n\n\t\treturn data;\n\t}\n\n\tchildrenIds() {\n\t\treturn this.node.children().map((node) => node.graphNodeId());\n\t}\n\n\tmaxInputsCount() {\n\t\treturn this.node.io.inputs.maxInputsCount();\n\t}\n\n\tinputIds(): (CoreGraphNodeId | undefined)[] {\n\t\treturn this.node.io.inputs.inputs().map((node) => (node != null ? node.graphNodeId() : undefined));\n\t}\n\n\tinput_connection_output_indices() {\n\t\treturn this.node.io.connections\n\t\t\t.inputConnections()\n\t\t\t?.map((connection) => (connection != null ? connection.output_index : undefined));\n\t}\n\tnamed_input_connection_points() {\n\t\treturn this.node.io.inputs.named_input_connection_points.map((i) => i.toJSON());\n\t}\n\tnamed_output_connection_points() {\n\t\treturn this.node.io.outputs.named_output_connection_points.map((o) => o.toJSON());\n\t}\n\n\tto_json_params_from_names(param_names: string[], include_components: boolean = false) {\n\t\treturn param_names.map((param_name) => {\n\t\t\treturn this.node.params.get(param_name)!.graphNodeId();\n\t\t});\n\t\t// const params_json_by_name: PolyDictionary<string> = {};\n\t\t// for (let param_name of param_names) {\n\t\t// \tconst param = this.node.params.get(param_name);\n\t\t// \tif (param) {\n\t\t// \t\tparams_json_by_name[param_name] = param.graphNodeId();\n\n\t\t// \t\tif (include_components && param.isMultiple() && param.components) {\n\t\t// \t\t\tfor (let component of param.components) {\n\t\t// \t\t\t\tparams_json_by_name[component.name] = component.graphNodeId();\n\t\t// \t\t\t}\n\t\t// \t\t}\n\t\t// \t}\n\t\t// }\n\t\t// return params_json_by_name;\n\t}\n\tto_json_params(include_components: boolean = false) {\n\t\treturn this.to_json_params_from_names(this.node.params.names, include_components);\n\t}\n\t// to_json_params_without_components(){\n\t// \treturn this.to_json_params(false)\n\t// }\n\t// to_json_params_with_components(){\n\t// \treturn this.to_json_params(true)\n\t// }\n\t// to_json_spare_params(include_components: boolean = false) {\n\t// \treturn this.to_json_params_from_names(this.node.params.spare_names, include_components);\n\t// }\n}\n","import {BaseParamType} from '../_Base';\nimport {BaseNodeType} from '../../nodes/_Base';\nimport {ParamType} from '../../poly/ParamType';\nimport {ParamEvent} from '../../poly/ParamEvent';\nimport {NodeContext} from '../../poly/NodeContext';\nimport {CoreGraphNode} from '../../../core/graph/CoreGraphNode';\nimport {ColorConversion} from '../../../core/Color';\nimport {CoreType} from '../../../core/Type';\nimport {ArrayUtils} from '../../../core/ArrayUtils';\nimport {ObjectUtils} from '../../../core/ObjectUtils';\nimport {Boolean2, Number2, PolyDictionary} from '../../../types/GlobalTypes';\n\nconst CALLBACK_OPTION = 'callback';\nconst CALLBACK_STRING_OPTION = 'callbackString';\n// const COLOR_OPTION = 'color';\nconst COMPUTE_ON_DIRTY = 'computeOnDirty';\nconst COOK_OPTION = 'cook';\nconst FILE_BROWSE_OPTION = 'fileBrowse';\nconst FILE_TYPE_OPTION = 'type';\n// const EXPRESSION_ONLY_OPTION = 'expression_only';\nconst EXPRESSION = 'expression';\nconst FOR_ENTITIES = 'forEntities';\nconst LABEL = 'label';\nconst LEVEL = 'level';\nconst MENU = 'menu';\nconst ENTRIES = 'entries';\n// const TYPE = 'type';\n// const RADIO = 'radio';\nconst MULTILINE_OPTION = 'multiline';\nconst LANGUAGE_OPTION = 'language';\nconst NODE_SELECTION = 'nodeSelection';\nconst NODE_SELECTION_CONTEXT = 'context';\nconst NODE_SELECTION_TYPES = 'types';\nconst PARAM_SELECTION = 'paramSelection';\nconst DEPENDENT_ON_FOUND_NODE = 'dependentOnFoundNode';\nconst RANGE_OPTION = 'range';\nconst RANGE_LOCKED_OPTION = 'rangeLocked';\nconst STEP_OPTION = 'step';\nconst SPARE_OPTION = 'spare';\nconst TEXTURE_OPTION = 'texture';\nconst ENV_OPTION = 'env';\nconst HIDDEN_OPTION = 'hidden';\n// const SHOW_LABEL_OPTION = 'show_label';\nconst FIELD_OPTION = 'field';\nconst VISIBLE_IF_OPTION = 'visibleIf';\nconst COLOR_CONVERSION = 'conversion';\n\nexport interface NumericParamOptionsMenuEntry {\n\tname: string;\n\tvalue: number;\n}\nexport interface StringParamOptionsMenuEntry {\n\tname: string;\n\tvalue: string;\n}\nexport interface MenuNumericParamOptions {\n\tmenu?: {\n\t\tentries: NumericParamOptionsMenuEntry[];\n\t};\n}\nexport interface MenuStringParamOptions {\n\tmenu?: {\n\t\tentries: StringParamOptionsMenuEntry[];\n\t};\n}\nexport enum StringParamLanguage {\n\t// JAVASCRIPT = 'javascript',\n\tTYPESCRIPT = 'typescript',\n\t// GLSL = 'glsl',\n}\n\nexport enum FileType {\n\tTEXTURE_IMAGE = 'texture_image',\n\tTEXTURE_VIDEO = 'texture_video',\n\tGEOMETRY = 'geometry',\n\tFONT = 'font',\n\tSVG = 'svg',\n}\n\nexport type VisibleIfParamOptions = PolyDictionary<number | boolean>;\ninterface BaseParamOptions {\n\t// cook\n\tcook?: boolean;\n\t// spare\n\tspare?: boolean;\n\t// visible\n\thidden?: boolean;\n\t// show_label?: boolean;\n\tfield?: boolean;\n\tvisibleIf?: VisibleIfParamOptions | VisibleIfParamOptions[];\n}\n\ninterface ExpressionParamOptions {\n\texpression?: {\n\t\tforEntities?: boolean;\n\t};\n}\n\ninterface NumberParamOptions extends BaseParamOptions {\n\trange?: Number2;\n\trangeLocked?: Boolean2;\n\tstep?: number;\n}\n\ninterface FileParamOptions {\n\tfileBrowse?: {\n\t\ttype: FileType[];\n\t};\n}\ninterface ComputeOnDirtyParamOptions {\n\tcomputeOnDirty?: boolean;\n}\ninterface CallbackParamOptions {\n\tcallback?: (node: BaseNodeType, param: BaseParamType) => any;\n\tcallbackString?: string;\n}\ninterface LabelParamOptions {\n\tlabel?: string;\n}\ninterface ColorConversionOptions {\n\tconversion?: ColorConversion;\n}\n\n// actual param options\nexport interface BooleanParamOptions\n\textends BaseParamOptions,\n\t\tComputeOnDirtyParamOptions,\n\t\tMenuNumericParamOptions,\n\t\tExpressionParamOptions,\n\t\tCallbackParamOptions {}\nexport interface ButtonParamOptions extends BaseParamOptions, CallbackParamOptions, LabelParamOptions {}\nexport interface ColorParamOptions\n\textends BaseParamOptions,\n\t\tColorConversionOptions,\n\t\tExpressionParamOptions,\n\t\tCallbackParamOptions,\n\t\tComputeOnDirtyParamOptions {}\nexport interface FloatParamOptions\n\textends NumberParamOptions,\n\t\tMenuNumericParamOptions,\n\t\tComputeOnDirtyParamOptions,\n\t\tExpressionParamOptions,\n\t\tCallbackParamOptions {}\nexport interface FolderParamOptions extends BaseParamOptions {\n\tlevel?: number;\n}\nexport interface IntegerParamOptions extends NumberParamOptions, MenuNumericParamOptions, CallbackParamOptions {}\nexport interface OperatorPathParamOptions\n\textends BaseParamOptions,\n\t\tFileParamOptions,\n\t\tComputeOnDirtyParamOptions,\n\t\tCallbackParamOptions {\n\tnodeSelection?: {\n\t\tcontext?: NodeContext;\n\t\ttypes?: Readonly<string[]>;\n\t};\n\tdependentOnFoundNode?: boolean;\n\tparamSelection?: ParamType | boolean;\n}\nexport interface RampParamOptions extends BaseParamOptions {}\nexport interface SeparatorParamOptions extends BaseParamOptions {}\nexport interface StringParamOptions\n\textends BaseParamOptions,\n\t\tFileParamOptions,\n\t\tCallbackParamOptions,\n\t\tExpressionParamOptions {\n\tmultiline?: boolean;\n\tlanguage?: StringParamLanguage;\n}\ninterface VectorParamOptions\n\textends BaseParamOptions,\n\t\tExpressionParamOptions,\n\t\tCallbackParamOptions,\n\t\tComputeOnDirtyParamOptions {}\nexport interface Vector2ParamOptions extends VectorParamOptions {}\nexport interface Vector3ParamOptions extends VectorParamOptions {}\nexport interface Vector4ParamOptions extends VectorParamOptions {}\n\nexport interface ParamOptions\n\textends NumberParamOptions,\n\t\tColorConversionOptions,\n\t\tComputeOnDirtyParamOptions,\n\t\tFolderParamOptions,\n\t\tExpressionParamOptions,\n\t\tButtonParamOptions,\n\t\tFileParamOptions,\n\t\tMenuNumericParamOptions,\n\t\tStringParamOptions,\n\t\tOperatorPathParamOptions {\n\ttexture?: {\n\t\tenv?: boolean;\n\t};\n}\n\nexport class OptionsController {\n\tprivate _programatic_visible_state: boolean = true;\n\tprivate _options!: ParamOptions;\n\tprivate _default_options!: ParamOptions;\n\tconstructor(private _param: BaseParamType) {\n\t\t// this._options = lodash_cloneDeep(this._default_options);\n\t}\n\tdispose() {\n\t\tthis._options[CALLBACK_OPTION] = undefined;\n\t\tthis._options[CALLBACK_STRING_OPTION] = undefined;\n\t\tthis._visibility_graph_node?.dispose();\n\t}\n\n\tset(options: ParamOptions) {\n\t\tthis._default_options = options;\n\t\tthis._options = ObjectUtils.cloneDeep(this._default_options);\n\t\tthis.post_set_options();\n\t}\n\tcopy(options_controller: OptionsController) {\n\t\tthis._default_options = ObjectUtils.cloneDeep(options_controller.default());\n\t\tthis._options = ObjectUtils.cloneDeep(options_controller.current());\n\t\tthis.post_set_options();\n\t}\n\tset_option<K extends keyof ParamOptions>(name: K, value: ParamOptions[K]) {\n\t\tthis._options[name] = value;\n\t\tif (this._param.components) {\n\t\t\tfor (let component of this._param.components) {\n\t\t\t\tcomponent.options.set_option(name, value);\n\t\t\t}\n\t\t}\n\t}\n\tprivate post_set_options() {\n\t\tthis._handle_computeOnDirty();\n\t}\n\tparam() {\n\t\treturn this._param;\n\t}\n\tnode(): BaseNodeType {\n\t\treturn this._param.node;\n\t}\n\tdefault() {\n\t\treturn this._default_options;\n\t}\n\tcurrent() {\n\t\treturn this._options;\n\t}\n\n\t// utils\n\thas_options_overridden(): boolean {\n\t\treturn !ObjectUtils.isEqual(this._options, this._default_options);\n\t}\n\toverridden_options(): ParamOptions {\n\t\tconst overriden: ParamOptions = {};\n\t\tconst option_names = Object.keys(this._options) as Array<keyof ParamOptions>;\n\t\tfor (let option_name of option_names) {\n\t\t\tif (!ObjectUtils.isEqual(this._options[option_name], this._default_options[option_name])) {\n\t\t\t\tconst cloned_option = ObjectUtils.cloneDeep(this._options[option_name]);\n\t\t\t\tObject.assign(overriden, {[option_name]: cloned_option});\n\t\t\t}\n\t\t}\n\t\treturn overriden;\n\t}\n\toverridden_option_names(): Array<keyof ParamOptions> {\n\t\treturn Object.keys(this.overridden_options()) as Array<keyof ParamOptions>;\n\t}\n\n\t// compute on dirty\n\tcomputeOnDirty(): boolean {\n\t\treturn this._options[COMPUTE_ON_DIRTY] || false;\n\t}\n\tprivate _computeOnDirty_callback_added: boolean | undefined;\n\tprivate _handle_computeOnDirty() {\n\t\tif (this.computeOnDirty()) {\n\t\t\tif (!this._computeOnDirty_callback_added) {\n\t\t\t\tthis.param().addPostDirtyHook('computeOnDirty', this._compute_param.bind(this));\n\t\t\t\tthis._computeOnDirty_callback_added = true;\n\t\t\t}\n\t\t}\n\t}\n\tprivate async _compute_param() {\n\t\tawait this.param().compute();\n\t}\n\n\t// callback\n\thas_callback() {\n\t\treturn this._options[CALLBACK_OPTION] != null || this._options[CALLBACK_STRING_OPTION] != null;\n\t}\n\n\tprivate _callbackAllowed = false;\n\tallowCallback() {\n\t\tthis._callbackAllowed = true;\n\t}\n\n\texecute_callback() {\n\t\tif (!this._callbackAllowed) {\n\t\t\treturn;\n\t\t}\n\t\tif (!this.node()) {\n\t\t\treturn;\n\t\t}\n\t\t// we only allow execution when scene is loaded\n\t\t// to avoid errors such as an operator_path param\n\t\t// executing its callback before the node it points to is created\n\t\tif (!this.node().scene().loadingController.loaded()) {\n\t\t\treturn;\n\t\t}\n\t\tconst callback = this.get_callback();\n\t\tif (callback != null) {\n\t\t\t// not running the callback when a node is cooking prevents some event nodes from behaving as expected.\n\t\t\t// It may also prevent files such as the sop/file to reload correctly if its reload callback was called while it loads a file\n\t\t\t// if (!this.node.cookController.is_cooking) {\n\t\t\tconst parent_param = this.param().parent_param;\n\t\t\tif (parent_param) {\n\t\t\t\t// if the param is a component of a MultipleParam,\n\t\t\t\t// we let the parent handle the callback.\n\t\t\t\t// The main reason is for material builder uniforms.\n\t\t\t\t// If the component executes the callback, the uniform that is expecting a vector\n\t\t\t\t// will be receiving a float. The reason is that the callback is created by the ParamConfig, and it is then passed down to the component unchanged.\n\t\t\t\t// I could maybe find a way so that the param config creates callback for the multiple param\n\t\t\t\t// and also for the components. But they would have to be assigned correctly by the multiple param\n\t\t\t\tparent_param.options.execute_callback();\n\t\t\t} else {\n\t\t\t\tcallback(this.node(), this.param());\n\t\t\t}\n\t\t\t// } else {\n\t\t\t// \tconsole.warn(`node ${this.node.fullPath()} cooking, not running callback`, this.param.name);\n\t\t\t// }\n\t\t}\n\t}\n\tprivate get_callback() {\n\t\tif (this.has_callback()) {\n\t\t\treturn (this._options[CALLBACK_OPTION] =\n\t\t\t\tthis._options[CALLBACK_OPTION] || this.create_callback_from_string());\n\t\t}\n\t}\n\tprivate create_callback_from_string() {\n\t\tconst callbackString = this._options[CALLBACK_STRING_OPTION];\n\t\tif (callbackString) {\n\t\t\tconst callback_function = new Function('node', 'scene', 'window', 'location', callbackString);\n\t\t\treturn () => {\n\t\t\t\tcallback_function(this.node(), this.node().scene(), null, null);\n\t\t\t};\n\t\t}\n\t}\n\n\t// color\n\tcolor_conversion() {\n\t\treturn this._options[COLOR_CONVERSION];\n\t}\n\n\t// cook\n\tmakes_node_dirty_when_dirty() {\n\t\tlet cook_options;\n\n\t\t// false as the dirty state will go through the parent param\n\t\tif (this.param().parent_param != null) {\n\t\t\treturn false;\n\t\t}\n\n\t\tlet value = true;\n\t\tif ((cook_options = this._options[COOK_OPTION]) != null) {\n\t\t\tvalue = cook_options;\n\t\t}\n\t\treturn value;\n\t}\n\n\t// desktop\n\tfile_browse_option() {\n\t\treturn this._options[FILE_BROWSE_OPTION];\n\t}\n\tfile_browse_allowed(): boolean {\n\t\treturn this.file_browse_option() != null;\n\t}\n\tfile_browse_type(): FileType[] | null {\n\t\tconst option = this.file_browse_option();\n\t\tif (option) {\n\t\t\treturn option[FILE_TYPE_OPTION];\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t// expression\n\t// get displays_expression_only() {\n\t// \treturn this._options[EXPRESSION_ONLY_OPTION] === true;\n\t// }\n\tis_expression_for_entities(): boolean {\n\t\tconst expr_option = this._options[EXPRESSION];\n\t\tif (expr_option) {\n\t\t\treturn expr_option[FOR_ENTITIES] || false;\n\t\t}\n\t\treturn false;\n\t}\n\n\t// folder\n\tlevel() {\n\t\treturn this._options[LEVEL] || 0;\n\t}\n\n\t// menu\n\thas_menu() {\n\t\treturn this.menu_options() != null;\n\t}\n\n\tprivate menu_options() {\n\t\treturn this._options[MENU];\n\t}\n\t// private get menu_type() {\n\t// \tif(this.menu_options){\n\t// \t\treturn this.menu_options[TYPE];\n\t// \t}\n\t// }\n\n\tmenu_entries() {\n\t\tconst options = this.menu_options();\n\t\tif (options) {\n\t\t\treturn options[ENTRIES];\n\t\t} else {\n\t\t\treturn [];\n\t\t}\n\t}\n\n\thas_menu_radio() {\n\t\treturn this.has_menu(); //&& this.menu_options[TYPE] === RADIO;\n\t}\n\n\t// multiline\n\tis_multiline(): boolean {\n\t\treturn this._options[MULTILINE_OPTION] === true;\n\t}\n\tlanguage(): StringParamLanguage | undefined {\n\t\treturn this._options[LANGUAGE_OPTION];\n\t}\n\tis_code(): boolean {\n\t\treturn this.language() != null;\n\t}\n\n\t// node selection\n\tnode_selection_options() {\n\t\treturn this._options[NODE_SELECTION];\n\t}\n\tnode_selection_context() {\n\t\tconst options = this.node_selection_options();\n\t\tif (options) {\n\t\t\treturn options[NODE_SELECTION_CONTEXT];\n\t\t}\n\t}\n\tnode_selection_types() {\n\t\tconst options = this.node_selection_options();\n\t\tif (options) {\n\t\t\treturn options[NODE_SELECTION_TYPES];\n\t\t}\n\t}\n\n\tdependent_on_found_node() {\n\t\tif (DEPENDENT_ON_FOUND_NODE in this._options) {\n\t\t\treturn this._options[DEPENDENT_ON_FOUND_NODE];\n\t\t} else {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\t// param selection\n\tis_selecting_param() {\n\t\treturn this.param_selection_options() != null;\n\t}\n\tparam_selection_options() {\n\t\treturn this._options[PARAM_SELECTION];\n\t}\n\tparam_selection_type() {\n\t\tconst options = this.param_selection_options();\n\t\tif (options) {\n\t\t\tconst type_or_boolean = options;\n\t\t\tif (!CoreType.isBoolean(type_or_boolean)) {\n\t\t\t\treturn type_or_boolean;\n\t\t\t}\n\t\t}\n\t}\n\n\t// range\n\trange(): Number2 {\n\t\t// cannot force range easily, as values are not necessarily from 0 to N\n\t\t// if(this.self.has_menu() && this.self.menu_entries()){\n\t\t// \treturn [0, this.self.menu_entries().length-1 ]\n\t\t// } else {\n\t\treturn this._options[RANGE_OPTION] || [0, 1];\n\t\t// }\n\t}\n\tstep(): number | undefined {\n\t\treturn this._options[STEP_OPTION];\n\t}\n\n\tprivate range_locked(): Boolean2 {\n\t\t// if(this.self.has_menu() && this.self.menu_entries()){\n\t\t// \treturn [true, true]\n\t\t// } else {\n\t\treturn this._options[RANGE_LOCKED_OPTION] || [false, false];\n\t\t// }\n\t}\n\n\tensure_in_range(value: number): number {\n\t\tconst range = this.range();\n\n\t\tif (value >= range[0] && value <= range[1]) {\n\t\t\treturn value;\n\t\t} else {\n\t\t\tif (value < range[0]) {\n\t\t\t\treturn this.range_locked()[0] === true ? range[0] : value;\n\t\t\t} else {\n\t\t\t\treturn this.range_locked()[1] === true ? range[1] : value;\n\t\t\t}\n\t\t}\n\t}\n\n\t// spare\n\tis_spare(): boolean {\n\t\treturn this._options[SPARE_OPTION] || false;\n\t}\n\n\t// texture\n\ttexture_options() {\n\t\treturn this._options[TEXTURE_OPTION];\n\t}\n\ttexture_as_env(): boolean {\n\t\tconst texture_options = this.texture_options();\n\t\tif (texture_options != null) {\n\t\t\treturn texture_options[ENV_OPTION] === true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t// visible\n\tis_hidden(): boolean {\n\t\treturn this._options[HIDDEN_OPTION] === true || this._programatic_visible_state === false;\n\t}\n\tis_visible(): boolean {\n\t\treturn !this.is_hidden();\n\t}\n\tset_visible_state(state: boolean) {\n\t\tthis._options[HIDDEN_OPTION] = !state;\n\t\tthis.param().emit(ParamEvent.VISIBLE_UPDATED);\n\t}\n\t// label\n\tlabel() {\n\t\treturn this._options[LABEL];\n\t}\n\tis_label_hidden(): boolean {\n\t\tconst type = this.param().type();\n\t\treturn (\n\t\t\t// this._options[SHOW_LABEL_OPTION] === false ||\n\t\t\ttype === ParamType.BUTTON ||\n\t\t\ttype === ParamType.SEPARATOR ||\n\t\t\t(type === ParamType.BOOLEAN && this.is_field_hidden())\n\t\t);\n\t}\n\tis_field_hidden(): boolean {\n\t\treturn this._options[FIELD_OPTION] === false;\n\t}\n\n\t// programatic visibility\n\tui_data_depends_on_other_params(): boolean {\n\t\treturn VISIBLE_IF_OPTION in this._options;\n\t}\n\tvisibility_predecessors() {\n\t\tconst visibility_options = this._options[VISIBLE_IF_OPTION];\n\t\tif (!visibility_options) {\n\t\t\treturn [];\n\t\t}\n\t\tlet predecessor_names: string[] = [];\n\t\tif (CoreType.isArray(visibility_options)) {\n\t\t\tpredecessor_names = ArrayUtils.uniq(visibility_options.map((options) => Object.keys(options)).flat());\n\t\t} else {\n\t\t\tpredecessor_names = Object.keys(visibility_options);\n\t\t}\n\t\tconst node = this.param().node;\n\t\treturn ArrayUtils.compact(\n\t\t\tpredecessor_names.map((name) => {\n\t\t\t\tconst param = node.params.get(name);\n\t\t\t\tif (param) {\n\t\t\t\t\treturn param;\n\t\t\t\t} else {\n\t\t\t\t\tconsole.error(\n\t\t\t\t\t\t`param ${name} not found as visibility condition for ${this.param().name()} in node ${this.param().node.type()}`\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t})\n\t\t);\n\t}\n\n\tprivate _update_visibility_and_remove_dirty_bound = this.update_visibility_and_remove_dirty.bind(this);\n\tprivate _visibility_graph_node: CoreGraphNode | undefined;\n\tprivate _ui_data_dependency_set: boolean = false;\n\tset_ui_data_dependency() {\n\t\t// currently this is only called on request on a per-param and therefore per-node basis, not on scene load for the whole scene\n\t\tif (this._ui_data_dependency_set) {\n\t\t\treturn;\n\t\t}\n\t\tthis._ui_data_dependency_set = true;\n\t\tconst predecessors = this.visibility_predecessors();\n\t\tif (predecessors.length > 0) {\n\t\t\tthis._visibility_graph_node = new CoreGraphNode(this.param().scene(), 'param_visibility');\n\t\t\tfor (let predecessor of predecessors) {\n\t\t\t\tthis._visibility_graph_node.addGraphInput(predecessor);\n\t\t\t}\n\t\t\tthis._visibility_graph_node.addPostDirtyHook(\n\t\t\t\t'_update_visibility_and_remove_dirty',\n\t\t\t\tthis._update_visibility_and_remove_dirty_bound\n\t\t\t);\n\t\t}\n\t}\n\tprivate update_visibility_and_remove_dirty() {\n\t\tthis.update_visibility();\n\t\tthis.param().removeDirtyState();\n\t}\n\n\tasync update_visibility() {\n\t\tconst options = this._options[VISIBLE_IF_OPTION];\n\t\tif (options) {\n\t\t\tconst params = this.visibility_predecessors();\n\t\t\tconst promises = params.map((p) => {\n\t\t\t\tif (p.isDirty()) {\n\t\t\t\t\treturn p.compute();\n\t\t\t\t}\n\t\t\t});\n\t\t\tthis._programatic_visible_state = false;\n\t\t\tawait Promise.all(promises);\n\n\t\t\tif (CoreType.isArray(options)) {\n\t\t\t\tfor (let options_set of options) {\n\t\t\t\t\tconst satisfied_values = params.filter((param) => param.value == options_set[param.name()]);\n\t\t\t\t\tif (satisfied_values.length == params.length) {\n\t\t\t\t\t\tthis._programatic_visible_state = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst satisfied_values = params.filter((param) => param.value == options[param.name()]);\n\t\t\t\tthis._programatic_visible_state = satisfied_values.length == params.length;\n\t\t\t}\n\n\t\t\tthis.param().emit(ParamEvent.VISIBLE_UPDATED);\n\t\t}\n\t}\n}\n","import jsep from 'jsep';\nimport {CoreType} from '../../../core/Type';\njsep.addUnaryOp('@');\n// self.jsep = jsep\nlet precedence = 10;\njsep.addBinaryOp('**', precedence);\n// precedence = 1\n// jsep.addBinaryOp('`', precedence)\n// const HOUDINI_QUOTE_CODE = 96; // houdini quote\n// const JSEP_COMPOUND = 'Compound'\nconst JSEP_IDENTIFIER = 'Identifier';\nconst JSEP_LITERAL = 'Literal';\n// const JSEP_BINARY_EXPRESSION = 'BynaryExpression'\nconst JSEP_CALL_EXPRESSION = 'CallExpression';\nconst STRING_EXPRESSION_SEPARATOR = '`';\n\nexport class ParsedTree {\n\tpublic node: jsep.Expression | undefined;\n\tpublic error_message: string | undefined;\n\n\tconstructor() {}\n\n\tparse_expression(string: string) {\n\t\ttry {\n\t\t\tthis.reset();\n\t\t\tthis.node = jsep(string);\n\t\t} catch (e) {\n\t\t\tconst message = `could not parse the expression '${string}' (error: ${e})`;\n\t\t\tthis.error_message = message;\n\t\t}\n\t}\n\tparse_expression_for_string_param(string: string) {\n\t\ttry {\n\t\t\tthis.reset();\n\n\t\t\tconst elements = ParsedTree.string_value_elements(string);\n\t\t\tconst nodes = [];\n\t\t\tfor (let i = 0; i < elements.length; i++) {\n\t\t\t\tconst element = elements[i];\n\t\t\t\tlet node;\n\t\t\t\tif (i % 2 == 1) {\n\t\t\t\t\tnode = jsep(element);\n\t\t\t\t} else {\n\t\t\t\t\tnode = {\n\t\t\t\t\t\ttype: JSEP_LITERAL,\n\t\t\t\t\t\tvalue: `'${element}'`,\n\t\t\t\t\t\traw: `'${element}'`,\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tnodes.push(node);\n\t\t\t\t// nodes.push({\n\t\t\t\t// \ttype: JSEP_CALL_EXPRESSION,\n\t\t\t\t// \targuments: [node],\n\t\t\t\t// \tcallee: {\n\t\t\t\t// \t\ttype: JSEP_IDENTIFIER,\n\t\t\t\t// \t\tname: 'toString',\n\t\t\t\t// \t}\n\t\t\t\t// })\n\t\t\t}\n\t\t\t// let last_plus_node;\n\t\t\t// for(let i=0; i<(nodes.length-1); i++){\n\t\t\t// \tconst plus_node = {\n\t\t\t// \t\ttype: JSEP_BINARY_EXPRESSION,\n\t\t\t// \t\toperator: '+',\n\t\t\t// \t\tleft: last_plus_node || nodes[i],\n\t\t\t// \t\tright: nodes[i+1],\n\t\t\t// \t}\n\t\t\t// \tlast_plus_node = plus_node;\n\t\t\t// }\n\t\t\t// this.node = last_plus_node\n\t\t\tthis.node = (<unknown>{\n\t\t\t\ttype: JSEP_CALL_EXPRESSION,\n\t\t\t\targuments: nodes,\n\t\t\t\tcallee: {\n\t\t\t\t\ttype: JSEP_IDENTIFIER,\n\t\t\t\t\tname: 'strConcat',\n\t\t\t\t},\n\t\t\t}) as jsep.Compound;\n\t\t} catch (e) {\n\t\t\tconst message = `could not parse the expression '${string}' (error: ${e})`;\n\t\t\tthis.error_message = message;\n\t\t}\n\t}\n\n\tstatic string_value_elements(v: string): string[] {\n\t\tif (v != null) {\n\t\t\tif (CoreType.isString(v)) {\n\t\t\t\treturn v.split(STRING_EXPRESSION_SEPARATOR);\n\t\t\t} else {\n\t\t\t\treturn [];\n\t\t\t}\n\t\t} else {\n\t\t\treturn [];\n\t\t}\n\t}\n\t// static string_value_contains_expression(v:string): boolean{\n\t// \treturn ((this.string_value_elements(v).length - 1) % 2) === 0;\n\t// }\n\n\t// deep_parse_for_string_expressions(){\n\t// \t// for string expressions which have more than a single `<expr>` element\n\t// \t// pt_`@ptnum`\n\t// \t// `@ptnum`_pt\n\t// \t// pt_`@ptnum`_`1+1`\n\t// \tif(this.node.type == JSEP_COMPOUND){\n\t// \t\tconst args = this.node.body\n\t// \t\tlet arg;\n\t// \t\tfor(let i=0; i<args.length; i++){\n\t// \t\t\targ = args[i]\n\t// \t\t\tif(arg.type == JSEP_LITERAL){\n\t// \t\t\t\tconst arg_node = jsep(arg.value)\n\t// \t\t\t\targs[i] = arg_node\n\t// \t\t\t}\n\t// \t\t}\n\t// \t} else {\n\t// \t\t// for string expressions which havea single `<expr>` element\n\t// \t\t// `@ptnum`\n\t// \t\tif(this.node.type == JSEP_LITERAL){\n\t// \t\t\tconst raw = this.node.raw\n\t// \t\t\tconst first_char_code = raw.charCodeAt(0)\n\t// \t\t\tconst last_char_code = raw.charCodeAt(raw.length-1)\n\t// \t\t\tif(first_char_code == HOUDINI_QUOTE_CODE && last_char_code == HOUDINI_QUOTE_CODE){\n\t// \t\t\t\tthis.node = jsep(\"''+\"+this.node.value) // add the prefix ''+ to ensure we have a string as a result, and not a number\n\t// \t\t\t}\n\t// \t\t}\n\t// \t}\n\t// }\n\n\tprivate reset() {\n\t\tthis.node = undefined;\n\t\tthis.error_message = undefined;\n\t}\n}\n","import {TypedNumericParam} from './_Numeric';\nimport {ParamType} from '../poly/ParamType';\nimport {CoreString} from '../../core/String';\nimport {ParamInitValuesTypeMap} from './types/ParamInitValuesTypeMap';\nimport {ParamValuesTypeMap} from './types/ParamValuesTypeMap';\nimport {CoreType} from '../../core/Type';\nexport class FloatParam extends TypedNumericParam<ParamType.FLOAT> {\n\tstatic type() {\n\t\treturn ParamType.FLOAT;\n\t}\n\tdefaultValueSerialized() {\n\t\treturn this._default_value;\n\t}\n\trawInputSerialized() {\n\t\treturn this._raw_input;\n\t}\n\tvalueSerialized() {\n\t\treturn this.value;\n\t}\n\tprotected _copy_value(param: FloatParam) {\n\t\tthis.set(param.valueSerialized());\n\t}\n\tprotected _prefilter_invalid_raw_input(raw_input: any): ParamInitValuesTypeMap[ParamType.INTEGER] {\n\t\tif (CoreType.isArray(raw_input)) {\n\t\t\treturn raw_input[0] as ParamInitValuesTypeMap[ParamType.INTEGER];\n\t\t}\n\t\tif (CoreType.isString(raw_input) && CoreString.isNumber(raw_input)) {\n\t\t\treturn parseFloat(raw_input);\n\t\t}\n\t\treturn raw_input;\n\t}\n\n\tstatic are_raw_input_equal(\n\t\traw_input1: ParamInitValuesTypeMap[ParamType.FLOAT],\n\t\traw_input2: ParamInitValuesTypeMap[ParamType.FLOAT]\n\t) {\n\t\treturn raw_input1 == raw_input2;\n\t}\n\tstatic are_values_equal(val1: ParamValuesTypeMap[ParamType.FLOAT], val2: ParamValuesTypeMap[ParamType.FLOAT]) {\n\t\treturn val1 == val2;\n\t}\n\tstatic convert(raw_val: ParamInitValuesTypeMap[ParamType.FLOAT]): number | null {\n\t\tif (CoreType.isNumber(raw_val)) {\n\t\t\treturn raw_val;\n\t\t} else {\n\t\t\tif (CoreType.isBoolean(raw_val)) {\n\t\t\t\treturn raw_val ? 1 : 0;\n\t\t\t} else {\n\t\t\t\tif (CoreString.isNumber(raw_val)) {\n\t\t\t\t\tconst parsed = parseFloat(raw_val);\n\t\t\t\t\tif (CoreType.isNumber(parsed)) {\n\t\t\t\t\t\treturn parsed;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t}\n\tconvert(raw_val: ParamInitValuesTypeMap[ParamType.FLOAT]): number | null {\n\t\tconst result = FloatParam.convert(raw_val);\n\t\tif (result) {\n\t\t\treturn this.options.ensure_in_range(result);\n\t\t} else {\n\t\t\treturn result;\n\t\t}\n\t}\n}\n","import {Number2} from '../../types/GlobalTypes';\nimport {SkinnedMesh} from 'three/src/objects/SkinnedMesh';\nimport {Scene} from 'three/src/scenes/Scene';\nimport {Points} from 'three/src/objects/Points';\nimport {Group} from 'three/src/objects/Group';\nimport {FrontSide} from 'three/src/constants';\nimport {Color} from 'three/src/math/Color';\nimport {Bone} from 'three/src/objects/Bone';\nimport {Material} from 'three/src/materials/Material';\nimport {PointsMaterial} from 'three/src/materials/PointsMaterial';\nimport {MeshStandardMaterial} from 'three/src/materials/MeshStandardMaterial';\nimport {MeshLambertMaterial} from 'three/src/materials/MeshLambertMaterial';\nimport {LineBasicMaterial} from 'three/src/materials/LineBasicMaterial';\n// object types\nimport {Object3D} from 'three/src/core/Object3D';\nimport {Mesh} from 'three/src/objects/Mesh';\nimport {LineSegments} from 'three/src/objects/LineSegments';\nimport {LOD} from 'three/src/objects/LOD';\n\ninterface MaterialsByString {\n\t[propName: string]: Material;\n}\n\nexport enum ObjectType {\n\tOBJECT3D = 'Object3D',\n\tMESH = 'Mesh',\n\tPOINTS = 'Points',\n\tLINE_SEGMENTS = 'LineSegments',\n\tLOD = 'LOD',\n}\n\nexport interface ObjectData {\n\ttype: ObjectType;\n\tname: string | null;\n\tchildren_count: number;\n\tpoints_count: number;\n}\nexport interface ObjectByObjectType {\n\t[ObjectType.MESH]: Mesh;\n\t[ObjectType.POINTS]: Points;\n\t[ObjectType.LINE_SEGMENTS]: LineSegments;\n\t[ObjectType.OBJECT3D]: Object3D;\n\t[ObjectType.LOD]: LOD;\n}\nexport interface ObjectConstructorByObjectType {\n\t[ObjectType.MESH]: typeof Mesh;\n\t[ObjectType.POINTS]: typeof Points;\n\t[ObjectType.LINE_SEGMENTS]: typeof LineSegments;\n\t[ObjectType.OBJECT3D]: typeof Object3D;\n\t[ObjectType.LOD]: typeof LOD;\n}\nexport const OBJECT_CONSTRUCTOR_BY_OBJECT_TYPE: ObjectConstructorByObjectType = {\n\t[ObjectType.MESH]: Mesh,\n\t[ObjectType.POINTS]: Points,\n\t[ObjectType.LINE_SEGMENTS]: LineSegments,\n\t[ObjectType.OBJECT3D]: Object3D,\n\t[ObjectType.LOD]: LOD,\n};\nexport function objectTypeFromConstructor(constructor: Function) {\n\tswitch (constructor) {\n\t\tcase Object3D:\n\t\t\treturn ObjectType.OBJECT3D;\n\t\tcase Mesh:\n\t\t\treturn ObjectType.MESH;\n\t\tcase Points:\n\t\t\treturn ObjectType.POINTS;\n\t\tcase LineSegments:\n\t\t\treturn ObjectType.LINE_SEGMENTS;\n\t\tcase LOD:\n\t\t\treturn ObjectType.LOD;\n\t\tdefault:\n\t\t\tconsole.warn('object type not supported', constructor);\n\t\t\treturn ObjectType.MESH;\n\t}\n}\nexport function ObjectTypeByObject(object: Object3D): ObjectType | undefined {\n\tif (object instanceof Mesh) {\n\t\treturn ObjectType.MESH;\n\t} else if (object instanceof LineSegments) {\n\t\treturn ObjectType.LINE_SEGMENTS;\n\t} else if (object instanceof Points) {\n\t\treturn ObjectType.POINTS;\n\t} else if (object instanceof Object3D) {\n\t\treturn ObjectType.OBJECT3D;\n\t}\n\t// else if (object instanceof LOD) {\n\t// \treturn ObjectType.LOD;\n\t// }\n\tconsole.warn('ObjectTypeByObject received an unknown object type', object);\n}\nexport const ObjectTypes = [ObjectType.MESH, ObjectType.POINTS, ObjectType.LINE_SEGMENTS];\nexport const ObjectTypeMenuEntries = [\n\t{name: 'Mesh', value: ObjectTypes.indexOf(ObjectType.MESH)},\n\t{name: 'Points', value: ObjectTypes.indexOf(ObjectType.POINTS)},\n\t{name: 'LineSegments', value: ObjectTypes.indexOf(ObjectType.LINE_SEGMENTS)},\n];\n\nconst materials: MaterialsByString = {\n\tMeshStandard: new MeshStandardMaterial({\n\t\tcolor: 0xffffff,\n\t\t//vertexColors: VertexColors\n\t\tside: FrontSide, // DoubleSide\n\t\tmetalness: 0.5,\n\t\troughness: 0.9,\n\t}),\n\t[ObjectType.MESH]: new MeshLambertMaterial({\n\t\t// MeshStandardMaterial\n\t\tcolor: new Color(1, 1, 1),\n\t\tside: FrontSide,\n\t\tvertexColors: false,\n\t\ttransparent: true,\n\t\tdepthTest: true,\n\t}),\n\t[ObjectType.POINTS]: new PointsMaterial({\n\t\tcolor: 0xffffff,\n\t\tsize: 0.1,\n\t\t//blending: AdditiveBlending\n\t\tdepthTest: true,\n\t}),\n\t[ObjectType.LINE_SEGMENTS]: new LineBasicMaterial({\n\t\tcolor: 0xffffff,\n\t\tlinewidth: 1,\n\t}),\n};\n\nexport enum AttribClass {\n\tVERTEX = 0,\n\tOBJECT = 1,\n}\nexport const ATTRIBUTE_CLASSES: Array<AttribClass> = [AttribClass.VERTEX, AttribClass.OBJECT];\n\nexport const AttribClassMenuEntries = [\n\t{name: 'vertex', value: AttribClass.VERTEX},\n\t{name: 'object', value: AttribClass.OBJECT},\n];\n\nexport enum AttribType {\n\tNUMERIC = 0,\n\tSTRING = 1,\n}\nexport const ATTRIBUTE_TYPES: Array<AttribType> = [AttribType.NUMERIC, AttribType.STRING];\nexport const AttribTypeMenuEntries = [\n\t{name: 'numeric', value: AttribType.NUMERIC},\n\t{name: 'string', value: AttribType.STRING},\n];\n\nexport enum AttribSize {\n\tFLOAT = 1,\n\tVECTOR2 = 2,\n\tVECTOR3 = 3,\n\tVECTOR4 = 4,\n}\nexport const ATTRIBUTE_SIZES: Array<AttribSize> = [\n\tAttribSize.FLOAT,\n\tAttribSize.VECTOR2,\n\tAttribSize.VECTOR3,\n\tAttribSize.VECTOR4,\n];\nexport const ATTRIBUTE_SIZE_RANGE: Number2 = [AttribSize.FLOAT, AttribSize.VECTOR4];\n\nexport const CoreConstant = {\n\tATTRIB_CLASS: {\n\t\tVERTEX: AttribClass.VERTEX,\n\t\tOBJECT: AttribClass.OBJECT,\n\t},\n\n\tOBJECT_TYPES: ObjectTypes,\n\tCONSTRUCTOR_NAMES_BY_CONSTRUCTOR_NAME: {\n\t\t[Scene.name]: 'Scene',\n\t\t[Group.name]: 'Group',\n\t\t[Object3D.name]: 'Object3D',\n\t\t[Mesh.name]: 'Mesh',\n\t\t[Points.name]: 'Points',\n\t\t[LineSegments.name]: 'LineSegments',\n\t\t[Bone.name]: 'Bone',\n\t\t[SkinnedMesh.name]: 'SkinnedMesh',\n\t},\n\tCONSTRUCTORS_BY_NAME: {\n\t\t[ObjectType.MESH]: Mesh,\n\t\t[ObjectType.POINTS]: Points,\n\t\t[ObjectType.LINE_SEGMENTS]: LineSegments,\n\t},\n\n\tMATERIALS: materials,\n};\n","// import {TypedParamVisitor} from './_Base';\nimport {BaseParamType} from './_Base';\nimport {TypedPathParam} from './_BasePath';\nimport {CoreWalker} from '../../core/Walker';\nimport {BaseNodeType} from '../nodes/_Base';\nimport {ParamType} from '../poly/ParamType';\nimport {ParamValuesTypeMap} from './types/ParamValuesTypeMap';\nimport {ParamEvent} from '../poly/ParamEvent';\nimport {ParamInitValuesTypeMap} from './types/ParamInitValuesTypeMap';\nimport {NodeContext, BaseNodeByContextMap, ChildrenNodeMapByContextMap} from '../poly/NodeContext';\nimport {ParamConstructorMap} from './types/ParamConstructorMap';\nimport {CoreType} from '../../core/Type';\n\nenum OperatorPathMode {\n\tNODE = 'NODE',\n\tPARAM = 'PARAM',\n}\n\nexport class OperatorPathParam extends TypedPathParam<ParamType.OPERATOR_PATH> {\n\tprivate _found_node: BaseNodeType | null = null;\n\tprivate _found_node_with_expected_type: BaseNodeType | null = null;\n\tprivate _found_param: BaseParamType | null = null;\n\tprivate _found_param_with_expected_type: BaseParamType | null = null;\n\n\tstatic type() {\n\t\treturn ParamType.OPERATOR_PATH;\n\t}\n\tdefaultValueSerialized() {\n\t\treturn this._default_value;\n\t}\n\trawInputSerialized() {\n\t\treturn `${this._raw_input}`;\n\t}\n\tvalueSerialized() {\n\t\treturn `${this.value}`;\n\t}\n\tprotected _copy_value(param: OperatorPathParam) {\n\t\tthis.set(param.valueSerialized());\n\t}\n\tstatic are_raw_input_equal(\n\t\traw_input1: ParamInitValuesTypeMap[ParamType.OPERATOR_PATH],\n\t\traw_input2: ParamInitValuesTypeMap[ParamType.OPERATOR_PATH]\n\t) {\n\t\treturn raw_input1 == raw_input2;\n\t}\n\tstatic are_values_equal(\n\t\tval1: ParamValuesTypeMap[ParamType.OPERATOR_PATH],\n\t\tval2: ParamValuesTypeMap[ParamType.OPERATOR_PATH]\n\t) {\n\t\treturn val1 == val2;\n\t}\n\tisDefault(): boolean {\n\t\treturn this._value == this._default_value;\n\t}\n\tsetNode(node: BaseNodeType) {\n\t\tthis.set(node.fullPath());\n\t}\n\tprotected processRawInput() {\n\t\tif (this._value != this._raw_input) {\n\t\t\tthis._value = this._raw_input;\n\t\t\tthis.setDirty();\n\t\t\tthis.emitController.emit(ParamEvent.VALUE_UPDATED);\n\t\t}\n\t}\n\tprotected async process_computation() {\n\t\tthis.find_target();\n\t}\n\tfind_target() {\n\t\tif (!this.node) {\n\t\t\treturn;\n\t\t}\n\t\tconst path = this._value;\n\t\tlet node: BaseNodeType | null = null;\n\t\tlet param: BaseParamType | null = null;\n\t\tconst path_non_empty = path != null && path !== '';\n\t\tconst mode: OperatorPathMode = this.options.param_selection_options()\n\t\t\t? OperatorPathMode.PARAM\n\t\t\t: OperatorPathMode.NODE;\n\n\t\tthis.scene().referencesController.reset_reference_from_param(this); // must be before decomposed path is changed\n\t\tthis.decomposed_path.reset();\n\t\tif (path_non_empty) {\n\t\t\tif (mode == OperatorPathMode.PARAM) {\n\t\t\t\tparam = CoreWalker.find_param(this.node, path, this.decomposed_path);\n\t\t\t} else {\n\t\t\t\tnode = CoreWalker.find_node(this.node, path, this.decomposed_path);\n\t\t\t}\n\t\t}\n\n\t\tconst current_found_entity = mode == OperatorPathMode.PARAM ? this._found_param : this._found_node;\n\t\tconst newly_found_entity = mode == OperatorPathMode.PARAM ? param : node;\n\n\t\tthis.scene().referencesController.set_named_nodes_from_param(this);\n\t\tif (node) {\n\t\t\tthis.scene().referencesController.set_reference_from_param(this, node);\n\t\t}\n\n\t\tif (current_found_entity?.graphNodeId() !== newly_found_entity?.graphNodeId()) {\n\t\t\tconst dependent_on_found_node = this.options.dependent_on_found_node();\n\n\t\t\tif (this._found_node) {\n\t\t\t\tif (dependent_on_found_node) {\n\t\t\t\t\tthis.removeGraphInput(this._found_node);\n\t\t\t\t} else {\n\t\t\t\t\t// this._found_node.remove_param_referree(this) // TODO: typescript\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (mode == OperatorPathMode.PARAM) {\n\t\t\t\tthis._found_param = param;\n\t\t\t\tthis._found_node = null;\n\t\t\t} else {\n\t\t\t\tthis._found_node = node;\n\t\t\t\tthis._found_param = null;\n\t\t\t}\n\n\t\t\tif (node) {\n\t\t\t\tthis._assign_found_node(node);\n\t\t\t}\n\t\t\tif (param) {\n\t\t\t\tthis._assign_found_param(param);\n\t\t\t}\n\n\t\t\tthis.options.execute_callback();\n\t\t}\n\t\tthis.removeDirtyState();\n\t}\n\n\tprivate _assign_found_node(node: BaseNodeType) {\n\t\tconst dependent_on_found_node = this.options.dependent_on_found_node();\n\t\tif (this._is_node_expected_context(node)) {\n\t\t\tif (this._is_node_expected_type(node)) {\n\t\t\t\tthis._found_node_with_expected_type = node;\n\t\t\t\tif (dependent_on_found_node) {\n\t\t\t\t\tthis.addGraphInput(node);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.states.error.set(\n\t\t\t\t\t`node type is ${node.type()} but the params expects one of ${(\n\t\t\t\t\t\tthis._expected_node_types() || []\n\t\t\t\t\t).join(', ')}`\n\t\t\t\t);\n\t\t\t}\n\t\t} else {\n\t\t\tthis.states.error.set(\n\t\t\t\t`node context is ${node.nodeContext()} but the params expects a ${this._expected_context()}`\n\t\t\t);\n\t\t}\n\t}\n\tprivate _assign_found_param(param: BaseParamType) {\n\t\tif (this._is_param_expected_type(param)) {\n\t\t\tthis._found_param_with_expected_type = param;\n\t\t} else {\n\t\t\tthis.states.error.set(\n\t\t\t\t`param type is ${param.type()} but the params expects a ${this._expected_param_type()}`\n\t\t\t);\n\t\t}\n\t}\n\n\tfound_node() {\n\t\treturn this._found_node;\n\t}\n\tfound_param() {\n\t\treturn this._found_param;\n\t}\n\tfound_node_with_context<N extends NodeContext>(context: N): BaseNodeByContextMap[N] | undefined {\n\t\treturn this._found_node_with_expected_type as BaseNodeByContextMap[N];\n\t\t// if (node) {\n\t\t// \tif (node.node_context() == context) {\n\t\t// \t\treturn node as BaseNodeByContextMap[N];\n\t\t// \t} else {\n\t\t// \t\tthis.states.error.set(`expected node context to be ${context}, but was instead ${node.node_context()}`);\n\t\t// \t}\n\t\t// } else {\n\t\t// \tthis.states.error.set('no node found');\n\t\t// }\n\t}\n\t// found_node_with_context_and_type<N extends NodeContext, K extends keyof ChildrenNodeMapByContextMap[N]>(\n\t// \tcontext: N,\n\t// \ttype: K\n\t// ): ChildrenNodeMapByContextMap[N][K] | undefined {\n\tfound_node_with_context_and_type<N extends NodeContext, K extends keyof ChildrenNodeMapByContextMap[N]>(\n\t\tcontext: N,\n\t\ttype_or_types: K | K[]\n\t): ChildrenNodeMapByContextMap[N][K] | undefined {\n\t\tconst node = this.found_node_with_context(context);\n\t\tif (node) {\n\t\t\tif (CoreType.isArray(type_or_types)) {\n\t\t\t\tfor (let type of type_or_types) {\n\t\t\t\t\tif (node.type() == type) {\n\t\t\t\t\t\treturn (<unknown>node) as ChildrenNodeMapByContextMap[N][K];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis.states.error.set(\n\t\t\t\t\t`expected node type to be ${type_or_types.join(', ')}, but was instead ${node.type()}`\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tconst type = type_or_types;\n\t\t\t\tif (node.type() == type) {\n\t\t\t\t\treturn (<unknown>node) as ChildrenNodeMapByContextMap[N][K];\n\t\t\t\t} else {\n\t\t\t\t\tthis.states.error.set(`expected node type to be ${type}, but was instead ${node.type()}`);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfound_param_with_type<T extends ParamType>(type: T): ParamConstructorMap[T] | undefined {\n\t\tif (this._found_param_with_expected_type) {\n\t\t\treturn this._found_param_with_expected_type as ParamConstructorMap[T];\n\t\t}\n\t}\n\n\tfound_node_with_expected_type() {\n\t\treturn this._found_node_with_expected_type;\n\t}\n\tprivate _expected_context() {\n\t\treturn this.options.node_selection_context();\n\t}\n\tprivate _is_node_expected_context(node: BaseNodeType) {\n\t\tconst expected_context = this._expected_context();\n\t\tif (expected_context == null) {\n\t\t\treturn true;\n\t\t}\n\t\tconst node_context = node.parent()?.childrenController?.context;\n\t\treturn expected_context == node_context;\n\t}\n\tprivate _expected_node_types() {\n\t\treturn this.options.node_selection_types();\n\t}\n\tprivate _expected_param_type() {\n\t\treturn this.options.param_selection_type();\n\t}\n\tprivate _is_node_expected_type(node: BaseNodeType) {\n\t\tconst expected_types = this._expected_node_types();\n\t\tif (expected_types == null) {\n\t\t\treturn true;\n\t\t}\n\t\treturn expected_types?.includes(node.type());\n\t}\n\tprivate _is_param_expected_type(param: BaseParamType) {\n\t\tconst expected_types = this._expected_node_types();\n\t\tif (expected_types == null) {\n\t\t\treturn true;\n\t\t}\n\t\treturn expected_types.includes(param.type());\n\t}\n\n\tnotify_path_rebuild_required(node: BaseNodeType) {\n\t\tthis.decomposed_path.update_from_name_change(node);\n\t\tconst new_path = this.decomposed_path.to_path();\n\t\tthis.set(new_path);\n\t}\n\tnotify_target_param_owner_params_updated(node: BaseNodeType) {\n\t\tthis.setDirty();\n\t}\n}\n","import {TypedParam} from './_Base';\nimport {ParsedTree} from '../expressions/traversers/ParsedTree';\nimport {ParamType} from '../poly/ParamType';\nimport {ParamInitValuesTypeMap} from './types/ParamInitValuesTypeMap';\nimport {ParamValuesTypeMap} from './types/ParamValuesTypeMap';\nimport {ExpressionController} from './utils/ExpressionController';\nimport {ParamEvent} from '../poly/ParamEvent';\nimport {CoreType} from '../../core/Type';\n\nexport class StringParam extends TypedParam<ParamType.STRING> {\n\tstatic type() {\n\t\treturn ParamType.STRING;\n\t}\n\tdefaultValueSerialized() {\n\t\treturn this._default_value;\n\t}\n\tprotected _clone_raw_input(raw_input: ParamInitValuesTypeMap[ParamType.STRING]) {\n\t\treturn `${raw_input}`;\n\t}\n\trawInputSerialized() {\n\t\treturn `${this._raw_input}`;\n\t}\n\tvalueSerialized() {\n\t\treturn `${this.value}`;\n\t}\n\tprotected _copy_value(param: StringParam) {\n\t\tthis.set(param.value);\n\t}\n\n\tstatic are_raw_input_equal(\n\t\traw_input1: ParamInitValuesTypeMap[ParamType.STRING],\n\t\traw_input2: ParamInitValuesTypeMap[ParamType.STRING]\n\t) {\n\t\treturn raw_input1 == raw_input2;\n\t}\n\tstatic are_values_equal(val1: ParamValuesTypeMap[ParamType.STRING], val2: ParamValuesTypeMap[ParamType.STRING]) {\n\t\treturn val1 == val2;\n\t}\n\tisDefault(): boolean {\n\t\treturn this._raw_input == this._default_value;\n\t}\n\n\tconvert(raw_val: any): string {\n\t\tif (CoreType.isString(raw_val)) {\n\t\t\treturn raw_val;\n\t\t}\n\t\treturn `${raw_val}`;\n\t}\n\n\trawInput() {\n\t\treturn this._raw_input;\n\t}\n\tprotected processRawInput() {\n\t\tthis.states.error.clear();\n\n\t\tif (this._value_elements(this._raw_input).length >= 3) {\n\t\t\tthis._expression_controller = this._expression_controller || new ExpressionController(this);\n\t\t\tif (this._raw_input != this._expression_controller.expression()) {\n\t\t\t\tthis._expression_controller.set_expression(this._raw_input);\n\t\t\t\tthis.setDirty();\n\t\t\t\tthis.emitController.emit(ParamEvent.EXPRESSION_UPDATED);\n\t\t\t}\n\t\t} else {\n\t\t\tif (this._raw_input != this._value) {\n\t\t\t\tthis._value = this._raw_input;\n\t\t\t\tthis.removeDirtyState();\n\t\t\t\tthis.setSuccessorsDirty(this);\n\t\t\t\tthis.emitController.emit(ParamEvent.VALUE_UPDATED);\n\t\t\t\tthis.options.execute_callback();\n\t\t\t\tif (this._expression_controller) {\n\t\t\t\t\tthis._expression_controller.set_expression(undefined, false);\n\t\t\t\t\tthis.emitController.emit(ParamEvent.EXPRESSION_UPDATED); // ensure expression is considered removed\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprotected async process_computation(): Promise<void> {\n\t\tif (this.expressionController?.active() && !this.expressionController.requires_entities()) {\n\t\t\tconst expression_result = await this.expressionController.compute_expression();\n\t\t\tif (this.expressionController.is_errored()) {\n\t\t\t\tthis.states.error.set(`expression error: ${this.expressionController.error_message()}`);\n\t\t\t} else {\n\t\t\t\tconst converted = this.convert(expression_result);\n\t\t\t\t// we need to check if equal nulls explicitely\n\t\t\t\t// as the empty string '' evals to false...\n\t\t\t\tif (converted != null) {\n\t\t\t\t\tthis._value = converted;\n\t\t\t\t\tthis.emitController.emit(ParamEvent.VALUE_UPDATED);\n\t\t\t\t\tthis.options.execute_callback();\n\t\t\t\t} else {\n\t\t\t\t\tthis.states.error.set(`expression returns an invalid type (${expression_result})`);\n\t\t\t\t}\n\t\t\t\tthis.removeDirtyState();\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate _value_elements(v: string): string[] {\n\t\treturn ParsedTree.string_value_elements(v);\n\t}\n}\n","import {TypedNode} from '../_Base';\nimport {NodeContext} from '../../poly/NodeContext';\nimport {NodeParamsConfig} from '../utils/params/ParamsConfig';\nimport {EventContext} from '../../scene/utils/events/_BaseEventsController';\nimport {BaseEventConnectionPoint} from '../utils/io/connections/Event';\nimport {MapUtils} from '../../../core/MapUtils';\n\ntype DispatchHook = (event_context: EventContext<Event>) => void;\n\nexport class TypedEventNode<K extends NodeParamsConfig> extends TypedNode<NodeContext.EVENT, K> {\n\tstatic nodeContext(): NodeContext {\n\t\treturn NodeContext.EVENT;\n\t}\n\n\tinitializeBaseNode() {\n\t\tthis.uiData.setLayoutHorizontal();\n\t\t// this.addPostDirtyHook('_eval_all_params_on_dirty', this._eval_all_params_on_dirty_bound);\n\t\t// cook is required for some nodes like event/animation\n\t\tthis.addPostDirtyHook('cook_without_inputs_on_dirty', this._cook_without_inputs_bound);\n\n\t\tthis.io.inputs.set_depends_on_inputs(false);\n\t\tthis.io.connections.initInputs();\n\t\tthis.io.connection_points.spare_params.initializeNode();\n\t}\n\n\t// ensures that event nodes are cooked when scene is loaded\n\t// private _eval_all_params_on_dirty_bound = this._eval_all_params_on_dirty.bind(this);\n\t// _eval_all_params_on_dirty() {\n\t// \tthis.params.eval_all();\n\t// }\n\tprivate _cook_without_inputs_bound = this._cook_without_inputs.bind(this);\n\t_cook_without_inputs() {\n\t\tthis.cookController.cook_main_without_inputs();\n\t}\n\tcook() {\n\t\tthis.cookController.end_cook();\n\t}\n\t// eval_params_and_process_event(event_context: EventContext<Event>, connection_point: BaseEventConnectionPoint) {\n\t// \t// not evaluation params now, since we are evaluating them on dirty\n\t// \t// this.params.eval_all().then(()=>{\n\t// \t\tthis.process_event(event_context, connection_point)\n\t// \t// })\n\t// }\n\tprocess_event_via_connection_point(event_context: EventContext<Event>, connection_point: BaseEventConnectionPoint) {\n\t\tif (connection_point.event_listener) {\n\t\t\tconnection_point.event_listener(event_context);\n\t\t} else {\n\t\t\tthis.process_event(event_context);\n\t\t}\n\t}\n\tprocess_event(event_context: EventContext<Event>) {}\n\n\t//\n\t//\n\t// It may be more practical to use cook, rather than process_event\n\t// to benefit from params evaluation.\n\t// But that would mean that each node receiving an event would make the successors dirty,\n\t// which may also be problematic. So for now, I use process_event\n\t//\n\t//\n\tprotected async dispatch_event_to_output(output_name: string, event_context: EventContext<Event>) {\n\t\tthis.run_on_dispatch_hook(output_name, event_context);\n\t\tconst index = this.io.outputs.get_output_index(output_name);\n\t\tif (index >= 0) {\n\t\t\tconst connections = this.io.connections.outputConnections();\n\t\t\tconst current_connections = connections.filter((connection) => connection.output_index == index);\n\t\t\tlet dest_node: BaseEventNodeType;\n\t\t\tfor (let connection of current_connections) {\n\t\t\t\tdest_node = connection.node_dest;\n\t\t\t\tconst connection_point = dest_node.io.inputs.named_input_connection_points[connection.input_index];\n\t\t\t\tdest_node.process_event_via_connection_point(event_context, connection_point);\n\t\t\t}\n\t\t\t// const nodes = current_connections.map((connection) => connection.node_dest);\n\t\t\t// for (let node of nodes) {\n\t\t\t// \tnode.process_event(event_context);\n\t\t\t// }\n\t\t} else {\n\t\t\tconsole.warn(`requested output '${output_name}' does not exist on node '${this.fullPath()}'`);\n\t\t}\n\t}\n\n\tprivate _on_dispatch_hooks_by_output_name: Map<string, DispatchHook[]> | undefined;\n\tpublic onDispatch(output_name: string, callback: DispatchHook) {\n\t\tthis._on_dispatch_hooks_by_output_name = this._on_dispatch_hooks_by_output_name || new Map();\n\t\tMapUtils.push_on_array_at_entry(this._on_dispatch_hooks_by_output_name, output_name, callback);\n\t}\n\tprivate run_on_dispatch_hook(output_name: string, event_context: EventContext<Event>) {\n\t\tif (this._on_dispatch_hooks_by_output_name) {\n\t\t\tconst hooks = this._on_dispatch_hooks_by_output_name.get(output_name);\n\t\t\tif (hooks) {\n\t\t\t\tfor (let hook of hooks) {\n\t\t\t\t\thook(event_context);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nexport type BaseEventNodeType = TypedEventNode<any>;\nexport class BaseEventNodeClass extends TypedEventNode<any> {}\n","import {BaseParamType} from '../../params/_Base';\nimport jsep from 'jsep';\nimport {CoreType} from '../../../core/Type';\nexport const VARIABLE_PREFIX = '$';\n\nexport abstract class BaseTraverser {\n\tpublic _error_message: string | undefined;\n\n\tconstructor(public param: BaseParamType) {}\n\n\tprotected clear_error() {\n\t\tthis._error_message = undefined;\n\t}\n\tprotected set_error(message: string) {\n\t\tthis._error_message = this._error_message || message;\n\t}\n\tprotected _set_error_from_error_bound = this._set_error_from_error.bind(this);\n\tprivate _set_error_from_error(error: Error | string) {\n\t\tif (CoreType.isString(error)) {\n\t\t\tthis._error_message = error;\n\t\t} else {\n\t\t\tthis._error_message = error.message;\n\t\t}\n\t}\n\tis_errored(): boolean {\n\t\treturn this._error_message != null;\n\t}\n\terror_message() {\n\t\treturn this._error_message;\n\t}\n\treset() {\n\t\tthis._error_message = undefined;\n\t}\n\n\ttraverse_node(node: jsep.Expression): string | undefined {\n\t\tconst method_name = `traverse_${node.type}`;\n\t\tconst method = (this as any)[method_name];\n\t\tif (method) {\n\t\t\treturn (this as any)[method_name](node);\n\t\t} else {\n\t\t\tthis.set_error(`expression unknown node type: ${node.type}`);\n\t\t}\n\t}\n\n\tprotected abstract traverse_CallExpression(node: jsep.CallExpression): string | undefined; //{\n\n\tprotected traverse_BinaryExpression(node: jsep.BinaryExpression): string {\n\t\treturn `${this.traverse_node(node.left)} ${node.operator} ${this.traverse_node(node.right)}`;\n\t}\n\tprotected traverse_LogicalExpression(node: jsep.LogicalExpression): string {\n\t\t// || or &&\n\t\treturn `${this.traverse_node(node.left)} ${node.operator} ${this.traverse_node(node.right)}`;\n\t}\n\tprotected traverse_MemberExpression(node: jsep.MemberExpression): string {\n\t\treturn `${this.traverse_node(node.object)}.${this.traverse_node(node.property)}`;\n\t}\n\tprotected traverse_ConditionalExpression(node: jsep.ConditionalExpression): string {\n\t\treturn `(${this.traverse_node(node.test)}) ? (${this.traverse_node(node.consequent)}) : (${this.traverse_node(\n\t\t\tnode.alternate\n\t\t)})`;\n\t}\n\n\t// currently only used for string expressions such as\n\t// pt_`@ptnum+1`\n\tprotected traverse_Compound(node: jsep.Compound): string {\n\t\tconst args = node.body;\n\t\tlet traversed_args = [];\n\t\tfor (let i = 0; i < args.length; i++) {\n\t\t\tconst arg_node = args[i];\n\t\t\tif (arg_node.type == 'Identifier') {\n\t\t\t\tif ((arg_node as jsep.Identifier).name[0] == VARIABLE_PREFIX) {\n\t\t\t\t\ttraversed_args.push('`${' + this.traverse_node(arg_node) + '}`');\n\t\t\t\t} else {\n\t\t\t\t\ttraversed_args.push(`'${(arg_node as jsep.Identifier).name}'`);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\ttraversed_args.push('`${' + this.traverse_node(arg_node) + '}`');\n\t\t\t}\n\t\t}\n\t\treturn traversed_args.join(' + ');\n\t}\n\tprotected abstract traverse_UnaryExpression(node: jsep.UnaryExpression): string; //{\n\n\tprotected traverse_Literal(node: jsep.Literal): string {\n\t\treturn `${node.raw}`; // 5 or 'string' (raw will include quotes)\n\t}\n\n\tprotected abstract traverse_Identifier(node: jsep.Identifier): string | undefined; //{\n}\n","export class AttributeRequirementsController {\n\tprivate _attribute_names: Set<string> | undefined;\n\tconstructor() {}\n\n\treset() {\n\t\tif (this._attribute_names) {\n\t\t\tthis._attribute_names.clear();\n\t\t}\n\t}\n\tassign_attributes_lines(): string {\n\t\tif (this._attribute_names) {\n\t\t\tconst lines: string[] = [];\n\t\t\tthis._attribute_names?.forEach((attribute_name: string) => {\n\t\t\t\tlines.push(AttributeRequirementsController.assign_attribute_line(attribute_name));\n\t\t\t});\n\t\t\treturn lines.join(';\\n');\n\t\t} else {\n\t\t\treturn '';\n\t\t}\n\t}\n\tassign_arrays_lines(): string {\n\t\tif (this._attribute_names) {\n\t\t\tconst lines: string[] = [];\n\t\t\tthis._attribute_names?.forEach((attribute_name: string) => {\n\t\t\t\tlines.push(AttributeRequirementsController.assign_item_size_line(attribute_name));\n\t\t\t\tlines.push(AttributeRequirementsController.assign_array_line(attribute_name));\n\t\t\t});\n\t\t\treturn lines.join(';\\n');\n\t\t} else {\n\t\t\treturn '';\n\t\t}\n\t}\n\tattribute_presence_check_line(): string {\n\t\tif (this._attribute_names) {\n\t\t\tconst var_names: string[] = [];\n\t\t\tthis._attribute_names?.forEach((attribute_name: string) => {\n\t\t\t\tconst var_name = AttributeRequirementsController.var_attribute(attribute_name);\n\t\t\t\tvar_names.push(var_name);\n\t\t\t});\n\t\t\tif (var_names.length > 0) {\n\t\t\t\treturn var_names.join(' && ');\n\t\t\t}\n\t\t}\n\t\t// TODO: add test that a Point Sop can take an expression that does not require attributes\n\t\treturn 'true';\n\t}\n\n\tadd(attribute_name: string) {\n\t\tthis._attribute_names = this._attribute_names || new Set<string>();\n\t\tthis._attribute_names.add(attribute_name);\n\t}\n\n\tstatic assign_attribute_line(attribute_name: string) {\n\t\tconst var_attribute = this.var_attribute(attribute_name);\n\t\treturn `const ${var_attribute} = entities[0].geometry().attributes['${attribute_name}']`;\n\t}\n\tstatic assign_item_size_line(attribute_name: string) {\n\t\tconst var_attribute = this.var_attribute(attribute_name);\n\t\tconst var_attribute_size = this.var_attribute_size(attribute_name);\n\t\treturn `const ${var_attribute_size} = ${var_attribute}.itemSize`;\n\t}\n\tstatic assign_array_line(attribute_name: string) {\n\t\tconst var_attribute = this.var_attribute(attribute_name);\n\t\tconst var_array = this.var_array(attribute_name);\n\t\treturn `const ${var_array} = ${var_attribute}.array`;\n\t}\n\n\tstatic var_attribute(attribute_name: string) {\n\t\treturn `attrib_${attribute_name}`;\n\t}\n\tstatic var_attribute_size(attribute_name: string) {\n\t\treturn `attrib_size_${attribute_name}`;\n\t}\n\tstatic var_array(attribute_name: string) {\n\t\treturn `array_${attribute_name}`;\n\t}\n\tvar_attribute_size(attribute_name: string) {\n\t\treturn AttributeRequirementsController.var_attribute_size(attribute_name);\n\t}\n\tvar_array(attribute_name: string) {\n\t\treturn AttributeRequirementsController.var_array(attribute_name);\n\t}\n}\n","/**\n * The following expressions are available to use in most parameters:\n *\n * ## variables\n *\n * - $F: current frame\n * - $T: current time\n * - $CH: current param name\n * - $CEX: input centroid x component\n * - $CEY: input centroid y component\n * - $CEZ: input centroid z component\n *\n * Those variables are aliases to the javascript math module:\n *\n * - $E\n * - $LN2\n * - $LN10\n * - $LOG10E\n * - $LOG2E\n * - $PI\n * - $SQRT1_2\n * - $SQRT2\n *\n * ## math expressions\n *\n * The following are native javascript functions:\n *\n * - abs\n * - acos\n * - acosh\n * - asin\n * - asinh\n * - atan\n * - atan2\n * - atanh\n * - ceil\n * - cos\n * - cosh\n * - exp\n * - expm1\n * - floor\n * - log\n * - log1p\n * - log2\n * - log10\n * - max\n * - min\n * - pow\n * - random (which aliases to Math.rand())\n * - round\n * - sign\n * - sin\n * - sinh\n * - sqrt\n * - tan\n * - tanh\n *\n * If you are targetting ES6 (available in modern browsers), you can also have:\n *\n * - cbrt\n * - hypot\n * - log10\n * - trunc\n *\n * The following are aliases from the [Polygonjs CoreMath](https://github.com/polygonjs/polygonjs-engine/blob/master/src/core/math/_Module.ts) module:\n *\n * - fit\n * - fit01\n * - fract\n * - deg2rad\n * - rad2deg\n * - rand\n * - clamp\n *\n * And the following are alias to the [Polygonjs Easing](https://github.com/polygonjs/polygonjs-engine/blob/master/src/core/math/Easing.ts) module:\n *\n * - linear\n * - ease_i\n * - ease_o\n * - ease_io\n * - ease_i2\n * - ease_o2\n * - ease_io2\n * - ease_i3\n * - ease_o3\n * - ease_io3\n * - ease_i4\n * - ease_o4\n * - ease_io4\n * - ease_i_sin\n * - ease_o_sin\n * - ease_io_sin\n * - ease_i_elastic\n * - ease_o_elastic\n * - ease_io_elastic\n *\n *\n * ## string expressions:\n *\n * - precision (alias to the [CoreString](https://github.com/polygonjs/polygonjs-engine/blob/master/src/core/String.ts) module precision method)\n * - [strCharsCount](/docs/expressions/strCharsCount)\n * - [strConcat](/docs/expressions/strConcat)\n * - [strIndex](/docs/expressions/strIndex)\n * - [strSub](/docs/expressions/strSub)\n *\n *  */\n\nimport {BaseParamType} from '../../params/_Base';\nimport {CoreGraphNode} from '../../../core/graph/CoreGraphNode';\nimport {ParsedTree} from './ParsedTree';\nimport {LiteralConstructsController, LiteralConstructMethod} from '../LiteralConstructsController';\nimport {BaseMethod} from '../methods/_Base';\nimport {CoreAttribute} from '../../../core/geometry/Attribute';\n\n// import {JsepsByString} from '../DependenciesController'\nimport jsep from 'jsep';\n\n// import {Vector3} from 'three/src/math/Vector3'\ntype LiteralConstructDictionary = PolyDictionary<LiteralConstructMethod>;\ntype AnyDictionary = PolyDictionary<any>;\n\nconst NATIVE_MATH_METHODS = [\n\t'abs',\n\t'acos',\n\t'acosh',\n\t'asin',\n\t'asinh',\n\t'atan',\n\t'atan2',\n\t'atanh',\n\t'ceil',\n\t'cos',\n\t'cosh',\n\t'exp',\n\t'expm1',\n\t'floor',\n\t'log',\n\t'log1p',\n\t'log2',\n\t'log10',\n\t'max',\n\t'min',\n\t'pow',\n\t'round',\n\t'sign',\n\t'sin',\n\t'sinh',\n\t'sqrt',\n\t'tan',\n\t'tanh',\n];\nconst NATIVE_ES6_MATH_METHODS = ['cbrt', 'hypot', 'log10', 'trunc'];\nconst NATIVE_MATH_METHODS_RENAMED: AnyDictionary = {\n\tmath_random: 'random',\n};\nconst CORE_MATH_METHODS = ['fit', 'fit01', 'fract', 'deg2rad', 'rad2deg', 'rand', 'clamp'];\nimport {Easing} from '../../../core/math/Easing';\nconst EASING_METHODS = Object.keys(Easing);\n\nconst CORE_STRING_METHODS = ['precision'];\nconst NATIVE_MATH_CONSTANTS = ['E', 'LN2', 'LN10', 'LOG10E', 'LOG2E', 'PI', 'SQRT1_2', 'SQRT2'];\n\nconst DIRECT_EXPRESSION_FUNCTIONS: AnyDictionary = {};\nNATIVE_MATH_METHODS.forEach((name) => {\n\tDIRECT_EXPRESSION_FUNCTIONS[name] = `Math.${name}`;\n});\nNATIVE_ES6_MATH_METHODS.forEach((name) => {\n\tDIRECT_EXPRESSION_FUNCTIONS[name] = `Math.${name}`;\n});\nObject.keys(NATIVE_MATH_METHODS_RENAMED).forEach((name) => {\n\tconst remaped = NATIVE_MATH_METHODS_RENAMED[name];\n\tDIRECT_EXPRESSION_FUNCTIONS[name] = `Math.${remaped}`;\n});\nCORE_MATH_METHODS.forEach((name) => {\n\tDIRECT_EXPRESSION_FUNCTIONS[name] = `Core.Math.${name}`;\n});\nEASING_METHODS.forEach((name) => {\n\tDIRECT_EXPRESSION_FUNCTIONS[name] = `Core.Math.Easing.${name}`;\n});\nCORE_STRING_METHODS.forEach((name) => {\n\tDIRECT_EXPRESSION_FUNCTIONS[name] = `Core.String.${name}`;\n});\n\nconst LITERAL_CONSTRUCT: LiteralConstructDictionary = {\n\tif: LiteralConstructsController.if,\n};\n\nconst GLOBAL_CONSTANTS: PolyDictionary<string> = {};\nNATIVE_MATH_CONSTANTS.forEach((name) => {\n\tGLOBAL_CONSTANTS[name] = `Math.${name}`;\n});\n\nconst QUOTE = \"'\";\nconst ARGUMENTS_SEPARATOR = ', ';\nconst ATTRIBUTE_PREFIX = '@';\nimport {VARIABLE_PREFIX} from './_Base';\n\nconst PROPERTY_OFFSETS: AnyDictionary = {\n\tx: 0,\n\ty: 1,\n\tz: 2,\n\tw: 3,\n\tr: 0,\n\tg: 1,\n\tb: 2,\n};\n\nimport {BaseTraverser} from './_Base';\nimport {MethodDependency} from '../MethodDependency';\nimport {AttributeRequirementsController} from '../AttributeRequirementsController';\nimport {CoreMath} from '../../../core/math/_Module';\nimport {CoreString} from '../../../core/String';\n\n// import {AsyncFunction} from '../../../core/AsyncFunction';\nimport {Poly} from '../../Poly';\nimport {CoreType} from '../../../core/Type';\nimport {PolyDictionary} from '../../../types/GlobalTypes';\n\nexport class FunctionGenerator extends BaseTraverser {\n\tprivate function: Function | undefined;\n\tprivate _attribute_requirements_controller = new AttributeRequirementsController();\n\tprivate function_main_string: string | undefined;\n\tprivate methods: BaseMethod[] = [];\n\tprivate method_index: number = -1;\n\n\tpublic method_dependencies: MethodDependency[] = [];\n\tpublic immutable_dependencies: CoreGraphNode[] = [];\n\t// public jsep_dependencies: JsepDependency[] = []\n\t// public jsep_nodes_by_missing_paths: JsepsByString = {}\n\n\t// private string_generator: ExpressionStringGenerator = new ExpressionStringGenerator()\n\n\tconstructor(public param: BaseParamType) {\n\t\tsuper(param);\n\t}\n\n\tpublic parse_tree(parsed_tree: ParsedTree) {\n\t\tthis.reset();\n\n\t\tif (parsed_tree.error_message == null) {\n\t\t\ttry {\n\t\t\t\t// this.function_pre_entities_loop_lines = [];\n\t\t\t\tthis._attribute_requirements_controller.reset();\n\t\t\t\t// this.function_pre_body = ''\n\t\t\t\tif (parsed_tree.node) {\n\t\t\t\t\tconst function_main_string = this.traverse_node(parsed_tree.node);\n\t\t\t\t\tif (function_main_string && !this.is_errored()) {\n\t\t\t\t\t\tthis.function_main_string = function_main_string;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tconsole.warn('no parsed_tree.node');\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\tconsole.warn(`error in expression for param ${this.param.fullPath()}`);\n\t\t\t\tconsole.warn(e);\n\t\t\t}\n\n\t\t\tif (this.function_main_string) {\n\t\t\t\ttry {\n\t\t\t\t\t// not sure why I needed AsyncFunction\n\t\t\t\t\tthis.function = new Function(\n\t\t\t\t\t\t'Core',\n\t\t\t\t\t\t'param',\n\t\t\t\t\t\t'methods',\n\t\t\t\t\t\t'_set_error_from_error',\n\t\t\t\t\t\t`\n\t\t\t\t\ttry {\n\t\t\t\t\t\t${this.function_body()}\n\t\t\t\t\t} catch(e) {\n\t\t\t\t\t\t_set_error_from_error(e)\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}`\n\t\t\t\t\t);\n\t\t\t\t} catch (e) {\n\t\t\t\t\tconsole.warn(e);\n\t\t\t\t\tthis.set_error('cannot generate function');\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.set_error('cannot generate function body');\n\t\t\t}\n\t\t} else {\n\t\t\tthis.set_error('cannot parse expression');\n\t\t}\n\t}\n\n\treset() {\n\t\tsuper.reset();\n\t\tthis.function_main_string = undefined;\n\t\tthis.methods = [];\n\t\tthis.method_index = -1;\n\t\tthis.function = undefined;\n\t\tthis.method_dependencies = [];\n\t\tthis.immutable_dependencies = [];\n\t}\n\n\tfunction_body() {\n\t\tif (this.param.options.is_expression_for_entities()) {\n\t\t\treturn `\n\t\t\tconst entities = param.expressionController.entities();\n\t\t\tif(entities){\n\t\t\t\treturn new Promise( async (resolve, reject)=>{\n\t\t\t\t\tlet entity;\n\t\t\t\t\tconst entity_callback = param.expressionController.entity_callback();\n\t\t\t\t\t${this._attribute_requirements_controller.assign_attributes_lines()}\n\t\t\t\t\tif( ${this._attribute_requirements_controller.attribute_presence_check_line()} ){\n\t\t\t\t\t\t${this._attribute_requirements_controller.assign_arrays_lines()}\n\t\t\t\t\t\tfor(let index=0; index < entities.length; index++){\n\t\t\t\t\t\t\tentity = entities[index];\n\t\t\t\t\t\t\tresult = ${this.function_main_string};\n\t\t\t\t\t\t\tentity_callback(entity, result);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tresolve()\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst error = new Error('attribute not found')\n\t\t\t\t\t\t_set_error_from_error(error)\n\t\t\t\t\t\treject(error)\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t}\n\t\t\treturn []`;\n\t\t} else {\n\t\t\treturn `\n\t\t\treturn new Promise( async (resolve, reject)=>{\n\t\t\t\ttry {\n\t\t\t\t\tconst value = ${this.function_main_string}\n\t\t\t\t\tresolve(value)\n\t\t\t\t} catch(e) {\n\t\t\t\t\t_set_error_from_error(e)\n\t\t\t\t\treject()\n\t\t\t\t}\n\t\t\t})\n\t\t\t`;\n\t\t}\n\t}\n\n\teval_allowed(): boolean {\n\t\treturn this.function != null;\n\t}\n\teval_function() {\n\t\t// this.param.entity_attrib_values = this.param.entity_attrib_values || {}\n\t\t// this.param.entity_attrib_values.position =\n\t\t// \tthis.param.entity_attrib_values.position || new THREE.Vector3()\n\t\tif (this.function) {\n\t\t\tthis.clear_error();\n\n\t\t\tconst Core = {\n\t\t\t\tMath: CoreMath,\n\t\t\t\tString: CoreString,\n\t\t\t};\n\t\t\tconst result = this.function(Core, this.param, this.methods, this._set_error_from_error_bound);\n\t\t\treturn result;\n\t\t}\n\t}\n\n\t//\n\t//\n\t// TRAVERSE METHODS\n\t//\n\t//\n\tprotected traverse_CallExpression(node: jsep.CallExpression): string | undefined {\n\t\tconst method_arguments = node.arguments.map((arg) => {\n\t\t\treturn this.traverse_node(arg);\n\t\t});\n\t\tconst callee = node.callee as jsep.Identifier;\n\t\tconst method_name = callee.name;\n\t\tif (method_name) {\n\t\t\t// literal construct (if...)\n\t\t\tconst literal_contruct = LITERAL_CONSTRUCT[method_name];\n\t\t\tif (literal_contruct) {\n\t\t\t\treturn literal_contruct(method_arguments);\n\t\t\t}\n\n\t\t\t// direct expressions (Math.floor, Math.sin...)\n\t\t\tconst arguments_joined = `${method_arguments.join(ARGUMENTS_SEPARATOR)}`;\n\t\t\tconst direct_function_name = DIRECT_EXPRESSION_FUNCTIONS[method_name];\n\t\t\tif (direct_function_name) {\n\t\t\t\treturn `${direct_function_name}(${arguments_joined})`;\n\t\t\t}\n\n\t\t\t// indirect methods (pointsCount, asset...)\n\t\t\tconst expressionRegister = Poly.expressionsRegister;\n\t\t\tconst indirect_method = expressionRegister.getMethod(method_name);\n\t\t\tif (indirect_method) {\n\t\t\t\tconst path_node = node.arguments[0];\n\t\t\t\t// const path_argument = this.string_generator.traverse_node(path_node)\n\t\t\t\tconst function_string = `return ${method_arguments[0]}`;\n\t\t\t\tlet path_argument_function;\n\t\t\t\tlet path_argument = [];\n\t\t\t\ttry {\n\t\t\t\t\tpath_argument_function = new Function(function_string);\n\t\t\t\t\tpath_argument = path_argument_function();\n\t\t\t\t} catch {\n\t\t\t\t\t// path_argument_function = new AsyncFunction(function_string)\n\t\t\t\t\t// it looks like if the input contains an await,\n\t\t\t\t\t// it is because it has been generated by another indirect function.\n\t\t\t\t\t// This means that the dependencies have been generated already\n\t\t\t\t\t// so we may not need to do it now\n\t\t\t\t}\n\t\t\t\tthis._create_method_and_dependencies(method_name, path_argument, path_node);\n\t\t\t\treturn `(await methods[${this.method_index}].process_arguments([${arguments_joined}]))`;\n\t\t\t} else {\n\t\t\t\tconst available_methods = expressionRegister.availableMethods().join(', ');\n\t\t\t\tconst message = `method not found (${method_name}), available methods are: ${available_methods}`;\n\t\t\t\tPoly.warn(message);\n\t\t\t}\n\t\t}\n\n\t\tthis.set_error(`unknown method: ${method_name}`);\n\t}\n\tprotected traverse_BinaryExpression(node: jsep.BinaryExpression): string {\n\t\t// if(node.right.type == 'Identifier'){\n\t\t// \tthis.set_error(`cannot have identifier after ${node.operator}`)\n\t\t// \treturn \"\"\n\t\t// }\n\t\treturn `(${this.traverse_node(node.left)} ${node.operator} ${this.traverse_node(node.right)})`;\n\t}\n\tprotected traverse_LogicalExpression(node: jsep.LogicalExpression): string {\n\t\t// || or &&\n\t\t// if(node.right.type == 'Identifier'){\n\t\t// \tthis.set_error(`cannot have identifier after ${node.operator}`)\n\t\t// \treturn \"\"\n\t\t// }\n\t\treturn `(${this.traverse_node(node.left)} ${node.operator} ${this.traverse_node(node.right)})`;\n\t}\n\tprotected traverse_MemberExpression(node: jsep.MemberExpression): string {\n\t\treturn `${this.traverse_node(node.object)}.${this.traverse_node(node.property)}`;\n\t}\n\tprotected traverse_UnaryExpression(node: jsep.UnaryExpression): string {\n\t\tif (node.operator === ATTRIBUTE_PREFIX) {\n\t\t\tlet argument = node.argument;\n\t\t\tlet attribute_name;\n\t\t\tlet property;\n\t\t\tswitch (argument.type) {\n\t\t\t\tcase 'Identifier': {\n\t\t\t\t\tconst argument_identifier = (<unknown>argument) as jsep.Identifier;\n\t\t\t\t\tattribute_name = argument_identifier.name;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 'MemberExpression': {\n\t\t\t\t\tconst argument_member_expression = (<unknown>argument) as jsep.MemberExpression;\n\t\t\t\t\tconst attrib_node = argument_member_expression.object as jsep.Identifier;\n\t\t\t\t\tconst property_node = argument_member_expression.property as jsep.Identifier;\n\t\t\t\t\tattribute_name = attrib_node.name;\n\t\t\t\t\tproperty = property_node.name;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// this.function_pre_body += `\n\t\t\t// param.entity_attrib_value(${QUOTE}${attrib_node.name}${QUOTE}, param.entity_attrib_values.position);\n\t\t\t// `\n\t\t\tif (attribute_name) {\n\t\t\t\tattribute_name = CoreAttribute.remap_name(attribute_name);\n\t\t\t\tif (attribute_name == 'ptnum') {\n\t\t\t\t\treturn '((entity != null) ? entity.index() : 0)';\n\t\t\t\t} else {\n\t\t\t\t\tconst var_attribute_size = this._attribute_requirements_controller.var_attribute_size(\n\t\t\t\t\t\tattribute_name\n\t\t\t\t\t);\n\t\t\t\t\tconst var_array = this._attribute_requirements_controller.var_array(attribute_name);\n\t\t\t\t\tthis._attribute_requirements_controller.add(attribute_name);\n\t\t\t\t\tif (property) {\n\t\t\t\t\t\tconst property_offset = PROPERTY_OFFSETS[property];\n\t\t\t\t\t\treturn `${var_array}[entity.index()*${var_attribute_size}+${property_offset}]`;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn `${var_array}[entity.index()*${var_attribute_size}]`;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconsole.warn('attribute not found');\n\t\t\t\treturn '';\n\t\t\t}\n\t\t} else {\n\t\t\treturn `${node.operator}${this.traverse_node(node.argument)}`; // -5\n\t\t}\n\t}\n\n\tprotected traverse_Literal(node: jsep.Literal): string {\n\t\treturn `${node.raw}`; // 5 or 'string' (raw will include quotes)\n\t}\n\n\tprotected traverse_Identifier(node: jsep.Identifier): string | undefined {\n\t\tconst identifier_first_char = node.name[0];\n\t\tif (identifier_first_char == VARIABLE_PREFIX) {\n\t\t\tconst identifier_name_without_dollar_sign = node.name.substr(1);\n\n\t\t\t// globals constants: Math.PI or Math.E\n\t\t\tconst direct_constant_name = GLOBAL_CONSTANTS[identifier_name_without_dollar_sign];\n\t\t\tif (direct_constant_name) {\n\t\t\t\treturn direct_constant_name;\n\t\t\t}\n\n\t\t\t// scene or node globals: $F, $T, $CH, $OS\n\t\t\tconst method_name = `traverse_Identifier_${identifier_name_without_dollar_sign}`;\n\t\t\tconst method = (this as any)[method_name];\n\t\t\tif (method) {\n\t\t\t\treturn (this as any)[method_name]();\n\t\t\t} else {\n\t\t\t\tthis.set_error(`identifier unknown: ${node.name}`);\n\t\t\t}\n\t\t} else {\n\t\t\treturn node.name; // @ptnum will call this method and return \"ptnum\"\n\t\t}\n\t}\n\n\t//\n\t//\n\t// Identifier methods (called from Identifier_body)\n\t//\n\t//\n\tprotected traverse_Identifier_F(): string {\n\t\tthis.immutable_dependencies.push(this.param.scene().timeController.graphNode);\n\t\treturn `param.scene().timeController.frame()`;\n\t}\n\t// protected traverse_Identifier_FPS(): string {\n\t// \tthis.immutable_dependencies.push(this.param.scene().timeController.graphNode);\n\t// \treturn `param.scene().timeController.fps`;\n\t// }\n\tprotected traverse_Identifier_T(): string {\n\t\tthis.immutable_dependencies.push(this.param.scene().timeController.graphNode);\n\t\treturn `param.scene().timeController.time()`;\n\t}\n\tprotected traverse_Identifier_CH(): string {\n\t\treturn `${QUOTE}${this.param.name()}${QUOTE}`;\n\t}\n\tprotected traverse_Identifier_CEX(): string {\n\t\treturn this._method_centroid('x');\n\t}\n\tprotected traverse_Identifier_CEY(): string {\n\t\treturn this._method_centroid('y');\n\t}\n\tprotected traverse_Identifier_CEZ(): string {\n\t\treturn this._method_centroid('z');\n\t}\n\t// TODO:\n\t// '$OS': '_eval_identifier_as_node_name',\n\t// '$BBX': '_eval_identifier_as_bounding_box_relative',\n\n\tprivate _method_centroid(component: string): string {\n\t\tconst method_arguments = [0, `${QUOTE}${component}${QUOTE}`];\n\t\tconst arguments_joined = method_arguments.join(ARGUMENTS_SEPARATOR);\n\t\tthis._create_method_and_dependencies('centroid', 0);\n\t\treturn `(await methods[${this.method_index}].process_arguments([${arguments_joined}]))`;\n\t}\n\n\t//\n\t//\n\t// Methods dependencies\n\t//\n\t//\n\tprivate _create_method_and_dependencies(\n\t\tmethod_name: string,\n\t\tpath_argument: number | string,\n\t\tpath_node?: jsep.Expression\n\t) {\n\t\tconst expressionRegister = Poly.expressionsRegister;\n\t\tconst method_constructor = expressionRegister.getMethod(method_name);\n\t\tif (!method_constructor) {\n\t\t\tconst available_methods = expressionRegister.availableMethods();\n\t\t\tconst message = `method not found (${method_name}), available methods are: ${available_methods.join(', ')}`;\n\t\t\tthis.set_error(message);\n\t\t\tPoly.warn(message);\n\t\t\treturn;\n\t\t}\n\t\tconst method = new method_constructor(this.param) as BaseMethod;\n\t\tthis.method_index += 1;\n\t\tthis.methods[this.method_index] = method;\n\n\t\tif (method.require_dependency()) {\n\t\t\tconst method_dependency = method.find_dependency(path_argument);\n\t\t\tif (method_dependency) {\n\t\t\t\tif (path_node) {\n\t\t\t\t\tmethod_dependency.set_jsep_node(path_node);\n\t\t\t\t}\n\t\t\t\tthis.method_dependencies.push(method_dependency);\n\t\t\t} else {\n\t\t\t\tif (path_node && CoreType.isString(path_argument)) {\n\t\t\t\t\tthis.param\n\t\t\t\t\t\t.scene()\n\t\t\t\t\t\t.missingExpressionReferencesController.register(this.param, path_node, path_argument);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// method_dependencies.resolved_graph_nodes.forEach((graph_node)=>{\n\t\t// \tif(path_node){\n\t\t// \t\tconst jsep_dependency = new JsepDependency(graph_node, path_node)\n\t\t// \t\tthis.jsep_dependencies.push(jsep_dependency)\n\t\t// \t} else {\n\t\t// \t\tthis.immutable_dependencies.push(graph_node)\n\t\t// \t}\n\n\t\t// })\n\n\t\t// if(path_node){\n\t\t// \treference_search_result.missing_paths.forEach((path)=>{\n\t\t// \t\tthis.jsep_nodes_by_missing_paths[path] = this.jsep_nodes_by_missing_paths[path] || []\n\t\t// \t\tthis.jsep_nodes_by_missing_paths[path].push(path_node)\n\t\t// \t})\n\t\t// }\n\t}\n}\n","export type LiteralConstructMethod = (args: any[]) => string\n\nexport class LiteralConstructsController {\n\tstatic if(args: any[]): string {\n\t\tconst condition = args[0]\n\t\tconst val_true = args[1]\n\t\tconst val_false = args[2]\n\t\treturn `(${condition}) ? (${val_true}) : (${val_false})`\n\t}\n}\n","import {BaseParamType} from '../../params/_Base';\nimport {ParsedTree} from './ParsedTree';\nimport jsep from 'jsep';\n\nconst ARGUMENTS_SEPARATOR = ', ';\n\nimport {BaseTraverser} from './_Base';\n\nexport class ExpressionStringGenerator extends BaseTraverser {\n\tconstructor(public param: BaseParamType) {\n\t\tsuper(param);\n\t}\n\n\tparse_tree(parsed_tree: ParsedTree) {\n\t\tif (parsed_tree.error_message == null && parsed_tree.node) {\n\t\t\ttry {\n\t\t\t\treturn this.traverse_node(parsed_tree.node);\n\t\t\t} catch (e) {\n\t\t\t\tthis.set_error('could not traverse tree');\n\t\t\t}\n\t\t} else {\n\t\t\tthis.set_error('cannot parse tree');\n\t\t}\n\t}\n\n\tprotected traverse_CallExpression(node: jsep.CallExpression): string {\n\t\tconst method_arguments = node.arguments.map((arg) => {\n\t\t\treturn this.traverse_node(arg);\n\t\t});\n\t\tconst arguments_joined = `${method_arguments.join(ARGUMENTS_SEPARATOR)}`;\n\n\t\tconst method_name = (node.callee as jsep.Identifier).name;\n\t\treturn `${method_name}(${arguments_joined})`;\n\t}\n\tprotected traverse_UnaryExpression(node: jsep.UnaryExpression): string {\n\t\treturn `${node.operator}${this.traverse_node(node.argument)}`; // -5\n\t}\n\n\tprotected traverse_Identifier(node: jsep.Identifier): string {\n\t\treturn `${node.name}`;\n\t}\n}\n","import {BaseParamType} from '../params/_Base';\n// import {ParsedTree} from './Traverser/ParsedTree'\nimport {FunctionGenerator} from './traversers/FunctionGenerator';\n// import {NodeSimple} from '../../core/graph/NodeSimple'\n// import {MissingReferencesController} from './MissingReferencesController'\n// import {NamesListener} from './NamesListener'\nimport {MethodDependency} from './MethodDependency';\nimport jsep from 'jsep';\n\nexport interface JsepsByString {\n\t[propName: string]: jsep.Expression[];\n}\n\nexport class DependenciesController {\n\terror_message: string | undefined;\n\t// private references_controller: MissingReferencesController\n\tprivate cyclic_graph_detected: boolean = false;\n\t// private jsep_nodes_by_missing_paths: JsepsByString = {}\n\tprivate method_dependencies: MethodDependency[] = [];\n\n\t// private names_listeners: NamesListener[] = []\n\n\tconstructor(public param: BaseParamType) {\n\t\t// this.references_controller = this.param.scene().missing_expression_references_controller\n\t}\n\n\tprotected set_error(message: string) {\n\t\tthis.error_message = this.error_message || message;\n\t}\n\n\treset() {\n\t\tthis.param.graphDisconnectPredecessors();\n\n\t\tthis.method_dependencies.forEach((method_dependency) => {\n\t\t\tmethod_dependency.reset();\n\t\t});\n\t\tthis.method_dependencies = [];\n\n\t\t// this.jsep_nodes_by_missing_paths = {}\n\t\t// const ref_ids = Object.keys(this.missing_expression_references_by_id)\n\t\t// ref_ids.forEach(ref_id=>{\n\t\t// \tconst ref = this.missing_expression_references_by_id[ref_id]\n\t\t// \tthis.references_controller.unregister(ref)\n\t\t// })\n\t\t// this.missing_expression_references_by_id = {}\n\n\t\t// this.names_listeners.forEach(names_listener=>{names_listener.reset()})\n\t}\n\n\tupdate(function_generator: FunctionGenerator) {\n\t\t// const immutable_dependencies = function_generator.immutable_dependencies\n\t\t// const jsep_dependencies = function_generator.jsep_dependencies\n\t\t// const jsep_nodes_by_missing_paths = function_generator.jsep_nodes_by_missing_paths\n\n\t\t// if(jsep_dependencies.length > 0){\n\t\t// \tconsole.log(\"connect_param_to_dependencies\", this.param.fullPath())\n\t\t// }\n\n\t\tthis.cyclic_graph_detected = false;\n\n\t\tthis.connect_immutable_dependencies(function_generator);\n\t\tthis.method_dependencies = function_generator.method_dependencies;\n\t\tthis.handle_method_dependencies();\n\t\t// this.connect_missing_paths(function_generator)\n\n\t\tthis.listen_for_name_changes();\n\t}\n\n\tprivate connect_immutable_dependencies(function_generator: FunctionGenerator) {\n\t\tfunction_generator.immutable_dependencies.forEach((dependency) => {\n\t\t\tif (this.cyclic_graph_detected == false) {\n\t\t\t\tif (this.param.addGraphInput(dependency) == false) {\n\t\t\t\t\tthis.cyclic_graph_detected = true;\n\t\t\t\t\tthis.set_error('cannot create expression, infinite graph detected');\n\t\t\t\t\tthis.reset();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\tprivate handle_method_dependencies() {\n\t\tthis.method_dependencies.forEach((method_dependency) => {\n\t\t\tif (this.cyclic_graph_detected == false) {\n\t\t\t\tthis.handle_method_dependency(method_dependency);\n\t\t\t}\n\t\t});\n\t}\n\n\tprivate handle_method_dependency(method_dependency: MethodDependency) {\n\t\tconst node_simple = method_dependency.resolved_graph_node;\n\n\t\tif (node_simple) {\n\t\t\t// this should update the jsep_node, and run the expression to string parser\n\t\t\t// when a name in the referenced nodes is updated\n\t\t\t// const names_listener = new NamesListener(this.param, node_simple, jsep_node)\n\t\t\t// TODO: test that it is no longer active if expression is updated\n\n\t\t\tif (!this.param.addGraphInput(node_simple)) {\n\t\t\t\tthis.cyclic_graph_detected = true;\n\t\t\t\tthis.set_error('cannot create expression, infinite graph detected');\n\t\t\t\tthis.reset();\n\t\t\t\treturn;\n\t\t\t}\n\t\t} // else {\n\t\t// const jsep_node = method_dependency.jsep_node\n\t\t//}\n\t}\n\n\tprivate listen_for_name_changes() {\n\t\tthis.method_dependencies.forEach((method_dependency) => {\n\t\t\tmethod_dependency.listen_for_name_changes();\n\t\t});\n\t}\n\n\t// private connect_missing_paths(function_generator: FunctionGenerator){\n\n\t// \tconst jsep_nodes_by_missing_paths = function_generator.jsep_nodes_by_missing_paths\n\t// \tconst missing_paths = Object.keys(jsep_nodes_by_missing_paths)\n\n\t// \tmissing_paths.forEach((missing_path)=>{\n\t// \t\tconst fullPath = CoreWalker.make_absolute(this.param.node(), missing_path)\n\t// \t\tconst jsep_nodes = jsep_nodes_by_missing_paths[missing_path]\n\t// \t\tjsep_nodes.forEach(jsep_node=>{\n\t// \t\t\tconst missing_expression_reference = this.references_controller.register(this.param, jsep_node, fullPath)\n\n\t// \t\t\tthis.missing_expression_references_by_id[missing_expression_reference.id] = missing_expression_reference\n\t// \t\t})\n\t// \t})\n\n\t// }\n}\n","import {BaseParamType} from '../params/_Base';\nimport {ParsedTree} from './traversers/ParsedTree';\n// import {MissingReferencesController} from './MissingReferencesController'\n// import CoreWalker from 'src/core/Walker'\n\nimport {FunctionGenerator} from './traversers/FunctionGenerator';\nimport {ExpressionStringGenerator} from './traversers/ExpressionStringGenerator';\nimport {DependenciesController} from './DependenciesController';\nimport {ParamType} from '../poly/ParamType';\n\nexport class ExpressionManager {\n\tpublic parse_completed: boolean = false;\n\tprivate parse_started: boolean = false;\n\tprivate function_generator: FunctionGenerator;\n\tprivate expression_string_generator: ExpressionStringGenerator | undefined;\n\tpublic dependencies_controller: DependenciesController;\n\t// private _error_message: string | undefined;\n\tprivate parsed_tree: ParsedTree = new ParsedTree();\n\n\tconstructor(\n\t\tpublic param: BaseParamType // public element_index: number=0\n\t) {\n\t\tthis.function_generator = new FunctionGenerator(this.param);\n\t\tthis.dependencies_controller = new DependenciesController(this.param);\n\t}\n\n\tparse_expression(expression: string) {\n\t\tif (this.parse_started) {\n\t\t\tthrow new Error(`parse in progress for param ${this.param.fullPath()}`);\n\t\t}\n\t\tthis.parse_started = true;\n\t\tthis.parse_completed = false;\n\t\tthis.parsed_tree = this.parsed_tree || new ParsedTree();\n\n\t\tthis.reset();\n\t\tif (this.param.type() == ParamType.STRING) {\n\t\t\tthis.parsed_tree.parse_expression_for_string_param(expression);\n\t\t} else {\n\t\t\tthis.parsed_tree.parse_expression(expression);\n\t\t}\n\t\tthis.function_generator.parse_tree(this.parsed_tree);\n\n\t\tif (this.function_generator.error_message() == null) {\n\t\t\tthis.dependencies_controller.update(this.function_generator);\n\t\t\tif (this.dependencies_controller.error_message) {\n\t\t\t\tthis.param.states.error.set(this.dependencies_controller.error_message);\n\t\t\t} else {\n\t\t\t\tthis.parse_completed = true;\n\t\t\t\tthis.parse_started = false;\n\t\t\t}\n\t\t} //else {\n\t\t//this.set_error(this.function_generator.error_message);\n\t\t//}\n\t}\n\tasync compute_function(): Promise<any> {\n\t\t// this.parse_and_update_dependencies_if_not_done(expression);\n\t\tif (this.compute_allowed()) {\n\t\t\ttry {\n\t\t\t\tconst new_value = await this.function_generator.eval_function();\n\t\t\t\treturn new_value;\n\t\t\t} catch (e) {\n\t\t\t\t// if (this.function_generator.is_errored && this.function_generator.error_message) {\n\t\t\t\t// \tthis.set_error(this.function_generator.error_message);\n\t\t\t\t// }\n\t\t\t\treturn; // new Promise((resolve, reject) => resolve());\n\t\t\t}\n\t\t} else {\n\t\t\treturn new Promise((resolve, reject) => {\n\t\t\t\tresolve(null);\n\t\t\t});\n\t\t}\n\t}\n\n\treset() {\n\t\tthis.parse_completed = false;\n\t\tthis.parse_started = false;\n\t\t// this._error_message = undefined;\n\t\t// if(force){ // || this.element_index <= 1){\n\t\tthis.dependencies_controller.reset();\n\t\t// }\n\t\tthis.function_generator.reset();\n\t}\n\n\tis_errored(): boolean {\n\t\treturn this.function_generator.is_errored();\n\t}\n\terror_message() {\n\t\treturn this.function_generator.error_message();\n\t}\n\n\tprivate compute_allowed(): boolean {\n\t\treturn /*this._error_message == null &&*/ this.function_generator.eval_allowed();\n\t}\n\n\t// private parse_and_update_dependencies(expression: string) {\n\t// \tif (this.param.has_expression()) {\n\t// \t\tthis.parse_expression(expression);\n\n\t// \t\tif (this.error_message != null) {\n\t// \t\t\tthis.param.states.error.set(`expression error: \"${expression}\" (${this.error_message})`);\n\t// \t\t}\n\t// \t\t// this.parse_completed = true\n\t// \t}\n\t// }\n\t// private parse_and_update_dependencies_if_not_done(expression: string) {\n\t// \tif (!this.parse_completed) {\n\t// \t\tthis.parse_and_update_dependencies(expression);\n\t// \t}\n\t// }\n\n\tupdate_from_method_dependency_name_change() {\n\t\tthis.expression_string_generator =\n\t\t\tthis.expression_string_generator || new ExpressionStringGenerator(this.param);\n\n\t\tconst new_expression_string = this.expression_string_generator.parse_tree(this.parsed_tree);\n\n\t\tif (new_expression_string) {\n\t\t\tthis.param.set(new_expression_string);\n\t\t} else {\n\t\t\tconsole.warn('failed to regenerate expression');\n\t\t}\n\t\t// this.param.expressionController?.set_expression(new_expression_string);\n\n\t\t// this.reset()\n\t\t// if (new_expression_string) {\n\t\t// this.parse_expression(new_expression_string);\n\t\t// }\n\t}\n}\n","import {BaseParamType} from '../_Base';\nimport {ExpressionManager} from '../../expressions/ExpressionManager';\nimport {CorePoint} from '../../../core/geometry/Point';\nimport {CoreEntity} from '../../../core/geometry/Entity';\nimport {ParamType} from '../../poly/ParamType';\nimport {ParamValuesTypeMap} from '../types/ParamValuesTypeMap';\nimport {CoreObject} from '../../../core/geometry/Object';\nimport {MethodDependency} from '../../expressions/MethodDependency';\nimport {CoreGraphNodeId} from '../../../core/graph/CoreGraph';\n\n// type ParamTypeElem = ParamType;\ntype EntityCallback<T extends ParamType> = (\n\tentity: CoreEntity,\n\tvalue: ParamValuesTypeMap[T] | any /*TODO: typescript: any is used here mostly to compile*/\n) => void;\ntype PointEntityCallback<T extends ParamType> = (\n\tentity: CorePoint,\n\tvalue: ParamValuesTypeMap[T] | any /*TODO: typescript: any is used here mostly to compile*/\n) => void;\ntype ObjectEntityCallback<T extends ParamType> = (\n\tentity: CoreObject,\n\tvalue: ParamValuesTypeMap[T] | any /*TODO: typescript: any is used here mostly to compile*/\n) => void;\n\nexport class ExpressionController<T extends ParamType> {\n\tprotected _expression: string | undefined;\n\tprotected _entities: CoreEntity[] | undefined;\n\tprotected _entity_callback: EntityCallback<T> | undefined;\n\tprotected _manager: ExpressionManager | undefined;\n\tprotected _method_dependencies_by_graph_node_id: Map<CoreGraphNodeId, MethodDependency> | undefined;\n\t// private _reset_bound = this.reset.bind(this);\n\tconstructor(protected param: BaseParamType) {\n\t\t// this.param.dirtyController.addPostDirtyHook('expression_controller_reset', this._reset_bound);\n\t}\n\t// remove_dirty_hook() {\n\t// \t// this.param.dirtyController.removePostDirtyHook('expression_controller_reset');\n\t// }\n\tdispose() {\n\t\tthis._resetMethodDependencies();\n\t}\n\tprivate _resetMethodDependencies() {\n\t\tthis._method_dependencies_by_graph_node_id?.forEach((method_dependency) => {\n\t\t\tmethod_dependency.dispose();\n\t\t});\n\t\tthis._method_dependencies_by_graph_node_id?.clear();\n\t}\n\tregisterMethodDependency(method_dependency: MethodDependency) {\n\t\tthis._method_dependencies_by_graph_node_id = this._method_dependencies_by_graph_node_id || new Map();\n\t\tthis._method_dependencies_by_graph_node_id.set(method_dependency.graphNodeId(), method_dependency);\n\t}\n\n\tactive() {\n\t\treturn this._expression != null;\n\t}\n\texpression() {\n\t\treturn this._expression;\n\t}\n\tis_errored() {\n\t\tif (this._manager) {\n\t\t\treturn this._manager.is_errored();\n\t\t}\n\t\treturn false;\n\t}\n\terror_message() {\n\t\tif (this._manager) {\n\t\t\treturn this._manager.error_message();\n\t\t}\n\t\treturn null;\n\t}\n\trequires_entities() {\n\t\treturn this.param.options.is_expression_for_entities();\n\t}\n\t// private reset() {\n\t// \tthis._manager?.clear_error();\n\t// }\n\n\tset_expression(expression: string | undefined, set_dirty: boolean = true) {\n\t\tthis.param.scene().missingExpressionReferencesController.deregister_param(this.param);\n\t\tthis.param.scene().expressionsController.deregister_param(this.param);\n\n\t\tif (this._expression != expression) {\n\t\t\tthis._resetMethodDependencies();\n\t\t\tthis._expression = expression;\n\n\t\t\tif (this._expression) {\n\t\t\t\tthis._manager = this._manager || new ExpressionManager(this.param);\n\t\t\t\tthis._manager.parse_expression(this._expression);\n\t\t\t} else {\n\t\t\t\tthis._manager?.reset();\n\t\t\t}\n\n\t\t\tif (set_dirty) {\n\t\t\t\tthis.param.setDirty();\n\t\t\t}\n\t\t}\n\t}\n\n\tupdate_from_method_dependency_name_change() {\n\t\tif (this._manager && this.active()) {\n\t\t\tthis._manager.update_from_method_dependency_name_change();\n\t\t}\n\t}\n\n\tasync compute_expression() {\n\t\tif (this._manager && this.active()) {\n\t\t\tconst result = await this._manager.compute_function();\n\t\t\treturn result;\n\t\t}\n\t}\n\tasync compute_expression_for_entities(entities: CoreEntity[], callback: EntityCallback<T>) {\n\t\tthis.set_entities(entities, callback);\n\t\tawait this.compute_expression();\n\t\tif (this._manager?.error_message()) {\n\t\t\tthis.param.node.states.error.set(`expression evalution error: ${this._manager?.error_message()}`);\n\t\t}\n\n\t\tthis.reset_entities();\n\t}\n\tcompute_expression_for_points(entities: CorePoint[], callback: PointEntityCallback<T>) {\n\t\treturn this.compute_expression_for_entities(entities, callback as EntityCallback<T>);\n\t}\n\tcompute_expression_for_objects(entities: CoreObject[], callback: ObjectEntityCallback<T>) {\n\t\treturn this.compute_expression_for_entities(entities, callback as EntityCallback<T>);\n\t}\n\tentities() {\n\t\treturn this._entities;\n\t}\n\tentity_callback() {\n\t\treturn this._entity_callback;\n\t}\n\tset_entities(entities: CoreEntity[], callback: EntityCallback<T>) {\n\t\tthis._entities = entities;\n\t\tthis._entity_callback = callback;\n\t}\n\treset_entities() {\n\t\tthis._entities = undefined;\n\t\tthis._entity_callback = undefined;\n\t}\n}\n","var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n","import {WebGLRenderer} from 'three/src/renderers/WebGLRenderer';\nimport {Texture} from 'three/src/textures/Texture';\nimport {WebGLRenderTarget, WebGLRenderTargetOptions} from 'three/src/renderers/WebGLRenderTarget';\nimport {WebGLMultisampleRenderTarget} from 'three/src/renderers/WebGLMultisampleRenderTarget';\n\ninterface RendererByString {\n\t[propName: string]: WebGLRenderer;\n}\ninterface TextureByString {\n\t[propName: string]: Texture;\n}\n\ninterface POLYWebGLRenderer extends WebGLRenderer {\n\t_polygon_id: number;\n}\n\nconst CONTEXT_OPTIONS = {\n\t// antialias: false, // leave that to the renderer node\n\t// preserveDrawingBuffer: true, // this could only be useful to capture static images\n};\n\ntype Callback = (value: WebGLRenderer) => void;\n\nenum WebGLContext {\n\tWEBGL = 'webgl',\n\tWEBGL2 = 'webgl2',\n\tEXPERIMENTAL_WEBGL = 'experimental-webgl',\n\tEXPERIMENTAL_WEBGL2 = 'experimental-webgl2',\n}\n\nexport class RenderersController {\n\t_next_renderer_id: number = 0;\n\t_next_env_map_id: number = 0;\n\t_renderers: RendererByString = {};\n\t_env_maps: TextureByString = {};\n\t_printDebug = false;\n\tprivate _require_webgl2: boolean = false;\n\tprivate _resolves: Callback[] = [];\n\tprivate _webgl2_available: boolean | undefined;\n\n\tconstructor() {}\n\n\tsetPrintDebug(state: boolean = true) {\n\t\tthis._printDebug = state;\n\t}\n\tprintDebug() {\n\t\treturn this._printDebug;\n\t}\n\tprintDebugMessage(message: any) {\n\t\tif (!this._printDebug) {\n\t\t\treturn;\n\t\t}\n\t\tconsole.log('[Poly debug]', message);\n\t}\n\n\tsetRequireWebGL2() {\n\t\tif (!this._require_webgl2) {\n\t\t\tthis._require_webgl2 = true;\n\t\t}\n\t}\n\twebgl2Available() {\n\t\tif (this._webgl2_available === undefined) {\n\t\t\tthis._webgl2_available = this._set_webgl2_available();\n\t\t}\n\t\treturn this._webgl2_available;\n\t}\n\tprivate _set_webgl2_available() {\n\t\tconst canvas = document.createElement('canvas');\n\t\treturn (window.WebGL2RenderingContext && canvas.getContext(WebGLContext.WEBGL2)) != null;\n\t}\n\n\trenderingContext(canvas: HTMLCanvasElement): WebGLRenderingContext | null {\n\t\tlet gl: WebGLRenderingContext | null = null;\n\t\tif (this._require_webgl2) {\n\t\t\tgl = this._rendering_context_webgl(canvas, true);\n\t\t\tif (!gl) {\n\t\t\t\tconsole.warn('failed to create webgl2 context');\n\t\t\t}\n\t\t}\n\t\tif (!gl) {\n\t\t\tgl = this._rendering_context_webgl(canvas, false);\n\t\t}\n\n\t\t// gl.getExtension('OES_standard_derivatives') // for derivative normals, but it cannot work at the moment (see node Gl/DerivativeNormals)\n\t\t// to test data texture\n\t\t// gl.getExtension('OES_texture_float')\n\t\t// gl.getExtension('OES_texture_float_linear')\n\n\t\treturn gl;\n\t}\n\tprivate _rendering_context_webgl(canvas: HTMLCanvasElement, webgl2: boolean): WebGLRenderingContext | null {\n\t\tlet context_name: WebGLContext;\n\t\tif (this.webgl2Available()) {\n\t\t\tcontext_name = WebGLContext.WEBGL2;\n\t\t} else {\n\t\t\tcontext_name = webgl2 ? WebGLContext.WEBGL2 : WebGLContext.WEBGL;\n\t\t}\n\t\tlet gl = canvas.getContext(context_name, CONTEXT_OPTIONS);\n\t\tif (gl) {\n\t\t\tthis.printDebugMessage(`create gl context: ${context_name}.`);\n\t\t} else {\n\t\t\tcontext_name = webgl2 ? WebGLContext.EXPERIMENTAL_WEBGL2 : WebGLContext.EXPERIMENTAL_WEBGL;\n\t\t\tthis.printDebugMessage(`create gl context: ${context_name}.`);\n\t\t\tgl = canvas.getContext(context_name, CONTEXT_OPTIONS);\n\t\t}\n\t\treturn gl as WebGLRenderingContext | null;\n\t}\n\n\tregisterRenderer(renderer: WebGLRenderer) {\n\t\tif ((renderer as POLYWebGLRenderer)._polygon_id) {\n\t\t\tthrow new Error('render already registered');\n\t\t}\n\t\t(renderer as POLYWebGLRenderer)._polygon_id = this._next_renderer_id += 1;\n\n\t\tthis._renderers[(renderer as POLYWebGLRenderer)._polygon_id] = renderer;\n\n\t\tif (Object.keys(this._renderers).length == 1) {\n\t\t\tthis.flush_callbacks_with_renderer(renderer);\n\t\t}\n\t}\n\tderegisterRenderer(renderer: WebGLRenderer) {\n\t\tdelete this._renderers[(renderer as POLYWebGLRenderer)._polygon_id];\n\t\trenderer.dispose();\n\t}\n\tfirstRenderer(): WebGLRenderer | null {\n\t\tconst first_id = Object.keys(this._renderers)[0];\n\t\tif (first_id) {\n\t\t\treturn this._renderers[first_id];\n\t\t}\n\t\treturn null;\n\t}\n\trenderers(): WebGLRenderer[] {\n\t\treturn Object.values(this._renderers);\n\t}\n\n\tprivate flush_callbacks_with_renderer(renderer: WebGLRenderer) {\n\t\tlet callback: Callback | undefined;\n\t\twhile ((callback = this._resolves.pop())) {\n\t\t\tcallback(renderer);\n\t\t}\n\t}\n\n\tasync waitForRenderer(): Promise<WebGLRenderer> {\n\t\tconst renderer = this.firstRenderer();\n\t\tif (renderer) {\n\t\t\treturn renderer;\n\t\t} else {\n\t\t\treturn new Promise((resolve, reject) => {\n\t\t\t\tthis._resolves.push(resolve);\n\t\t\t});\n\t\t}\n\t}\n\n\trenderTarget(width: number, height: number, parameters: WebGLRenderTargetOptions) {\n\t\tif (this.webgl2Available()) {\n\t\t\treturn new WebGLMultisampleRenderTarget(width, height, parameters);\n\t\t} else {\n\t\t\treturn new WebGLRenderTarget(width, height, parameters);\n\t\t}\n\t}\n}\n","export class PolyLibsController {\n\tprivate _root: string = '/three/js/libs';\n\n\troot() {\n\t\treturn this._root;\n\t}\n\tsetRoot(url: string) {\n\t\tthis._root = url;\n\t}\n}\n","import {BaseNodeClass} from '../../../nodes/_Base';\nimport {BaseOperation} from '../../../operations/_Base';\nimport {NodeContext} from '../../NodeContext';\nimport {PolyEngine} from '../../../Poly';\nimport {PolyDictionary} from '../../../../types/GlobalTypes';\n\nexport interface RegisterOptions {\n\tonly?: string[];\n\texcept?: string[];\n\tuserAllowed?: boolean;\n}\n\n// export interface BaseNodeConstructor {\n// \tnew (): BaseNode;\n// }\n\nexport type BaseNodeConstructor = typeof BaseNodeClass;\ntype NodeConstructorByType = Map<string, BaseNodeConstructor>;\ntype NodeConstructorByTypeByContext = Map<NodeContext, NodeConstructorByType>;\ntype TabMenuByTypeByContext = Map<NodeContext, Map<string, string>>;\ntype RegisterOptionsByTypeByContext = Map<NodeContext, Map<string, RegisterOptions>>;\n\nexport type BaseOperationConstructor = typeof BaseOperation;\ntype OperationConstructorByType = Map<string, BaseOperationConstructor>;\ntype OperationConstructorByTypeByContext = Map<NodeContext, OperationConstructorByType>;\n\nexport class NodesRegister {\n\tprivate _node_register: NodeConstructorByTypeByContext = new Map();\n\tprivate _node_register_categories: TabMenuByTypeByContext = new Map();\n\tprivate _node_register_options: RegisterOptionsByTypeByContext = new Map();\n\n\tconstructor(private poly: PolyEngine) {}\n\n\tregister(node: BaseNodeConstructor, tab_menu_category?: string, options?: RegisterOptions) {\n\t\tconst context = node.nodeContext();\n\t\tconst nodeType = node.type().toLowerCase();\n\n\t\tlet current_nodes_for_context = this._node_register.get(context);\n\t\tif (!current_nodes_for_context) {\n\t\t\tcurrent_nodes_for_context = new Map();\n\t\t\tthis._node_register.set(context, current_nodes_for_context);\n\t\t}\n\n\t\tconst already_registered_node = current_nodes_for_context.get(nodeType);\n\t\tif (already_registered_node) {\n\t\t\tconsole.error(`node ${context}/${nodeType} already registered`);\n\t\t\treturn;\n\t\t}\n\t\tcurrent_nodes_for_context.set(nodeType, node);\n\n\t\tif (tab_menu_category) {\n\t\t\tlet current_categories = this._node_register_categories.get(context);\n\t\t\tif (!current_categories) {\n\t\t\t\tcurrent_categories = new Map();\n\t\t\t\tthis._node_register_categories.set(context, current_categories);\n\t\t\t}\n\t\t\tcurrent_categories.set(nodeType, tab_menu_category);\n\t\t}\n\n\t\tif (options) {\n\t\t\tlet current_options = this._node_register_options.get(context);\n\t\t\tif (!current_options) {\n\t\t\t\tcurrent_options = new Map();\n\t\t\t\tthis._node_register_options.set(context, current_options);\n\t\t\t}\n\t\t\tcurrent_options.set(nodeType, options);\n\t\t}\n\t\tthis.poly.pluginsRegister.registerNode(node);\n\t}\n\tderegister(context: NodeContext, node_type: string) {\n\t\tthis._node_register.get(context)?.delete(node_type);\n\t\tthis._node_register_categories.get(context)?.delete(node_type);\n\t\tthis._node_register_options.get(context)?.delete(node_type);\n\t}\n\tisRegistered(context: NodeContext, type: string): boolean {\n\t\tconst nodes_for_context = this._node_register.get(context);\n\t\tif (!nodes_for_context) {\n\t\t\treturn false;\n\t\t}\n\t\treturn nodes_for_context.get(type) != null;\n\t}\n\tregisteredNodesForContextAndParentType(context: NodeContext, parent_node_type: string) {\n\t\tconst map = this._node_register.get(context);\n\t\tif (map) {\n\t\t\tconst nodes_for_context: BaseNodeConstructor[] = [];\n\t\t\tthis._node_register.get(context)?.forEach((node, type) => {\n\t\t\t\tnodes_for_context.push(node);\n\t\t\t});\n\t\t\treturn nodes_for_context.filter((node) => {\n\t\t\t\tconst nodeType = node.type().toLowerCase();\n\t\t\t\tconst options = this._node_register_options.get(context)?.get(nodeType);\n\t\t\t\tif (!options) {\n\t\t\t\t\treturn true;\n\t\t\t\t} else {\n\t\t\t\t\tconst option_only = options['only'];\n\t\t\t\t\tconst option_except = options['except'];\n\t\t\t\t\tconst context_and_type = `${context}/${parent_node_type}`;\n\t\t\t\t\tif (option_only) {\n\t\t\t\t\t\treturn option_only.includes(context_and_type);\n\t\t\t\t\t}\n\t\t\t\t\tif (option_except) {\n\t\t\t\t\t\treturn !option_except.includes(context_and_type);\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t});\n\t\t} else {\n\t\t\treturn [];\n\t\t}\n\t}\n\tregisteredNodes(context: NodeContext, parent_node_type: string): PolyDictionary<BaseNodeConstructor> {\n\t\tconst nodesByType: PolyDictionary<BaseNodeConstructor> = {};\n\t\tconst nodes = this.registeredNodesForContextAndParentType(context, parent_node_type);\n\t\tfor (let node of nodes) {\n\t\t\tconst type = node.type().toLowerCase();\n\t\t\tnodesByType[type] = node;\n\t\t}\n\t\treturn nodesByType;\n\t}\n\tregisteredCategory(context: NodeContext, type: string) {\n\t\treturn this._node_register_categories.get(context)?.get(type.toLowerCase());\n\t}\n\n\tmap() {\n\t\treturn this._node_register;\n\t}\n}\n\nexport class OperationsRegister {\n\tprivate _operation_register: OperationConstructorByTypeByContext = new Map();\n\n\tconstructor(private poly: PolyEngine) {}\n\n\tregister(operation: BaseOperationConstructor) {\n\t\tconst context = operation.context();\n\t\tlet current_operations_for_context = this._operation_register.get(context);\n\t\tif (!current_operations_for_context) {\n\t\t\tcurrent_operations_for_context = new Map();\n\t\t\tthis._operation_register.set(context, current_operations_for_context);\n\t\t}\n\n\t\tconst operationType = operation.type().toLowerCase();\n\t\tconst already_registered_operation = current_operations_for_context.get(operationType);\n\t\tif (already_registered_operation) {\n\t\t\tconst message = `operation ${context}/${operationType} already registered`;\n\t\t\tconsole.error(message);\n\t\t\treturn;\n\t\t}\n\t\tcurrent_operations_for_context.set(operationType, operation);\n\t\tthis.poly.pluginsRegister.registerOperation(operation);\n\t}\n\n\tregisteredOperationsForContextAndParentType(context: NodeContext, parent_node_type: string) {\n\t\tconst map = this._operation_register.get(context);\n\t\tif (map) {\n\t\t\tconst nodes_for_context: BaseOperationConstructor[] = [];\n\t\t\tthis._operation_register.get(context)?.forEach((operation, type) => {\n\t\t\t\tnodes_for_context.push(operation);\n\t\t\t});\n\t\t\treturn nodes_for_context;\n\t\t} else {\n\t\t\treturn [];\n\t\t}\n\t}\n\tregisteredOperation(context: NodeContext, operationType: string): BaseOperationConstructor | undefined {\n\t\tconst current_operations_for_context = this._operation_register.get(context);\n\t\tif (current_operations_for_context) {\n\t\t\treturn current_operations_for_context.get(operationType.toLowerCase());\n\t\t}\n\t}\n}\n","import {BaseExpressionRegister} from './_BaseRegister';\nimport {ExpressionMap} from './All';\n\nexport class ExpressionRegister extends BaseExpressionRegister {\n\tgetMethod<K extends keyof ExpressionMap>(name: K): ExpressionMap[K] | undefined {\n\t\treturn super.getMethod(name as any);\n\t}\n}\n","import {BaseMethod} from '../../../expressions/methods/_Base';\n\nexport class BaseExpressionRegister {\n\tprivate _methods_names: string[] = [];\n\tprivate _methods_by_name: Map<string, typeof BaseMethod> = new Map();\n\n\tregister(expression: typeof BaseMethod, name: string) {\n\t\tthis._methods_names.push(name);\n\t\tthis._methods_by_name.set(name, expression);\n\t}\n\tgetMethod(name: string) {\n\t\treturn this._methods_by_name.get(name);\n\t}\n\tavailableMethods(): string[] {\n\t\treturn this._methods_names;\n\t}\n}\n","import {ModulesMap} from './All';\nimport {BaseModulesRegister} from './_BaseRegister';\n\nexport class DynamicModulesRegister extends BaseModulesRegister {\n\tasync module<K extends keyof ModulesMap>(name: K): Promise<ModulesMap[K] | undefined> {\n\t\treturn await super.module(name as any);\n\t}\n}\n","import {AssemblersMap} from './All';\nimport {BaseAssemblersRegister, AssemblerName} from './_BaseRegister';\nimport {BaseNodeType} from '../../../nodes/_Base';\n\nexport class AssemblersRegister extends BaseAssemblersRegister {\n\tassembler<K extends keyof AssemblersMap>(node: BaseNodeType, name: K): AssemblersMap[K]['controller'] | undefined {\n\t\tconst pair = this._controller_assembler_by_name.get(name as AssemblerName);\n\t\tif (pair) {\n\t\t\tconst controller = pair.controller;\n\t\t\tconst assembler = pair.assembler;\n\t\t\treturn new controller(node, assembler);\n\t\t}\n\t\treturn pair;\n\t}\n\n\tunregister<K extends keyof AssemblersMap>(name: K) {\n\t\tconst pair = this._controller_assembler_by_name.get(name as AssemblerName);\n\t\tsuper.unregister(name as AssemblerName);\n\t\treturn pair;\n\t}\n}\n","import {PolyEngine} from '../../../Poly';\nimport {PolyPlugin, PolyPluginData} from './Plugin';\nimport {BaseNodeConstructor, BaseOperationConstructor} from '../nodes/NodesRegister';\nimport {NodeContext} from '../../NodeContext';\nimport {PolyDictionary} from '../../../../types/GlobalTypes';\n\nexport interface PluginsRegisterData {\n\tplugins: PolyDictionary<PolyPluginData>;\n\tnodes: PolyDictionary<PolyDictionary<string>>;\n\toperations: PolyDictionary<PolyDictionary<string>>;\n}\n\nexport class PluginsRegister {\n\tprivate _current_plugin: PolyPlugin | undefined;\n\tprivate _plugins_by_name: Map<string, PolyPlugin> = new Map();\n\tprivate _plugin_name_by_node_context_by_type: Map<NodeContext, Map<string, string>> = new Map();\n\tprivate _plugin_name_by_operation_context_by_type: Map<NodeContext, Map<string, string>> = new Map();\n\n\tconstructor(private poly: PolyEngine) {}\n\n\tregister(plugin: PolyPlugin) {\n\t\tthis._current_plugin = plugin;\n\t\tthis._plugins_by_name.set(plugin.name(), plugin);\n\t\tplugin.init(this.poly);\n\t\tthis._current_plugin = undefined;\n\t}\n\tpluginByName(pluginName: string) {\n\t\treturn this._plugins_by_name.get(pluginName);\n\t}\n\n\tregisterNode(node: BaseNodeConstructor) {\n\t\tif (!this._current_plugin) {\n\t\t\treturn;\n\t\t}\n\t\tconst context = node.nodeContext();\n\t\tconst type = node.type();\n\t\tlet map_for_context = this._plugin_name_by_node_context_by_type.get(context);\n\t\tif (!map_for_context) {\n\t\t\tmap_for_context = new Map();\n\t\t\tthis._plugin_name_by_node_context_by_type.set(context, map_for_context);\n\t\t}\n\t\tmap_for_context.set(type, this._current_plugin.name());\n\t}\n\tregisterOperation(operation: BaseOperationConstructor) {\n\t\tif (!this._current_plugin) {\n\t\t\treturn;\n\t\t}\n\t\tconst context = operation.context();\n\t\tconst type = operation.type();\n\t\tlet map_for_context = this._plugin_name_by_operation_context_by_type.get(context);\n\t\tif (!map_for_context) {\n\t\t\tmap_for_context = new Map();\n\t\t\tthis._plugin_name_by_operation_context_by_type.set(context, map_for_context);\n\t\t}\n\t\tmap_for_context.set(type, this._current_plugin.name());\n\t}\n\n\ttoJson() {\n\t\tconst data: PluginsRegisterData = {\n\t\t\tplugins: {},\n\t\t\tnodes: {},\n\t\t\toperations: {},\n\t\t};\n\n\t\tthis._plugins_by_name.forEach((plugin, name) => {\n\t\t\tdata.plugins[name] = plugin.toJSON();\n\t\t});\n\n\t\tthis._plugin_name_by_node_context_by_type.forEach((map_for_context, context) => {\n\t\t\tdata.nodes[context] = {};\n\t\t\tmap_for_context.forEach((plugin_name, type) => {\n\t\t\t\tdata.nodes[context][type] = plugin_name;\n\t\t\t});\n\t\t});\n\t\tthis._plugin_name_by_operation_context_by_type.forEach((map_for_context, context) => {\n\t\t\tdata.operations[context] = {};\n\t\t\tmap_for_context.forEach((plugin_name, type) => {\n\t\t\t\tdata.operations[context][type] = plugin_name;\n\t\t\t});\n\t\t});\n\n\t\treturn data;\n\t}\n}\n","import {BaseNodeClass} from '../../../nodes/_Base';\nimport {PolyEngine} from '../../../Poly';\n\ntype BaseNodeConstructor = typeof BaseNodeClass;\n\nexport class CamerasRegister {\n\tprivate _camera_types: string[] = [];\n\n\tconstructor(poly: PolyEngine) {}\n\n\tregister(node: BaseNodeConstructor) {\n\t\tconst node_type = node.type();\n\t\tif (!this._camera_types.includes(node_type)) {\n\t\t\tthis._camera_types.push(node_type);\n\t\t}\n\t}\n\tregisteredTypes() {\n\t\treturn this._camera_types;\n\t}\n}\n","import {BaseNodeClass} from './nodes/_Base';\nimport {PolyScene} from './scene/PolyScene';\nimport {RenderersController} from './poly/RenderersController';\nimport {PolyLibsController} from './poly/PolyLibsController';\nimport {\n\tNodesRegister,\n\tRegisterOptions,\n\tBaseNodeConstructor,\n\tOperationsRegister,\n} from './poly/registers/nodes/NodesRegister';\nimport {ExpressionRegister} from './poly/registers/expressions/ExpressionRegister';\nimport {NodeContext} from './poly/NodeContext';\nimport {DynamicModulesRegister} from './poly/registers/modules/DynamicModulesRegister';\nimport {AssemblersRegister} from './poly/registers/assemblers/AssemblersRegistry';\nimport {BaseCoreLogger} from '../core/logger/Base';\nimport {BaseOperation} from './operations/_Base';\nimport {PluginsRegister} from './poly/registers/plugins/PluginsRegister';\nimport {CamerasRegister} from './poly/registers/cameras/CamerasRegister';\nimport {PolyPlugin} from './poly/registers/plugins/Plugin';\nimport {PolyDictionary} from '../types/GlobalTypes';\n\ndeclare global {\n\tinterface Window {\n\t\t__POLYGONJS_POLY_INSTANCE__: PolyEngine;\n\t}\n}\n\nexport class PolyEngine {\n\t// static _instance: Poly | undefined;\n\tpublic readonly renderersController: RenderersController = new RenderersController();\n\tpublic readonly nodesRegister: NodesRegister = new NodesRegister(this);\n\tpublic readonly operationsRegister: OperationsRegister = new OperationsRegister(this);\n\tpublic readonly expressionsRegister: ExpressionRegister = new ExpressionRegister();\n\tpublic readonly modulesRegister: DynamicModulesRegister = new DynamicModulesRegister();\n\tpublic readonly assemblersRegister: AssemblersRegister = new AssemblersRegister();\n\tpublic readonly pluginsRegister: PluginsRegister = new PluginsRegister(this);\n\tpublic readonly camerasRegister: CamerasRegister = new CamerasRegister(this);\n\tscenesByUuid: PolyDictionary<PolyScene> = {};\n\t_env: string | undefined;\n\tprivate _player_mode: boolean = true;\n\tprivate _logger: BaseCoreLogger | null = null;\n\n\tstatic _instance_() {\n\t\t// we are using a window globals to ensure 2 instances can never be created\n\t\t// even when the js are compiled by different means,\n\t\t// which can happen in the editor.\n\t\tif (window.__POLYGONJS_POLY_INSTANCE__) {\n\t\t\treturn window.__POLYGONJS_POLY_INSTANCE__;\n\t\t} else {\n\t\t\tconst instance = new PolyEngine();\n\t\t\twindow.__POLYGONJS_POLY_INSTANCE__ = instance;\n\t\t\t// this._instance = instance\n\t\t\treturn window.__POLYGONJS_POLY_INSTANCE__;\n\t\t}\n\t\t// return (this._instance = this._instance || new Poly());\n\t}\n\tprivate constructor() {}\n\n\tsetPlayerMode(mode: boolean) {\n\t\tthis._player_mode = mode;\n\t}\n\tplayerMode() {\n\t\treturn this._player_mode;\n\t}\n\n\tregisterNode(node: BaseNodeConstructor, tab_menu_category?: string, options?: RegisterOptions) {\n\t\tthis.nodesRegister.register(node, tab_menu_category, options);\n\t}\n\tregisterOperation(operation: typeof BaseOperation) {\n\t\tthis.operationsRegister.register(operation);\n\t}\n\tregisterCamera(node: BaseNodeConstructor) {\n\t\tthis.camerasRegister.register(node);\n\t}\n\tregisterPlugin(plugin: PolyPlugin) {\n\t\tthis.pluginsRegister.register(plugin);\n\t}\n\tregisteredNodes(parent_context: NodeContext, type: string): PolyDictionary<typeof BaseNodeClass> {\n\t\treturn this.nodesRegister.registeredNodes(parent_context, type);\n\t}\n\tregisteredOperation(parent_context: NodeContext, operation_type: string): typeof BaseOperation | undefined {\n\t\treturn this.operationsRegister.registeredOperation(parent_context, operation_type);\n\t}\n\tregisteredCameraTypes() {\n\t\treturn this.camerasRegister.registeredTypes();\n\t}\n\n\tinWorkerThread() {\n\t\treturn false;\n\t}\n\tdesktopController(): any {}\n\n\t//\n\t//\n\t// LIBS\n\t//\n\t//\n\tprivate _libs_controller: PolyLibsController | undefined;\n\tget libs() {\n\t\treturn (this._libs_controller = this._libs_controller || new PolyLibsController());\n\t}\n\n\t//\n\t//\n\t// ENV\n\t//\n\t//\n\tsetEnv(env: string) {\n\t\tthis._env = env;\n\t}\n\tenv() {\n\t\treturn this._env;\n\t}\n\n\t//\n\t//\n\t// LOGGER\n\t//\n\t//\n\tsetLogger(logger: BaseCoreLogger | null) {\n\t\tthis._logger = logger;\n\t}\n\tget logger() {\n\t\treturn this._logger;\n\t}\n\n\tlog(message?: any, ...optionalParams: any[]) {\n\t\tthis.logger?.log(...[message, ...optionalParams]);\n\t}\n\twarn(message?: any, ...optionalParams: any[]) {\n\t\tthis.logger?.warn(...[message, ...optionalParams]);\n\t}\n\terror(message?: any, ...optionalParams: any[]) {\n\t\tthis.logger?.error(...[message, ...optionalParams]);\n\t}\n}\n\nexport const Poly = PolyEngine._instance_();\n","import {BaseNodeType} from '../engine/nodes/_Base';\nimport {BaseParamType} from '../engine/params/_Base';\nimport {DecomposedPath} from './DecomposedPath';\nimport {NodeContext, BaseNodeByContextMap} from '../engine/poly/NodeContext';\nimport {ErrorState} from '../engine/nodes/utils/states/Error';\n\ntype NodeOrParam = BaseNodeType | BaseParamType;\n\nexport const NODE_PATH_DEFAULT = {\n\tNODE: {\n\t\tUV: '/COP/imageUv',\n\t\tENV_MAP: '/COP/envMap',\n\t},\n};\n\nexport class TypedNodePathParamValue {\n\tprivate _node: BaseNodeType | null = null;\n\tconstructor(private _path: string = '') {}\n\tset_path(path: string) {\n\t\tthis._path = path;\n\t}\n\tset_node(node: BaseNodeType | null) {\n\t\tthis._node = node;\n\t}\n\tpath() {\n\t\treturn this._path;\n\t}\n\tnode() {\n\t\treturn this._node;\n\t}\n\n\tresolve(node_start: BaseNodeType) {\n\t\tthis._node = CoreWalker.find_node(node_start, this._path);\n\t}\n\n\tclone() {\n\t\tconst cloned = new TypedNodePathParamValue(this._path);\n\t\tcloned.set_node(this._node);\n\t\treturn cloned;\n\t}\n\n\tensure_node_context<N extends NodeContext>(\n\t\tcontext: N,\n\t\terror_state?: ErrorState\n\t): BaseNodeByContextMap[N] | undefined {\n\t\tconst found_node = this.node();\n\t\tif (!found_node) {\n\t\t\terror_state?.set(`no node found at ${this.path()}`);\n\t\t\treturn;\n\t\t}\n\t\tconst node_context = found_node.nodeContext();\n\t\tif (node_context == context) {\n\t\t\treturn found_node as BaseNodeByContextMap[N];\n\t\t} else {\n\t\t\terror_state?.set(`expected ${context} node, but got a ${node_context}`);\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nexport class TypedParamPathParamValue {\n\tprivate _param: BaseParamType | null = null;\n\tconstructor(private _path: string = '') {}\n\tset_path(path: string) {\n\t\tthis._path = path;\n\t}\n\tset_param(param: BaseParamType | null) {\n\t\tthis._param = param;\n\t}\n\tpath() {\n\t\treturn this._path;\n\t}\n\tparam() {\n\t\treturn this._param;\n\t}\n\n\tresolve(node_start: BaseNodeType) {\n\t\tthis._param = CoreWalker.find_param(node_start, this._path);\n\t}\n\n\tclone() {\n\t\tconst cloned = new TypedParamPathParamValue(this._path);\n\t\tcloned.set_param(this._param);\n\t\treturn cloned;\n\t}\n}\n\nexport class CoreWalker {\n\tpublic static readonly SEPARATOR = '/';\n\tpublic static readonly DOT = '.';\n\tpublic static readonly CURRENT = CoreWalker.DOT;\n\tpublic static readonly PARENT = '..';\n\tpublic static readonly CURRENT_WITH_SLASH = `${CoreWalker.CURRENT}/`;\n\tpublic static readonly PARENT_WITH_SLASH = `${CoreWalker.PARENT}/`;\n\tpublic static readonly NON_LETTER_PREFIXES = [CoreWalker.SEPARATOR, CoreWalker.DOT];\n\n\tstatic split_parent_child(path: string) {\n\t\tconst elements: string[] = path.split(CoreWalker.SEPARATOR).filter((e) => e.length > 0);\n\t\tconst child_path = elements.pop();\n\t\tconst parent_path = elements.join(CoreWalker.SEPARATOR);\n\t\treturn {parent: parent_path, child: child_path};\n\t}\n\n\tstatic find_node(node_src: BaseNodeType, path: string, decomposed_path?: DecomposedPath): BaseNodeType | null {\n\t\tif (!node_src) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst elements: string[] = path.split(CoreWalker.SEPARATOR).filter((e) => e.length > 0);\n\t\tconst first_element = elements[0];\n\n\t\tlet next_node: BaseNodeType | null = null;\n\t\tif (path[0] === CoreWalker.SEPARATOR) {\n\t\t\tconst path_from_root = path.substr(1);\n\t\t\tnext_node = this.find_node(node_src.root(), path_from_root, decomposed_path);\n\t\t} else {\n\t\t\tswitch (first_element) {\n\t\t\t\tcase CoreWalker.PARENT:\n\t\t\t\t\tdecomposed_path?.add_path_element(first_element);\n\t\t\t\t\tnext_node = node_src.parent();\n\t\t\t\t\tbreak;\n\t\t\t\tcase CoreWalker.CURRENT:\n\t\t\t\t\tdecomposed_path?.add_path_element(first_element);\n\t\t\t\t\tnext_node = node_src;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\t// TODO: What does .node means?? in which case is this not a node? (it is for nodes which cannot have children - but I'd like to unify the api)\n\t\t\t\t\t// console.error(\"rethink this method Walker.find_node\")\n\t\t\t\t\t// if (node_src.node != null) {\n\t\t\t\t\tnext_node = node_src.node(first_element);\n\t\t\t\t\tif (next_node) {\n\t\t\t\t\t\tdecomposed_path?.add_node(first_element, next_node);\n\t\t\t\t\t}\n\n\t\t\t\t// if (next_node == null) { this.find_node_warning(node_src, first_element); }\n\t\t\t\t// return next_node;\n\t\t\t\t// break\n\t\t\t\t// }\n\t\t\t}\n\n\t\t\tif (next_node != null && elements.length > 1) {\n\t\t\t\tconst remainder = elements.slice(1).join(CoreWalker.SEPARATOR);\n\t\t\t\tnext_node = this.find_node(next_node, remainder, decomposed_path);\n\t\t\t}\n\t\t\treturn next_node;\n\t\t}\n\n\t\treturn next_node;\n\t}\n\n\tstatic find_param(node_src: BaseNodeType, path: string, decomposed_path?: DecomposedPath): BaseParamType | null {\n\t\tif (!node_src) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst elements = path.split(CoreWalker.SEPARATOR);\n\n\t\tif (elements.length === 1) {\n\t\t\treturn node_src.params.get(elements[0]);\n\t\t} else {\n\t\t\tconst node_path = elements.slice(0, +(elements.length - 2) + 1 || undefined).join(CoreWalker.SEPARATOR);\n\t\t\tconst node = this.find_node(node_src, node_path, decomposed_path);\n\t\t\tif (node != null) {\n\t\t\t\tconst param_name = elements[elements.length - 1];\n\t\t\t\tconst param = node.params.get(param_name);\n\t\t\t\tif (decomposed_path && param) {\n\t\t\t\t\tdecomposed_path.add_node(param_name, param);\n\t\t\t\t}\n\t\t\t\treturn param;\n\t\t\t} else {\n\t\t\t\treturn null;\n\t\t\t\t// throw `no node found for path ${node_path}`;\n\t\t\t}\n\t\t}\n\t}\n\tstatic relativePath(src_graph_node: Readonly<BaseNodeType>, dest_graph_node: Readonly<BaseNodeType>): string {\n\t\tconst parent = this.closest_common_parent(src_graph_node, dest_graph_node);\n\t\tif (!parent) {\n\t\t\treturn dest_graph_node.fullPath();\n\t\t} else {\n\t\t\tconst distance = this.distanceToParent(src_graph_node, parent);\n\t\t\tlet up = '';\n\t\t\tif (distance > 0) {\n\t\t\t\tlet i = 0;\n\t\t\t\tconst ups = [];\n\t\t\t\twhile (i++ < distance) {\n\t\t\t\t\tups.push(CoreWalker.PARENT);\n\t\t\t\t}\n\t\t\t\tup = ups.join(CoreWalker.SEPARATOR) + CoreWalker.SEPARATOR;\n\t\t\t}\n\n\t\t\tconst parent_path_elements = parent\n\t\t\t\t.fullPath()\n\t\t\t\t.split(CoreWalker.SEPARATOR)\n\t\t\t\t.filter((e) => e.length > 0);\n\t\t\tconst dest_path_elements = dest_graph_node\n\t\t\t\t.fullPath()\n\t\t\t\t.split(CoreWalker.SEPARATOR)\n\t\t\t\t.filter((e) => e.length > 0);\n\t\t\tconst remaining_elements = [];\n\t\t\tlet cmptr = 0;\n\t\t\tfor (let dest_path_element of dest_path_elements) {\n\t\t\t\tif (!parent_path_elements[cmptr]) {\n\t\t\t\t\tremaining_elements.push(dest_path_element);\n\t\t\t\t}\n\t\t\t\tcmptr++;\n\t\t\t}\n\t\t\tconst down = remaining_elements.join(CoreWalker.SEPARATOR);\n\t\t\treturn `${up}${down}`;\n\t\t}\n\t}\n\n\tstatic closest_common_parent(\n\t\tgraph_node1: Readonly<BaseNodeType>,\n\t\tgraph_node2: Readonly<BaseNodeType>\n\t): Readonly<BaseNodeType> | null {\n\t\tconst parents1 = this.parents(graph_node1).reverse().concat([graph_node1]);\n\t\tconst parents2 = this.parents(graph_node2).reverse().concat([graph_node2]);\n\n\t\tconst min_depth = Math.min(parents1.length, parents2.length);\n\t\tlet found_parent = null;\n\n\t\tfor (let i = 0; i < min_depth; i++) {\n\t\t\tif (parents1[i].graphNodeId() == parents2[i].graphNodeId()) {\n\t\t\t\tfound_parent = parents1[i];\n\t\t\t}\n\t\t}\n\t\treturn found_parent;\n\t}\n\tstatic parents(graph_node: Readonly<NodeOrParam>): Readonly<BaseNodeType>[] {\n\t\tconst parents = [];\n\t\tlet parent = graph_node.parent();\n\t\twhile (parent) {\n\t\t\tparents.push(parent);\n\t\t\tparent = parent.parent();\n\t\t}\n\t\treturn parents;\n\t}\n\tstatic distanceToParent(graph_node: Readonly<NodeOrParam>, dest: Readonly<BaseNodeType>): number {\n\t\tlet distance = 0;\n\t\tlet current: Readonly<NodeOrParam | null> = graph_node;\n\t\tconst dest_id = dest.graphNodeId();\n\t\twhile (current && current.graphNodeId() != dest_id) {\n\t\t\tdistance += 1;\n\t\t\tcurrent = current.parent();\n\t\t}\n\t\tif (current && current.graphNodeId() == dest_id) {\n\t\t\treturn distance;\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tstatic make_absolute_path(node_src: BaseNodeType | BaseParamType, path: string): string | null {\n\t\tif (path[0] == CoreWalker.SEPARATOR) {\n\t\t\treturn path;\n\t\t}\n\n\t\tconst path_elements = path.split(CoreWalker.SEPARATOR);\n\t\tconst first_element = path_elements.shift();\n\n\t\tif (first_element) {\n\t\t\tswitch (first_element) {\n\t\t\t\tcase '..': {\n\t\t\t\t\tconst parent = node_src.parent();\n\t\t\t\t\tif (parent) {\n\t\t\t\t\t\treturn this.make_absolute_path(parent, path_elements.join(CoreWalker.SEPARATOR));\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcase '.': {\n\t\t\t\t\treturn this.make_absolute_path(node_src, path_elements.join(CoreWalker.SEPARATOR));\n\t\t\t\t}\n\t\t\t\tdefault: {\n\t\t\t\t\treturn [node_src.fullPath(), path].join(CoreWalker.SEPARATOR);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\treturn node_src.fullPath();\n\t\t}\n\t}\n}\n","import {CoreType} from './Type';\nimport {ArrayUtils} from './ArrayUtils';\n\nconst ATTRIB_NAMES_SEPARATOR = /[, ]/; //[',', ' ']\n\n// const LETTERS = 'abcdefghijklmnopqrstuvwxyz'\n// const LETTERS_UPPERCASE = LETTERS.toUpperCase()\n// const NUMBERS = '0123645789'\n// const ALL = LETTERS + LETTERS_UPPERCASE + NUMBERS\n\nconst TAIL_DIGIT_MATCH_REGEXP = /\\d+$/;\nconst LEADING_ZEROS_MATCH_REGEXP = /^0+/;\n// const DIGIT_PREDEDED_BY_UNDERSCOPE = /_\\d$/\nconst INDICES_LIST_SEPARATOR = /,| /;\nconst ZERO = '0';\nconst SPACE = ' ';\n\n// https://stackoverflow.com/questions/41856126/regexp-optional-dot-in-a-decimal-number\nconst NUM_REGEXP = /^-?\\d+\\.?\\d*$/;\nenum BooleanString {\n\tTRUE = 'true',\n\tFALSE = 'false',\n}\n\nexport class CoreString {\n\t// static has_tail_digits(word: string): boolean {\n\t// \tconst match = word.match(TAIL_DIGIT_MATCH_REGEXP)\n\t// \treturn (match != null)\n\t// }\n\tstatic isBoolean(word: string): boolean {\n\t\treturn word == BooleanString.TRUE || word == BooleanString.FALSE;\n\t}\n\tstatic toBoolean(word: string): boolean {\n\t\treturn word == BooleanString.TRUE;\n\t}\n\tstatic isNumber(word: string): boolean {\n\t\treturn NUM_REGEXP.test(word);\n\t}\n\n\tstatic tailDigits(word: string): number {\n\t\tconst match = word.match(TAIL_DIGIT_MATCH_REGEXP);\n\t\tif (match) {\n\t\t\treturn parseInt(match[0]);\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tstatic increment(word: string): string {\n\t\tconst match = word.match(TAIL_DIGIT_MATCH_REGEXP);\n\t\tif (match) {\n\t\t\tlet numbers_as_str = match[0];\n\t\t\tlet zeros_prefix: string = '';\n\t\t\tconst leading_zeros_match = numbers_as_str.match(LEADING_ZEROS_MATCH_REGEXP);\n\t\t\tif (leading_zeros_match) {\n\t\t\t\tzeros_prefix = leading_zeros_match[0];\n\t\t\t}\n\n\t\t\tconst digits = parseInt(numbers_as_str);\n\t\t\tif (digits == 0) {\n\t\t\t\tif (zeros_prefix.length > 0) {\n\t\t\t\t\tif (zeros_prefix[zeros_prefix.length - 1] == ZERO) {\n\t\t\t\t\t\tzeros_prefix = zeros_prefix.slice(0, -1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst prefix = word.substring(0, word.length - match[0].length);\n\t\t\treturn `${prefix}${zeros_prefix}${digits + 1}`;\n\t\t} else {\n\t\t\treturn `${word}1`;\n\t\t}\n\t}\n\n\tstatic pluralize(word: string): string {\n\t\tconst last_char = word[word.length - 1];\n\t\tif (last_char !== 's') {\n\t\t\treturn `${word}s`;\n\t\t} else {\n\t\t\treturn word;\n\t\t}\n\t}\n\n\tstatic camelCase(str: string): string {\n\t\tconst elements = str.replace(/_/g, ' ').split(' ');\n\t\tlet newWord = '';\n\t\tfor (let i = 0; i < elements.length; i++) {\n\t\t\tlet element = elements[i].toLowerCase();\n\t\t\tif (i > 0) {\n\t\t\t\telement = this.upperFirst(element);\n\t\t\t}\n\t\t\tnewWord += element;\n\t\t}\n\t\treturn newWord;\n\n\t\t// inspired from https://blog.bitsrc.io/5-string-manipulation-libraries-for-javascript-5de27e48ee62\n\t\t// return str.replace(/_/g, ' ').replace(/(?:^\\w|[A-Z0-9]|\\b\\w|\\s+)/g, function (match, index) {\n\t\t// \tconsole.log('match', match, index);\n\t\t// \tif (+match === 0) return ''; // or if (/\\s+/.test(match)) for white spaces\n\t\t// \treturn index === 0 ? match.toLowerCase() : match.toUpperCase();\n\t\t// });\n\t}\n\n\tstatic upperFirst(word: string): string {\n\t\tconst newString = word[0].toUpperCase() + word.substr(1);\n\t\treturn newString;\n\t}\n\t// https://stackoverflow.com/questions/52963900/convert-different-strings-to-snake-case-in-javascript\n\t// static snake_case(str: string): string {\n\t// \treturn str\n\t// \t\t.replace(/\\W+/g, ' ')\n\t// \t\t.split(/ |\\B(?=[A-Z])/)\n\t// \t\t.map((word) => word.toLowerCase())\n\t// \t\t.join('_');\n\t// }\n\tstatic titleize(word: string): string {\n\t\tconst elements = word.split(/\\s|_/g);\n\t\tconst newElements = elements.map((elem) => this.upperFirst(elem));\n\t\treturn newElements.join(' ');\n\t}\n\n\t// static type_to_class_name(word: string): string {\n\t// \treturn this.upperFirst(this.camelCase(word));\n\t// }\n\n\t// static timestamp_to_seconds(word: string): number {\n\t// \treturn Date.parse(word) / 1000;\n\t// }\n\t// static seconds_to_timestamp(seconds: number): string {\n\t// \tconst d = new Date();\n\t// \td.setTime(seconds * 1000);\n\t// \treturn d.toISOString().substr(11, 8);\n\t// }\n\n\tstatic precision(val: number, decimals: number = 2): string {\n\t\tdecimals = Math.max(decimals, 0);\n\t\tconst elements = `${val}`.split('.');\n\n\t\tif (decimals <= 0) {\n\t\t\treturn elements[0];\n\t\t}\n\n\t\tlet frac = elements[1];\n\t\tif (frac !== undefined) {\n\t\t\tif (frac.length > decimals) {\n\t\t\t\tfrac = frac.substring(0, decimals);\n\t\t\t}\n\n\t\t\tfrac = frac.padEnd(decimals, '0');\n\t\t\treturn `${elements[0]}.${frac}`;\n\t\t} else {\n\t\t\tconst string_to_pad = `${val}.`;\n\t\t\tconst pad = string_to_pad.length + decimals;\n\t\t\treturn string_to_pad.padEnd(pad, '0');\n\t\t}\n\t}\n\n\tstatic ensureFloat(num: number): string {\n\t\t// const integer = Math.floor(num)\n\t\t// const delta = num - integer\n\t\t// if(delta)\n\t\tconst num_as_string = `${num}`;\n\t\tconst dot_pos = num_as_string.indexOf('.');\n\t\tif (dot_pos >= 0) {\n\t\t\treturn num_as_string;\n\t\t} else {\n\t\t\treturn `${num_as_string}.0`;\n\t\t}\n\t}\n\n\t// https://stackoverflow.com/questions/26246601/wildcard-string-comparison-in-javascript#32402438\n\tstatic matchMask(word: string, mask: string) {\n\t\tif (mask === '*') {\n\t\t\treturn true;\n\t\t}\n\t\tif (word == mask) {\n\t\t\treturn true;\n\t\t}\n\t\tconst elements = mask.split(SPACE);\n\t\tif (elements.length > 1) {\n\t\t\tfor (let element of elements) {\n\t\t\t\tconst match = this.matchMask(word, element);\n\t\t\t\tif (match) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\t// \".\"  => Find a single character, except newline or line terminator\n\t\t// \".*\" => Matches any string that contains zero or more characters\n\t\tmask = mask.split('*').join('.*');\n\n\t\t// \"^\"  => Matches any string with the following at the beginning of it\n\t\t// \"$\"  => Matches any string with that in front at the end of it\n\t\tmask = `^${mask}$`;\n\n\t\t// Create a regular expression object for matching string\n\t\tconst regex = new RegExp(mask);\n\n\t\t// Returns true if it finds a match, otherwise it returns false\n\t\treturn regex.test(word);\n\t}\n\tstatic matchesOneMask(word: string, masks: string[]): boolean {\n\t\tlet matches_one_mask = false;\n\t\tfor (let mask of masks) {\n\t\t\tif (CoreString.matchMask(word, mask)) {\n\t\t\t\tmatches_one_mask = true;\n\t\t\t}\n\t\t}\n\t\treturn matches_one_mask;\n\t}\n\n\tstatic attribNames(word: string): string[] {\n\t\tconst elements = word.split(ATTRIB_NAMES_SEPARATOR);\n\t\tconst names_set: Set<string> = new Set();\n\t\tfor (let element of elements) {\n\t\t\telement = element.trim();\n\t\t\tif (element.length > 0) {\n\t\t\t\tnames_set.add(element);\n\t\t\t}\n\t\t}\n\t\tconst names: string[] = new Array(names_set.size);\n\t\tlet i = 0;\n\t\tnames_set.forEach((name) => {\n\t\t\tnames[i] = name;\n\t\t\ti++;\n\t\t});\n\t\treturn names;\n\t}\n\n\tstatic indices(indices_string: string): number[] {\n\t\tconst elements = indices_string.split(INDICES_LIST_SEPARATOR);\n\t\tif (elements.length > 1) {\n\t\t\tconst indices: number[] = elements.flatMap((element) => this.indices(element));\n\t\t\treturn ArrayUtils.uniq(indices).sort((a, b) => a - b);\n\t\t} else {\n\t\t\tconst element = elements[0];\n\t\t\tif (element) {\n\t\t\t\tconst range_separator = '-';\n\t\t\t\tif (element.indexOf(range_separator) > 0) {\n\t\t\t\t\tconst range_elements = element.split(range_separator);\n\t\t\t\t\treturn ArrayUtils.range(parseInt(range_elements[0]), parseInt(range_elements[1]) + 1);\n\t\t\t\t} else {\n\t\t\t\t\tconst parsed = parseInt(element);\n\t\t\t\t\tif (CoreType.isNumber(parsed)) {\n\t\t\t\t\t\treturn [parsed];\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn [];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn [];\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic escapeLineBreaks(word: string): string {\n\t\treturn word.replace(/(\\r\\n|\\n|\\r)/gm, '\\\\n');\n\t}\n}\n","export class SetUtils {\n\tstatic union<T extends string | number>(set0: Set<T>, set1: Set<T>): Set<T> {\n\t\tconst newSet: Set<T> = new Set();\n\t\tset0.forEach((val) => newSet.add(val));\n\t\tset1.forEach((val) => newSet.add(val));\n\t\treturn newSet;\n\t}\n\tstatic intersection<T extends string | number>(set0: Set<T>, set1: Set<T>): Set<T> {\n\t\tconst newSet: Set<T> = new Set();\n\t\tset0.forEach((val) => {\n\t\t\tif (set1.has(val)) {\n\t\t\t\tnewSet.add(val);\n\t\t\t}\n\t\t});\n\t\tset1.forEach((val) => {\n\t\t\tif (set0.has(val)) {\n\t\t\t\tnewSet.add(val);\n\t\t\t}\n\t\t});\n\t\treturn newSet;\n\t}\n\tstatic difference<T extends string | number>(set0: Set<T>, set1: Set<T>): Set<T> {\n\t\tconst newSet: Set<T> = new Set();\n\t\tset0.forEach((val) => {\n\t\t\tif (!set1.has(val)) {\n\t\t\t\tnewSet.add(val);\n\t\t\t}\n\t\t});\n\t\tset1.forEach((val) => {\n\t\t\tif (!set0.has(val)) {\n\t\t\t\tnewSet.add(val);\n\t\t\t}\n\t\t});\n\t\treturn newSet;\n\t}\n}\n","import {MapUtils} from './MapUtils';\nimport {SetUtils} from './SetUtils';\nimport {CoreType} from './Type';\n\nexport class ArrayUtils {\n\tstatic min<T>(array: Array<T>): T {\n\t\tlet min = array[0];\n\t\tfor (let element of array) {\n\t\t\tif (element < min) {\n\t\t\t\tmin = element;\n\t\t\t}\n\t\t}\n\t\treturn min;\n\t}\n\tstatic max<T>(array: Array<T>): T {\n\t\tlet min = array[0];\n\t\tfor (let element of array) {\n\t\t\tif (element > min) {\n\t\t\t\tmin = element;\n\t\t\t}\n\t\t}\n\t\treturn min;\n\t}\n\tstatic sum(array: number[]): number {\n\t\tlet sum = 0;\n\t\tfor (let element of array) {\n\t\t\tsum += element;\n\t\t}\n\t\treturn sum;\n\t}\n\tstatic compact<T>(array: Array<T | null | undefined>): Array<T> {\n\t\tconst newArray: Array<T> = [];\n\n\t\tfor (let elem of array) {\n\t\t\tif (elem != null) {\n\t\t\t\tnewArray.push(elem);\n\t\t\t}\n\t\t}\n\n\t\treturn newArray;\n\t}\n\tstatic uniq<T>(array: Array<T>): Array<T> {\n\t\tconst tmpSet: Set<T> = new Set();\n\n\t\tfor (let elem of array) {\n\t\t\ttmpSet.add(elem);\n\t\t}\n\n\t\tconst newArray: Array<T> = new Array(tmpSet.size);\n\t\tlet i = 0;\n\t\ttmpSet.forEach((elem) => {\n\t\t\tnewArray[i] = elem;\n\t\t\ti++;\n\t\t});\n\n\t\treturn newArray;\n\t}\n\tstatic chunk<T extends number | string>(array: Array<T>, chunkSize: number): Array<Array<T>> {\n\t\tconst newArray: Array<Array<T>> = [];\n\n\t\tlet newSubArray: Array<T> = [];\n\t\tnewArray.push(newSubArray);\n\t\tfor (let i = 0; i < array.length; i++) {\n\t\t\tif (newSubArray.length == chunkSize) {\n\t\t\t\tnewSubArray = [];\n\t\t\t\tnewArray.push(newSubArray);\n\t\t\t}\n\t\t\tnewSubArray.push(array[i]);\n\t\t}\n\n\t\treturn newArray;\n\t}\n\tstatic union<T extends number | string>(array0: Array<T>, array1: Array<T>): Array<T> {\n\t\tconst newArray: Array<T> = [];\n\t\tconst unionSet = SetUtils.union(this.toSet(array0), this.toSet(array1));\n\t\tunionSet.forEach((val) => newArray.push(val));\n\n\t\treturn newArray;\n\t}\n\tstatic intersection<T extends number | string>(array0: Array<T>, array1: Array<T>): Array<T> {\n\t\tconst newArray: Array<T> = [];\n\t\tconst intersectionSet = SetUtils.intersection(this.toSet(array0), this.toSet(array1));\n\t\tintersectionSet.forEach((val) => newArray.push(val));\n\n\t\treturn newArray;\n\t}\n\tstatic difference<T extends number | string>(array0: Array<T>, array1: Array<T>): Array<T> {\n\t\tconst newArray: Array<T> = [];\n\t\tconst differenceSet = SetUtils.difference(this.toSet(array0), this.toSet(array1));\n\t\tdifferenceSet.forEach((val) => newArray.push(val));\n\n\t\treturn newArray;\n\t}\n\tstatic toSet<T extends number | string>(array: Array<T>): Set<T> {\n\t\tconst set: Set<T> = new Set();\n\t\tfor (let elem of array) {\n\t\t\tset.add(elem);\n\t\t}\n\t\treturn set;\n\t}\n\tstatic isEqual<T extends number | string>(array0: Array<T>, array1: Array<T>): boolean {\n\t\tif (array0.length != array1.length) {\n\t\t\treturn false;\n\t\t}\n\t\tconst count = array0.length;\n\t\tfor (let i = 0; i < count; i++) {\n\t\t\tif (array0[i] != array1[i]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\tstatic sortBy<T, K extends number | string>(array: Array<T>, callback: (e: T) => K): Array<T> {\n\t\tif (array.length == 0) {\n\t\t\treturn [];\n\t\t}\n\t\tconst elementsByValue: Map<K, T[]> = new Map();\n\t\tconst valuesSet: Set<K> = new Set();\n\t\tfor (let elem of array) {\n\t\t\tconst value: K = callback(elem);\n\t\t\tvaluesSet.add(value);\n\t\t\tMapUtils.push_on_array_at_entry(elementsByValue, value, elem);\n\t\t}\n\t\tconst values: K[] = new Array(valuesSet.size);\n\t\tlet i = 0;\n\t\tvaluesSet.forEach((value) => {\n\t\t\tvalues[i] = value;\n\t\t\ti++;\n\t\t});\n\n\t\t// sort differently if the callback return value is a string or a number\n\t\tif (CoreType.isString(values[0])) {\n\t\t\tvalues.sort();\n\t\t} else {\n\t\t\tvalues.sort((a, b) => (a as number) - (b as number));\n\t\t}\n\n\t\tconst sorted_elements: Array<T> = new Array(array.length);\n\t\ti = 0;\n\t\tfor (let value of values) {\n\t\t\tconst elements_for_value = elementsByValue.get(value);\n\t\t\tif (elements_for_value) {\n\t\t\t\tfor (let element of elements_for_value) {\n\t\t\t\t\tsorted_elements[i] = element;\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn sorted_elements;\n\t}\n\n\tstatic range(start: number, end?: number, step: number = 1): number[] {\n\t\tif (end == null) {\n\t\t\tend = start;\n\t\t\tstart = 0;\n\t\t}\n\t\tconst length = Math.floor((end - start) / step);\n\t\tconst array: number[] = new Array(length);\n\n\t\tfor (let i = 0; i < array.length; i++) {\n\t\t\tarray[i] = start + i * step;\n\t\t}\n\t\treturn array;\n\t}\n}\n","//     JavaScript Expression Parser (JSEP) 0.3.5\n//     JSEP may be freely distributed under the MIT License\n//     https://ericsmekens.github.io/jsep/\n\n/*global module: true, exports: true, console: true */\n(function (root) {\n\t'use strict';\n\t// Node Types\n\t// ----------\n\n\t// This is the full set of types that any JSEP node can be.\n\t// Store them here to save space when minified\n\tvar COMPOUND = 'Compound',\n\t\tIDENTIFIER = 'Identifier',\n\t\tMEMBER_EXP = 'MemberExpression',\n\t\tLITERAL = 'Literal',\n\t\tTHIS_EXP = 'ThisExpression',\n\t\tCALL_EXP = 'CallExpression',\n\t\tUNARY_EXP = 'UnaryExpression',\n\t\tBINARY_EXP = 'BinaryExpression',\n\t\tLOGICAL_EXP = 'LogicalExpression',\n\t\tCONDITIONAL_EXP = 'ConditionalExpression',\n\t\tARRAY_EXP = 'ArrayExpression',\n\n\t\tPERIOD_CODE = 46, // '.'\n\t\tCOMMA_CODE  = 44, // ','\n\t\tSQUOTE_CODE = 39, // single quote\n\t\tDQUOTE_CODE = 34, // double quotes\n\t\tOPAREN_CODE = 40, // (\n\t\tCPAREN_CODE = 41, // )\n\t\tOBRACK_CODE = 91, // [\n\t\tCBRACK_CODE = 93, // ]\n\t\tQUMARK_CODE = 63, // ?\n\t\tSEMCOL_CODE = 59, // ;\n\t\tCOLON_CODE  = 58, // :\n\n\t\tthrowError = function(message, index) {\n\t\t\tvar error = new Error(message + ' at character ' + index);\n\t\t\terror.index = index;\n\t\t\terror.description = message;\n\t\t\tthrow error;\n\t\t},\n\n\t// Operations\n\t// ----------\n\n\t// Set `t` to `true` to save space (when minified, not gzipped)\n\t\tt = true,\n\t// Use a quickly-accessible map to store all of the unary operators\n\t// Values are set to `true` (it really doesn't matter)\n\t\tunary_ops = {'-': t, '!': t, '~': t, '+': t},\n\t// Also use a map for the binary operations but set their values to their\n\t// binary precedence for quick reference:\n\t// see [Order of operations](http://en.wikipedia.org/wiki/Order_of_operations#Programming_language)\n\t\tbinary_ops = {\n\t\t\t'||': 1, '&&': 2, '|': 3,  '^': 4,  '&': 5,\n\t\t\t'==': 6, '!=': 6, '===': 6, '!==': 6,\n\t\t\t'<': 7,  '>': 7,  '<=': 7,  '>=': 7,\n\t\t\t'<<':8,  '>>': 8, '>>>': 8,\n\t\t\t'+': 9, '-': 9,\n\t\t\t'*': 10, '/': 10, '%': 10\n\t\t},\n\t// Get return the longest key length of any object\n\t\tgetMaxKeyLen = function(obj) {\n\t\t\tvar max_len = 0, len;\n\t\t\tfor(var key in obj) {\n\t\t\t\tif((len = key.length) > max_len && obj.hasOwnProperty(key)) {\n\t\t\t\t\tmax_len = len;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn max_len;\n\t\t},\n\t\tmax_unop_len = getMaxKeyLen(unary_ops),\n\t\tmax_binop_len = getMaxKeyLen(binary_ops),\n\t// Literals\n\t// ----------\n\t// Store the values to return for the various literals we may encounter\n\t\tliterals = {\n\t\t\t'true': true,\n\t\t\t'false': false,\n\t\t\t'null': null\n\t\t},\n\t// Except for `this`, which is special. This could be changed to something like `'self'` as well\n\t\tthis_str = 'this',\n\t// Returns the precedence of a binary operator or `0` if it isn't a binary operator\n\t\tbinaryPrecedence = function(op_val) {\n\t\t\treturn binary_ops[op_val] || 0;\n\t\t},\n\t// Utility function (gets called from multiple places)\n\t// Also note that `a && b` and `a || b` are *logical* expressions, not binary expressions\n\t\tcreateBinaryExpression = function (operator, left, right) {\n\t\t\tvar type = (operator === '||' || operator === '&&') ? LOGICAL_EXP : BINARY_EXP;\n\t\t\treturn {\n\t\t\t\ttype: type,\n\t\t\t\toperator: operator,\n\t\t\t\tleft: left,\n\t\t\t\tright: right\n\t\t\t};\n\t\t},\n\t\t// `ch` is a character code in the next three functions\n\t\tisDecimalDigit = function(ch) {\n\t\t\treturn (ch >= 48 && ch <= 57); // 0...9\n\t\t},\n\t\tisIdentifierStart = function(ch) {\n\t\t\treturn (ch === 36) || (ch === 95) || // `$` and `_`\n\t\t\t\t\t(ch >= 65 && ch <= 90) || // A...Z\n\t\t\t\t\t(ch >= 97 && ch <= 122) || // a...z\n                    (ch >= 128 && !binary_ops[String.fromCharCode(ch)]); // any non-ASCII that is not an operator\n\t\t},\n\t\tisIdentifierPart = function(ch) {\n\t\t\treturn (ch === 36) || (ch === 95) || // `$` and `_`\n\t\t\t\t\t(ch >= 65 && ch <= 90) || // A...Z\n\t\t\t\t\t(ch >= 97 && ch <= 122) || // a...z\n\t\t\t\t\t(ch >= 48 && ch <= 57) || // 0...9\n                    (ch >= 128 && !binary_ops[String.fromCharCode(ch)]); // any non-ASCII that is not an operator\n\t\t},\n\n\t\t// Parsing\n\t\t// -------\n\t\t// `expr` is a string with the passed in expression\n\t\tjsep = function(expr) {\n\t\t\t// `index` stores the character number we are currently at while `length` is a constant\n\t\t\t// All of the gobbles below will modify `index` as we move along\n\t\t\tvar index = 0,\n\t\t\t\tcharAtFunc = expr.charAt,\n\t\t\t\tcharCodeAtFunc = expr.charCodeAt,\n\t\t\t\texprI = function(i) { return charAtFunc.call(expr, i); },\n\t\t\t\texprICode = function(i) { return charCodeAtFunc.call(expr, i); },\n\t\t\t\tlength = expr.length,\n\n\t\t\t\t// Push `index` up to the next non-space character\n\t\t\t\tgobbleSpaces = function() {\n\t\t\t\t\tvar ch = exprICode(index);\n\t\t\t\t\t// space or tab\n\t\t\t\t\twhile(ch === 32 || ch === 9 || ch === 10 || ch === 13) {\n\t\t\t\t\t\tch = exprICode(++index);\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\t// The main parsing function. Much of this code is dedicated to ternary expressions\n\t\t\t\tgobbleExpression = function() {\n\t\t\t\t\tvar test = gobbleBinaryExpression(),\n\t\t\t\t\t\tconsequent, alternate;\n\t\t\t\t\tgobbleSpaces();\n\t\t\t\t\tif(exprICode(index) === QUMARK_CODE) {\n\t\t\t\t\t\t// Ternary expression: test ? consequent : alternate\n\t\t\t\t\t\tindex++;\n\t\t\t\t\t\tconsequent = gobbleExpression();\n\t\t\t\t\t\tif(!consequent) {\n\t\t\t\t\t\t\tthrowError('Expected expression', index);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tgobbleSpaces();\n\t\t\t\t\t\tif(exprICode(index) === COLON_CODE) {\n\t\t\t\t\t\t\tindex++;\n\t\t\t\t\t\t\talternate = gobbleExpression();\n\t\t\t\t\t\t\tif(!alternate) {\n\t\t\t\t\t\t\t\tthrowError('Expected expression', index);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\ttype: CONDITIONAL_EXP,\n\t\t\t\t\t\t\t\ttest: test,\n\t\t\t\t\t\t\t\tconsequent: consequent,\n\t\t\t\t\t\t\t\talternate: alternate\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthrowError('Expected :', index);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn test;\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\t// Search for the operation portion of the string (e.g. `+`, `===`)\n\t\t\t\t// Start by taking the longest possible binary operations (3 characters: `===`, `!==`, `>>>`)\n\t\t\t\t// and move down from 3 to 2 to 1 character until a matching binary operation is found\n\t\t\t\t// then, return that binary operation\n\t\t\t\tgobbleBinaryOp = function() {\n\t\t\t\t\tgobbleSpaces();\n\t\t\t\t\tvar biop, to_check = expr.substr(index, max_binop_len), tc_len = to_check.length;\n\t\t\t\t\twhile(tc_len > 0) {\n\t\t\t\t\t\t// Don't accept a binary op when it is an identifier.\n\t\t\t\t\t\t// Binary ops that start with a identifier-valid character must be followed\n\t\t\t\t\t\t// by a non identifier-part valid character\n\t\t\t\t\t\tif(binary_ops.hasOwnProperty(to_check) && (\n\t\t\t\t\t\t\t!isIdentifierStart(exprICode(index)) ||\n\t\t\t\t\t\t\t(index+to_check.length< expr.length && !isIdentifierPart(exprICode(index+to_check.length)))\n\t\t\t\t\t\t)) {\n\t\t\t\t\t\t\tindex += tc_len;\n\t\t\t\t\t\t\treturn to_check;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tto_check = to_check.substr(0, --tc_len);\n\t\t\t\t\t}\n\t\t\t\t\treturn false;\n\t\t\t\t},\n\n\t\t\t\t// This function is responsible for gobbling an individual expression,\n\t\t\t\t// e.g. `1`, `1+2`, `a+(b*2)-Math.sqrt(2)`\n\t\t\t\tgobbleBinaryExpression = function() {\n\t\t\t\t\tvar ch_i, node, biop, prec, stack, biop_info, left, right, i, cur_biop;\n\n\t\t\t\t\t// First, try to get the leftmost thing\n\t\t\t\t\t// Then, check to see if there's a binary operator operating on that leftmost thing\n\t\t\t\t\tleft = gobbleToken();\n\t\t\t\t\tbiop = gobbleBinaryOp();\n\n\t\t\t\t\t// If there wasn't a binary operator, just return the leftmost node\n\t\t\t\t\tif(!biop) {\n\t\t\t\t\t\treturn left;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Otherwise, we need to start a stack to properly place the binary operations in their\n\t\t\t\t\t// precedence structure\n\t\t\t\t\tbiop_info = { value: biop, prec: binaryPrecedence(biop)};\n\n\t\t\t\t\tright = gobbleToken();\n\t\t\t\t\tif(!right) {\n\t\t\t\t\t\tthrowError(\"Expected expression after \" + biop, index);\n\t\t\t\t\t}\n\t\t\t\t\tstack = [left, biop_info, right];\n\n\t\t\t\t\t// Properly deal with precedence using [recursive descent](http://www.engr.mun.ca/~theo/Misc/exp_parsing.htm)\n\t\t\t\t\twhile((biop = gobbleBinaryOp())) {\n\t\t\t\t\t\tprec = binaryPrecedence(biop);\n\n\t\t\t\t\t\tif(prec === 0) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbiop_info = { value: biop, prec: prec };\n\n\t\t\t\t\t\tcur_biop = biop;\n\t\t\t\t\t\t// Reduce: make a binary expression from the three topmost entries.\n\t\t\t\t\t\twhile ((stack.length > 2) && (prec <= stack[stack.length - 2].prec)) {\n\t\t\t\t\t\t\tright = stack.pop();\n\t\t\t\t\t\t\tbiop = stack.pop().value;\n\t\t\t\t\t\t\tleft = stack.pop();\n\t\t\t\t\t\t\tnode = createBinaryExpression(biop, left, right);\n\t\t\t\t\t\t\tstack.push(node);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tnode = gobbleToken();\n\t\t\t\t\t\tif(!node) {\n\t\t\t\t\t\t\tthrowError(\"Expected expression after \" + cur_biop, index);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tstack.push(biop_info, node);\n\t\t\t\t\t}\n\n\t\t\t\t\ti = stack.length - 1;\n\t\t\t\t\tnode = stack[i];\n\t\t\t\t\twhile(i > 1) {\n\t\t\t\t\t\tnode = createBinaryExpression(stack[i - 1].value, stack[i - 2], node);\n\t\t\t\t\t\ti -= 2;\n\t\t\t\t\t}\n\t\t\t\t\treturn node;\n\t\t\t\t},\n\n\t\t\t\t// An individual part of a binary expression:\n\t\t\t\t// e.g. `foo.bar(baz)`, `1`, `\"abc\"`, `(a % 2)` (because it's in parenthesis)\n\t\t\t\tgobbleToken = function() {\n\t\t\t\t\tvar ch, to_check, tc_len;\n\n\t\t\t\t\tgobbleSpaces();\n\t\t\t\t\tch = exprICode(index);\n\n\t\t\t\t\tif(isDecimalDigit(ch) || ch === PERIOD_CODE) {\n\t\t\t\t\t\t// Char code 46 is a dot `.` which can start off a numeric literal\n\t\t\t\t\t\treturn gobbleNumericLiteral();\n\t\t\t\t\t} else if(ch === SQUOTE_CODE || ch === DQUOTE_CODE) {\n\t\t\t\t\t\t// Single or double quotes\n\t\t\t\t\t\treturn gobbleStringLiteral();\n\t\t\t\t\t} else if (ch === OBRACK_CODE) {\n\t\t\t\t\t\treturn gobbleArray();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tto_check = expr.substr(index, max_unop_len);\n\t\t\t\t\t\ttc_len = to_check.length;\n\t\t\t\t\t\twhile(tc_len > 0) {\n\t\t\t\t\t\t// Don't accept an unary op when it is an identifier.\n\t\t\t\t\t\t// Unary ops that start with a identifier-valid character must be followed\n\t\t\t\t\t\t// by a non identifier-part valid character\n\t\t\t\t\t\t\tif(unary_ops.hasOwnProperty(to_check) && (\n\t\t\t\t\t\t\t\t!isIdentifierStart(exprICode(index)) ||\n\t\t\t\t\t\t\t\t(index+to_check.length < expr.length && !isIdentifierPart(exprICode(index+to_check.length)))\n\t\t\t\t\t\t\t)) {\n\t\t\t\t\t\t\t\tindex += tc_len;\n\t\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\t\ttype: UNARY_EXP,\n\t\t\t\t\t\t\t\t\toperator: to_check,\n\t\t\t\t\t\t\t\t\targument: gobbleToken(),\n\t\t\t\t\t\t\t\t\tprefix: true\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tto_check = to_check.substr(0, --tc_len);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (isIdentifierStart(ch) || ch === OPAREN_CODE) { // open parenthesis\n\t\t\t\t\t\t\t// `foo`, `bar.baz`\n\t\t\t\t\t\t\treturn gobbleVariable();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn false;\n\t\t\t\t},\n\t\t\t\t// Parse simple numeric literals: `12`, `3.4`, `.5`. Do this by using a string to\n\t\t\t\t// keep track of everything in the numeric literal and then calling `parseFloat` on that string\n\t\t\t\tgobbleNumericLiteral = function() {\n\t\t\t\t\tvar number = '', ch, chCode;\n\t\t\t\t\twhile(isDecimalDigit(exprICode(index))) {\n\t\t\t\t\t\tnumber += exprI(index++);\n\t\t\t\t\t}\n\n\t\t\t\t\tif(exprICode(index) === PERIOD_CODE) { // can start with a decimal marker\n\t\t\t\t\t\tnumber += exprI(index++);\n\n\t\t\t\t\t\twhile(isDecimalDigit(exprICode(index))) {\n\t\t\t\t\t\t\tnumber += exprI(index++);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tch = exprI(index);\n\t\t\t\t\tif(ch === 'e' || ch === 'E') { // exponent marker\n\t\t\t\t\t\tnumber += exprI(index++);\n\t\t\t\t\t\tch = exprI(index);\n\t\t\t\t\t\tif(ch === '+' || ch === '-') { // exponent sign\n\t\t\t\t\t\t\tnumber += exprI(index++);\n\t\t\t\t\t\t}\n\t\t\t\t\t\twhile(isDecimalDigit(exprICode(index))) { //exponent itself\n\t\t\t\t\t\t\tnumber += exprI(index++);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(!isDecimalDigit(exprICode(index-1)) ) {\n\t\t\t\t\t\t\tthrowError('Expected exponent (' + number + exprI(index) + ')', index);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\n\t\t\t\t\tchCode = exprICode(index);\n\t\t\t\t\t// Check to make sure this isn't a variable name that start with a number (123abc)\n\t\t\t\t\tif(isIdentifierStart(chCode)) {\n\t\t\t\t\t\tthrowError('Variable names cannot start with a number (' +\n\t\t\t\t\t\t\t\t\tnumber + exprI(index) + ')', index);\n\t\t\t\t\t} else if(chCode === PERIOD_CODE) {\n\t\t\t\t\t\tthrowError('Unexpected period', index);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn {\n\t\t\t\t\t\ttype: LITERAL,\n\t\t\t\t\t\tvalue: parseFloat(number),\n\t\t\t\t\t\traw: number\n\t\t\t\t\t};\n\t\t\t\t},\n\n\t\t\t\t// Parses a string literal, staring with single or double quotes with basic support for escape codes\n\t\t\t\t// e.g. `\"hello world\"`, `'this is\\nJSEP'`\n\t\t\t\tgobbleStringLiteral = function() {\n\t\t\t\t\tvar str = '', quote = exprI(index++), closed = false, ch;\n\n\t\t\t\t\twhile(index < length) {\n\t\t\t\t\t\tch = exprI(index++);\n\t\t\t\t\t\tif(ch === quote) {\n\t\t\t\t\t\t\tclosed = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} else if(ch === '\\\\') {\n\t\t\t\t\t\t\t// Check for all of the common escape codes\n\t\t\t\t\t\t\tch = exprI(index++);\n\t\t\t\t\t\t\tswitch(ch) {\n\t\t\t\t\t\t\t\tcase 'n': str += '\\n'; break;\n\t\t\t\t\t\t\t\tcase 'r': str += '\\r'; break;\n\t\t\t\t\t\t\t\tcase 't': str += '\\t'; break;\n\t\t\t\t\t\t\t\tcase 'b': str += '\\b'; break;\n\t\t\t\t\t\t\t\tcase 'f': str += '\\f'; break;\n\t\t\t\t\t\t\t\tcase 'v': str += '\\x0B'; break;\n\t\t\t\t\t\t\t\tdefault : str += ch;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tstr += ch;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif(!closed) {\n\t\t\t\t\t\tthrowError('Unclosed quote after \"'+str+'\"', index);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn {\n\t\t\t\t\t\ttype: LITERAL,\n\t\t\t\t\t\tvalue: str,\n\t\t\t\t\t\traw: quote + str + quote\n\t\t\t\t\t};\n\t\t\t\t},\n\n\t\t\t\t// Gobbles only identifiers\n\t\t\t\t// e.g.: `foo`, `_value`, `$x1`\n\t\t\t\t// Also, this function checks if that identifier is a literal:\n\t\t\t\t// (e.g. `true`, `false`, `null`) or `this`\n\t\t\t\tgobbleIdentifier = function() {\n\t\t\t\t\tvar ch = exprICode(index), start = index, identifier;\n\n\t\t\t\t\tif(isIdentifierStart(ch)) {\n\t\t\t\t\t\tindex++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrowError('Unexpected ' + exprI(index), index);\n\t\t\t\t\t}\n\n\t\t\t\t\twhile(index < length) {\n\t\t\t\t\t\tch = exprICode(index);\n\t\t\t\t\t\tif(isIdentifierPart(ch)) {\n\t\t\t\t\t\t\tindex++;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tidentifier = expr.slice(start, index);\n\n\t\t\t\t\tif(literals.hasOwnProperty(identifier)) {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\ttype: LITERAL,\n\t\t\t\t\t\t\tvalue: literals[identifier],\n\t\t\t\t\t\t\traw: identifier\n\t\t\t\t\t\t};\n\t\t\t\t\t} else if(identifier === this_str) {\n\t\t\t\t\t\treturn { type: THIS_EXP };\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\ttype: IDENTIFIER,\n\t\t\t\t\t\t\tname: identifier\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\t// Gobbles a list of arguments within the context of a function call\n\t\t\t\t// or array literal. This function also assumes that the opening character\n\t\t\t\t// `(` or `[` has already been gobbled, and gobbles expressions and commas\n\t\t\t\t// until the terminator character `)` or `]` is encountered.\n\t\t\t\t// e.g. `foo(bar, baz)`, `my_func()`, or `[bar, baz]`\n\t\t\t\tgobbleArguments = function(termination) {\n\t\t\t\t\tvar ch_i, args = [], node, closed = false;\n\t\t\t\t\tvar separator_count = 0;\n\t\t\t\t\twhile(index < length) {\n\t\t\t\t\t\tgobbleSpaces();\n\t\t\t\t\t\tch_i = exprICode(index);\n\t\t\t\t\t\tif(ch_i === termination) { // done parsing\n\t\t\t\t\t\t\tclosed = true;\n\t\t\t\t\t\t\tindex++;\n\t\t\t\t\t\t\tif(termination === CPAREN_CODE && separator_count && separator_count >= args.length){\n\t\t\t\t\t\t\t\tthrowError('Unexpected token ' + String.fromCharCode(termination), index);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} else if (ch_i === COMMA_CODE) { // between expressions\n\t\t\t\t\t\t\tindex++;\n\t\t\t\t\t\t\tseparator_count++;\n\t\t\t\t\t\t\tif(separator_count !== args.length) { // missing argument\n\t\t\t\t\t\t\t\tif(termination === CPAREN_CODE) {\n\t\t\t\t\t\t\t\t\tthrowError('Unexpected token ,', index);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse if(termination === CBRACK_CODE) {\n\t\t\t\t\t\t\t\t\tfor(var arg = args.length; arg< separator_count; arg++) {\n\t\t\t\t\t\t\t\t\t\targs.push(null);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tnode = gobbleExpression();\n\t\t\t\t\t\t\tif(!node || node.type === COMPOUND) {\n\t\t\t\t\t\t\t\tthrowError('Expected comma', index);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\targs.push(node);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!closed) {\n\t\t\t\t\t\tthrowError('Expected ' + String.fromCharCode(termination), index);\n\t\t\t\t\t}\n\t\t\t\t\treturn args;\n\t\t\t\t},\n\n\t\t\t\t// Gobble a non-literal variable name. This variable name may include properties\n\t\t\t\t// e.g. `foo`, `bar.baz`, `foo['bar'].baz`\n\t\t\t\t// It also gobbles function calls:\n\t\t\t\t// e.g. `Math.acos(obj.angle)`\n\t\t\t\tgobbleVariable = function() {\n\t\t\t\t\tvar ch_i, node;\n\t\t\t\t\tch_i = exprICode(index);\n\n\t\t\t\t\tif(ch_i === OPAREN_CODE) {\n\t\t\t\t\t\tnode = gobbleGroup();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnode = gobbleIdentifier();\n\t\t\t\t\t}\n\t\t\t\t\tgobbleSpaces();\n\t\t\t\t\tch_i = exprICode(index);\n\t\t\t\t\twhile(ch_i === PERIOD_CODE || ch_i === OBRACK_CODE || ch_i === OPAREN_CODE) {\n\t\t\t\t\t\tindex++;\n\t\t\t\t\t\tif(ch_i === PERIOD_CODE) {\n\t\t\t\t\t\t\tgobbleSpaces();\n\t\t\t\t\t\t\tnode = {\n\t\t\t\t\t\t\t\ttype: MEMBER_EXP,\n\t\t\t\t\t\t\t\tcomputed: false,\n\t\t\t\t\t\t\t\tobject: node,\n\t\t\t\t\t\t\t\tproperty: gobbleIdentifier()\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t} else if(ch_i === OBRACK_CODE) {\n\t\t\t\t\t\t\tnode = {\n\t\t\t\t\t\t\t\ttype: MEMBER_EXP,\n\t\t\t\t\t\t\t\tcomputed: true,\n\t\t\t\t\t\t\t\tobject: node,\n\t\t\t\t\t\t\t\tproperty: gobbleExpression()\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tgobbleSpaces();\n\t\t\t\t\t\t\tch_i = exprICode(index);\n\t\t\t\t\t\t\tif(ch_i !== CBRACK_CODE) {\n\t\t\t\t\t\t\t\tthrowError('Unclosed [', index);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tindex++;\n\t\t\t\t\t\t} else if(ch_i === OPAREN_CODE) {\n\t\t\t\t\t\t\t// A function call is being made; gobble all the arguments\n\t\t\t\t\t\t\tnode = {\n\t\t\t\t\t\t\t\ttype: CALL_EXP,\n\t\t\t\t\t\t\t\t'arguments': gobbleArguments(CPAREN_CODE),\n\t\t\t\t\t\t\t\tcallee: node\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}\n\t\t\t\t\t\tgobbleSpaces();\n\t\t\t\t\t\tch_i = exprICode(index);\n\t\t\t\t\t}\n\t\t\t\t\treturn node;\n\t\t\t\t},\n\n\t\t\t\t// Responsible for parsing a group of things within parentheses `()`\n\t\t\t\t// This function assumes that it needs to gobble the opening parenthesis\n\t\t\t\t// and then tries to gobble everything within that parenthesis, assuming\n\t\t\t\t// that the next thing it should see is the close parenthesis. If not,\n\t\t\t\t// then the expression probably doesn't have a `)`\n\t\t\t\tgobbleGroup = function() {\n\t\t\t\t\tindex++;\n\t\t\t\t\tvar node = gobbleExpression();\n\t\t\t\t\tgobbleSpaces();\n\t\t\t\t\tif(exprICode(index) === CPAREN_CODE) {\n\t\t\t\t\t\tindex++;\n\t\t\t\t\t\treturn node;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrowError('Unclosed (', index);\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\t// Responsible for parsing Array literals `[1, 2, 3]`\n\t\t\t\t// This function assumes that it needs to gobble the opening bracket\n\t\t\t\t// and then tries to gobble the expressions as arguments.\n\t\t\t\tgobbleArray = function() {\n\t\t\t\t\tindex++;\n\t\t\t\t\treturn {\n\t\t\t\t\t\ttype: ARRAY_EXP,\n\t\t\t\t\t\telements: gobbleArguments(CBRACK_CODE)\n\t\t\t\t\t};\n\t\t\t\t},\n\n\t\t\t\tnodes = [], ch_i, node;\n\n\t\t\twhile(index < length) {\n\t\t\t\tch_i = exprICode(index);\n\n\t\t\t\t// Expressions can be separated by semicolons, commas, or just inferred without any\n\t\t\t\t// separators\n\t\t\t\tif(ch_i === SEMCOL_CODE || ch_i === COMMA_CODE) {\n\t\t\t\t\tindex++; // ignore separators\n\t\t\t\t} else {\n\t\t\t\t\t// Try to gobble each expression individually\n\t\t\t\t\tif((node = gobbleExpression())) {\n\t\t\t\t\t\tnodes.push(node);\n\t\t\t\t\t// If we weren't able to find a binary expression and are out of room, then\n\t\t\t\t\t// the expression passed in probably has too much\n\t\t\t\t\t} else if(index < length) {\n\t\t\t\t\t\tthrowError('Unexpected \"' + exprI(index) + '\"', index);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If there's only one expression just try returning the expression\n\t\t\tif(nodes.length === 1) {\n\t\t\t\treturn nodes[0];\n\t\t\t} else {\n\t\t\t\treturn {\n\t\t\t\t\ttype: COMPOUND,\n\t\t\t\t\tbody: nodes\n\t\t\t\t};\n\t\t\t}\n\t\t};\n\n\t// To be filled in by the template\n\tjsep.version = '0.3.5';\n\tjsep.toString = function() { return 'JavaScript Expression Parser (JSEP) v' + jsep.version; };\n\n\t/**\n\t * @method jsep.addUnaryOp\n\t * @param {string} op_name The name of the unary op to add\n\t * @return jsep\n\t */\n\tjsep.addUnaryOp = function(op_name) {\n\t\tmax_unop_len = Math.max(op_name.length, max_unop_len);\n\t\tunary_ops[op_name] = t; return this;\n\t};\n\n\t/**\n\t * @method jsep.addBinaryOp\n\t * @param {string} op_name The name of the binary op to add\n\t * @param {number} precedence The precedence of the binary op (can be a float)\n\t * @return jsep\n\t */\n\tjsep.addBinaryOp = function(op_name, precedence) {\n\t\tmax_binop_len = Math.max(op_name.length, max_binop_len);\n\t\tbinary_ops[op_name] = precedence;\n\t\treturn this;\n\t};\n\n\t/**\n\t * @method jsep.addLiteral\n\t * @param {string} literal_name The name of the literal to add\n\t * @param {*} literal_value The value of the literal\n\t * @return jsep\n\t */\n\tjsep.addLiteral = function(literal_name, literal_value) {\n\t\tliterals[literal_name] = literal_value;\n\t\treturn this;\n\t};\n\n\t/**\n\t * @method jsep.removeUnaryOp\n\t * @param {string} op_name The name of the unary op to remove\n\t * @return jsep\n\t */\n\tjsep.removeUnaryOp = function(op_name) {\n\t\tdelete unary_ops[op_name];\n\t\tif(op_name.length === max_unop_len) {\n\t\t\tmax_unop_len = getMaxKeyLen(unary_ops);\n\t\t}\n\t\treturn this;\n\t};\n\n\t/**\n\t * @method jsep.removeAllUnaryOps\n\t * @return jsep\n\t */\n\tjsep.removeAllUnaryOps = function() {\n\t\tunary_ops = {};\n\t\tmax_unop_len = 0;\n\n\t\treturn this;\n\t};\n\n\t/**\n\t * @method jsep.removeBinaryOp\n\t * @param {string} op_name The name of the binary op to remove\n\t * @return jsep\n\t */\n\tjsep.removeBinaryOp = function(op_name) {\n\t\tdelete binary_ops[op_name];\n\t\tif(op_name.length === max_binop_len) {\n\t\t\tmax_binop_len = getMaxKeyLen(binary_ops);\n\t\t}\n\t\treturn this;\n\t};\n\n\t/**\n\t * @method jsep.removeAllBinaryOps\n\t * @return jsep\n\t */\n\tjsep.removeAllBinaryOps = function() {\n\t\tbinary_ops = {};\n\t\tmax_binop_len = 0;\n\n\t\treturn this;\n\t};\n\n\t/**\n\t * @method jsep.removeLiteral\n\t * @param {string} literal_name The name of the literal to remove\n\t * @return jsep\n\t */\n\tjsep.removeLiteral = function(literal_name) {\n\t\tdelete literals[literal_name];\n\t\treturn this;\n\t};\n\n\t/**\n\t * @method jsep.removeAllLiterals\n\t * @return jsep\n\t */\n\tjsep.removeAllLiterals = function() {\n\t\tliterals = {};\n\n\t\treturn this;\n\t};\n\n\t// In desktop environments, have a way to restore the old value for `jsep`\n\tif (typeof exports === 'undefined') {\n\t\tvar old_jsep = root.jsep;\n\t\t// The star of the show! It's a function!\n\t\troot.jsep = jsep;\n\t\t// And a courteous function willing to move out of the way for other similarly-named objects!\n\t\tjsep.noConflict = function() {\n\t\t\tif(root.jsep === jsep) {\n\t\t\t\troot.jsep = old_jsep;\n\t\t\t}\n\t\t\treturn jsep;\n\t\t};\n\t} else {\n\t\t// In Node.JS environments\n\t\tif (typeof module !== 'undefined' && module.exports) {\n\t\t\texports = module.exports = jsep;\n\t\t} else {\n\t\t\texports.parse = jsep;\n\t\t}\n\t}\n}(this));\n","// events\nexport enum NodeEvent {\n\tCREATED = 'node_created',\n\tDELETED = 'node_deleted',\n\tNAME_UPDATED = 'node_name_update',\n\tOVERRIDE_CLONABLE_STATE_UPDATE = 'node_override_clonable_state_update',\n\tNAMED_OUTPUTS_UPDATED = 'node_named_outputs_updated',\n\tNAMED_INPUTS_UPDATED = 'node_named_inputs_updated',\n\tINPUTS_UPDATED = 'node_inputs_updated',\n\tPARAMS_UPDATED = 'node_params_updated',\n\tUI_DATA_POSITION_UPDATED = 'node_ui_data_position_updated',\n\tUI_DATA_COMMENT_UPDATED = 'node_ui_data_comment_updated',\n\tERROR_UPDATED = 'node_error_updated',\n\tFLAG_BYPASS_UPDATED = 'bypass_flag_updated',\n\tFLAG_DISPLAY_UPDATED = 'display_flag_updated',\n\tFLAG_OPTIMIZE_UPDATED = 'optimize_flag_updated',\n\tSELECTION_UPDATED = 'selection_updated',\n}\n","export class TypeAssert {\n\tstatic unreachable(x: never): never {\n\t\tthrow new Error(\"Didn't expect to get here\");\n\t}\n}\n","import {CoreGraphNode} from './CoreGraphNode';\nimport {CoreGraphNodeId} from './CoreGraph';\n\nexport type PostDirtyHook = (caller?: CoreGraphNode) => void;\n\nexport class DirtyController {\n\t_dirty_count: number = 0;\n\t_dirty: boolean = true;\n\t_dirty_timestamp: number | undefined;\n\t_cached_successors: CoreGraphNode[] | undefined;\n\t_forbidden_trigger_nodes: CoreGraphNodeId[] | undefined;\n\n\t// hooks\n\t_post_dirty_hooks: PostDirtyHook[] | undefined;\n\t_post_dirty_hook_names: string[] | undefined;\n\n\tconstructor(private node: CoreGraphNode) {}\n\n\tdispose() {\n\t\tthis._cached_successors = undefined;\n\t\tthis._post_dirty_hooks = undefined;\n\t\tthis._post_dirty_hook_names = undefined;\n\t}\n\n\tisDirty(): boolean {\n\t\treturn this._dirty === true;\n\t}\n\tdirtyTimestamp() {\n\t\treturn this._dirty_timestamp;\n\t}\n\tdirtyCount(): number {\n\t\treturn this._dirty_count;\n\t}\n\taddPostDirtyHook(name: string, method: PostDirtyHook) {\n\t\tthis._post_dirty_hook_names = this._post_dirty_hook_names || [];\n\t\tthis._post_dirty_hooks = this._post_dirty_hooks || [];\n\n\t\tif (!this._post_dirty_hook_names.includes(name)) {\n\t\t\tthis._post_dirty_hook_names.push(name);\n\t\t\tthis._post_dirty_hooks.push(method);\n\t\t} else {\n\t\t\tconsole.warn(`hook with name ${name} already exists`, this.node);\n\t\t}\n\t}\n\tremovePostDirtyHook(name: string) {\n\t\tif (this._post_dirty_hook_names && this._post_dirty_hooks) {\n\t\t\tconst index = this._post_dirty_hook_names.indexOf(name);\n\t\t\tif (index >= 0) {\n\t\t\t\tthis._post_dirty_hook_names.splice(index, 1);\n\t\t\t\tthis._post_dirty_hooks.splice(index, 1);\n\t\t\t}\n\t\t}\n\t}\n\thas_hook(name: string): boolean {\n\t\tif (this._post_dirty_hook_names) {\n\t\t\treturn this._post_dirty_hook_names.includes(name);\n\t\t}\n\t\treturn false;\n\t}\n\n\tremoveDirtyState(): void {\n\t\tthis._dirty = false;\n\t}\n\tset_forbidden_trigger_nodes(nodes: CoreGraphNode[]) {\n\t\tthis._forbidden_trigger_nodes = nodes.map((n) => n.graphNodeId());\n\t}\n\n\tset_dirty(original_trigger_graph_node?: CoreGraphNode | null, propagate?: boolean): void {\n\t\tif (propagate == null) {\n\t\t\tpropagate = true;\n\t\t}\n\t\tif (\n\t\t\toriginal_trigger_graph_node &&\n\t\t\tthis._forbidden_trigger_nodes &&\n\t\t\tthis._forbidden_trigger_nodes.includes(original_trigger_graph_node.graphNodeId())\n\t\t) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (original_trigger_graph_node == null) {\n\t\t\toriginal_trigger_graph_node = this.node;\n\t\t}\n\n\t\tthis._dirty = true;\n\t\tthis._dirty_timestamp = performance.now();\n\t\tthis._dirty_count += 1;\n\n\t\tthis.run_post_dirty_hooks(original_trigger_graph_node);\n\n\t\tif (propagate === true) {\n\t\t\tthis.set_successors_dirty(original_trigger_graph_node);\n\t\t}\n\t}\n\n\trun_post_dirty_hooks(original_trigger_graph_node?: CoreGraphNode) {\n\t\tif (this._post_dirty_hooks) {\n\t\t\tconst cooker = this.node.scene().cooker;\n\t\t\tif (cooker.blocked) {\n\t\t\t\tcooker.enqueue(this.node, original_trigger_graph_node);\n\t\t\t} else {\n\t\t\t\tfor (let hook of this._post_dirty_hooks) {\n\t\t\t\t\thook(original_trigger_graph_node);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tset_successors_dirty(original_trigger_graph_node?: CoreGraphNode): void {\n\t\tconst propagate = false;\n\t\tthis._cached_successors = this._cached_successors || this.node.graphAllSuccessors();\n\n\t\tfor (let successor of this._cached_successors) {\n\t\t\tsuccessor.dirtyController.set_dirty(original_trigger_graph_node, propagate);\n\t\t}\n\t}\n\n\tclear_successors_cache() {\n\t\tthis._cached_successors = undefined;\n\t}\n\tclear_successors_cache_with_predecessors() {\n\t\tthis.clear_successors_cache();\n\t\tfor (let predecessor of this.node.graphAllPredecessors()) {\n\t\t\tpredecessor.dirtyController.clear_successors_cache();\n\t\t}\n\t}\n}\n","import {CoreGraph, CoreGraphNodeId} from './CoreGraph';\nimport {DirtyController, PostDirtyHook} from './DirtyController';\nimport {PolyScene} from '../../engine/scene/PolyScene';\n\nexport class CoreGraphNode {\n\tprivate _graph: CoreGraph;\n\tprivate _graph_node_id: CoreGraphNodeId;\n\tprivate _dirty_controller: DirtyController = new DirtyController(this);\n\tconstructor(protected _scene: PolyScene, protected _name: string) {\n\t\tthis._graph_node_id = _scene.graph.next_id();\n\t\t_scene.graph.add_node(this);\n\t\tthis._graph = _scene.graph;\n\t}\n\n\tdispose() {\n\t\tthis._dirty_controller.dispose();\n\t\tthis.graphRemove();\n\t}\n\n\tname() {\n\t\treturn this._name;\n\t}\n\tsetName(name: string) {\n\t\tthis._name = name;\n\t}\n\n\tscene() {\n\t\treturn this._scene;\n\t}\n\t// graph() {\n\t// \treturn this._graph;\n\t// }\n\tgraphNodeId(): CoreGraphNodeId {\n\t\treturn this._graph_node_id;\n\t}\n\n\t//\n\t//\n\t// DIRTY CONTROLLER\n\t//\n\t//\n\tget dirtyController() {\n\t\treturn this._dirty_controller;\n\t}\n\tsetDirty(trigger?: CoreGraphNode | null) {\n\t\ttrigger = trigger || this;\n\t\tthis._dirty_controller.set_dirty(trigger);\n\t}\n\tsetSuccessorsDirty(trigger?: CoreGraphNode) {\n\t\tthis._dirty_controller.set_successors_dirty(trigger);\n\t}\n\tremoveDirtyState() {\n\t\tthis._dirty_controller.removeDirtyState();\n\t}\n\tisDirty() {\n\t\treturn this._dirty_controller.isDirty();\n\t}\n\taddPostDirtyHook(name: string, callback: PostDirtyHook) {\n\t\tthis._dirty_controller.addPostDirtyHook(name, callback);\n\t}\n\n\t//\n\t//\n\t// GRAPH\n\t//\n\t//\n\n\tgraphRemove() {\n\t\tthis._graph.remove_node(this);\n\t}\n\n\taddGraphInput(src: CoreGraphNode, check_if_graph_has_cycle = true): boolean {\n\t\treturn this._graph.connect(src, this, check_if_graph_has_cycle);\n\t}\n\tremoveGraphInput(src: CoreGraphNode) {\n\t\tthis._graph.disconnect(src, this);\n\t}\n\n\tgraphDisconnectPredecessors() {\n\t\tthis._graph.disconnect_predecessors(this);\n\t}\n\tgraphDisconnectSuccessors() {\n\t\tthis._graph.disconnect_successors(this);\n\t}\n\n\tgraphPredecessorIds(): CoreGraphNodeId[] {\n\t\treturn this._graph.predecessor_ids(this._graph_node_id) || [];\n\t}\n\tgraphPredecessors(): CoreGraphNode[] {\n\t\treturn this._graph.predecessors(this);\n\t}\n\tgraphSuccessors(): CoreGraphNode[] {\n\t\treturn this._graph.successors(this);\n\t}\n\tgraphAllPredecessors(): CoreGraphNode[] {\n\t\treturn this._graph.all_predecessors(this);\n\t}\n\tgraphAllSuccessors(): CoreGraphNode[] {\n\t\treturn this._graph.all_successors(this);\n\t}\n}\n","import {Vector2} from 'three/src/math/Vector2';\nimport {Vector3} from 'three/src/math/Vector3';\nimport {Vector4} from 'three/src/math/Vector4';\nimport {BufferAttribute} from 'three/src/core/BufferAttribute';\nimport {AttribValue, PolyDictionary} from '../../types/GlobalTypes';\nimport {CoreType} from '../Type';\nimport {AttribSize} from './Constant';\n\nexport enum Attribute {\n\tPOSITION = 'position',\n\tNORMAL = 'normal',\n\tTANGENT = 'tangent',\n}\n\nconst ATTRIB_NAME_MAP: PolyDictionary<string> = {\n\tP: 'position',\n\tN: 'normal',\n\tCd: 'color',\n};\n\nexport class CoreAttribute {\n\tstatic remap_name(name: string): string {\n\t\treturn ATTRIB_NAME_MAP[name] || name;\n\t}\n\n\tstatic array_to_indexed_arrays(array: string[]) {\n\t\tconst index_by_value: PolyDictionary<number> = {};\n\t\tlet current_index = 0;\n\t\tconst indices = [];\n\t\tconst values = [];\n\n\t\tlet i = 0;\n\t\twhile (i < array.length) {\n\t\t\t//(value = array[i++])?\n\t\t\tconst value = array[i];\n\t\t\tconst index = index_by_value[value];\n\t\t\tif (index != null) {\n\t\t\t\tindices.push(index);\n\t\t\t} else {\n\t\t\t\tvalues.push(value);\n\t\t\t\tindices.push(current_index);\n\t\t\t\tindex_by_value[value] = current_index;\n\t\t\t\tcurrent_index += 1;\n\t\t\t}\n\n\t\t\ti++;\n\t\t}\n\n\t\treturn {\n\t\t\tindices,\n\t\t\tvalues,\n\t\t};\n\t}\n\n\tstatic default_value(size: number) {\n\t\tswitch (size) {\n\t\t\tcase 1:\n\t\t\t\treturn 0;\n\t\t\tcase 2:\n\t\t\t\treturn new Vector2(0, 0);\n\t\t\tcase 3:\n\t\t\t\treturn new Vector3(0, 0, 0);\n\t\t\tdefault:\n\t\t\t\tthrow `size ${size} not yet implemented`;\n\t\t}\n\t}\n\n\tstatic copy(src: BufferAttribute, dest: BufferAttribute, mark_as_needs_update = true) {\n\t\tconst src_array = src?.array as number[] | undefined;\n\t\tconst dest_array = dest?.array as number[] | undefined;\n\t\tif (src_array && dest_array) {\n\t\t\tconst min_length = Math.min(src_array.length, dest_array.length);\n\t\t\tfor (let i = 0; i < min_length; i++) {\n\t\t\t\tdest_array[i] = src_array[i];\n\t\t\t}\n\n\t\t\tif (mark_as_needs_update) {\n\t\t\t\tdest.needsUpdate = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic attribSizeFromValue(val: AttribValue): number | null {\n\t\tif (CoreType.isString(val) || CoreType.isNumber(val)) {\n\t\t\treturn AttribSize.FLOAT;\n\t\t}\n\t\tif (CoreType.isArray(val)) {\n\t\t\treturn val.length;\n\t\t}\n\n\t\tswitch (val.constructor) {\n\t\t\tcase Vector2:\n\t\t\t\treturn AttribSize.VECTOR2;\n\t\t\tcase Vector3:\n\t\t\t\treturn AttribSize.VECTOR3;\n\t\t\tcase Vector4:\n\t\t\t\treturn AttribSize.VECTOR4;\n\t\t}\n\t\treturn 0;\n\t}\n}\n","export enum ParamEvent {\n\tVISIBLE_UPDATED = 'param_visible_updated',\n\t// UPDATED = 'param_updated',\n\tRAW_INPUT_UPDATED = 'raw_input_updated',\n\tVALUE_UPDATED = 'param_value_updated',\n\tEXPRESSION_UPDATED = 'param_expression_update',\n\tERROR_UPDATED = 'param_error_updated',\n\tDELETED = 'param_deleted',\n}\n","import {Vector2} from 'three/src/math/Vector2';\nimport {Color} from 'three/src/math/Color';\nimport {BaseNodeType} from '../_Base';\nimport {NodeEvent} from '../../poly/NodeEvent';\nimport {CoreType} from '../../../core/Type';\n\nexport interface NodeUIDataJson {\n\tx: number;\n\ty: number;\n\tcomment?: string;\n}\n\nexport class UIData {\n\tprivate _position: Vector2 = new Vector2();\n\tprotected _width: number = 50;\n\t// private _border_radius: number = 3;\n\tprivate _color: Color = new Color(0.75, 0.75, 0.75);\n\t// private _icon: string | null = null;\n\tprivate _layout_vertical: boolean = true;\n\tprivate _comment: string | undefined;\n\tprivate _json: NodeUIDataJson = {\n\t\tx: 0,\n\t\ty: 0,\n\t};\n\n\tconstructor(private node: BaseNodeType, x: number = 0, y: number = 0) {\n\t\tthis._position.x = x;\n\t\tthis._position.y = y;\n\t}\n\n\tsetComment(comment: string | undefined) {\n\t\tthis._comment = comment;\n\t\tthis.node.emit(NodeEvent.UI_DATA_COMMENT_UPDATED);\n\t}\n\tcomment(): string | undefined {\n\t\treturn this._comment;\n\t}\n\tsetColor(color: Color) {\n\t\tthis._color = color;\n\t}\n\tcolor() {\n\t\treturn this._color;\n\t}\n\t// setIcon(icon: string) {\n\t// \tthis._icon = icon;\n\t// }\n\t// icon() {\n\t// \treturn this._icon;\n\t// }\n\tsetLayoutHorizontal() {\n\t\tthis._layout_vertical = false;\n\t}\n\tisLayoutVertical() {\n\t\treturn this._layout_vertical;\n\t}\n\n\tcopy(ui_data: UIData) {\n\t\tthis._position.copy(ui_data.position());\n\t\tthis._color.copy(ui_data.color());\n\t}\n\n\tposition() {\n\t\treturn this._position;\n\t}\n\n\tsetPosition(new_position: Vector2 | number, y: number = 0) {\n\t\tif (CoreType.isNumber(new_position)) {\n\t\t\tconst x = new_position;\n\t\t\tthis._position.set(x, y);\n\t\t} else {\n\t\t\tthis._position.copy(new_position);\n\t\t}\n\t\tthis.node.emit(NodeEvent.UI_DATA_POSITION_UPDATED);\n\t}\n\n\ttranslate(offset: Vector2, snap: boolean = false) {\n\t\tthis._position.add(offset);\n\n\t\tif (snap) {\n\t\t\tthis._position.x = Math.round(this._position.x);\n\t\t\tthis._position.y = Math.round(this._position.y);\n\t\t}\n\n\t\tthis.node.emit(NodeEvent.UI_DATA_POSITION_UPDATED);\n\t}\n\n\ttoJSON(): NodeUIDataJson {\n\t\tthis._json.x = this._position.x;\n\t\tthis._json.y = this._position.y;\n\t\tthis._json.comment = this._comment;\n\t\treturn this._json;\n\t}\n}\n","import {BaseNodeType} from '../../_Base';\n\nexport class BaseState {\n\tconstructor(protected node: BaseNodeType) {}\n}\n","import {BaseState} from './Base';\n\nexport class TimeDependentState extends BaseState {\n\tactive() {\n\t\treturn this.are_params_time_dependent() || this.are_inputs_time_dependent();\n\t}\n\n\tare_params_time_dependent(): boolean {\n\t\tconst param_names = this.node.params.names;\n\t\tfor (let param_name of param_names) {\n\t\t\tconst param = this.node.params.get(param_name);\n\t\t\tif (param && param.states.time_dependent.active()) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tare_inputs_time_dependent(): boolean {\n\t\tconst inputs = this.node.io.inputs.inputs();\n\t\tfor (let input of inputs) {\n\t\t\tif (input && input.states.time_dependent.active()) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tforce_time_dependent() {\n\t\tconst predecessor_ids = this.node.graphPredecessors().map((n) => n.graphNodeId());\n\t\tconst frame_node = this.node.scene().timeController.graphNode;\n\t\tif (!predecessor_ids.includes(frame_node.graphNodeId())) {\n\t\t\tthis.node.addGraphInput(frame_node, false);\n\t\t}\n\t}\n\tunforce_time_dependent() {\n\t\tconst frame_node = this.node.scene().timeController.graphNode;\n\t\tthis.node.removeGraphInput(frame_node);\n\t}\n}\n","import {NodeEvent} from '../../../poly/NodeEvent';\nimport {BaseState} from './Base';\nimport {Poly} from '../../../Poly';\n\nexport class ErrorState extends BaseState {\n\tprivate _message: string | undefined;\n\n\tset(message: string | undefined) {\n\t\tif (this._message != message) {\n\t\t\tif (message) {\n\t\t\t\tPoly.warn(`[${this.node.fullPath()}] error: '${message}'`);\n\t\t\t}\n\t\t\tthis._message = message;\n\t\t\tthis.on_update();\n\t\t}\n\t}\n\tmessage() {\n\t\treturn this._message;\n\t}\n\tclear() {\n\t\tthis.set(undefined);\n\t}\n\tactive(): boolean {\n\t\treturn this._message != null;\n\t}\n\n\tprotected on_update() {\n\t\tif (this._message != null) {\n\t\t\t// console.warn(\"new error\", message, this.self.fullPath())\n\t\t\tthis.node.setContainer(null, `from error '${this._message}'`);\n\t\t}\n\n\t\tthis.node.emit(NodeEvent.ERROR_UPDATED);\n\t}\n}\n","import {BaseNodeType} from '../_Base';\n\nimport {TimeDependentState} from './states/TimeDependent';\nimport {ErrorState} from './states/Error';\n\nexport class StatesController {\n\ttime_dependent = new TimeDependentState(this.node);\n\terror = new ErrorState(this.node);\n\tconstructor(protected node: BaseNodeType) {}\n}\n","import {BaseNodeType} from '../_Base';\nimport {CoreGraphNode} from '../../../core/graph/CoreGraphNode';\nimport {NodeEvent} from '../../poly/NodeEvent';\nimport {CoreType} from '../../../core/Type';\n\ntype Callback = () => void;\n\nexport class NameController {\n\tprivate _graph_node: CoreGraphNode;\n\tprivate _on_set_name_hooks: Callback[] | undefined;\n\tprivate _on_set_fullPath_hooks: Callback[] | undefined;\n\n\tconstructor(protected node: BaseNodeType) {\n\t\tthis._graph_node = new CoreGraphNode(node.scene(), 'node_name_controller');\n\t\t// this._graph_node.set_scene(this.node.scene);\n\t}\n\n\tdispose() {\n\t\tthis._graph_node.dispose();\n\t\tthis._on_set_name_hooks = undefined;\n\t\tthis._on_set_fullPath_hooks = undefined;\n\t}\n\n\tget graph_node() {\n\t\treturn this._graph_node;\n\t}\n\n\tstatic base_name(node: BaseNodeType) {\n\t\tlet base: string = node.type();\n\t\tconst last_char = base[base.length - 1];\n\t\tif (!CoreType.isNaN(parseInt(last_char))) {\n\t\t\tbase += '_';\n\t\t}\n\t\treturn `${base}1`;\n\t}\n\n\trequest_name_to_parent(new_name: string) {\n\t\tconst parent = this.node.parent();\n\t\tif (parent && parent.childrenAllowed() && parent.childrenController) {\n\t\t\tparent.childrenController.set_child_name(this.node, new_name);\n\t\t} else {\n\t\t\tconsole.warn('request_name_to_parent failed, no parent found');\n\t\t}\n\t}\n\tsetName(new_name: string) {\n\t\tif (new_name != this.node.name()) {\n\t\t\tthis.request_name_to_parent(new_name);\n\t\t}\n\t}\n\tupdate_name_from_parent(new_name: string) {\n\t\tthis.node._set_core_name(new_name);\n\t\tthis.post_setName();\n\t\tthis.run_post_set_fullPath_hooks();\n\t\tif (this.node.childrenAllowed()) {\n\t\t\tconst children = this.node.childrenController?.children();\n\t\t\tif (children) {\n\t\t\t\tfor (let child_node of children) {\n\t\t\t\t\tchild_node.nameController.run_post_set_fullPath_hooks();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (this.node.lifecycle.creation_completed) {\n\t\t\tthis.node.scene().missingExpressionReferencesController.check_for_missing_references(this.node);\n\t\t\tthis.node.scene().expressionsController.regenerate_referring_expressions(this.node);\n\t\t}\n\t\tthis.node.scene().referencesController.notify_name_updated(this.node);\n\t\tthis.node.emit(NodeEvent.NAME_UPDATED);\n\t}\n\n\tadd_post_set_name_hook(hook: Callback) {\n\t\tthis._on_set_name_hooks = this._on_set_name_hooks || [];\n\t\tthis._on_set_name_hooks.push(hook);\n\t}\n\tadd_post_set_fullPath_hook(hook: Callback) {\n\t\tthis._on_set_fullPath_hooks = this._on_set_fullPath_hooks || [];\n\t\tthis._on_set_fullPath_hooks.push(hook);\n\t}\n\n\tpost_setName() {\n\t\tif (this._on_set_name_hooks) {\n\t\t\tfor (let hook of this._on_set_name_hooks) {\n\t\t\t\thook();\n\t\t\t}\n\t\t}\n\t}\n\trun_post_set_fullPath_hooks() {\n\t\tif (this._on_set_fullPath_hooks) {\n\t\t\tfor (let hook of this._on_set_fullPath_hooks) {\n\t\t\t\thook();\n\t\t\t}\n\t\t}\n\t}\n}\n","import {BaseNodeType} from '../../_Base';\nimport {NameController} from '../NameController';\n\ntype Callback = () => void;\nimport {CoreWalker} from '../../../../core/Walker';\n\nexport class HierarchyParentController {\n\tprivate _parent: BaseNodeType | null = null;\n\tprivate _on_set_parent_hooks: Callback[] | undefined;\n\n\tconstructor(protected node: BaseNodeType) {}\n\n\tparent() {\n\t\treturn this._parent;\n\t}\n\n\tsetParent(parent: BaseNodeType | null) {\n\t\tif (parent != this.node.parentController.parent()) {\n\t\t\tthis._parent = parent;\n\t\t\tif (this._parent) {\n\t\t\t\tthis.node.nameController.request_name_to_parent(NameController.base_name(this.node));\n\t\t\t}\n\t\t}\n\t}\n\tis_selected(): boolean {\n\t\treturn this.parent()?.childrenController?.selection?.contains(this.node) || false;\n\t}\n\tfullPath(relative_to_parent?: BaseNodeType): string {\n\t\tconst separator = CoreWalker.SEPARATOR;\n\t\tif (this._parent != null) {\n\t\t\tif (this._parent == relative_to_parent) {\n\t\t\t\treturn this.node.name();\n\t\t\t} else {\n\t\t\t\tconst parent_fullPath = this._parent.fullPath(relative_to_parent);\n\t\t\t\tif (parent_fullPath === separator) {\n\t\t\t\t\treturn parent_fullPath + this.node.name();\n\t\t\t\t} else {\n\t\t\t\t\treturn parent_fullPath + separator + this.node.name();\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\treturn separator;\n\t\t}\n\t}\n\n\tonSetParent() {\n\t\tif (this._on_set_parent_hooks) {\n\t\t\tfor (let hook of this._on_set_parent_hooks) {\n\t\t\t\thook();\n\t\t\t}\n\t\t}\n\t}\n\tfind_node(path: string | null): BaseNodeType | null {\n\t\tif (path == null) {\n\t\t\treturn null;\n\t\t}\n\t\tif (path == CoreWalker.CURRENT || path == CoreWalker.CURRENT_WITH_SLASH) {\n\t\t\treturn this.node;\n\t\t}\n\t\tif (path == CoreWalker.PARENT || path == CoreWalker.PARENT_WITH_SLASH) {\n\t\t\treturn this.node.parent();\n\t\t}\n\n\t\tconst separator = CoreWalker.SEPARATOR;\n\t\tif (path[0] === separator) {\n\t\t\tpath = path.substring(1, path.length);\n\t\t}\n\n\t\t// check that path is a string, since there has been errors where it wasn't the case\n\t\tif (path.split) {\n\t\t\tconst elements = path.split(separator);\n\t\t\tif (elements.length === 1) {\n\t\t\t\tconst name = elements[0];\n\t\t\t\tif (this.node.childrenController) {\n\t\t\t\t\treturn this.node.childrenController.child_by_name(name);\n\t\t\t\t} else {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn CoreWalker.find_node(this.node, path);\n\t\t\t}\n\t\t} else {\n\t\t\tconsole.error('unexpected path given:', path);\n\t\t\treturn null;\n\t\t}\n\t}\n}\n","// import UIData from './UIData';\nimport {BaseNodeType} from '../engine/nodes/_Base';\nimport {NodeEvent} from '../engine/poly/NodeEvent';\nimport {CoreGraphNodeId} from './graph/CoreGraph';\nimport {ArrayUtils} from './ArrayUtils';\n\nexport class CoreNodeSelection {\n\t_node_ids: CoreGraphNodeId[] = [];\n\tconstructor(private _node: BaseNodeType) {\n\t\t// super();\n\t\t// this._node_ids = [];\n\t}\n\n\tnode() {\n\t\treturn this._node;\n\t}\n\n\tnodes(): BaseNodeType[] {\n\t\treturn this._node.scene().graph.nodes_from_ids(this._node_ids) as BaseNodeType[];\n\t}\n\n\tcontains(node: BaseNodeType): boolean {\n\t\treturn this._node_ids.includes(node.graphNodeId());\n\t}\n\tequals(nodes: BaseNodeType[]): boolean {\n\t\tconst node_ids = nodes.map((node) => node.graphNodeId()).sort();\n\t\treturn ArrayUtils.isEqual(node_ids, this._node_ids);\n\t}\n\n\tclear() {\n\t\tthis._node_ids = [];\n\t\tthis.send_update_event();\n\t}\n\tset(nodes: BaseNodeType[]) {\n\t\t// this.remove(this.nodes());\n\t\tthis._node_ids = [];\n\t\tthis.add(nodes);\n\t}\n\n\tadd(nodes_to_add: BaseNodeType[]) {\n\t\tconst node_ids_to_add = nodes_to_add.map((node) => node.graphNodeId());\n\t\tthis._node_ids = ArrayUtils.union(this._node_ids, node_ids_to_add);\n\n\t\tthis.send_update_event();\n\t}\n\n\tremove(nodes_to_remove: BaseNodeType[]) {\n\t\tconst node_ids_to_remove = nodes_to_remove.map((node) => node.graphNodeId());\n\t\tthis._node_ids = ArrayUtils.difference(this._node_ids, node_ids_to_remove);\n\n\t\tthis.send_update_event();\n\t}\n\n\tprivate send_update_event() {\n\t\tthis._node.emit(NodeEvent.SELECTION_UPDATED);\n\t}\n\n\tprivate _json: CoreGraphNodeId[] = [];\n\ttoJSON() {\n\t\tthis._json = this._json || [];\n\t\tthis._json = this._node_ids.map((id) => id);\n\t\treturn this._json;\n\t}\n}\n","import {InputsController} from '../InputsController';\nimport {InputCloneMode} from '../../../../../engine/poly/InputCloneMode';\nimport {TypeAssert} from '../../../../../engine/poly/Assert';\nimport {CoreType} from '../../../../../core/Type';\n\nexport class ClonedStatesController {\n\tprivate _cloned_states: InputCloneMode[] | undefined;\n\tprivate _cloned_state: InputCloneMode | undefined;\n\tprivate _clone_required_states: boolean[] = [];\n\tprivate _overridden: boolean = false;\n\n\tconstructor(protected inputs_controller: InputsController) {}\n\tinit_inputs_cloned_state(states: InputCloneMode | InputCloneMode[]) {\n\t\tif (CoreType.isArray(states)) {\n\t\t\tthis._cloned_states = states;\n\t\t} else {\n\t\t\tthis._cloned_state = states;\n\t\t}\n\n\t\tthis._update_clone_required_state();\n\t}\n\n\toverride_cloned_state_allowed() {\n\t\tif (this._cloned_states) {\n\t\t\tfor (let state of this._cloned_states) {\n\t\t\t\tif (state == InputCloneMode.FROM_NODE) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (this._cloned_state) {\n\t\t\treturn this._cloned_state == InputCloneMode.FROM_NODE;\n\t\t}\n\t\treturn false;\n\t}\n\n\tclone_required_state(index: number): boolean {\n\t\treturn this._clone_required_states[index];\n\t}\n\tclone_required_states(): boolean | boolean[] {\n\t\treturn this._clone_required_states;\n\t}\n\n\tprivate _get_clone_required_state(index: number): boolean {\n\t\tconst states = this._cloned_states;\n\t\tif (states) {\n\t\t\tconst state = states[index];\n\t\t\tif (state != null) {\n\t\t\t\treturn this.clone_required_from_state(state);\n\t\t\t}\n\t\t}\n\t\tif (this._cloned_state) {\n\t\t\treturn this.clone_required_from_state(this._cloned_state);\n\t\t}\n\t\treturn true;\n\t}\n\tprivate clone_required_from_state(state: InputCloneMode) {\n\t\tswitch (state) {\n\t\t\tcase InputCloneMode.ALWAYS:\n\t\t\t\treturn true;\n\t\t\tcase InputCloneMode.NEVER:\n\t\t\t\treturn false;\n\t\t\tcase InputCloneMode.FROM_NODE:\n\t\t\t\treturn !this._overridden;\n\t\t}\n\t\treturn TypeAssert.unreachable(state);\n\t}\n\n\toverride_cloned_state(state: boolean) {\n\t\tthis._overridden = state;\n\t\tthis._update_clone_required_state();\n\t}\n\toverriden() {\n\t\treturn this._overridden;\n\t}\n\tprivate _update_clone_required_state() {\n\t\tif (this._cloned_states) {\n\t\t\tconst states: boolean[] = [];\n\t\t\tfor (let i = 0; i < this._cloned_states.length; i++) {\n\t\t\t\tstates[i] = this._get_clone_required_state(i);\n\t\t\t}\n\t\t\tthis._clone_required_states = states;\n\t\t\treturn;\n\t\t}\n\t\tif (this._cloned_state) {\n\t\t\tconst max_inputs = this.inputs_controller.inputs_count();\n\t\t\tconst states: boolean[] = [];\n\t\t\tfor (let i = 0; i < max_inputs; i++) {\n\t\t\t\tstates[i] = this._get_clone_required_state(i);\n\t\t\t}\n\t\t\tthis._clone_required_states = states;\n\t\t\treturn;\n\t\t}\n\t}\n}\n","import {ClonedStatesController} from './inputs/ClonedStatesController';\nimport {InputCloneMode} from '../../../../engine/poly/InputCloneMode';\nimport {BaseOperationContainer} from '../_Base';\n\nexport class InputsController {\n\tconstructor(private operation_container: BaseOperationContainer) {}\n\tinputs_count() {\n\t\treturn this.operation_container.inputs_count();\n\t}\n\n\t//\n\t//\n\t// CLONABLE STATES\n\t//\n\t//\n\tprivate _cloned_states_controller: ClonedStatesController | undefined;\n\tinit_inputs_cloned_state(states: InputCloneMode | InputCloneMode[]) {\n\t\tif (!this._cloned_states_controller) {\n\t\t\tthis._cloned_states_controller = new ClonedStatesController(this);\n\t\t\tthis._cloned_states_controller.init_inputs_cloned_state(states);\n\t\t}\n\t}\n\n\tclone_required(index: number) {\n\t\tconst state = this._cloned_states_controller?.clone_required_state(index);\n\t\tif (state != null) {\n\t\t\treturn state;\n\t\t}\n\t\treturn true;\n\t}\n\toverride_cloned_state(state: boolean) {\n\t\tthis._cloned_states_controller?.override_cloned_state(state);\n\t}\n}\n","import {BaseOperationContainer} from './_Base';\nimport {BaseSopOperation} from '../sop/_Base';\nimport {ParamsInitData} from '../../../engine/nodes/utils/io/IOController';\nimport {CoreGroup} from '../../../core/geometry/Group';\n\nexport type OperationInputsMap = WeakMap<SopOperationContainer, Map<number, number>>;\n\nexport class SopOperationContainer extends BaseOperationContainer {\n\tconstructor(protected operation: BaseSopOperation, protected name: string, protected init_params: ParamsInitData) {\n\t\tsuper(operation, name, init_params);\n\t}\n\n\t// TODO: there may a better to overload add_input\n\tprotected _inputs: SopOperationContainer[] = [];\n\tprivate _current_input_index: number = 0;\n\tadd_input(input: SopOperationContainer) {\n\t\tsuper.setInput(this._current_input_index, input);\n\t\tthis.increment_input_index();\n\t}\n\tincrement_input_index() {\n\t\tthis._current_input_index++;\n\t}\n\tcurrent_input_index() {\n\t\treturn this._current_input_index;\n\t}\n\n\tprivate _compute_result: CoreGroup | undefined;\n\tprivate _dirty: boolean = true;\n\tsetDirty() {\n\t\tif (this._dirty) {\n\t\t\treturn;\n\t\t}\n\t\tthis._compute_result = undefined;\n\t\tfor (let i = 0; i < this._inputs.length; i++) {\n\t\t\tconst input_operation = this._inputs[i];\n\t\t\tinput_operation.setDirty();\n\t\t}\n\t}\n\n\tasync compute(input_contents: CoreGroup[], operation_inputs_map: OperationInputsMap) {\n\t\tif (this._compute_result) {\n\t\t\treturn this._compute_result;\n\t\t}\n\n\t\tconst operation_input_contents: CoreGroup[] = [];\n\n\t\t// process node inputs\n\t\tconst node_inputs_map = operation_inputs_map.get(this);\n\t\tif (node_inputs_map) {\n\t\t\tnode_inputs_map.forEach((node_input_index: number, operation_input_index: number) => {\n\t\t\t\toperation_input_contents[operation_input_index] = input_contents[node_input_index];\n\t\t\t});\n\t\t}\n\n\t\t// process operation inputs\n\t\tfor (let i = 0; i < this._inputs.length; i++) {\n\t\t\tconst input_operation = this._inputs[i];\n\t\t\tlet result = await input_operation.compute(input_contents, operation_inputs_map);\n\t\t\tif (result) {\n\t\t\t\tif (this.input_clone_required(i)) {\n\t\t\t\t\tresult = result.clone();\n\t\t\t\t}\n\t\t\t\toperation_input_contents[i] = result;\n\t\t\t}\n\t\t}\n\n\t\t// cook and store result\n\t\tconst result = this.operation.cook(operation_input_contents, this.params);\n\t\tif (result) {\n\t\t\tif (result instanceof Promise) {\n\t\t\t\tthis._compute_result = await result;\n\t\t\t} else {\n\t\t\t\tthis._compute_result = result;\n\t\t\t}\n\t\t} else {\n\t\t\tthis._compute_result = undefined;\n\t\t}\n\t\tthis._dirty = false;\n\t\treturn this._compute_result;\n\t}\n}\n","import {ParamsInitData} from '../../../engine/nodes/utils/io/IOController';\nimport {ParamType} from '../../../engine/poly/ParamType';\nimport {Color} from 'three/src/math/Color';\nimport {Vector2} from 'three/src/math/Vector2';\nimport {Vector3} from 'three/src/math/Vector3';\nimport {Vector4} from 'three/src/math/Vector4';\nimport {TypedNodePathParamValue, TypedParamPathParamValue} from '../../../core/Walker';\nimport {BaseNodeType} from '../../../engine/nodes/_Base';\nimport {BaseOperation, DefaultOperationParams, DefaultOperationParam} from '../_Base';\nimport {ParamInitValueSerializedTypeMap} from '../../../engine/params/types/ParamInitValueSerializedTypeMap';\nimport {InputsController} from './utils/InputsController';\nimport {CoreType} from '../../../core/Type';\n\ntype SimpleParamJsonExporterData<T extends ParamType> = ParamInitValueSerializedTypeMap[T];\n\nexport class BaseOperationContainer {\n\tprotected params: DefaultOperationParams = {};\n\tprivate _path_params: TypedNodePathParamValue[] | undefined;\n\n\tconstructor(protected operation: BaseOperation, protected name: string, init_params: ParamsInitData) {\n\t\tthis._apply_default_params();\n\t\tthis._apply_init_params(init_params);\n\t\tthis._init_cloned_states();\n\t}\n\n\t//\n\t//\n\t// PATH PARAMS\n\t//\n\t//\n\tpath_param_resolve_required() {\n\t\treturn this._path_params != null;\n\t}\n\tresolve_path_params(node_start: BaseNodeType) {\n\t\tif (!this._path_params) {\n\t\t\treturn;\n\t\t}\n\t\tfor (let path_param of this._path_params) {\n\t\t\tpath_param.resolve(node_start);\n\t\t}\n\t}\n\n\t//\n\t//\n\t// PARAM VALUES CONVERSION\n\t//\n\t//\n\tprivate _apply_default_params() {\n\t\tconst default_params = (this.operation.constructor as typeof BaseOperation).DEFAULT_PARAMS;\n\t\tconst param_names = Object.keys(default_params);\n\t\tfor (let param_name of param_names) {\n\t\t\tconst param_data = default_params[param_name];\n\t\t\tconst clone_param_data = this._convert_param_data(param_name, param_data);\n\t\t\tif (clone_param_data != undefined) {\n\t\t\t\tthis.params[param_name] = clone_param_data;\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate _apply_init_params(init_params: ParamsInitData) {\n\t\tconst param_names = Object.keys(init_params);\n\t\tfor (let param_name of param_names) {\n\t\t\tconst param_data = init_params[param_name];\n\t\t\tif (param_data.simple_data != null) {\n\t\t\t\tconst simple_data = param_data.simple_data;\n\t\t\t\tconst clone_param_data = this._convert_export_param_data(param_name, simple_data);\n\t\t\t\tif (clone_param_data != undefined) {\n\t\t\t\t\tthis.params[param_name] = clone_param_data;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate _convert_param_data(param_name: string, param_data: DefaultOperationParam<ParamType>) {\n\t\tif (CoreType.isNumber(param_data) || CoreType.isBoolean(param_data) || CoreType.isString(param_data)) {\n\t\t\treturn param_data;\n\t\t}\n\t\tif (param_data instanceof TypedNodePathParamValue) {\n\t\t\tconst cloned = param_data.clone();\n\t\t\tif (!this._path_params) {\n\t\t\t\tthis._path_params = [];\n\t\t\t}\n\t\t\tthis._path_params.push(cloned);\n\t\t\treturn cloned;\n\t\t}\n\t\tif (\n\t\t\tparam_data instanceof Color ||\n\t\t\tparam_data instanceof Vector2 ||\n\t\t\tparam_data instanceof Vector3 ||\n\t\t\tparam_data instanceof Vector4\n\t\t) {\n\t\t\treturn param_data.clone();\n\t\t}\n\t}\n\n\tprivate _convert_export_param_data(param_name: string, param_data: SimpleParamJsonExporterData<ParamType>) {\n\t\tconst default_param = this.params[param_name];\n\t\tif (CoreType.isBoolean(param_data)) {\n\t\t\treturn param_data;\n\t\t}\n\t\tif (CoreType.isNumber(param_data)) {\n\t\t\tif (CoreType.isBoolean(default_param)) {\n\t\t\t\t// if we receive 0, it may be for a boolean param,\n\t\t\t\t// so if the default is a boolean, we convert\n\t\t\t\treturn param_data >= 1 ? true : false;\n\t\t\t} else {\n\t\t\t\treturn param_data;\n\t\t\t}\n\t\t}\n\t\tif (CoreType.isString(param_data)) {\n\t\t\tif (default_param) {\n\t\t\t\tif (default_param instanceof TypedNodePathParamValue) {\n\t\t\t\t\treturn default_param.set_path(param_data);\n\t\t\t\t}\n\t\t\t\tif (default_param instanceof TypedParamPathParamValue) {\n\t\t\t\t\treturn default_param.set_path(param_data);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn param_data;\n\t\t}\n\t\tif (CoreType.isArray(param_data)) {\n\t\t\t(this.params[param_name] as Vector3).fromArray(param_data as number[]);\n\t\t}\n\t}\n\n\t//\n\t//\n\t// INPUTS\n\t//\n\t//\n\tprotected _inputs: BaseOperationContainer[] | undefined;\n\tsetInput(index: number, input: BaseOperationContainer) {\n\t\tthis._inputs = this._inputs || [];\n\t\tthis._inputs[index] = input;\n\t}\n\tinputs_count() {\n\t\tif (this._inputs) {\n\t\t\treturn this._inputs.length;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tprivate _inputs_controller: InputsController | undefined;\n\tprotected inputs_controller() {\n\t\treturn (this._inputs_controller = this._inputs_controller || new InputsController(this));\n\t}\n\tprivate _init_cloned_states() {\n\t\tconst default_cloned_states = (this.operation.constructor as typeof BaseOperation).INPUT_CLONED_STATE;\n\t\tthis.inputs_controller().init_inputs_cloned_state(default_cloned_states);\n\t}\n\tinput_clone_required(index: number): boolean {\n\t\tif (!this._inputs_controller) {\n\t\t\treturn true;\n\t\t}\n\t\treturn this._inputs_controller.clone_required(index);\n\t}\n\toverride_input_clone_state(state: boolean) {\n\t\tthis.inputs_controller().override_cloned_state(state);\n\t}\n\n\t//\n\t//\n\t// COOK\n\t//\n\t//\n\tcook(input_contents: any[]) {\n\t\treturn this.operation.cook(input_contents, this.params);\n\t}\n}\n","import {Constructor, PolyDictionary} from '../../../../types/GlobalTypes';\nimport {CoreString} from '../../../../core/String';\nimport {BaseNodeType} from '../../_Base';\nimport {NodeEvent} from '../../../poly/NodeEvent';\nimport {NodeContext} from '../../../poly/NodeContext';\nimport {NameController} from '../NameController';\nimport {CoreNodeSelection} from '../../../../core/NodeSelection';\nimport {Poly} from '../../../Poly';\nimport {ParamsInitData} from '../io/IOController';\nimport {CoreGraphNodeId} from '../../../../core/graph/CoreGraph';\nimport {BaseOperationContainer} from '../../../operations/container/_Base';\nimport {SopOperationContainer} from '../../../operations/container/sop';\nimport {BaseSopOperation} from '../../../operations/sop/_Base';\n\ntype OutputNodeFindMethod = (() => BaseNodeType) | undefined;\n\nexport class HierarchyChildrenController {\n\tprivate _children: PolyDictionary<BaseNodeType> = {};\n\tprivate _children_by_type: PolyDictionary<CoreGraphNodeId[]> = {};\n\tprivate _children_and_grandchildren_by_context: PolyDictionary<CoreGraphNodeId[]> = {};\n\n\tprivate _selection: CoreNodeSelection | undefined;\n\tget selection(): CoreNodeSelection {\n\t\treturn (this._selection = this._selection || new CoreNodeSelection(this.node));\n\t}\n\tconstructor(protected node: BaseNodeType, private _context: NodeContext) {}\n\n\tdispose() {\n\t\tconst children = this.children();\n\t\tfor (let child of children) {\n\t\t\tthis.node.removeNode(child);\n\t\t}\n\t\tthis._selection = undefined;\n\t}\n\n\tget context() {\n\t\treturn this._context;\n\t}\n\n\t//\n\t//\n\t// OUTPUT NODE\n\t//\n\t//\n\tprivate _output_node_find_method: (() => BaseNodeType) | undefined;\n\tset_output_node_find_method(method: OutputNodeFindMethod) {\n\t\tthis._output_node_find_method = method;\n\t}\n\toutput_node() {\n\t\tif (this._output_node_find_method) {\n\t\t\treturn this._output_node_find_method();\n\t\t}\n\t}\n\n\t//\n\t//\n\t//\n\t//\n\t//\n\n\tset_child_name(node: BaseNodeType, new_name: string): void {\n\t\tlet current_child_with_name;\n\t\tnew_name = new_name.replace(/[^A-Za-z0-9]/g, '_');\n\t\tnew_name = new_name.replace(/^[0-9]/, '_'); // replace first char if not a letter\n\n\t\tif ((current_child_with_name = this._children[new_name]) != null) {\n\t\t\t// only return if found node is same as argument node, and if new_name is same as current_name\n\t\t\tif (node.name() === new_name && current_child_with_name.graphNodeId() === node.graphNodeId()) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// increment new_name\n\t\t\tnew_name = CoreString.increment(new_name);\n\n\t\t\treturn this.set_child_name(node, new_name);\n\t\t} else {\n\t\t\tconst current_name = node.name();\n\n\t\t\t// delete old entry if node was in _children with old name\n\t\t\tconst current_child = this._children[current_name];\n\t\t\tif (current_child) {\n\t\t\t\tdelete this._children[current_name];\n\t\t\t}\n\n\t\t\t// add to new name\n\t\t\tthis._children[new_name] = node;\n\t\t\tnode.nameController.update_name_from_parent(new_name);\n\t\t\tthis._add_to_nodesByType(node);\n\t\t\tthis.node.scene().nodesController.addToInstanciatedNode(node);\n\t\t}\n\t}\n\n\tnode_context_signature() {\n\t\treturn `${this.node.nodeContext()}/${this.node.type()}`;\n\t}\n\n\tavailable_children_classes() {\n\t\treturn Poly.registeredNodes(this._context, this.node.type());\n\t}\n\n\tis_valid_child_type(node_type: string): boolean {\n\t\tconst node_class = this.available_children_classes()[node_type];\n\t\treturn node_class != null;\n\t}\n\n\t// create_node(node_type: string, params_init_value_overrides?: ParamsInitData): BaseNodeType {\n\t// \tconst node_class = this.available_children_classes()[node_type];\n\n\t// \tif (node_class == null) {\n\t// \t\tconst message = `child node type '${node_type}' not found for node '${this.node.fullPath()}'. Available types are: ${Object.keys(\n\t// \t\t\tthis.available_children_classes()\n\t// \t\t).join(', ')}, ${this._context}, ${this.node.type}`;\n\t// \t\tconsole.error(message);\n\t// \t\tthrow message;\n\t// \t} else {\n\t// \t\tconst child_node = new node_class(this.node.scene, `child_node_${node_type}`, params_init_value_overrides);\n\t// \t\tchild_node.initialize_base_and_node();\n\t// \t\tthis.add_node(child_node);\n\t// \t\tchild_node.lifecycle.set_creation_completed();\n\t// \t\treturn child_node;\n\t// \t}\n\t// }\n\tcreateNode<K extends BaseNodeType>(\n\t\tnode_class_or_string: string | Constructor<K>,\n\t\tparams_init_value_overrides?: ParamsInitData,\n\t\tnode_type = ''\n\t): K {\n\t\tif (typeof node_class_or_string == 'string') {\n\t\t\tconst node_class = this._find_node_class(node_class_or_string);\n\t\t\treturn this._create_and_init_node(node_class, params_init_value_overrides, node_type) as K;\n\t\t} else {\n\t\t\treturn this._create_and_init_node(node_class_or_string, params_init_value_overrides, node_type);\n\t\t}\n\t}\n\tprivate _create_and_init_node<K extends BaseNodeType>(\n\t\tnode_class: Constructor<K>,\n\t\tparams_init_value_overrides?: ParamsInitData,\n\t\tnode_type = ''\n\t) {\n\t\tconst child_node = new node_class(this.node.scene(), `child_node_${node_type}`, params_init_value_overrides);\n\t\tchild_node.initialize_base_and_node();\n\t\tthis.add_node(child_node);\n\t\tchild_node.lifecycle.set_creation_completed();\n\t\treturn child_node;\n\t}\n\tprivate _find_node_class(node_type: string) {\n\t\tconst node_class = this.available_children_classes()[node_type.toLowerCase()];\n\n\t\tif (node_class == null) {\n\t\t\tconst message = `child node type '${node_type}' not found for node '${this.node.fullPath()}'. Available types are: ${Object.keys(\n\t\t\t\tthis.available_children_classes()\n\t\t\t).join(', ')}, ${this._context}, ${this.node.type()}`;\n\t\t\tconsole.error(message);\n\t\t\tthrow message;\n\t\t}\n\t\treturn node_class;\n\t}\n\tcreate_operation_container(\n\t\toperation_type: string,\n\t\toperation_container_name: string,\n\t\tparams_init_value_overrides?: ParamsInitData\n\t): BaseOperationContainer {\n\t\tconst operation_class = Poly.registeredOperation(this._context, operation_type);\n\n\t\tif (operation_class == null) {\n\t\t\tconst message = `no operation found with context ${this._context}/${operation_type}`;\n\t\t\tconsole.error(message);\n\t\t\tthrow message;\n\t\t} else {\n\t\t\tconst operation = new operation_class(this.node.scene()) as BaseSopOperation;\n\t\t\tconst operation_container = new SopOperationContainer(\n\t\t\t\toperation,\n\t\t\t\toperation_container_name,\n\t\t\t\tparams_init_value_overrides || {}\n\t\t\t);\n\t\t\treturn operation_container;\n\t\t}\n\t}\n\n\tadd_node(child_node: BaseNodeType) {\n\t\tchild_node.setParent(this.node);\n\t\tchild_node.params.init();\n\t\tchild_node.parentController.onSetParent();\n\t\tchild_node.nameController.run_post_set_fullPath_hooks();\n\t\tif (child_node.childrenAllowed() && child_node.childrenController) {\n\t\t\tfor (let child of child_node.childrenController.children()) {\n\t\t\t\tchild.nameController.run_post_set_fullPath_hooks();\n\t\t\t}\n\t\t}\n\t\tthis.node.emit(NodeEvent.CREATED, {child_node_json: child_node.toJSON()});\n\t\tif (this.node.scene().lifecycleController.onCreateHookAllowed()) {\n\t\t\tchild_node.lifecycle.run_on_create_hooks();\n\t\t}\n\t\tchild_node.lifecycle.run_on_add_hooks();\n\t\tthis.set_child_name(child_node, NameController.base_name(child_node));\n\t\tthis.node.lifecycle.run_on_child_add_hooks(child_node);\n\n\t\tif (child_node.require_webgl2()) {\n\t\t\tthis.node.scene().webgl_controller.set_require_webgl2();\n\t\t}\n\n\t\tthis.node.scene().missingExpressionReferencesController.check_for_missing_references(child_node);\n\n\t\treturn child_node;\n\t}\n\n\tremoveNode(child_node: BaseNodeType): void {\n\t\tif (child_node.parent() != this.node) {\n\t\t\treturn console.warn(`node ${child_node.name()} not under parent ${this.node.fullPath()}`);\n\t\t} else {\n\t\t\tif (this.selection.contains(child_node)) {\n\t\t\t\tthis.selection.remove([child_node]);\n\t\t\t}\n\n\t\t\tconst first_connection = child_node.io.connections.firstInputConnection();\n\t\t\tconst input_connections = child_node.io.connections.inputConnections();\n\t\t\tconst output_connections = child_node.io.connections.outputConnections();\n\t\t\tif (input_connections) {\n\t\t\t\tfor (let input_connection of input_connections) {\n\t\t\t\t\tif (input_connection) {\n\t\t\t\t\t\tinput_connection.disconnect({setInput: true});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (output_connections) {\n\t\t\t\tfor (let output_connection of output_connections) {\n\t\t\t\t\tif (output_connection) {\n\t\t\t\t\t\toutput_connection.disconnect({setInput: true});\n\t\t\t\t\t\tif (first_connection) {\n\t\t\t\t\t\t\tconst old_src = first_connection.node_src;\n\t\t\t\t\t\t\tconst old_output_index = output_connection.output_index;\n\t\t\t\t\t\t\tconst old_dest = output_connection.node_dest;\n\t\t\t\t\t\t\tconst old_input_index = output_connection.input_index;\n\t\t\t\t\t\t\told_dest.io.inputs.setInput(old_input_index, old_src, old_output_index);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// remove from children\n\t\t\tchild_node.setParent(null);\n\t\t\tdelete this._children[child_node.name()];\n\t\t\tthis._remove_from_nodesByType(child_node);\n\t\t\tthis.node.scene().nodesController.removeFromInstanciatedNode(child_node);\n\n\t\t\t// set other dependencies dirty\n\t\t\t// Note that this call to set_dirty was initially before this._children_node.remove_graph_input\n\t\t\t// but that prevented the obj/geo node to properly clear its sop_group if this was the last node\n\t\t\t// if (this._is_dependent_on_children && this._children_node) {\n\t\t\t// \tthis._children_node.set_successors_dirty(this.node);\n\t\t\t// }\n\t\t\tchild_node.setSuccessorsDirty(this.node);\n\t\t\t// disconnect successors\n\t\t\tchild_node.graphDisconnectSuccessors();\n\n\t\t\tthis.node.lifecycle.run_on_child_remove_hooks(child_node);\n\t\t\tchild_node.lifecycle.run_on_delete_hooks();\n\t\t\tchild_node.dispose();\n\t\t\tchild_node.emit(NodeEvent.DELETED, {parent_id: this.node.graphNodeId()});\n\t\t}\n\t}\n\n\t_add_to_nodesByType(node: BaseNodeType) {\n\t\tconst node_id = node.graphNodeId();\n\t\tconst type = node.type();\n\t\tthis._children_by_type[type] = this._children_by_type[type] || [];\n\t\tif (!this._children_by_type[type].includes(node_id)) {\n\t\t\tthis._children_by_type[type].push(node_id);\n\t\t}\n\t\tthis.add_to_children_and_grandchildren_by_context(node);\n\t}\n\t_remove_from_nodesByType(node: BaseNodeType) {\n\t\tconst node_id = node.graphNodeId();\n\t\tconst type = node.type();\n\t\tif (this._children_by_type[type]) {\n\t\t\tconst index = this._children_by_type[type].indexOf(node_id);\n\t\t\tif (index >= 0) {\n\t\t\t\tthis._children_by_type[type].splice(index, 1);\n\t\t\t\tif (this._children_by_type[type].length == 0) {\n\t\t\t\t\tdelete this._children_by_type[type];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthis.remove_from_children_and_grandchildren_by_context(node);\n\t}\n\tadd_to_children_and_grandchildren_by_context(node: BaseNodeType) {\n\t\tconst node_id = node.graphNodeId();\n\t\tconst type = node.nodeContext();\n\t\tthis._children_and_grandchildren_by_context[type] = this._children_and_grandchildren_by_context[type] || [];\n\t\tif (!this._children_and_grandchildren_by_context[type].includes(node_id)) {\n\t\t\tthis._children_and_grandchildren_by_context[type].push(node_id);\n\t\t}\n\t\tconst parent = this.node.parent();\n\t\tif (parent && parent.childrenAllowed()) {\n\t\t\tparent.childrenController?.add_to_children_and_grandchildren_by_context(node);\n\t\t}\n\t}\n\tremove_from_children_and_grandchildren_by_context(node: BaseNodeType) {\n\t\tconst node_id = node.graphNodeId();\n\t\tconst type = node.nodeContext();\n\t\tif (this._children_and_grandchildren_by_context[type]) {\n\t\t\tconst index = this._children_and_grandchildren_by_context[type].indexOf(node_id);\n\t\t\tif (index >= 0) {\n\t\t\t\tthis._children_and_grandchildren_by_context[type].splice(index, 1);\n\t\t\t\tif (this._children_and_grandchildren_by_context[type].length == 0) {\n\t\t\t\t\tdelete this._children_and_grandchildren_by_context[type];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tconst parent = this.node.parent();\n\t\tif (parent && parent.childrenAllowed()) {\n\t\t\tparent.childrenController?.remove_from_children_and_grandchildren_by_context(node);\n\t\t}\n\t}\n\n\tnodesByType(type: string): BaseNodeType[] {\n\t\tconst node_ids = this._children_by_type[type] || [];\n\t\tconst graph = this.node.scene().graph;\n\t\tconst nodes: BaseNodeType[] = [];\n\t\tfor (let node_id of node_ids) {\n\t\t\tconst node = graph.node_from_id(node_id) as BaseNodeType;\n\t\t\tif (node) {\n\t\t\t\tnodes.push(node);\n\t\t\t}\n\t\t}\n\t\treturn nodes;\n\t}\n\tchild_by_name(name: string) {\n\t\treturn this._children[name];\n\t}\n\n\thas_children_and_grandchildren_with_context(context: NodeContext) {\n\t\treturn this._children_and_grandchildren_by_context[context] != null;\n\t}\n\n\tchildren(): BaseNodeType[] {\n\t\treturn Object.values(this._children);\n\t}\n\tchildren_names() {\n\t\treturn Object.keys(this._children).sort();\n\t}\n\n\ttraverse_children(callback: (arg0: BaseNodeType) => void) {\n\t\tfor (let child of this.children()) {\n\t\t\tcallback(child);\n\n\t\t\tchild.childrenController?.traverse_children(callback);\n\t\t}\n\t}\n}\n","import {BaseNodeType} from '../_Base';\n\ntype Callback = () => void;\ntype CallbackWithChildNode = (child_node: BaseNodeType) => void;\n\nexport class LifeCycleController {\n\tprotected _creation_completed = false;\n\tprotected _on_child_add_hooks: CallbackWithChildNode[] | undefined;\n\tprivate _on_child_remove_hooks: CallbackWithChildNode[] | undefined;\n\t// _on_creation_completed_hooks are used in the importer, once the node has been created, added and params are set\n\t// private _on_creation_completed_hooks: Callback[] | undefined;\n\tprivate _on_create_hooks: Callback[] | undefined;\n\tprivate _on_add_hooks: Callback[] | undefined;\n\tprivate _on_delete_hooks: Callback[] | undefined;\n\tconstructor(protected node: BaseNodeType) {}\n\n\tdispose() {\n\t\tthis._on_child_add_hooks = undefined;\n\t\tthis._on_child_remove_hooks = undefined;\n\t\tthis._on_create_hooks = undefined;\n\t\tthis._on_add_hooks = undefined;\n\t\tthis._on_delete_hooks = undefined;\n\t}\n\n\tset_creation_completed() {\n\t\tif (!this._creation_completed) {\n\t\t\tthis._creation_completed = true;\n\t\t\t// this.run_on_creation_completed_hooks();\n\t\t}\n\t}\n\tget creation_completed() {\n\t\treturn this.node.scene().loadingController.loaded() && this._creation_completed;\n\t}\n\t//\n\t//\n\t// ON CREATION COMPLETED\n\t//\n\t//\n\t// add_on_creation_completed_hook(callback: Callback) {\n\t// \tthis._on_creation_completed_hooks = this._on_creation_completed_hooks || [];\n\t// \tthis._on_creation_completed_hooks.push(callback);\n\t// }\n\t// private run_on_creation_completed_hooks() {\n\t// \tif (this._on_creation_completed_hooks) {\n\t// \t\tconsole.log('run_on_creation_completed_hooks', this.node.name);\n\t// \t}\n\t// \tthis.execute_hooks(this._on_creation_completed_hooks);\n\t// }\n\t//\n\t//\n\t// ON CHILD ADD\n\t//\n\t//\n\tadd_on_child_add_hook(callback: CallbackWithChildNode) {\n\t\tthis._on_child_add_hooks = this._on_child_add_hooks || [];\n\t\tthis._on_child_add_hooks.push(callback);\n\t}\n\trun_on_child_add_hooks(node: BaseNodeType) {\n\t\tthis.execute_hooks_with_child_node(this._on_child_add_hooks, node);\n\t}\n\n\t//\n\t//\n\t// ON CHILD REMOVE\n\t//\n\t//\n\tadd_on_child_remove_hook(callback: CallbackWithChildNode) {\n\t\tthis._on_child_remove_hooks = this._on_child_remove_hooks || [];\n\t\tthis._on_child_remove_hooks.push(callback);\n\t}\n\trun_on_child_remove_hooks(node: BaseNodeType) {\n\t\tthis.execute_hooks_with_child_node(this._on_child_remove_hooks, node);\n\t}\n\n\t//\n\t//\n\t// ON CREATE\n\t//\n\t//\n\tadd_on_create_hook(callback: Callback) {\n\t\tthis._on_create_hooks = this._on_create_hooks || [];\n\t\tthis._on_create_hooks.push(callback);\n\t}\n\trun_on_create_hooks() {\n\t\tthis.execute_hooks(this._on_create_hooks);\n\t}\n\n\t//\n\t//\n\t// ON ADD\n\t//\n\t//\n\tadd_on_add_hook(callback: Callback) {\n\t\tthis._on_add_hooks = this._on_add_hooks || [];\n\t\tthis._on_add_hooks.push(callback);\n\t}\n\trun_on_add_hooks() {\n\t\tthis.execute_hooks(this._on_add_hooks);\n\t}\n\n\t//\n\t//\n\t// ON DELETE\n\t//\n\t//\n\tadd_delete_hook(callback: Callback) {\n\t\tthis._on_delete_hooks = this._on_delete_hooks || [];\n\t\tthis._on_delete_hooks.push(callback);\n\t}\n\trun_on_delete_hooks() {\n\t\tthis.execute_hooks(this._on_delete_hooks);\n\t}\n\n\t//\n\t//\n\t// UTILS\n\t//\n\t//\n\tprotected execute_hooks(hooks: Callback[] | undefined) {\n\t\tif (hooks) {\n\t\t\tlet hook: Callback | undefined;\n\t\t\t// do not flush, as this MAY BE needed multiple times\n\t\t\tfor (hook of hooks) {\n\t\t\t\thook();\n\t\t\t}\n\t\t}\n\t}\n\tprotected execute_hooks_with_child_node(hooks: CallbackWithChildNode[] | undefined, child_node: BaseNodeType) {\n\t\tif (hooks) {\n\t\t\tlet hook: CallbackWithChildNode | undefined;\n\t\t\t// do not flush, as this is needed multiple times\n\t\t\tfor (hook of hooks) {\n\t\t\t\thook(child_node);\n\t\t\t}\n\t\t}\n\t}\n}\n","import {TypedNode} from '../nodes/_Base';\n\nimport {ContainableMap} from './utils/ContainableMap';\nimport {NodeContext} from '../poly/NodeContext';\n\nexport abstract class TypedContainer<NC extends NodeContext> {\n\tprotected _content!: ContainableMap[NC];\n\n\tconstructor(protected _node: TypedNode<NC, any>) {\n\t\t// this.update_eval_key();\n\t\t// this.set_content(this._default_content());\n\t}\n\n\tset_node(node: TypedNode<NC, any>) {\n\t\tthis._node = node;\n\t}\n\tnode(): TypedNode<NC, any> {\n\t\treturn this._node;\n\t}\n\n\t// clone() {\n\t// \tlet content;\n\t// \tconst cloned_container = new (<any>this.constructor)() as TypedContainer<T>;\n\t// \tcloned_container.set_node(this.node());\n\t// \tif ((content = this.content()) != null) {\n\t// \t\tcloned_container.set_content(content); //, this.eval_key() );\n\t// \t}\n\t// \treturn cloned_container;\n\t// }\n\t// reset_caches() {}\n\n\tset_content(content: ContainableMap[NC]) {\n\t\t// this.reset_caches();\n\t\tthis._content = content;\n\t\tthis._post_set_content();\n\t}\n\thas_content(): boolean {\n\t\treturn this._content != null;\n\t}\n\n\tcontent() {\n\t\treturn this._content;\n\t}\n\tprotected _post_set_content() {}\n\tpublic coreContent(): ContainableMap[NC] | undefined {\n\t\treturn this._content;\n\t}\n\tpublic coreContentCloned(): ContainableMap[NC] | undefined {\n\t\treturn this._content;\n\t}\n\t// abstract clone_content(): T\n\n\t// update_eval_key(eval_key?: number){\n\t// \tthis._eval_key = eval_key || performance.now();\n\t// }\n\t// eval_key(): number {\n\t// \treturn this._eval_key;\n\t// }\n\n\tinfos(): any {\n\t\treturn [];\n\t}\n}\n\nexport class BaseContainer extends TypedContainer<any> {}\n","import {NodeContext} from '../../poly/NodeContext';\nimport {TypedContainer} from '../_Base';\nimport {AnimationContainer} from '../Animation';\nimport {EventContainer} from '../Event';\nimport {GeometryContainer} from '../Geometry';\nimport {GlContainer} from '../Gl';\nimport {JsContainer} from '../Js';\nimport {ManagerContainer} from '../Manager';\nimport {MaterialContainer} from '../Material';\nimport {ObjectContainer} from '../Object';\nimport {TextureContainer} from '../Texture';\nimport {PostProcessContainer} from '../PostProcess';\nimport {RopContainer} from '../Rop';\nimport {TypedNode} from '../../nodes/_Base';\nimport {BaseAnimNodeType} from '../../nodes/anim/_Base';\nimport {BaseEventNodeType} from '../../nodes/event/_Base';\nimport {BaseSopNodeType} from '../../nodes/sop/_Base';\nimport {BaseGlNodeType} from '../../nodes/gl/_Base';\nimport {BaseJsNodeType} from '../../nodes/js/_Base';\nimport {BaseManagerNodeType} from '../../nodes/manager/_Base';\nimport {BaseMatNodeType} from '../../nodes/mat/_Base';\nimport {BaseObjNodeType} from '../../nodes/obj/_Base';\nimport {BaseCopNodeType} from '../../nodes/cop/_Base';\nimport {BasePostProcessNodeType} from '../../nodes/post/_Base';\nimport {BaseRopNodeType} from '../../nodes/rop/_Base';\n\n// export enum ContainerType {\n// \tANIMATION = 'ANIMATION',\n// \tEVENT = 'EVENT',\n// \tGEOMETRY = 'GEOMETRY',\n// \tGL = 'GL',\n// \tMANAGER = 'MANAGER',\n// \tMATERIAL = 'MATERIAL',\n// \tOBJECT = 'OBJECT',\n// \tTEXTURE = 'TEXTURE',\n// \tPOST = 'POST',\n// }\nexport type ContainerClassMapGeneric = {[key in NodeContext]: TypedContainer<key>};\nexport const ContainerClassMap = {\n\t[NodeContext.ANIM]: AnimationContainer,\n\t[NodeContext.COP]: TextureContainer,\n\t[NodeContext.EVENT]: EventContainer,\n\t[NodeContext.GL]: GlContainer,\n\t[NodeContext.JS]: JsContainer,\n\t[NodeContext.MANAGER]: ManagerContainer,\n\t[NodeContext.MAT]: MaterialContainer,\n\t[NodeContext.OBJ]: ObjectContainer,\n\t[NodeContext.POST]: PostProcessContainer,\n\t[NodeContext.ROP]: RopContainer,\n\t[NodeContext.SOP]: GeometryContainer,\n\t// JS: JsContainer;\n};\n\n// export type ContainerMap = {[key in NodeContext]: TypedContainer<key>};\n\ntype ContainerMapGeneric = {[key in NodeContext]: TypedContainer<key>};\n\nexport interface ContainerMap extends ContainerMapGeneric {\n\t[NodeContext.ANIM]: AnimationContainer;\n\t[NodeContext.COP]: TextureContainer;\n\t[NodeContext.EVENT]: EventContainer;\n\t[NodeContext.GL]: GlContainer;\n\t[NodeContext.JS]: JsContainer;\n\t[NodeContext.MANAGER]: ManagerContainer;\n\t[NodeContext.MAT]: MaterialContainer;\n\t[NodeContext.OBJ]: ObjectContainer;\n\t[NodeContext.POST]: PostProcessContainer;\n\t[NodeContext.ROP]: RopContainer;\n\t[NodeContext.SOP]: GeometryContainer;\n}\n\nexport type NodeTypeMapGeneric = {[key in NodeContext]: TypedNode<key, any>};\nexport interface NodeTypeMap extends NodeTypeMapGeneric {\n\t[NodeContext.ANIM]: BaseAnimNodeType;\n\t[NodeContext.COP]: BaseCopNodeType;\n\t[NodeContext.EVENT]: BaseEventNodeType;\n\t[NodeContext.GL]: BaseGlNodeType;\n\t[NodeContext.JS]: BaseJsNodeType;\n\t[NodeContext.MANAGER]: BaseManagerNodeType;\n\t[NodeContext.MAT]: BaseMatNodeType;\n\t[NodeContext.OBJ]: BaseObjNodeType;\n\t[NodeContext.POST]: BasePostProcessNodeType;\n\t[NodeContext.ROP]: BaseRopNodeType;\n\t[NodeContext.SOP]: BaseSopNodeType;\n\t// JS: JsContainer;\n}\n// export const NodeTypeMap: NodeTypeMapGeneric = {\n// \t\t[NodeContext.ANIM]: BaseAnimNodeType,\n// \t[NodeContext.EVENT]: TypedEventNode<any>,\n// \t[NodeContext.SOP]: TypedSopNode<any>,\n// \t[NodeContext.GL]: TypedGlNode<any>,\n// \t[NodeContext.MANAGER]: TypedBaseManagerNode<any>,\n// \t[NodeContext.MAT]: TypedMatNode<any, any>,\n// \t[NodeContext.OBJ]: TypedObjNode<any, any>,\n// \t[NodeContext.COP]: TypedCopNode<any>,\n// \t[NodeContext.POST]: TypedPostProcessNode<any, any>,\n// }\n","import {TypedContainer} from './_Base';\nimport {ContainableMap} from './utils/ContainableMap';\nimport {TimelineBuilder} from '../../core/animation/TimelineBuilder';\nimport {NodeContext} from '../poly/NodeContext';\n\nexport class AnimationContainer extends TypedContainer<NodeContext.ANIM> {\n\tset_content(content: ContainableMap[NodeContext.ANIM]) {\n\t\tsuper.set_content(content);\n\t}\n\tset_timeline_builder(timeline_builder: TimelineBuilder) {\n\t\treturn this.set_content(timeline_builder);\n\t}\n\ttimeline_builder() {\n\t\treturn this.content();\n\t}\n\n\tcoreContentCloned() {\n\t\tif (this._content) {\n\t\t\treturn this._content.clone();\n\t\t}\n\t}\n\n\t// infos() {\n\t// \tconst node = this.node()\n\t// \treturn [\n\t// \t\t`full path: ${node.fullPath()}`,\n\t// \t\t`${node.cooks_count()} cooks`,\n\t// \t\t`cook time: ${node.cook_time()}`,\n\t// \t\tthis.content(),\n\t// \t]\n\t// }\n}\n","import {TypedContainer} from './_Base';\nimport {ContainableMap} from './utils/ContainableMap';\nimport {NodeContext} from '../poly/NodeContext';\n\nexport class TextureContainer extends TypedContainer<NodeContext.COP> {\n\t// _content: Texture;\n\tset_content(content: ContainableMap[NodeContext.COP]) {\n\t\tsuper.set_content(content);\n\t}\n\n\t// set_texture(texture: Texture){\n\t// \tif (this._content != null) {\n\t// \t\tthis._content.dispose();\n\t// \t}\n\t// \tthis.set_content(texture);\n\t// }\n\ttexture(): ContainableMap[NodeContext.COP] {\n\t\treturn this._content;\n\t}\n\tcoreContent(): ContainableMap[NodeContext.COP] {\n\t\treturn this._content;\n\t}\n\tcoreContentCloned(): ContainableMap[NodeContext.COP] | undefined {\n\t\tconst texture = this._content?.clone();\n\t\tif (texture) {\n\t\t\ttexture.needsUpdate = true;\n\t\t}\n\t\treturn texture;\n\t}\n\n\tobject() {\n\t\treturn this.texture();\n\t}\n\n\tinfos() {\n\t\tif (this._content != null) {\n\t\t\treturn [this._content];\n\t\t}\n\t}\n\tresolution(): [number, number] {\n\t\tif (this._content) {\n\t\t\tif (this._content.image) {\n\t\t\t\treturn [this._content.image.width, this._content.image.height];\n\t\t\t}\n\t\t}\n\t\treturn [-1, -1];\n\t}\n}\n","import {TypedContainer} from './_Base';\nimport {ContainableMap} from './utils/ContainableMap';\nimport {NodeContext} from '../poly/NodeContext';\n\nexport class EventContainer extends TypedContainer<NodeContext.EVENT> {\n\tset_content(content: ContainableMap[NodeContext.EVENT]) {\n\t\tsuper.set_content(content);\n\t}\n}\n","import {TypedContainer} from './_Base';\nimport {NodeContext} from '../poly/NodeContext';\n\nexport class GlContainer extends TypedContainer<NodeContext.GL> {\n\tobject() {\n\t\treturn this._content;\n\t}\n}\n","import {TypedContainer} from './_Base';\nimport {NodeContext} from '../poly/NodeContext';\n\nexport class JsContainer extends TypedContainer<NodeContext.JS> {\n\tobject() {\n\t\treturn this._content;\n\t}\n}\n","import {TypedContainer} from './_Base';\nimport {ContainableMap} from './utils/ContainableMap';\nimport {NodeContext} from '../poly/NodeContext';\n\nexport class ManagerContainer extends TypedContainer<NodeContext.MANAGER> {\n\tset_content(content: ContainableMap[NodeContext.MANAGER]) {\n\t\tsuper.set_content(content);\n\t}\n}\n","import {Material} from 'three/src/materials/Material';\nimport {TypedContainer} from './_Base';\nimport {ContainableMap} from './utils/ContainableMap';\nimport {NodeContext} from '../poly/NodeContext';\n\nexport class MaterialContainer extends TypedContainer<NodeContext.MAT> {\n\tset_content(content: ContainableMap[NodeContext.MAT]) {\n\t\tsuper.set_content(content);\n\t}\n\tset_material(material: Material) {\n\t\tif (this._content != null) {\n\t\t\tthis._content.dispose();\n\t\t}\n\t\tthis.set_content(material);\n\t}\n\thas_material() {\n\t\treturn this.has_content();\n\t}\n\tmaterial() {\n\t\treturn this.content();\n\t}\n}\n","import {Object3D} from 'three/src/core/Object3D';\nimport {TypedContainer} from './_Base';\nimport {ContainableMap} from './utils/ContainableMap';\nimport {NodeContext} from '../poly/NodeContext';\n\nexport class ObjectContainer extends TypedContainer<NodeContext.OBJ> {\n\tset_content(content: ContainableMap[NodeContext.OBJ]) {\n\t\tsuper.set_content(content);\n\t}\n\tset_object(object: Object3D) {\n\t\treturn this.set_content(object);\n\t}\n\thas_object() {\n\t\treturn this.has_content();\n\t}\n\tobject() {\n\t\treturn this.content();\n\t}\n\n\t// infos() {\n\t// \tconst node = this.node()\n\t// \treturn [\n\t// \t\t`full path: ${node.fullPath()}`,\n\t// \t\t`${node.cooks_count()} cooks`,\n\t// \t\t`cook time: ${node.cook_time()}`,\n\t// \t\tthis.content(),\n\t// \t]\n\t// }\n}\n","import {TypedContainer} from './_Base';\nimport {ContainableMap} from './utils/ContainableMap';\nimport {NodeContext} from '../poly/NodeContext';\n\nexport class PostProcessContainer extends TypedContainer<NodeContext.POST> {\n\t// _content: any;\n\n\t// constructor() {\n\t// \tsuper();\n\t// }\n\tset_content(content: ContainableMap[NodeContext.POST]) {\n\t\tsuper.set_content(content);\n\t}\n\trender_pass() {\n\t\treturn this._content;\n\t}\n\n\tobject(options = {}) {\n\t\treturn this.render_pass();\n\t}\n\n\t// infos() {\n\t// \tif (this._content) {\n\t// \t\treturn [this._content];\n\t// \t}\n\t// }\n}\n","import {TypedContainer} from './_Base';\nimport {ContainableMap} from './utils/ContainableMap';\nimport {NodeContext} from '../poly/NodeContext';\n\nexport class RopContainer extends TypedContainer<NodeContext.ROP> {\n\tset_content(content: ContainableMap[NodeContext.ROP]) {\n\t\tsuper.set_content(content);\n\t}\n\trenderer() {\n\t\treturn this._content;\n\t}\n}\n","import {Vector3} from 'three/src/math/Vector3';\n// import {Object3D} from 'three/src/core/Object3D'\n// import {Group} from 'three/src/objects/Group'\nimport {Mesh} from 'three/src/objects/Mesh';\nimport {Box3} from 'three/src/math/Box3';\nimport {TypedContainer} from './_Base';\nimport {CoreGroup} from '../../core/geometry/Group';\nimport {CoreGeometry} from '../../core/geometry/Geometry';\nimport {BufferGeometry} from 'three/src/core/BufferGeometry';\n// import {Object3D} from 'three/src/core/Object3D';\nimport {ContainableMap} from './utils/ContainableMap';\nimport {CoreObject} from '../../core/geometry/Object';\nimport {AttribType, ObjectData} from '../../core/geometry/Constant';\nimport {NodeContext} from '../poly/NodeContext';\nimport {PolyDictionary} from '../../types/GlobalTypes';\n\nexport class GeometryContainer extends TypedContainer<NodeContext.SOP> {\n\t// set_objects(objects: Object3D[]) {}\n\n\tcoreContentCloned(): CoreGroup | undefined {\n\t\tif (this._content) {\n\t\t\treturn this._content.clone();\n\t\t}\n\t}\n\n\tset_content(content: ContainableMap[NodeContext.SOP]) {\n\t\tsuper.set_content(content);\n\t}\n\n\tprivate firstObject() {\n\t\tif (this._content) {\n\t\t\treturn this._content.objects()[0];\n\t\t}\n\t}\n\tprivate firstCoreObject() {\n\t\tconst object = this.firstObject();\n\t\tif (object) {\n\t\t\treturn new CoreObject(object, 0);\n\t\t}\n\t}\n\tprivate firstGeometry(): BufferGeometry | null {\n\t\tconst object = this.firstObject();\n\t\tif (object) {\n\t\t\treturn (object as Mesh).geometry as BufferGeometry;\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tobjectsCount(): number {\n\t\tif (this._content) {\n\t\t\treturn this._content.objects().length;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\tobjectsVisibleCount(): number {\n\t\tlet count = 0;\n\t\tif (this._content) {\n\t\t}\n\t\treturn count;\n\t}\n\tobjectsCountByType() {\n\t\tconst count_by_type: PolyDictionary<number> = {};\n\t\tconst core_group = this._content;\n\t\tif (this._content && core_group) {\n\t\t\tfor (let core_object of core_group.coreObjects()) {\n\t\t\t\tconst human_type = core_object.humanType();\n\t\t\t\tif (count_by_type[human_type] == null) {\n\t\t\t\t\tcount_by_type[human_type] = 0;\n\t\t\t\t}\n\t\t\t\tcount_by_type[human_type] += 1;\n\t\t\t}\n\t\t}\n\t\treturn count_by_type;\n\t}\n\tobjectsNamesByType() {\n\t\tconst names_by_type: PolyDictionary<string[]> = {};\n\t\tconst core_group = this._content;\n\t\tif (this._content && core_group) {\n\t\t\tfor (let core_object of core_group.coreObjects()) {\n\t\t\t\tconst human_type = core_object.humanType();\n\t\t\t\tnames_by_type[human_type] = names_by_type[human_type] || [];\n\t\t\t\tnames_by_type[human_type].push(core_object.name());\n\t\t\t}\n\t\t}\n\t\treturn names_by_type;\n\t}\n\n\tpointAttributeNames() {\n\t\tlet names: string[] = [];\n\t\tconst geometry = this.firstGeometry();\n\t\tif (geometry) {\n\t\t\tnames = Object.keys(geometry.attributes);\n\t\t}\n\t\treturn names;\n\t}\n\tpointAttributeSizesByName() {\n\t\tlet sizes_by_name: PolyDictionary<number> = {};\n\t\tconst geometry = this.firstGeometry();\n\t\tif (geometry) {\n\t\t\tObject.keys(geometry.attributes).forEach((attrib_name) => {\n\t\t\t\tconst attrib = geometry.attributes[attrib_name];\n\t\t\t\tsizes_by_name[attrib_name] = attrib.itemSize;\n\t\t\t});\n\t\t}\n\t\treturn sizes_by_name;\n\t}\n\tobjectAttributeSizesByName() {\n\t\tlet sizes_by_name: PolyDictionary<number> = {};\n\t\tconst core_object = this.firstCoreObject();\n\t\tif (core_object) {\n\t\t\tconst attribNames = core_object.attribNames();\n\t\t\tfor (let name of attribNames) {\n\t\t\t\tconst size = core_object.attribSize(name);\n\t\t\t\tif (size != null) {\n\t\t\t\t\tsizes_by_name[name] = size;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn sizes_by_name;\n\t}\n\tpointAttributeTypesByName() {\n\t\tlet types_by_name: PolyDictionary<AttribType> = {};\n\t\tconst geometry = this.firstGeometry();\n\t\tif (geometry) {\n\t\t\tconst core_geo = new CoreGeometry(geometry);\n\t\t\tObject.keys(geometry.attributes).forEach((attrib_name) => {\n\t\t\t\ttypes_by_name[attrib_name] = core_geo.attribType(attrib_name);\n\t\t\t});\n\t\t}\n\t\treturn types_by_name;\n\t}\n\tobjectAttributeTypesByName() {\n\t\tlet types_by_name: PolyDictionary<AttribType> = {};\n\t\tconst core_object = this.firstCoreObject();\n\t\tif (core_object) {\n\t\t\tfor (let name of core_object.attribNames()) {\n\t\t\t\ttypes_by_name[name] = core_object.attribType(name);\n\t\t\t}\n\t\t}\n\t\treturn types_by_name;\n\t}\n\tobjectAttributeNames() {\n\t\tlet names: string[] = [];\n\t\tconst object = this.firstObject();\n\t\tif (object) {\n\t\t\tnames = Object.keys(object.userData['attributes'] || {});\n\t\t}\n\t\treturn names;\n\t}\n\n\tpointsCount(): number {\n\t\tif (this._content) {\n\t\t\treturn this._content.pointsCount();\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\ttotalPointsCount(): number {\n\t\tif (this._content) {\n\t\t\treturn this._content.totalPointsCount();\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\tobjectsData(): ObjectData[] {\n\t\tif (this._content) {\n\t\t\treturn this._content.objectsData();\n\t\t} else {\n\t\t\treturn [];\n\t\t}\n\t}\n\n\t//\n\t//\n\t// BBOX\n\t//\n\t//\n\tboundingBox(): Box3 {\n\t\treturn this._content.boundingBox();\n\t}\n\tcenter(): Vector3 {\n\t\treturn this._content.center();\n\t}\n\tsize(): Vector3 {\n\t\treturn this._content.size();\n\t}\n}\n","import {TypedNode} from '../_Base';\nimport {NodeContext} from '../../poly/NodeContext';\nimport {ContainerMap, ContainerClassMap} from '../../containers/utils/ContainerMap';\n\ntype Callback<NC extends NodeContext> = (container: ContainerMap[NC] | undefined) => void;\n\nexport class TypedContainerController<NC extends NodeContext> {\n\tprivate _callbacks: Callback<NC>[] = [];\n\tprivate _callbacks_tmp: Callback<NC>[] = [];\n\tprotected _container: ContainerMap[NC];\n\n\tconstructor(protected node: TypedNode<NC, any>) {\n\t\tconst container_class = ContainerClassMap[node.nodeContext()];\n\t\tthis._container = new container_class(this.node as any) as ContainerMap[NC];\n\t}\n\n\tget container() {\n\t\treturn this._container;\n\t}\n\n\tasync requestContainer(): Promise<ContainerMap[NC]> {\n\t\tif (this.node.flags?.bypass?.active()) {\n\t\t\treturn (await this.requestInputContainer(0)) || this._container;\n\t\t}\n\t\tif (this.node.isDirty()) {\n\t\t\treturn new Promise((resolve, reject) => {\n\t\t\t\tthis._callbacks.push(resolve);\n\t\t\t\tthis.node.cookController.cook_main();\n\t\t\t});\n\t\t}\n\t\treturn this._container;\n\t}\n\t// async requestContainerTEST(): Promise<ContainerMap[NC]> {\n\t// \tif (this.node.flags?.bypass?.active()) {\n\t// \t\tconst container = await this.requestInputContainer(0);\n\t// \t\treturn container || this._container;\n\t// \t}\n\t// \tif (this.node.isDirty()) {\n\t// \t\tawait this.node.cookController.cook_main();\n\t// \t}\n\t// \treturn this._container;\n\t// }\n\n\t// TODO: should I merge this into the method above?\n\t// private process_container_request() {\n\t// \tif (this.node.flags?.bypass?.active()) {\n\t// \t\tconst input_index = 0;\n\t// \t\tthis.requestInputContainer(input_index).then((container) => {\n\t// \t\t\tthis.node.removeDirtyState();\n\t// \t\t\tif (container) {\n\t// \t\t\t\tthis.notify_requesters(container);\n\t// \t\t\t} else {\n\t// \t\t\t\tthis.node.states.error.set('input invalid');\n\t// \t\t\t}\n\t// \t\t});\n\t// \t} else {\n\t// \t\tif (this.node.isDirty()) {\n\t// \t\t\tthis.node.cookController.cook_main();\n\t// \t\t} else {\n\t// \t\t\tthis.notify_requesters();\n\t// \t\t}\n\t// \t}\n\t// }\n\n\tasync requestInputContainer(input_index: number) {\n\t\tconst input_node = (<unknown>this.node.io.inputs.input(input_index)) as TypedNode<NC, any>;\n\t\tif (input_node) {\n\t\t\treturn await input_node.requestContainer();\n\t\t} else {\n\t\t\tthis.node.states.error.set(`input ${input_index} required`);\n\t\t\tthis.notify_requesters();\n\t\t\treturn null;\n\t\t}\n\t}\n\tnotify_requesters(container?: ContainerMap[NC]) {\n\t\t// make a copy of the callbacks first,\n\t\t// to ensure that new ones are not added to this list\n\t\t// in side effects from those callbacks\n\t\t// (the test suite for the File SOP is a good test for this)\n\t\tthis._callbacks_tmp = this._callbacks.slice(); // clone\n\t\tthis._callbacks.splice(0, this._callbacks.length); // empty\n\n\t\tif (!container) {\n\t\t\tcontainer = this.node.containerController.container;\n\t\t}\n\t\tlet callback: Callback<NC> | undefined;\n\t\twhile ((callback = this._callbacks_tmp.pop())) {\n\t\t\tcallback(container);\n\t\t}\n\t\tthis.node.scene().cookController.remove_node(this.node);\n\t}\n}\n\nexport class BaseContainerController extends TypedContainerController<any> {}\n","import {NodeCookController} from '../CookController';\n\nexport interface NodePerformanceData {\n\tinputs_time: number;\n\tparams_time: number;\n\tcook_time: number;\n}\n\nexport class NodeCookPerformanceformanceController {\n\tprivate _inputs_start: number = 0;\n\tprivate _params_start: number = 0;\n\tprivate _cook_start: number = 0;\n\tprivate _cooks_count: number = 0;\n\tprivate _data: NodePerformanceData = {\n\t\tinputs_time: 0,\n\t\tparams_time: 0,\n\t\tcook_time: 0,\n\t};\n\n\tconstructor(private cookController: NodeCookController<any>) {}\n\n\tget cooks_count() {\n\t\treturn this._cooks_count;\n\t}\n\tget data() {\n\t\treturn this._data;\n\t}\n\n\tactive() {\n\t\treturn this.cookController.performance_record_started;\n\t}\n\n\t//\n\t// INPUTS\n\t//\n\trecord_inputs_start() {\n\t\tif (this.active()) {\n\t\t\tthis._inputs_start = performance.now();\n\t\t}\n\t}\n\trecord_inputs_end() {\n\t\tif (this.active()) {\n\t\t\tthis._data.inputs_time = performance.now() - this._inputs_start;\n\t\t}\n\t}\n\t//\n\t// PARAMS\n\t//\n\trecord_params_start() {\n\t\tif (this.active()) {\n\t\t\tthis._params_start = performance.now();\n\t\t}\n\t}\n\trecord_params_end() {\n\t\tif (this.active()) {\n\t\t\tthis._data.params_time = performance.now() - this._params_start;\n\t\t}\n\t}\n\t//\n\t// COOK\n\t//\n\trecord_cook_start() {\n\t\tif (this.active()) {\n\t\t\tthis._cook_start = performance.now();\n\t\t}\n\t}\n\trecord_cook_end() {\n\t\tif (this.active()) {\n\t\t\tthis._data.cook_time = performance.now() - this._cook_start;\n\t\t\tthis._cooks_count += 1;\n\t\t}\n\t}\n}\n","import {BaseNodeType} from '../_Base';\nimport {Poly} from '../../Poly';\nimport {CorePerformance} from '../../../core/performance/CorePerformance';\nimport {NodeCookPerformanceformanceController} from './cook/PerformanceController';\nimport {ContainerMap} from '../../containers/utils/ContainerMap';\nimport {NodeContext} from '../../poly/NodeContext';\nimport {ContainableMap} from '../../containers/utils/ContainableMap';\nimport {CoreGraphNode} from '../../../core/graph/CoreGraphNode';\nimport {CoreGraphNodeId} from '../../../core/graph/CoreGraph';\n\nexport type OnCookCompleteHook = (node: BaseNodeType) => void;\nexport class NodeCookController<NC extends NodeContext> {\n\tprivate _core_performance: CorePerformance;\n\tprivate _cooking: boolean = false;\n\tprivate _cooking_dirty_timestamp: number | undefined;\n\tprivate _performance_controller: NodeCookPerformanceformanceController = new NodeCookPerformanceformanceController(\n\t\tthis\n\t);\n\n\tconstructor(private node: BaseNodeType) {\n\t\tthis._core_performance = this.node.scene().performance;\n\t}\n\tget performance_record_started() {\n\t\treturn this._core_performance.started();\n\t}\n\n\t// Disallowing inputs evaluation is important for switch nodes (such as SOP and COP)\n\t// that should not evaluate all inputs, but only a single one, depending on a param value\n\t// currently only for switch SOP and COP\n\tprivate _inputs_evaluation_required: boolean = true;\n\tdisallow_inputs_evaluation() {\n\t\tthis._inputs_evaluation_required = false;\n\t}\n\n\tisCooking(): boolean {\n\t\treturn this._cooking === true;\n\t}\n\n\tprivate _init_cooking_state() {\n\t\tthis._cooking = true;\n\t\tthis._cooking_dirty_timestamp = this.node.dirtyController.dirtyTimestamp();\n\t}\n\n\tprivate _start_cook_if_no_errors(input_contents: ContainableMap[NC][]) {\n\t\tif (this.node.states.error.active()) {\n\t\t\tthis.end_cook();\n\t\t} else {\n\t\t\ttry {\n\t\t\t\tthis._performance_controller.record_cook_start();\n\t\t\t\tthis.node.cook(input_contents);\n\t\t\t} catch (e) {\n\t\t\t\tthis.node.states.error.set(`node internal error: '${e}'.`);\n\t\t\t\tPoly.warn(e);\n\t\t\t\tthis.end_cook();\n\t\t\t}\n\t\t}\n\t}\n\n\tasync cook_main() {\n\t\tif (this.isCooking()) {\n\t\t\treturn;\n\t\t}\n\t\tthis._init_cooking_state();\n\t\tthis.node.states.error.clear();\n\t\tthis.node.scene().cookController.add_node(this.node);\n\n\t\tlet input_contents: ContainableMap[NC][];\n\t\tif (this._inputs_evaluation_required) {\n\t\t\tinput_contents = await this._evaluate_inputs();\n\t\t} else {\n\t\t\tinput_contents = [];\n\t\t}\n\t\tif (this.node.params.params_eval_required()) {\n\t\t\tawait this._evaluate_params();\n\t\t}\n\t\tthis._start_cook_if_no_errors(input_contents);\n\t}\n\tasync cook_main_without_inputs() {\n\t\tthis.node.scene().cookController.add_node(this.node);\n\t\tif (this.isCooking()) {\n\t\t\t// TODO:\n\t\t\t// this seems to happen because when we flush the cooker queue,\n\t\t\t// some graph nodes will trigger more updates, which will then make dependent nodes\n\t\t\t// dirty again\n\t\t\tPoly.warn('cook_main_without_inputs already cooking', this.node.fullPath());\n\t\t\treturn;\n\t\t}\n\t\tthis._init_cooking_state();\n\t\tthis.node.states.error.clear();\n\n\t\tif (this.node.params.params_eval_required()) {\n\t\t\tawait this._evaluate_params();\n\t\t}\n\t\tthis._start_cook_if_no_errors([]);\n\t}\n\n\tend_cook(message?: string | null) {\n\t\tthis._finalize_cook_performance();\n\n\t\tconst dirty_timestamp = this.node.dirtyController.dirtyTimestamp();\n\t\tif (dirty_timestamp == null || dirty_timestamp === this._cooking_dirty_timestamp) {\n\t\t\tthis.node.removeDirtyState();\n\t\t\tthis._terminate_cook_process();\n\t\t} else {\n\t\t\tPoly.log('COOK AGAIN', dirty_timestamp, this._cooking_dirty_timestamp, this.node.fullPath());\n\t\t\tthis._cooking = false;\n\t\t\tthis.cook_main();\n\t\t}\n\t}\n\n\tprivate _terminate_cook_process() {\n\t\tif (this.isCooking()) {\n\t\t\tthis._cooking = false;\n\t\t\t// setTimeout(this.node.containerController.notify_requesters.bind(this.node.containerController), 0);\n\t\t\tthis.node.containerController.notify_requesters();\n\t\t\tthis._run_on_cook_complete_hooks();\n\t\t}\n\t}\n\n\tprivate async _evaluate_inputs(): Promise<ContainableMap[NC][]> {\n\t\tthis._performance_controller.record_inputs_start();\n\n\t\tlet input_containers: (ContainerMap[NC] | null)[] = [];\n\t\tconst io_inputs = this.node.io.inputs;\n\t\tif (this._inputs_evaluation_required) {\n\t\t\tif (io_inputs.is_any_input_dirty()) {\n\t\t\t\tinput_containers = await io_inputs.eval_required_inputs();\n\t\t\t} else {\n\t\t\t\tinput_containers = await io_inputs.containers_without_evaluation();\n\t\t\t}\n\t\t}\n\n\t\tconst inputs = io_inputs.inputs();\n\t\tconst input_contents: ContainableMap[NC][] = [];\n\t\tlet input_container: ContainerMap[NC] | null;\n\t\tfor (let i = 0; i < inputs.length; i++) {\n\t\t\tinput_container = input_containers[i];\n\t\t\tif (input_container) {\n\t\t\t\tif (io_inputs.cloneRequired(i)) {\n\t\t\t\t\tinput_contents[i] = input_container.coreContentCloned() as ContainableMap[NC];\n\t\t\t\t} else {\n\t\t\t\t\tinput_contents[i] = input_container.coreContent() as ContainableMap[NC];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthis._performance_controller.record_inputs_end();\n\t\treturn input_contents;\n\t}\n\tprivate async _evaluate_params() {\n\t\tthis._performance_controller.record_params_start();\n\t\tawait this.node.params.eval_all();\n\t\tthis._performance_controller.record_params_end();\n\t}\n\n\t//\n\t//\n\t// PERFORMANCE\n\t//\n\t//\n\tget cooks_count(): number {\n\t\treturn this._performance_controller.cooks_count;\n\t}\n\tget cook_time(): number {\n\t\treturn this._performance_controller.data.cook_time;\n\t}\n\n\tprivate _finalize_cook_performance() {\n\t\tif (!this._core_performance.started()) {\n\t\t\treturn;\n\t\t}\n\t\tthis._performance_controller.record_cook_end();\n\n\t\tthis._core_performance.record_node_cook_data(this.node, this._performance_controller.data);\n\t}\n\n\t//\n\t//\n\t// HOOK\n\t//\n\t//\n\tprivate _on_cook_complete_hook_ids: CoreGraphNodeId[] | undefined;\n\tprivate _on_cook_complete_hooks: OnCookCompleteHook[] | undefined;\n\tadd_on_cook_complete_hook(core_graph_node: CoreGraphNode, callback: OnCookCompleteHook) {\n\t\tthis._on_cook_complete_hook_ids = this._on_cook_complete_hook_ids || [];\n\t\tthis._on_cook_complete_hooks = this._on_cook_complete_hooks || [];\n\t\tthis._on_cook_complete_hook_ids.push(core_graph_node.graphNodeId());\n\t\tthis._on_cook_complete_hooks.push(callback);\n\t}\n\tremove_on_cook_complete_hook(core_graph_node: CoreGraphNode) {\n\t\tif (!this._on_cook_complete_hook_ids || !this._on_cook_complete_hooks) {\n\t\t\treturn;\n\t\t}\n\t\tconst index = this._on_cook_complete_hook_ids?.indexOf(core_graph_node.graphNodeId());\n\t\tthis._on_cook_complete_hook_ids.splice(index, 1);\n\t\tthis._on_cook_complete_hooks.splice(index, 1);\n\t}\n\tprivate _run_on_cook_complete_hooks() {\n\t\tif (this._on_cook_complete_hooks) {\n\t\t\tfor (let hook of this._on_cook_complete_hooks) {\n\t\t\t\thook(this.node);\n\t\t\t}\n\t\t}\n\t}\n}\n","import {TypedNumericParam} from './_Numeric';\nimport {ParamType} from '../poly/ParamType';\nimport {CoreString} from '../../core/String';\nimport {ParamValuesTypeMap} from './types/ParamValuesTypeMap';\nimport {ParamInitValuesTypeMap} from './types/ParamInitValuesTypeMap';\nimport {CoreType} from '../../core/Type';\n\nexport class BooleanParam extends TypedNumericParam<ParamType.BOOLEAN> {\n\tstatic type() {\n\t\treturn ParamType.BOOLEAN;\n\t}\n\t// TODO: be careful as this does not allow serialization of expressions as default value\n\tdefaultValueSerialized() {\n\t\tif (CoreType.isString(this._default_value)) {\n\t\t\treturn this._default_value;\n\t\t} else {\n\t\t\treturn this.convert(this._default_value) || false;\n\t\t}\n\t}\n\trawInputSerialized() {\n\t\treturn this._raw_input;\n\t}\n\tvalueSerialized() {\n\t\treturn this.value;\n\t}\n\tprotected _copy_value(param: BooleanParam) {\n\t\tthis.set(param.value);\n\t}\n\tstatic are_raw_input_equal(\n\t\traw_input1: ParamInitValuesTypeMap[ParamType.BOOLEAN],\n\t\traw_input2: ParamInitValuesTypeMap[ParamType.BOOLEAN]\n\t) {\n\t\treturn raw_input1 == raw_input2;\n\t}\n\tstatic are_values_equal(val1: ParamValuesTypeMap[ParamType.BOOLEAN], val2: ParamValuesTypeMap[ParamType.BOOLEAN]) {\n\t\treturn val1 == val2;\n\t}\n\tconvert(raw_val: ParamInitValuesTypeMap[ParamType.BOOLEAN]): boolean | null {\n\t\tif (CoreType.isBoolean(raw_val)) {\n\t\t\treturn raw_val;\n\t\t} else {\n\t\t\tif (CoreType.isNumber(raw_val)) {\n\t\t\t\treturn raw_val >= 1;\n\t\t\t} else {\n\t\t\t\tif (CoreType.isString(raw_val)) {\n\t\t\t\t\tif (CoreString.isBoolean(raw_val)) {\n\t\t\t\t\t\treturn CoreString.toBoolean(raw_val);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (CoreString.isNumber(raw_val)) {\n\t\t\t\t\t\t\tconst parsed = parseFloat(raw_val);\n\t\t\t\t\t\t\treturn parsed >= 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\t// convert_value(v: ParamInputValue): boolean {\n\t// \treturn this.value_to_boolean(v)\n\t// }\n\t// convert_default_value(v: ParamInputValue): number {\n\t// \tif (CoreType.isString(v)) {\n\t// \t\treturn v\n\t// \t} else {\n\t// \t\treturn this.value_to_boolean(v) // ? 1 : 0\n\t// \t}\n\t// }\n\t// is_value_expression(v: ParamInputValue): boolean {\n\t// \treturn !lodash_includes([true, false, 0, 1, '0', '1'], v)\n\t// }\n\n\t// value_to_boolean(v: ParamInputValue): boolean {\n\t// \tif (CoreType.isBoolean(v)) {\n\t// \t\treturn v\n\t// \t} else {\n\t// \t\tif (CoreType.isNumber(v)) {\n\t// \t\t\treturn v > 0\n\t// \t\t} else {\n\t// \t\t\treturn parseInt(v) > 0\n\t// \t\t}\n\t// \t}\n\t// }\n\n\t// eval(callback) {\n\t// \treturn this.eval_raw((val) => {\n\t// \t\tconst boolean_result = this.value_to_boolean(val)\n\t// \t\treturn callback(boolean_result)\n\t// \t})\n\t// }\n}\n","import {TypedParam} from './_Base';\nimport {ParamType} from '../poly/ParamType';\nimport {ParamValuesTypeMap} from './types/ParamValuesTypeMap';\nimport {ParamInitValuesTypeMap} from './types/ParamInitValuesTypeMap';\n\nexport class ButtonParam extends TypedParam<ParamType.BUTTON> {\n\tstatic type() {\n\t\treturn ParamType.BUTTON;\n\t}\n\tdefaultValueSerialized() {\n\t\treturn this._default_value;\n\t}\n\trawInputSerialized() {\n\t\treturn this._raw_input;\n\t}\n\tvalueSerialized() {\n\t\treturn this.value;\n\t}\n\tprotected _copy_value(param: ButtonParam) {}\n\tstatic are_raw_input_equal(\n\t\traw_input1: ParamInitValuesTypeMap[ParamType.BUTTON],\n\t\traw_input2: ParamInitValuesTypeMap[ParamType.BUTTON]\n\t) {\n\t\treturn true;\n\t}\n\tstatic are_values_equal(val1: ParamValuesTypeMap[ParamType.BUTTON], val2: ParamValuesTypeMap[ParamType.BUTTON]) {\n\t\treturn true;\n\t}\n\tasync pressButton() {\n\t\t// cook the node in case it requires it, since the callback will not be ran if the node is cooking\n\t\tif (this.node.isDirty() || this.node.cookController.isCooking()) {\n\t\t\tawait this.node.requestContainer();\n\t\t}\n\t\tthis.options.execute_callback();\n\t}\n}\n","import {Number3, StringOrNumber3} from '../../types/GlobalTypes';\nimport {TypedMultipleParam} from './_Multiple';\nimport {Color} from 'three/src/math/Color';\nimport {ParamType} from '../poly/ParamType';\nimport {FloatParam} from './Float';\nimport {ParamValuesTypeMap} from './types/ParamValuesTypeMap';\nimport {ParamInitValuesTypeMap} from './types/ParamInitValuesTypeMap';\nimport {ColorConversion} from '../../core/Color';\nimport {TypeAssert} from '../poly/Assert';\nimport {CoreType} from '../../core/Type';\n\nconst COMPONENT_NAMES_COLOR: Readonly<string[]> = ['r', 'g', 'b'];\nexport class ColorParam extends TypedMultipleParam<ParamType.COLOR> {\n\tprotected _value = new Color();\n\tprotected _value_pre_conversion = new Color();\n\tprivate _value_serialized_dirty: boolean = false;\n\tprivate _value_serialized: Number3 = [0, 0, 0];\n\tprivate _value_pre_conversion_serialized: Number3 = [0, 0, 0];\n\tr!: FloatParam;\n\tg!: FloatParam;\n\tb!: FloatParam;\n\tstatic type() {\n\t\treturn ParamType.COLOR;\n\t}\n\tcomponentNames(): Readonly<string[]> {\n\t\treturn COMPONENT_NAMES_COLOR;\n\t}\n\tdefaultValueSerialized() {\n\t\tif (CoreType.isArray(this._default_value)) {\n\t\t\treturn this._default_value;\n\t\t} else {\n\t\t\treturn this._default_value.toArray() as Number3;\n\t\t}\n\t}\n\t// rawInputSerialized() {\n\t// \tif (this._raw_input instanceof Color) {\n\t// \t\treturn this._raw_input.toArray() as Number3;\n\t// \t} else {\n\t// \t\tconst new_array: StringOrNumber3 = [this._raw_input[0], this._raw_input[1], this._raw_input[2]];\n\t// \t\treturn new_array;\n\t// \t}\n\t// }\n\tvalueSerialized() {\n\t\tthis._update_value_serialized_if_required();\n\t\treturn this._value_serialized;\n\t}\n\tvaluePreConversionSerialized() {\n\t\tthis._update_value_serialized_if_required();\n\t\treturn this._value_pre_conversion_serialized;\n\t}\n\tprivate _copied_value: Number3 = [0, 0, 0];\n\tprotected _copy_value(param: ColorParam) {\n\t\tparam.value.toArray(this._copied_value);\n\t\tthis.set(this._copied_value);\n\t}\n\t// protected _prefilter_invalid_raw_input(\n\t// \traw_input: ParamInitValuesTypeMap[ParamType.COLOR]\n\t// ): ParamInitValuesTypeMap[ParamType.COLOR] {\n\t// \treturn raw_input;\n\t// }\n\tprotected _clone_raw_input(raw_input: ParamInitValuesTypeMap[ParamType.COLOR]) {\n\t\tif (raw_input instanceof Color) {\n\t\t\treturn raw_input.clone();\n\t\t} else {\n\t\t\tconst new_array: StringOrNumber3 = [raw_input[0], raw_input[1], raw_input[2]];\n\t\t\treturn new_array;\n\t\t}\n\t}\n\tstatic are_raw_input_equal(\n\t\traw_input1: ParamInitValuesTypeMap[ParamType.COLOR],\n\t\traw_input2: ParamInitValuesTypeMap[ParamType.COLOR]\n\t) {\n\t\tif (raw_input1 instanceof Color) {\n\t\t\tif (raw_input2 instanceof Color) {\n\t\t\t\treturn raw_input1.equals(raw_input2);\n\t\t\t} else {\n\t\t\t\treturn raw_input1.r == raw_input2[0] && raw_input1.g == raw_input2[1] && raw_input1.b == raw_input2[2];\n\t\t\t}\n\t\t} else {\n\t\t\tif (raw_input2 instanceof Color) {\n\t\t\t\treturn raw_input1[0] == raw_input2.r && raw_input1[1] == raw_input2.g && raw_input1[2] == raw_input2.b;\n\t\t\t} else {\n\t\t\t\treturn (\n\t\t\t\t\traw_input1[0] == raw_input2[0] && raw_input1[1] == raw_input2[1] && raw_input1[2] == raw_input2[2]\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\tstatic are_values_equal(val1: ParamValuesTypeMap[ParamType.COLOR], val2: ParamValuesTypeMap[ParamType.COLOR]) {\n\t\treturn val1.equals(val2);\n\t}\n\tinitComponents() {\n\t\tsuper.initComponents();\n\t\tthis.r = this.components[0];\n\t\tthis.g = this.components[1];\n\t\tthis.b = this.components[2];\n\t\tthis._value_serialized_dirty = true;\n\t}\n\n\tprivate _update_value_serialized_if_required() {\n\t\tif (!this._value_serialized_dirty) {\n\t\t\treturn;\n\t\t}\n\t\tthis._value_serialized[0] = this._value.r;\n\t\tthis._value_serialized[1] = this._value.g;\n\t\tthis._value_serialized[2] = this._value.b;\n\t\tthis._value_pre_conversion_serialized[0] = this._value_pre_conversion.r;\n\t\tthis._value_pre_conversion_serialized[1] = this._value_pre_conversion.g;\n\t\tthis._value_pre_conversion_serialized[2] = this._value_pre_conversion.b;\n\t}\n\t// set_raw_input_from_components() {\n\t// \tif (this._raw_input instanceof Color) {\n\t// \t\tif (\n\t// \t\t\tCoreType.isNumber(this.r.raw_input) &&\n\t// \t\t\tCoreType.isNumber(this.g.raw_input) &&\n\t// \t\t\tCoreType.isNumber(this.b.raw_input)\n\t// \t\t) {\n\t// \t\t\tthis._raw_input.r = this.r.raw_input;\n\t// \t\t\tthis._raw_input.g = this.g.raw_input;\n\t// \t\t\tthis._raw_input.b = this.b.raw_input;\n\t// \t\t} else {\n\t// \t\t\tthis._raw_input = [this.r.raw_input, this.g.raw_input, this.b.raw_input];\n\t// \t\t}\n\t// \t} else {\n\t// \t\tthis._raw_input[0] = this.r.raw_input;\n\t// \t\tthis._raw_input[1] = this.g.raw_input;\n\t// \t\tthis._raw_input[2] = this.b.raw_input;\n\t// \t}\n\t// }\n\tvaluePreConversion() {\n\t\treturn this._value_pre_conversion;\n\t}\n\n\tset_value_from_components() {\n\t\tthis._value_pre_conversion.r = this.r.value;\n\t\tthis._value_pre_conversion.g = this.g.value;\n\t\tthis._value_pre_conversion.b = this.b.value;\n\n\t\tthis._value.copy(this._value_pre_conversion);\n\n\t\tconst conversion = this.options.color_conversion();\n\t\tif (conversion != null && conversion != ColorConversion.NONE) {\n\t\t\tswitch (conversion) {\n\t\t\t\tcase ColorConversion.GAMMA_TO_LINEAR: {\n\t\t\t\t\tthis._value.convertGammaToLinear();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tcase ColorConversion.LINEAR_TO_GAMMA: {\n\t\t\t\t\tthis._value.convertLinearToGamma();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tcase ColorConversion.SRGB_TO_LINEAR: {\n\t\t\t\t\tthis._value.convertSRGBToLinear();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tcase ColorConversion.LINEAR_TO_SRGB: {\n\t\t\t\t\tthis._value.convertLinearToSRGB();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tTypeAssert.unreachable(conversion);\n\t\t}\n\t\tthis._value_serialized_dirty = true;\n\t}\n\t// convert(input: ParamInitValuesTypeMap[ParamType.COLOR]): Color | null {\n\t// \tif (CoreType.isArray(input)) {\n\t// \t\tif(input.length == 3){\n\t// \t\t\tif( input.filter(CoreType.isNumber).length > 0 ){\n\t// \t\t\t\treturn new Color().fromArray(input);\n\t// \t\t\t}\n\t// \t\t\tif(first){\n\t// \t\t\t\tif(CoreType.isNumber(first)){\n\t// \t\t\t\t\treturn new Color().fromArray(input);\n\t// \t\t\t\t}\n\t// \t\t\t}\n\t// \t\t}\n\t// \t}\n\t// \treturn new Color();\n\t// }\n}\n","import {TypedParam} from './_Base';\nimport {ParamType} from '../poly/ParamType';\nimport {ParamValuesTypeMap} from './types/ParamValuesTypeMap';\nimport {ParamInitValuesTypeMap} from './types/ParamInitValuesTypeMap';\n\nexport class FolderParam extends TypedParam<ParamType.FOLDER> {\n\tstatic type() {\n\t\treturn ParamType.FOLDER;\n\t}\n\tdefaultValueSerialized() {\n\t\treturn this._default_value;\n\t}\n\trawInputSerialized() {\n\t\treturn this._raw_input;\n\t}\n\tvalueSerialized() {\n\t\treturn this.value;\n\t}\n\tprotected _copy_value(param: FolderParam) {}\n\tstatic are_raw_input_equal(\n\t\traw_input1: ParamInitValuesTypeMap[ParamType.FOLDER],\n\t\traw_input2: ParamInitValuesTypeMap[ParamType.FOLDER]\n\t) {\n\t\treturn true;\n\t}\n\tstatic are_values_equal(val1: ParamValuesTypeMap[ParamType.FOLDER], val2: ParamValuesTypeMap[ParamType.FOLDER]) {\n\t\treturn true;\n\t}\n}\n","import {TypedNumericParam} from './_Numeric';\nimport {ParamType} from '../poly/ParamType';\nimport {CoreString} from '../../core/String';\nimport {ParamInitValuesTypeMap} from './types/ParamInitValuesTypeMap';\nimport {ParamValuesTypeMap} from './types/ParamValuesTypeMap';\nimport {CoreType} from '../../core/Type';\n\nexport class IntegerParam extends TypedNumericParam<ParamType.INTEGER> {\n\tstatic type() {\n\t\treturn ParamType.INTEGER;\n\t}\n\tdefaultValueSerialized() {\n\t\treturn this._default_value;\n\t}\n\trawInputSerialized() {\n\t\treturn this._raw_input;\n\t}\n\tvalueSerialized() {\n\t\treturn this.value;\n\t}\n\tprotected _copy_value(param: IntegerParam) {\n\t\tthis.set(param.valueSerialized());\n\t}\n\tprotected _prefilter_invalid_raw_input(raw_input: any): ParamInitValuesTypeMap[ParamType.INTEGER] {\n\t\tif (CoreType.isArray(raw_input)) {\n\t\t\treturn raw_input[0] as ParamInitValuesTypeMap[ParamType.INTEGER];\n\t\t}\n\t\tif (CoreType.isString(raw_input) && CoreString.isNumber(raw_input)) {\n\t\t\treturn parseInt(raw_input);\n\t\t}\n\t\treturn raw_input;\n\t}\n\n\tstatic are_raw_input_equal(\n\t\traw_input1: ParamInitValuesTypeMap[ParamType.INTEGER],\n\t\traw_input2: ParamInitValuesTypeMap[ParamType.INTEGER]\n\t) {\n\t\treturn raw_input1 == raw_input2;\n\t}\n\tstatic are_values_equal(val1: ParamValuesTypeMap[ParamType.INTEGER], val2: ParamValuesTypeMap[ParamType.INTEGER]) {\n\t\treturn val1 == val2;\n\t}\n\tstatic convert(raw_val: ParamInitValuesTypeMap[ParamType.INTEGER]): number | null {\n\t\tif (CoreType.isNumber(raw_val)) {\n\t\t\treturn Math.round(raw_val);\n\t\t} else {\n\t\t\tif (CoreType.isBoolean(raw_val)) {\n\t\t\t\treturn raw_val ? 1 : 0;\n\t\t\t} else {\n\t\t\t\tif (CoreString.isNumber(raw_val)) {\n\t\t\t\t\tconst parsed = parseInt(raw_val);\n\t\t\t\t\tif (CoreType.isNumber(parsed)) {\n\t\t\t\t\t\treturn parsed;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t}\n\tconvert(raw_val: ParamInitValuesTypeMap[ParamType.INTEGER]): number | null {\n\t\tconst result = IntegerParam.convert(raw_val);\n\t\tif (result) {\n\t\t\treturn this.options.ensure_in_range(result);\n\t\t} else {\n\t\t\treturn result;\n\t\t}\n\t}\n}\n","import {BaseParamType} from './_Base';\nimport {TypedPathParam} from './_BasePath';\nimport {CoreWalker, TypedParamPathParamValue} from '../../core/Walker';\nimport {BaseNodeType} from '../nodes/_Base';\nimport {ParamType} from '../poly/ParamType';\nimport {ParamValuesTypeMap} from './types/ParamValuesTypeMap';\nimport {ParamEvent} from '../poly/ParamEvent';\nimport {ParamInitValuesTypeMap} from './types/ParamInitValuesTypeMap';\n\nexport class ParamPathParam extends TypedPathParam<ParamType.PARAM_PATH> {\n\t// private _found_param: BaseParamType | null = null;\n\n\tstatic type() {\n\t\treturn ParamType.PARAM_PATH;\n\t}\n\tinitialize_param() {\n\t\tthis._value = new TypedParamPathParamValue();\n\t}\n\n\tdefaultValueSerialized() {\n\t\treturn this._default_value;\n\t}\n\trawInputSerialized() {\n\t\treturn `${this._raw_input}`;\n\t}\n\tvalueSerialized() {\n\t\treturn `${this.value}`;\n\t}\n\tprotected _copy_value(param: ParamPathParam) {\n\t\tthis.set(param.valueSerialized());\n\t}\n\tstatic are_raw_input_equal(\n\t\traw_input1: ParamInitValuesTypeMap[ParamType.PARAM_PATH],\n\t\traw_input2: ParamInitValuesTypeMap[ParamType.PARAM_PATH]\n\t) {\n\t\treturn raw_input1 == raw_input2;\n\t}\n\tstatic are_values_equal(\n\t\tval1: ParamValuesTypeMap[ParamType.PARAM_PATH],\n\t\tval2: ParamValuesTypeMap[ParamType.PARAM_PATH]\n\t) {\n\t\treturn val1 == val2;\n\t}\n\tisDefault(): boolean {\n\t\treturn this._raw_input == this._default_value;\n\t}\n\tsetParam(param: BaseParamType) {\n\t\tthis.set(param.fullPath());\n\t}\n\tprotected processRawInput() {\n\t\tif (this._value.path() != this._raw_input) {\n\t\t\tthis._value.set_path(this._raw_input);\n\t\t\tthis.find_target();\n\t\t\tthis.setDirty();\n\t\t\tthis.emitController.emit(ParamEvent.VALUE_UPDATED);\n\t\t}\n\t}\n\tprotected async process_computation() {\n\t\tthis.find_target();\n\t}\n\tprivate find_target() {\n\t\tif (!this.node) {\n\t\t\treturn;\n\t\t}\n\t\tconst path = this._raw_input;\n\t\tlet param: BaseParamType | null = null;\n\t\tconst path_non_empty = path != null && path !== '';\n\n\t\tthis.scene().referencesController.reset_reference_from_param(this); // must be before decomposed path is changed\n\t\tthis.decomposed_path.reset();\n\t\tif (path_non_empty) {\n\t\t\tparam = CoreWalker.find_param(this.node, path, this.decomposed_path);\n\t\t}\n\n\t\tconst current_found_entity = this._value.param();\n\t\tconst newly_found_entity = param;\n\n\t\tthis.scene().referencesController.set_named_nodes_from_param(this);\n\t\tif (param) {\n\t\t\tthis.scene().referencesController.set_reference_from_param(this, param);\n\t\t}\n\n\t\tif (current_found_entity?.graphNodeId() !== newly_found_entity?.graphNodeId()) {\n\t\t\tconst dependent_on_found_node = this.options.dependent_on_found_node();\n\n\t\t\tconst previously_found_node = this._value.param();\n\t\t\tif (previously_found_node) {\n\t\t\t\tif (dependent_on_found_node) {\n\t\t\t\t\tthis.removeGraphInput(previously_found_node);\n\t\t\t\t} else {\n\t\t\t\t\t// this._found_node.remove_param_referree(this) // TODO: typescript\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (param) {\n\t\t\t\tthis._assign_found_node(param);\n\t\t\t} else {\n\t\t\t\tthis._value.set_param(null);\n\t\t\t}\n\n\t\t\tthis.options.execute_callback();\n\t\t}\n\t\tthis.removeDirtyState();\n\t}\n\n\tprivate _assign_found_node(param: BaseParamType) {\n\t\tconst dependent_on_found_node = this.options.dependent_on_found_node();\n\t\t// if (this._is_node_expected_context(node)) {\n\t\t// \tif (this._is_node_expected_type(node)) {\n\t\tthis._value.set_param(param);\n\t\tif (dependent_on_found_node) {\n\t\t\tthis.addGraphInput(param);\n\t\t}\n\t\t// \t} else {\n\t\t// \t\tthis.states.error.set(\n\t\t// \t\t\t`node type is ${node.type} but the params expects one of ${(this._expected_node_types() || []).join(\n\t\t// \t\t\t\t', '\n\t\t// \t\t\t)}`\n\t\t// \t\t);\n\t\t// \t}\n\t\t// } else {\n\t\t// \tthis.states.error.set(\n\t\t// \t\t`node context is ${node.node_context()} but the params expects a ${this._expected_context()}`\n\t\t// \t);\n\t\t// }\n\t}\n\n\t// private _expected_context() {\n\t// \treturn this.options.node_selection_context;\n\t// }\n\t// private _is_node_expected_context(node: BaseNodeType) {\n\t// \tconst expected_context = this._expected_context();\n\t// \tif (expected_context == null) {\n\t// \t\treturn true;\n\t// \t}\n\t// \tconst node_context = node.parent?.childrenController?.context;\n\t// \treturn expected_context == node_context;\n\t// }\n\t// private _expected_node_types() {\n\t// \treturn this.options.node_selection_types;\n\t// }\n\n\t// private _is_node_expected_type(node: BaseNodeType) {\n\t// \tconst expected_types = this._expected_node_types();\n\t// \tif (expected_types == null) {\n\t// \t\treturn true;\n\t// \t}\n\t// \treturn expected_types?.includes(node.type);\n\t// }\n\n\tnotify_path_rebuild_required(param: BaseParamType) {\n\t\tthis.decomposed_path.update_from_name_change(param);\n\t\tconst new_path = this.decomposed_path.to_path();\n\t\tthis.set(new_path);\n\t}\n\tnotify_target_param_owner_params_updated(node: BaseNodeType) {\n\t\tthis.setDirty();\n\t}\n}\n","import {TypedPathParam} from './_BasePath';\nimport {CoreWalker} from '../../core/Walker';\nimport {BaseNodeType} from '../nodes/_Base';\nimport {ParamType} from '../poly/ParamType';\nimport {ParamValuesTypeMap} from './types/ParamValuesTypeMap';\nimport {ParamEvent} from '../poly/ParamEvent';\nimport {ParamInitValuesTypeMap} from './types/ParamInitValuesTypeMap';\nimport {TypedNodePathParamValue} from '../../core/Walker';\n\nexport class NodePathParam extends TypedPathParam<ParamType.NODE_PATH> {\n\t// private _found_node: BaseNodeType | null = null;\n\n\tstatic type() {\n\t\treturn ParamType.NODE_PATH;\n\t}\n\tinitialize_param() {\n\t\tthis._value = new TypedNodePathParamValue();\n\t}\n\n\tdefaultValueSerialized() {\n\t\treturn this._default_value;\n\t}\n\trawInputSerialized() {\n\t\treturn `${this._raw_input}`;\n\t}\n\tvalueSerialized() {\n\t\treturn `${this.value}`;\n\t}\n\tprotected _copy_value(param: NodePathParam) {\n\t\tthis.set(param.valueSerialized());\n\t}\n\tstatic are_raw_input_equal(\n\t\traw_input1: ParamInitValuesTypeMap[ParamType.NODE_PATH],\n\t\traw_input2: ParamInitValuesTypeMap[ParamType.NODE_PATH]\n\t) {\n\t\treturn raw_input1 == raw_input2;\n\t}\n\tstatic are_values_equal(\n\t\tval1: ParamValuesTypeMap[ParamType.NODE_PATH],\n\t\tval2: ParamValuesTypeMap[ParamType.NODE_PATH]\n\t) {\n\t\treturn val1 == val2;\n\t}\n\tisDefault(): boolean {\n\t\treturn this._raw_input == this._default_value;\n\t}\n\tsetNode(node: BaseNodeType) {\n\t\tthis.set(node.fullPath());\n\t}\n\tprotected processRawInput() {\n\t\tif (this._value.path() != this._raw_input) {\n\t\t\tthis._value.set_path(this._raw_input);\n\t\t\tthis.find_target();\n\t\t\tthis.setDirty();\n\t\t\tthis.emitController.emit(ParamEvent.VALUE_UPDATED);\n\t\t}\n\t}\n\tprotected async process_computation() {\n\t\tthis.find_target();\n\t}\n\tprivate find_target() {\n\t\tif (!this.node) {\n\t\t\treturn;\n\t\t}\n\t\tconst path = this._raw_input;\n\t\tlet node: BaseNodeType | null = null;\n\t\tconst path_non_empty = path != null && path !== '';\n\n\t\tthis.scene().referencesController.reset_reference_from_param(this); // must be before decomposed path is changed\n\t\tthis.decomposed_path.reset();\n\t\tif (path_non_empty) {\n\t\t\tnode = CoreWalker.find_node(this.node, path, this.decomposed_path);\n\t\t}\n\n\t\tconst current_found_entity = this._value.node();\n\t\tconst newly_found_entity = node;\n\n\t\tthis.scene().referencesController.set_named_nodes_from_param(this);\n\t\tif (node) {\n\t\t\tthis.scene().referencesController.set_reference_from_param(this, node);\n\t\t}\n\n\t\tif (current_found_entity?.graphNodeId() !== newly_found_entity?.graphNodeId()) {\n\t\t\tconst dependent_on_found_node = this.options.dependent_on_found_node();\n\n\t\t\tconst previously_found_node = this._value.node();\n\t\t\tif (previously_found_node) {\n\t\t\t\tif (dependent_on_found_node) {\n\t\t\t\t\tthis.removeGraphInput(previously_found_node);\n\t\t\t\t} else {\n\t\t\t\t\t// this._found_node.remove_param_referree(this) // TODO: typescript\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (node) {\n\t\t\t\tthis._assign_found_node(node);\n\t\t\t} else {\n\t\t\t\tthis._value.set_node(null);\n\t\t\t}\n\n\t\t\tthis.options.execute_callback();\n\t\t}\n\t\tthis.removeDirtyState();\n\t}\n\n\tprivate _assign_found_node(node: BaseNodeType) {\n\t\tconst dependent_on_found_node = this.options.dependent_on_found_node();\n\t\tif (this._is_node_expected_context(node)) {\n\t\t\tif (this._is_node_expected_type(node)) {\n\t\t\t\tthis._value.set_node(node);\n\t\t\t\tif (dependent_on_found_node) {\n\t\t\t\t\tthis.addGraphInput(node);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.states.error.set(\n\t\t\t\t\t`node type is ${node.type()} but the params expects one of ${(\n\t\t\t\t\t\tthis._expected_node_types() || []\n\t\t\t\t\t).join(', ')}`\n\t\t\t\t);\n\t\t\t}\n\t\t} else {\n\t\t\tthis.states.error.set(\n\t\t\t\t`node context is ${node.nodeContext()} but the params expects a ${this._expected_context()}`\n\t\t\t);\n\t\t}\n\t}\n\n\tprivate _expected_context() {\n\t\treturn this.options.node_selection_context();\n\t}\n\tprivate _is_node_expected_context(node: BaseNodeType) {\n\t\tconst expected_context = this._expected_context();\n\t\tif (expected_context == null) {\n\t\t\treturn true;\n\t\t}\n\t\tconst node_context = node.parent()?.childrenController?.context;\n\t\treturn expected_context == node_context;\n\t}\n\tprivate _expected_node_types() {\n\t\treturn this.options.node_selection_types();\n\t}\n\n\tprivate _is_node_expected_type(node: BaseNodeType) {\n\t\tconst expected_types = this._expected_node_types();\n\t\tif (expected_types == null) {\n\t\t\treturn true;\n\t\t}\n\t\treturn expected_types?.includes(node.type());\n\t}\n\n\tnotify_path_rebuild_required(node: BaseNodeType) {\n\t\tthis.decomposed_path.update_from_name_change(node);\n\t\tconst new_path = this.decomposed_path.to_path();\n\t\tthis.set(new_path);\n\t}\n\tnotify_target_param_owner_params_updated(node: BaseNodeType) {\n\t\tthis.setDirty();\n\t}\n}\n","import {TypedParam} from './_Base';\nimport {ParamType} from '../poly/ParamType';\nimport {ParamValuesTypeMap} from './types/ParamValuesTypeMap';\nimport {ParamInitValuesTypeMap} from './types/ParamInitValuesTypeMap';\n\nexport class SeparatorParam extends TypedParam<ParamType.SEPARATOR> {\n\tstatic type() {\n\t\treturn ParamType.SEPARATOR;\n\t}\n\tdefaultValueSerialized() {\n\t\treturn this._default_value;\n\t}\n\trawInputSerialized() {\n\t\treturn this._raw_input;\n\t}\n\tvalueSerialized() {\n\t\treturn this.value;\n\t}\n\tprotected _copy_value(param: SeparatorParam) {}\n\n\tstatic are_raw_input_equal(\n\t\traw_input1: ParamInitValuesTypeMap[ParamType.SEPARATOR],\n\t\traw_input2: ParamInitValuesTypeMap[ParamType.SEPARATOR]\n\t) {\n\t\treturn true;\n\t}\n\tstatic are_values_equal(\n\t\tval1: ParamValuesTypeMap[ParamType.SEPARATOR],\n\t\tval2: ParamValuesTypeMap[ParamType.SEPARATOR]\n\t) {\n\t\treturn true;\n\t}\n}\n","import {TypedMultipleParam} from './_Multiple';\nimport {Number2, StringOrNumber2} from '../../types/GlobalTypes';\nimport {Vector2} from 'three/src/math/Vector2';\nimport {ParamType} from '../poly/ParamType';\nimport {FloatParam} from './Float';\nimport {ParamValuesTypeMap} from './types/ParamValuesTypeMap';\nimport {ParamInitValuesTypeMap} from './types/ParamInitValuesTypeMap';\nimport {CoreType} from '../../core/Type';\n\nconst COMPONENT_NAMES_VECTOR2: Readonly<string[]> = ['x', 'y'];\nexport class Vector2Param extends TypedMultipleParam<ParamType.VECTOR2> {\n\tprotected _value = new Vector2();\n\tx!: FloatParam;\n\ty!: FloatParam;\n\tstatic type() {\n\t\treturn ParamType.VECTOR2;\n\t}\n\n\tcomponentNames(): Readonly<string[]> {\n\t\treturn COMPONENT_NAMES_VECTOR2;\n\t}\n\tdefaultValueSerialized() {\n\t\tif (CoreType.isArray(this._default_value)) {\n\t\t\treturn this._default_value;\n\t\t} else {\n\t\t\treturn this._default_value.toArray() as Number2;\n\t\t}\n\t}\n\t// get raw_input_serialized() {\n\t// \tif (this._raw_input instanceof Vector2) {\n\t// \t\treturn this._raw_input.toArray() as Number2;\n\t// \t} else {\n\t// \t\tconst new_array: StringOrNumber2 = [this._raw_input[0], this._raw_input[1]];\n\t// \t\treturn new_array;\n\t// \t}\n\t// }\n\tvalueSerialized() {\n\t\treturn this.value.toArray() as Number2;\n\t}\n\tprivate _copied_value: Number2 = [0, 0];\n\tprotected _copy_value(param: Vector2Param) {\n\t\tparam.value.toArray(this._copied_value);\n\t\tthis.set(this._copied_value);\n\t}\n\n\tprotected _clone_raw_input(raw_input: ParamInitValuesTypeMap[ParamType.VECTOR2]) {\n\t\tif (raw_input instanceof Vector2) {\n\t\t\treturn raw_input.clone();\n\t\t} else {\n\t\t\tconst new_array: StringOrNumber2 = [raw_input[0], raw_input[1]];\n\t\t\treturn new_array;\n\t\t}\n\t}\n\tstatic are_raw_input_equal(\n\t\traw_input1: ParamInitValuesTypeMap[ParamType.VECTOR2],\n\t\traw_input2: ParamInitValuesTypeMap[ParamType.VECTOR2]\n\t) {\n\t\tif (raw_input1 instanceof Vector2) {\n\t\t\tif (raw_input2 instanceof Vector2) {\n\t\t\t\treturn raw_input1.equals(raw_input2);\n\t\t\t} else {\n\t\t\t\treturn raw_input1.x == raw_input2[0] && raw_input1.y == raw_input2[1];\n\t\t\t}\n\t\t} else {\n\t\t\tif (raw_input2 instanceof Vector2) {\n\t\t\t\treturn raw_input1[0] == raw_input2.x && raw_input1[1] == raw_input2.y;\n\t\t\t} else {\n\t\t\t\treturn raw_input1[0] == raw_input2[0] && raw_input1[1] == raw_input2[1];\n\t\t\t}\n\t\t}\n\t}\n\tstatic are_values_equal(val1: ParamValuesTypeMap[ParamType.VECTOR2], val2: ParamValuesTypeMap[ParamType.VECTOR2]) {\n\t\treturn val1.equals(val2);\n\t}\n\tinitComponents() {\n\t\tsuper.initComponents();\n\t\tthis.x = this.components[0];\n\t\tthis.y = this.components[1];\n\t}\n\n\tset_value_from_components() {\n\t\tthis._value.x = this.x.value;\n\t\tthis._value.y = this.y.value;\n\t}\n\t// convert(input: any) {\n\t// \tif (CoreType.isArray(input)) {\n\t// \t\treturn new Vector2().fromArray(input);\n\t// \t}\n\t// \treturn new Vector2();\n\t// }\n}\n","import {Number3, StringOrNumber3} from '../../types/GlobalTypes';\nimport {TypedMultipleParam} from './_Multiple';\nimport {FloatParam} from './Float';\nimport {Vector3} from 'three/src/math/Vector3';\nimport {ParamType} from '../poly/ParamType';\nimport {ParamValuesTypeMap} from './types/ParamValuesTypeMap';\nimport {ParamInitValuesTypeMap} from './types/ParamInitValuesTypeMap';\nimport {CoreType} from '../../core/Type';\n\nconst COMPONENT_NAMES_VECTOR3: Readonly<string[]> = ['x', 'y', 'z'];\nexport class Vector3Param extends TypedMultipleParam<ParamType.VECTOR3> {\n\tprotected _value = new Vector3();\n\tx!: FloatParam;\n\ty!: FloatParam;\n\tz!: FloatParam;\n\tstatic type() {\n\t\treturn ParamType.VECTOR3;\n\t}\n\tcomponentNames(): Readonly<string[]> {\n\t\treturn COMPONENT_NAMES_VECTOR3;\n\t}\n\tdefaultValueSerialized() {\n\t\tif (CoreType.isArray(this._default_value)) {\n\t\t\treturn this._default_value;\n\t\t} else {\n\t\t\treturn this._default_value.toArray() as Number3;\n\t\t}\n\t}\n\t// get raw_input_serialized() {\n\t// \tif (this._raw_input instanceof Vector3) {\n\t// \t\treturn this._raw_input.toArray() as Number3;\n\t// \t} else {\n\t// \t\tconst new_array: StringOrNumber3 = [this._raw_input[0], this._raw_input[1], this._raw_input[2]];\n\t// \t\treturn new_array;\n\t// \t}\n\t// }\n\tvalueSerialized() {\n\t\treturn this.value.toArray() as Number3;\n\t}\n\tprivate _copied_value: Number3 = [0, 0, 0];\n\tprotected _copy_value(param: Vector3Param) {\n\t\tparam.value.toArray(this._copied_value);\n\t\tthis.set(this._copied_value);\n\t}\n\n\tprotected _clone_raw_input(raw_input: ParamInitValuesTypeMap[ParamType.VECTOR3]) {\n\t\tif (raw_input instanceof Vector3) {\n\t\t\treturn raw_input.clone();\n\t\t} else {\n\t\t\tconst new_array: StringOrNumber3 = [raw_input[0], raw_input[1], raw_input[2]];\n\t\t\treturn new_array;\n\t\t}\n\t}\n\n\tstatic are_raw_input_equal(\n\t\traw_input1: ParamInitValuesTypeMap[ParamType.VECTOR3],\n\t\traw_input2: ParamInitValuesTypeMap[ParamType.VECTOR3]\n\t) {\n\t\tif (raw_input1 instanceof Vector3) {\n\t\t\tif (raw_input2 instanceof Vector3) {\n\t\t\t\treturn raw_input1.equals(raw_input2);\n\t\t\t} else {\n\t\t\t\treturn raw_input1.x == raw_input2[0] && raw_input1.y == raw_input2[1] && raw_input1.z == raw_input2[2];\n\t\t\t}\n\t\t} else {\n\t\t\tif (raw_input2 instanceof Vector3) {\n\t\t\t\treturn raw_input1[0] == raw_input2.x && raw_input1[1] == raw_input2.y && raw_input1[2] == raw_input2.z;\n\t\t\t} else {\n\t\t\t\treturn (\n\t\t\t\t\traw_input1[0] == raw_input2[0] && raw_input1[1] == raw_input2[1] && raw_input1[2] == raw_input2[2]\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\tstatic are_values_equal(val1: ParamValuesTypeMap[ParamType.VECTOR3], val2: ParamValuesTypeMap[ParamType.VECTOR3]) {\n\t\treturn val1.equals(val2);\n\t}\n\tinitComponents() {\n\t\tsuper.initComponents();\n\t\tthis.x = this.components[0];\n\t\tthis.y = this.components[1];\n\t\tthis.z = this.components[2];\n\t}\n\n\t// set_raw_input_from_components() {\n\t// \tif (this._raw_input instanceof Vector3) {\n\t// \t\tif (\n\t// \t\t\tCoreType.isNumber(this.x.raw_input) &&\n\t// \t\t\tCoreType.isNumber(this.y.raw_input) &&\n\t// \t\t\tCoreType.isNumber(this.z.raw_input)\n\t// \t\t) {\n\t// \t\t\tthis._raw_input.x = this.x.raw_input;\n\t// \t\t\tthis._raw_input.y = this.y.raw_input;\n\t// \t\t\tthis._raw_input.z = this.z.raw_input;\n\t// \t\t} else {\n\t// \t\t\tthis._raw_input = [this.x.raw_input, this.y.raw_input, this.z.raw_input];\n\t// \t\t}\n\t// \t} else {\n\t// \t\tthis._raw_input[0] = this.x.raw_input;\n\t// \t\tthis._raw_input[1] = this.y.raw_input;\n\t// \t\tthis._raw_input[2] = this.z.raw_input;\n\t// \t}\n\t// }\n\tset_value_from_components() {\n\t\tthis._value.x = this.x.value;\n\t\tthis._value.y = this.y.value;\n\t\tthis._value.z = this.z.value;\n\t}\n\t// convert(input: ParamInitValuesTypeMap[ParamType.VECTOR3]) {\n\t// \tif (CoreType.isArray(input)) {\n\t// \t\treturn new Vector3().fromArray(input);\n\t// \t}\n\t// \treturn new Vector3();\n\t// }\n}\n","import {Number4, StringOrNumber4} from '../../types/GlobalTypes';\nimport {TypedMultipleParam} from './_Multiple';\nimport {Vector4} from 'three/src/math/Vector4';\nimport {ParamType} from '../poly/ParamType';\nimport {FloatParam} from './Float';\nimport {ParamValuesTypeMap} from './types/ParamValuesTypeMap';\nimport {ParamInitValuesTypeMap} from './types/ParamInitValuesTypeMap';\nimport {CoreType} from '../../core/Type';\n\nconst COMPONENT_NAMES_VECTOR4: Readonly<string[]> = ['x', 'y', 'z', 'w'];\nexport class Vector4Param extends TypedMultipleParam<ParamType.VECTOR4> {\n\tprotected _value = new Vector4();\n\tx!: FloatParam;\n\ty!: FloatParam;\n\tz!: FloatParam;\n\tw!: FloatParam;\n\tstatic type() {\n\t\treturn ParamType.VECTOR4;\n\t}\n\tcomponentNames(): Readonly<string[]> {\n\t\treturn COMPONENT_NAMES_VECTOR4;\n\t}\n\tdefaultValueSerialized() {\n\t\tif (CoreType.isArray(this._default_value)) {\n\t\t\treturn this._default_value;\n\t\t} else {\n\t\t\treturn this._default_value.toArray() as Number4;\n\t\t}\n\t}\n\t// get raw_input_serialized() {\n\t// \tif (this._raw_input instanceof Vector4) {\n\t// \t\treturn this._raw_input.toArray() as Number4;\n\t// \t} else {\n\t// \t\tconst new_array: StringOrNumber4 = [\n\t// \t\t\tthis._raw_input[0],\n\t// \t\t\tthis._raw_input[1],\n\t// \t\t\tthis._raw_input[2],\n\t// \t\t\tthis._raw_input[3],\n\t// \t\t];\n\t// \t\treturn new_array;\n\t// \t}\n\t// }\n\tvalueSerialized() {\n\t\treturn this.value.toArray() as Number4;\n\t}\n\tprivate _copied_value: Number4 = [0, 0, 0, 0];\n\tprotected _copy_value(param: Vector4Param) {\n\t\tparam.value.toArray(this._copied_value);\n\t\tthis.set(this._copied_value);\n\t}\n\tprotected _clone_raw_input(raw_input: ParamInitValuesTypeMap[ParamType.VECTOR4]) {\n\t\tif (raw_input instanceof Vector4) {\n\t\t\treturn raw_input.clone();\n\t\t} else {\n\t\t\tconst new_array: StringOrNumber4 = [raw_input[0], raw_input[1], raw_input[2], raw_input[3]];\n\t\t\treturn new_array;\n\t\t}\n\t}\n\tstatic are_raw_input_equal(\n\t\traw_input1: ParamInitValuesTypeMap[ParamType.VECTOR4],\n\t\traw_input2: ParamInitValuesTypeMap[ParamType.VECTOR4]\n\t) {\n\t\tif (raw_input1 instanceof Vector4) {\n\t\t\tif (raw_input2 instanceof Vector4) {\n\t\t\t\treturn raw_input1.equals(raw_input2);\n\t\t\t} else {\n\t\t\t\treturn (\n\t\t\t\t\traw_input1.x == raw_input2[0] &&\n\t\t\t\t\traw_input1.y == raw_input2[1] &&\n\t\t\t\t\traw_input1.z == raw_input2[2] &&\n\t\t\t\t\traw_input1.w == raw_input2[3]\n\t\t\t\t);\n\t\t\t}\n\t\t} else {\n\t\t\tif (raw_input2 instanceof Vector4) {\n\t\t\t\treturn (\n\t\t\t\t\traw_input1[0] == raw_input2.x &&\n\t\t\t\t\traw_input1[1] == raw_input2.y &&\n\t\t\t\t\traw_input1[2] == raw_input2.z &&\n\t\t\t\t\traw_input1[3] == raw_input2.w\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\treturn (\n\t\t\t\t\traw_input1[0] == raw_input2[0] &&\n\t\t\t\t\traw_input1[1] == raw_input2[1] &&\n\t\t\t\t\traw_input1[2] == raw_input2[2] &&\n\t\t\t\t\traw_input1[3] == raw_input2[3]\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\tstatic are_values_equal(val1: ParamValuesTypeMap[ParamType.VECTOR4], val2: ParamValuesTypeMap[ParamType.VECTOR4]) {\n\t\treturn val1.equals(val2);\n\t}\n\tinitComponents() {\n\t\tsuper.initComponents();\n\t\tthis.x = this.components[0];\n\t\tthis.y = this.components[1];\n\t\tthis.z = this.components[2];\n\t\tthis.w = this.components[3];\n\t}\n\n\tset_value_from_components() {\n\t\tthis._value.x = this.x.value;\n\t\tthis._value.y = this.y.value;\n\t\tthis._value.z = this.z.value;\n\t\tthis._value.w = this.w.value;\n\t}\n\t// convert(input: any) {\n\t// \tif (CoreType.isArray(input)) {\n\t// \t\treturn new Vector4().fromArray(input);\n\t// \t}\n\t// \treturn new Vector4();\n\t// }\n}\n","import {BooleanParam} from '../Boolean';\nimport {ButtonParam} from '../Button';\nimport {ColorParam} from '../Color';\nimport {FloatParam} from '../Float';\nimport {FolderParam} from '../Folder';\nimport {IntegerParam} from '../Integer';\nimport {OperatorPathParam} from '../OperatorPath';\nimport {ParamPathParam} from '../ParamPath';\nimport {NodePathParam} from '../NodePath';\nimport {RampParam} from '../Ramp';\nimport {SeparatorParam} from '../Separator';\nimport {StringParam} from '../String';\nimport {Vector2Param} from '../Vector2';\nimport {Vector3Param} from '../Vector3';\nimport {Vector4Param} from '../Vector4';\n\nimport {ParamType} from '../../poly/ParamType';\n\ntype ParamClassMapType = {[key in ParamType]: any};\nexport const ParamConstructorByType: ParamClassMapType = {\n\t[ParamType.BOOLEAN]: BooleanParam,\n\t[ParamType.BUTTON]: ButtonParam,\n\t[ParamType.COLOR]: ColorParam,\n\t[ParamType.FLOAT]: FloatParam,\n\t[ParamType.FOLDER]: FolderParam,\n\t[ParamType.INTEGER]: IntegerParam,\n\t[ParamType.OPERATOR_PATH]: OperatorPathParam,\n\t[ParamType.PARAM_PATH]: ParamPathParam,\n\t[ParamType.NODE_PATH]: NodePathParam,\n\t[ParamType.RAMP]: RampParam,\n\t[ParamType.SEPARATOR]: SeparatorParam,\n\t[ParamType.STRING]: StringParam,\n\t[ParamType.VECTOR2]: Vector2Param,\n\t[ParamType.VECTOR3]: Vector3Param,\n\t[ParamType.VECTOR4]: Vector4Param,\n};\n","import {BaseParamType} from '../../../params/_Base';\nimport {ParamType} from '../../../poly/ParamType';\nimport {StringParam} from '../../../params/String';\nimport {OperatorPathParam} from '../../../params/OperatorPath';\nimport {FloatParam} from '../../../params/Float';\nimport {IntegerParam} from '../../../params/Integer';\nimport {NodePathParam} from '../../../params/NodePath';\nimport {ParamPathParam} from '../../../params/ParamPath';\n\ntype LabelControllerCallback = () => string;\n\nexport class ParamsLabelController {\n\tprivate _callback: LabelControllerCallback | undefined;\n\tprivate _params: BaseParamType[] | undefined;\n\t// private _graph_node: CoreGraphNode | undefined;\n\tconstructor() {}\n\n\tdispose() {\n\t\tthis._callback = undefined;\n\t}\n\n\tparams() {\n\t\treturn this._params;\n\t}\n\tcallback() {\n\t\treturn this._callback;\n\t}\n\n\tinit(params: BaseParamType[], callback?: LabelControllerCallback) {\n\t\tthis._params = params;\n\t\tif (callback) {\n\t\t\tthis._callback = callback;\n\t\t} else {\n\t\t\tconst param = this._params[0];\n\t\t\tswitch (param.type()) {\n\t\t\t\tcase ParamType.STRING:\n\t\t\t\t\treturn this._handle_string_param(param as StringParam);\n\t\t\t\tcase ParamType.OPERATOR_PATH:\n\t\t\t\t\treturn this._handle_operator_path_param(param as OperatorPathParam);\n\t\t\t\tcase ParamType.NODE_PATH:\n\t\t\t\t\treturn this._handle_node_path_param(param as NodePathParam);\n\t\t\t\tcase ParamType.PARAM_PATH:\n\t\t\t\t\treturn this._handle_param_path_param(param as ParamPathParam);\n\t\t\t\tcase ParamType.FLOAT:\n\t\t\t\t\treturn this._handle_number_param(param as FloatParam);\n\t\t\t\tcase ParamType.INTEGER:\n\t\t\t\t\treturn this._handle_number_param(param as IntegerParam);\n\t\t\t}\n\t\t}\n\t\t// this.graph_node.addGraphInput(this._param, false);\n\t}\n\n\tprivate _handle_string_param(param: StringParam) {\n\t\tthis._callback = () => {\n\t\t\treturn param.value;\n\t\t};\n\t}\n\tprivate _handle_operator_path_param(param: OperatorPathParam) {\n\t\tthis._callback = () => {\n\t\t\treturn param.value;\n\t\t};\n\t}\n\tprivate _handle_node_path_param(param: NodePathParam) {\n\t\tthis._callback = () => {\n\t\t\treturn param.value.path();\n\t\t};\n\t}\n\tprivate _handle_param_path_param(param: ParamPathParam) {\n\t\tthis._callback = () => {\n\t\t\treturn param.value.path();\n\t\t};\n\t}\n\tprivate _handle_number_param(param: FloatParam | IntegerParam) {\n\t\tthis._callback = () => {\n\t\t\treturn `${param.value}`;\n\t\t};\n\t}\n\n\t// set_callback(params: BaseParamType[], callback: LabelControllerCallback) {\n\t// \t// for (let param of params) {\n\t// \t// \tthis.graph_node.addGraphInput(param, false);\n\t// \t// }\n\t// \tthis._params = params\n\t// \tthis._callback = callback;\n\t// }\n\n\t// private get graph_node() {\n\t// \treturn (this._graph_node = this._graph_node || this._create_graph_node());\n\t// }\n\t// private _create_graph_node() {\n\t// \tconst graph_node = new CoreGraphNode(this.params_controller.node.scene, 'ParamsLabelController');\n\t// \tgraph_node.addPostDirtyHook('update_param_label', () => {\n\t// \t\tconsole.log('dirty');\n\t// \t\tif (this._callback) {\n\t// \t\t\tconsole.log(this._callback());\n\t// \t\t}\n\t// \t});\n\t// \treturn graph_node;\n\t// }\n}\n","import {BaseNodeType} from '../../_Base';\nimport {BaseParamType} from '../../../params/_Base';\nimport {ParamOptions} from '../../../params/utils/OptionsController';\nimport {CoreGraphNode} from '../../../../core/graph/CoreGraphNode';\n\nimport {FloatParam} from '../../../params/Float';\nimport {OperatorPathParam} from '../../../params/OperatorPath';\n\nimport {ParamType} from '../../../poly/ParamType';\n// import {ParamEvent} from '../../../poly/ParamEvent';\nimport {NodeParamsConfig} from './ParamsConfig';\n\nimport {ParamConstructorMap} from '../../../params/types/ParamConstructorMap';\nimport {ParamConstructorByType} from '../../../params/types/ParamConstructorByType';\nimport {ParamInitValuesTypeMap} from '../../../params/types/ParamInitValuesTypeMap';\nimport {ParamValuesTypeMap} from '../../../params/types/ParamValuesTypeMap';\nimport {NodeEvent} from '../../../poly/NodeEvent';\nimport {ParamInitValueSerializedTypeMap} from '../../../params/types/ParamInitValueSerializedTypeMap';\nimport {ParamsLabelController} from './ParamsLabelController';\nimport {Poly} from '../../../Poly';\nimport {ParamInitData} from '../io/IOController';\nimport {PolyDictionary} from '../../../../types/GlobalTypes';\n\nconst NODE_SIMPLE_NAME = 'params';\n\nexport type OnSceneLoadHook = () => void;\ntype PostCreateParamsHook = () => void;\n\nexport interface ParamOptionToAdd<T extends ParamType> {\n\tname: string;\n\ttype: T;\n\tinit_value: ParamInitValueSerializedTypeMap[T];\n\traw_input: ParamInitValueSerializedTypeMap[T];\n\toptions?: ParamOptions;\n}\nexport interface ParamsUpdateOptions {\n\tnames_to_delete?: string[];\n\tto_add?: ParamOptionToAdd<ParamType>[];\n}\n\nexport class ParamsController {\n\tprivate _param_create_mode: boolean = false;\n\tprivate _params_created: boolean = false;\n\tprivate _params_by_name: PolyDictionary<BaseParamType> = {};\n\t// caches\n\tprivate _params_list: BaseParamType[] = [];\n\tprivate _param_names: string[] = [];\n\tprivate _non_spare_params: BaseParamType[] = [];\n\tprivate _spare_params: BaseParamType[] = [];\n\tprivate _non_spare_param_names: string[] = [];\n\tprivate _spare_param_names: string[] = [];\n\n\tprivate _params_node: CoreGraphNode | undefined;\n\t// private _params_eval_key: string;\n\tprivate _params_added_since_last_params_eval: boolean = false;\n\t// private _current_param_folder_name: string | undefined;\n\n\t// hooks\n\tprivate _post_create_params_hook_names: string[] | undefined;\n\tprivate _post_create_params_hooks: PostCreateParamsHook[] | undefined;\n\tprivate _on_scene_load_hooks: OnSceneLoadHook[] | undefined;\n\tprivate _on_scene_load_hook_names: string[] | undefined;\n\n\t// labels\n\tprivate _label_controller: ParamsLabelController | undefined;\n\tget label(): ParamsLabelController {\n\t\treturn (this._label_controller = this._label_controller || new ParamsLabelController());\n\t}\n\thasLabelController(): boolean {\n\t\treturn this._label_controller != null;\n\t}\n\n\tconstructor(public readonly node: BaseNodeType) {}\n\n\tdispose() {\n\t\tif (this._params_node) {\n\t\t\tthis._params_node.dispose();\n\t\t}\n\n\t\t// dispose params\n\t\tfor (let param of this.all) {\n\t\t\tparam.dispose();\n\t\t}\n\n\t\t// hooks\n\t\tthis._post_create_params_hook_names = undefined;\n\t\tthis._post_create_params_hooks = undefined;\n\t\tthis._on_scene_load_hooks = undefined;\n\t\tthis._on_scene_load_hook_names = undefined;\n\n\t\t//\n\t\tthis._label_controller?.dispose();\n\t}\n\n\tprivate init_dependency_node() {\n\t\tif (!this._params_node) {\n\t\t\t// TODO: consider not having a params_node for nodes which have no parameters\n\t\t\tthis._params_node = new CoreGraphNode(this.node.scene(), NODE_SIMPLE_NAME);\n\t\t\t// this._params_node.set_scene(this.node.scene);\n\t\t\tthis.node.addGraphInput(this._params_node, false);\n\t\t}\n\t}\n\n\tinit() {\n\t\tthis.init_dependency_node();\n\t\t// this.reset_params()\n\t\tthis._param_create_mode = true;\n\n\t\tthis.init_from_params_config();\n\t\tthis.node.create_params();\n\t\tthis._post_create_params();\n\t}\n\tprivate _post_create_params() {\n\t\tthis._update_caches();\n\t\t// this._create_params_ui_data_dependencies();\n\t\tthis.init_param_accessors();\n\t\tthis._param_create_mode = false;\n\t\tthis._params_created = true;\n\n\t\tthis.run_post_create_params_hooks();\n\n\t\t// This was to debug a weird bug where I was adding nodes to the list\n\t\t// of params, from the DependenciesController\n\t\t// this._params_list.push = (...items: BaseParamType[]) => {\n\t\t// \tif (items[0] && !items[0].compute) {\n\t\t// \t\tPoly.warn('adding params', items);\n\t\t// \t}\n\t\t// \tfor (let i of items) {\n\t\t// \t\tthis._params_list[this._params_list.length] = i;\n\t\t// \t}\n\t\t// \treturn 0;\n\t\t// };\n\t}\n\tpost_create_spare_params() {\n\t\tthis._update_caches();\n\t\tthis.init_param_accessors();\n\t}\n\tupdate_params(options: ParamsUpdateOptions) {\n\t\tlet has_created_a_param = false;\n\t\tlet has_deleted_a_param = false;\n\t\tif (options.names_to_delete) {\n\t\t\tfor (let param_name of options.names_to_delete) {\n\t\t\t\tif (this.has(param_name)) {\n\t\t\t\t\tthis.delete_param(param_name);\n\t\t\t\t\thas_deleted_a_param = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (options.to_add) {\n\t\t\tfor (let param_data of options.to_add) {\n\t\t\t\tconst param = this.addParam(\n\t\t\t\t\tparam_data.type,\n\t\t\t\t\tparam_data.name,\n\t\t\t\t\tparam_data.init_value,\n\t\t\t\t\tparam_data.options\n\t\t\t\t);\n\t\t\t\tif (param) {\n\t\t\t\t\tif (param_data.raw_input != null) {\n\t\t\t\t\t\tparam.set(param_data.raw_input as never);\n\t\t\t\t\t}\n\t\t\t\t\thas_created_a_param = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (has_deleted_a_param || has_created_a_param) {\n\t\t\tthis.post_create_spare_params();\n\t\t\t// param.emit(ParamEvent.DELETED);\n\t\t\tthis.node.scene().referencesController.notify_params_updated(this.node);\n\t\t\tthis.node.emit(NodeEvent.PARAMS_UPDATED);\n\t\t}\n\t}\n\n\tprivate init_from_params_config() {\n\t\tconst params_config = this.node.params_config as NodeParamsConfig;\n\t\tlet init_values_used = false;\n\t\tif (params_config) {\n\t\t\tfor (let name of Object.keys(params_config)) {\n\t\t\t\tconst config = params_config[name];\n\t\t\t\tlet init_value: ParamInitData<ParamType> | undefined;\n\t\t\t\tif (this.node.params_init_value_overrides) {\n\t\t\t\t\tinit_value = this.node.params_init_value_overrides[name];\n\t\t\t\t\tinit_values_used = true;\n\t\t\t\t}\n\t\t\t\tthis.addParam(config.type, name, config.init_value, config.options, init_value);\n\t\t\t}\n\t\t}\n\t\t// this set dirty may not be necessary, but when starting a scene with a spotlight\n\t\t// with a non default t (ie: [2,2,0]), it would not be positionned correctly and would require\n\t\t// a cook\n\t\tif (init_values_used) {\n\t\t\tthis.node.setDirty();\n\t\t}\n\t\tthis.node.params_init_value_overrides = undefined;\n\t}\n\tprivate init_param_accessors() {\n\t\tlet current_names_in_accessor = Object.getOwnPropertyNames(this.node.pv);\n\t\tthis._remove_unneeded_accessors(current_names_in_accessor);\n\t\t// update var after having removed accessors\n\t\tcurrent_names_in_accessor = Object.getOwnPropertyNames(this.node.pv);\n\n\t\tfor (let param of this.all) {\n\t\t\tconst is_spare: boolean = param.options.is_spare();\n\n\t\t\tconst param_not_yet_in_accessors = !current_names_in_accessor.includes(param.name());\n\n\t\t\tif (param_not_yet_in_accessors || is_spare) {\n\t\t\t\tObject.defineProperty(this.node.pv, param.name(), {\n\t\t\t\t\tget: () => {\n\t\t\t\t\t\treturn param.value;\n\t\t\t\t\t},\n\t\t\t\t\t// only spare parameters can be removed\n\t\t\t\t\tconfigurable: is_spare,\n\t\t\t\t});\n\t\t\t\tObject.defineProperty(this.node.p, param.name(), {\n\t\t\t\t\tget: () => {\n\t\t\t\t\t\treturn param;\n\t\t\t\t\t},\n\t\t\t\t\tconfigurable: is_spare,\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n\tprivate _remove_unneeded_accessors(current_names_in_accessor: string[]) {\n\t\tconst current_param_names = this._param_names;\n\t\tconst names_to_remove = [];\n\t\tfor (let current_name_in_accessor of current_names_in_accessor) {\n\t\t\tif (!current_param_names.includes(current_name_in_accessor)) {\n\t\t\t\tnames_to_remove.push(current_name_in_accessor);\n\t\t\t}\n\t\t}\n\n\t\tfor (let name_to_remove of names_to_remove) {\n\t\t\tObject.defineProperty(this.node.pv, name_to_remove, {\n\t\t\t\tget: () => {\n\t\t\t\t\treturn undefined;\n\t\t\t\t},\n\t\t\t\tconfigurable: true,\n\t\t\t});\n\t\t\tObject.defineProperty(this.node.p, name_to_remove, {\n\t\t\t\tget: () => {\n\t\t\t\t\treturn undefined;\n\t\t\t\t},\n\t\t\t\tconfigurable: true,\n\t\t\t});\n\t\t}\n\t}\n\n\tget params_node() {\n\t\treturn this._params_node;\n\t}\n\tget all() {\n\t\treturn this._params_list;\n\t}\n\tget non_spare() {\n\t\treturn this._non_spare_params;\n\t}\n\tget spare() {\n\t\treturn this._spare_params;\n\t}\n\tget names(): string[] {\n\t\treturn this._param_names;\n\t}\n\tget non_spare_names(): string[] {\n\t\treturn this._non_spare_param_names;\n\t}\n\tget spare_names(): string[] {\n\t\treturn this._spare_param_names;\n\t}\n\n\tprivate set_with_type<T extends ParamType>(param_name: string, value: ParamInitValuesTypeMap[T], type: T) {\n\t\tconst param = this.param_with_type(param_name, type);\n\t\tif (param) {\n\t\t\tparam.set(value as never);\n\t\t} else {\n\t\t\tPoly.warn(`param ${param_name} not found with type ${type}`);\n\t\t}\n\t}\n\tset_float(param_name: string, value: ParamInitValuesTypeMap[ParamType.FLOAT]) {\n\t\tthis.set_with_type(param_name, value, ParamType.FLOAT);\n\t}\n\tset_vector3(param_name: string, value: ParamInitValuesTypeMap[ParamType.VECTOR3]) {\n\t\tthis.set_with_type(param_name, value, ParamType.VECTOR3);\n\t}\n\n\thas_param(param_name: string) {\n\t\treturn this._params_by_name[param_name] != null;\n\t}\n\thas(param_name: string) {\n\t\treturn this.has_param(param_name);\n\t}\n\tget(param_name: string) {\n\t\treturn this.param(param_name);\n\t}\n\tparam_with_type<T extends ParamType>(param_name: string, type: T): ParamConstructorMap[T] | undefined {\n\t\tconst param = this.param(param_name);\n\t\tif (param && param.type() == type) {\n\t\t\treturn param as ParamConstructorMap[T];\n\t\t}\n\t}\n\tget_float(param_name: string): FloatParam {\n\t\treturn this.param_with_type(param_name, ParamType.FLOAT) as FloatParam;\n\t}\n\tget_operator_path(param_name: string): OperatorPathParam {\n\t\treturn this.param_with_type(param_name, ParamType.OPERATOR_PATH) as OperatorPathParam;\n\t}\n\tvalue(param_name: string) {\n\t\treturn this.param(param_name)?.value;\n\t}\n\tvalue_with_type<T extends ParamType>(param_name: string, type: T): ParamValuesTypeMap[T] {\n\t\treturn this.param_with_type(param_name, type)?.value as ParamValuesTypeMap[T];\n\t\t// const param = this.param(name);\n\t\t// if (param && param.type() == type) {\n\t\t// \treturn param.value();\n\t\t// }\n\t}\n\tboolean(param_name: string) {\n\t\treturn this.value_with_type(param_name, ParamType.BOOLEAN);\n\t}\n\tfloat(param_name: string) {\n\t\treturn this.value_with_type(param_name, ParamType.FLOAT);\n\t}\n\tinteger(param_name: string) {\n\t\treturn this.value_with_type(param_name, ParamType.INTEGER);\n\t}\n\tstring(param_name: string) {\n\t\treturn this.value_with_type(param_name, ParamType.STRING);\n\t}\n\tvector2(param_name: string) {\n\t\treturn this.value_with_type(param_name, ParamType.VECTOR2);\n\t}\n\tvector3(param_name: string) {\n\t\treturn this.value_with_type(param_name, ParamType.VECTOR3);\n\t}\n\tcolor(param_name: string) {\n\t\treturn this.value_with_type(param_name, ParamType.COLOR);\n\t}\n\n\tparam(param_name: string) {\n\t\tconst p = this._params_by_name[param_name];\n\t\tif (p != null) {\n\t\t\treturn p;\n\t\t} else {\n\t\t\tPoly.warn(\n\t\t\t\t`tried to access param '${param_name}' in node ${this.node.fullPath()}, but existing params are: ${\n\t\t\t\t\tthis.names\n\t\t\t\t} on node ${this.node.fullPath()}`\n\t\t\t);\n\t\t\treturn null;\n\t\t}\n\t}\n\t// param_cache_name(param_name: string) {\n\t// \treturn `_param_${param_name}`;\n\t// }\n\n\t// delete_params(param_names: string[]) {\n\t// \tfor (let param_name of param_names) {\n\t// \t\tthis.delete_param(param_name);\n\t// \t}\n\n\t// }\n\t// call update_params instead\n\tprivate delete_param(param_name: string) {\n\t\tconst param = this._params_by_name[param_name];\n\t\tif (param) {\n\t\t\tif (this._params_node) {\n\t\t\t\tthis._params_node.removeGraphInput(this._params_by_name[param_name]);\n\t\t\t}\n\t\t\tparam._setup_node_dependencies(null);\n\t\t\tdelete this._params_by_name[param_name];\n\t\t\tif (param.isMultiple() && param.components) {\n\t\t\t\tfor (let component of param.components) {\n\t\t\t\t\tconst child_name = component.name();\n\t\t\t\t\tdelete this._params_by_name[child_name];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// const name_index = this._param_names.indexOf(param_name)\n\t\t\t// if(name_index >= 0){\n\t\t\t// \tthis._param_names.splice(name_index, 1)\n\t\t\t// }\n\t\t\t// param.emit(ParamEvent.DELETED);\n\t\t} else {\n\t\t\tthrow new Error(`param '${param_name}' does not exist on node ${this.node.fullPath()}`);\n\t\t}\n\t}\n\n\taddParam<T extends ParamType>(\n\t\ttype: T,\n\t\tparam_name: string,\n\t\tdefault_value: ParamInitValuesTypeMap[T],\n\t\toptions: ParamOptions = {},\n\t\tinit_data?: ParamInitData<T>\n\t): ParamConstructorMap[T] | undefined {\n\t\tconst is_spare = options['spare'] || false;\n\t\tif (this._param_create_mode === false && !is_spare) {\n\t\t\tPoly.warn(\n\t\t\t\t`node ${this.node.fullPath()} (${this.node.type()}) param '${param_name}' cannot be created outside of create_params`\n\t\t\t);\n\t\t}\n\t\tif (this.node.scene() == null) {\n\t\t\tPoly.warn(`node ${this.node.fullPath()} (${this.node.type()}) has no scene assigned`);\n\t\t}\n\n\t\tconst constructor = ParamConstructorByType[type];\n\t\tif (constructor != null) {\n\t\t\tconst existing_param = this._params_by_name[param_name];\n\t\t\tif (existing_param) {\n\t\t\t\tif (is_spare) {\n\t\t\t\t\t// delete the old one, otherwise the gl nodes when saved will attempt to set the value\n\t\t\t\t\t// of a param with the potentially wrong type\n\t\t\t\t\tif (existing_param.type() != type) {\n\t\t\t\t\t\tthis.delete_param(existing_param.name());\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// check that the param is spare, so that the ones generated by gl nodes are not generating an exception\n\t\t\t\t\tPoly.warn(`a param named ${param_name} already exists`, this.node);\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst param: ParamConstructorMap[T] = new constructor(this.node.scene(), this.node);\n\t\t\tparam.options.set(options);\n\n\t\t\tparam.setName(param_name);\n\t\t\tparam.setInitValue(default_value as never);\n\t\t\tparam.initComponents();\n\n\t\t\t// set param value\n\t\t\t// and overriden options\n\t\t\tif (init_data == null) {\n\t\t\t\tparam.set(default_value as never);\n\t\t\t} else {\n\t\t\t\t// If is_expression_for_entities is true, we need to call param.set with default_value first, such as for attrib_create.\n\t\t\t\t// Otherwise, as it would fail if the attribute was a vector\n\t\t\t\t// since that attribute would have .value equal to {x: undefined, y: undefined, z:undefined}\n\t\t\t\tif (param.options.is_expression_for_entities()) {\n\t\t\t\t\tparam.set(default_value as never);\n\t\t\t\t}\n\t\t\t\tif (init_data.raw_input != null) {\n\t\t\t\t\tparam.set(init_data.raw_input as never);\n\t\t\t\t} else {\n\t\t\t\t\tif (init_data.simple_data != null) {\n\t\t\t\t\t\tparam.set(init_data.simple_data as never);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (init_data.complex_data != null) {\n\t\t\t\t\t\t\tconst raw_input = init_data.complex_data.raw_input;\n\t\t\t\t\t\t\tif (raw_input) {\n\t\t\t\t\t\t\t\tparam.set(raw_input as never);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tparam.set(default_value as never);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tconst overriden_options = init_data.complex_data.overriden_options;\n\t\t\t\t\t\t\tif (overriden_options != null) {\n\t\t\t\t\t\t\t\tconst keys = Object.keys(overriden_options);\n\t\t\t\t\t\t\t\tfor (let key of keys) {\n\t\t\t\t\t\t\t\t\tparam.options.set_option(key as keyof ParamOptions, overriden_options[key]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tparam._setup_node_dependencies(this.node);\n\n\t\t\tthis._params_by_name[param.name()] = param as BaseParamType;\n\n\t\t\t// we add the components, so that we can access them with expressions like ch('ty')\n\t\t\tif (param.isMultiple() && param.components) {\n\t\t\t\tfor (let component of param.components) {\n\t\t\t\t\tthis._params_by_name[component.name()] = component as BaseParamType;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis._params_added_since_last_params_eval = true;\n\n\t\t\treturn param;\n\t\t}\n\t}\n\n\tprivate _update_caches() {\n\t\tthis._params_list = Object.values(this._params_by_name);\n\t\tthis._param_names = Object.keys(this._params_by_name);\n\t\tthis._non_spare_params = Object.values(this._params_by_name).filter((p) => !p.options.is_spare());\n\t\tthis._spare_params = Object.values(this._params_by_name).filter((p) => p.options.is_spare());\n\t\tthis._non_spare_param_names = Object.values(this._params_by_name)\n\t\t\t.filter((p) => !p.options.is_spare())\n\t\t\t.map((p) => p.name());\n\t\tthis._spare_param_names = Object.values(this._params_by_name)\n\t\t\t.filter((p) => p.options.is_spare())\n\t\t\t.map((p) => p.name());\n\t}\n\n\tasync _eval_param(param: BaseParamType) {\n\t\t// return new Promise((resolve, reject)=> {\n\t\t// const param_cache_name = this.param_cache_name(param.name());\n\t\t// const cached_value = this[param_cache_name] || null;\n\t\tif (/*cached_value == null ||*/ param.isDirty() /* || param.is_errored()*/) {\n\t\t\t/*const param_value =*/ await param.compute(); //.then(param_value=>{\n\t\t\t// this[param_cache_name] = param_value;\n\t\t\tif (param.states.error.active()) {\n\t\t\t\tthis.node.states.error.set(`param '${param.name()}' error: ${param.states.error.message()}`);\n\t\t\t}\n\t\t\t// return param_value;\n\t\t} else {\n\t\t\t// return param.value;\n\t\t}\n\t\t// });\n\t}\n\n\tasync eval_params(params: BaseParamType[]) {\n\t\tconst promises = [];\n\t\tfor (let param of params) {\n\t\t\tif (param.isDirty()) {\n\t\t\t\tpromises.push(this._eval_param(param));\n\t\t\t}\n\t\t}\n\t\tawait Promise.all(promises);\n\n\t\tif (this.node.states.error.active()) {\n\t\t\tthis.node.setContainer(null);\n\t\t}\n\t}\n\n\tparams_eval_required() {\n\t\treturn this._params_node && (this._params_node.isDirty() || this._params_added_since_last_params_eval);\n\t}\n\tasync eval_all() {\n\t\tif (this.params_eval_required()) {\n\t\t\tawait this.eval_params(this._params_list);\n\n\t\t\tthis._params_node?.removeDirtyState();\n\t\t\tthis._params_added_since_last_params_eval = false;\n\t\t}\n\t}\n\n\t//\n\t//\n\t// HOOKS\n\t//\n\t//\n\tonParamsCreated(hook_name: string, hook: PostCreateParamsHook) {\n\t\tif (this._params_created) {\n\t\t\thook();\n\t\t} else {\n\t\t\tif (this._post_create_params_hook_names && this._post_create_params_hook_names.includes(hook_name)) {\n\t\t\t\tPoly.error(`hook name ${hook_name} already exists`);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthis._post_create_params_hook_names = this._post_create_params_hook_names || [];\n\t\t\tthis._post_create_params_hook_names.push(hook_name);\n\t\t\tthis._post_create_params_hooks = this._post_create_params_hooks || [];\n\t\t\tthis._post_create_params_hooks.push(hook);\n\t\t}\n\t}\n\taddOnSceneLoadHook(param_name: string, method: OnSceneLoadHook) {\n\t\tthis._on_scene_load_hook_names = this._on_scene_load_hook_names || [];\n\t\tthis._on_scene_load_hooks = this._on_scene_load_hooks || [];\n\n\t\tif (!this._on_scene_load_hook_names.includes(param_name)) {\n\t\t\tthis._on_scene_load_hook_names.push(param_name);\n\t\t\tthis._on_scene_load_hooks.push(method);\n\t\t} else {\n\t\t\tPoly.warn(`hook with name ${param_name} already exists`, this.node);\n\t\t}\n\t}\n\tprivate run_post_create_params_hooks() {\n\t\tif (this._post_create_params_hooks) {\n\t\t\tfor (let hook of this._post_create_params_hooks) {\n\t\t\t\thook();\n\t\t\t}\n\t\t}\n\t}\n\trunOnSceneLoadHooks() {\n\t\tif (this._on_scene_load_hooks) {\n\t\t\tfor (let hook of this._on_scene_load_hooks) {\n\t\t\t\thook();\n\t\t\t}\n\t\t}\n\t}\n}\n","import {NodeParamsConfig} from './ParamsConfig';\n// import {ParamValuesTypeMap} from './ParamsController';\n// import {ParamType} from '../../../poly/ParamType';\n\n// function getProperty<T, K extends keyof T>(o: T, propertyName: K): T[K] {\n// \treturn o[propertyName]; // o[propertyName] is of type T[K]\n// }\n\n// let t: getProperty(ParamConfig, 'type')\n// function prop<T, K extends keyof T>(obj: T, key: K) {\n// \treturn typeof obj[key];\n// }\n// type test = Pick<ParamConfig<ParamType.FLOAT>, 'default_value'>;\n\nexport type ParamsValueAccessorType<T extends NodeParamsConfig> = {\n\treadonly [P in keyof T]: T[P]['value_type'];\n};\n\nexport class ParamsValueAccessor<T extends NodeParamsConfig> {\n\tconstructor() {\n\t\t// console.log('accessor', this);\n\t}\n}\n","import {NodeContext} from '../../../poly/NodeContext';\nimport {TypedNode} from '../../_Base';\nimport {NodeTypeMap} from '../../../containers/utils/ContainerMap';\nimport {ConnectionPointTypeMap} from './connections/ConnectionMap';\ninterface DisconnectionOptions {\n\tsetInput?: boolean;\n}\n\nexport class TypedNodeConnection<NC extends NodeContext> {\n\tprivate static _next_id: number = 0;\n\tprivate _id: number;\n\n\tconstructor(\n\t\tprivate _node_src: TypedNode<NC, any>,\n\t\tprivate _node_dest: TypedNode<NC, any>,\n\t\tprivate _output_index: number = 0,\n\t\tprivate _input_index: number = 0\n\t) {\n\t\tif (this._output_index == null) {\n\t\t\tthrow 'bad output index';\n\t\t}\n\t\tif (this._input_index == null) {\n\t\t\tthrow 'bad input index';\n\t\t}\n\n\t\tthis._id = TypedNodeConnection._next_id++;\n\n\t\tif (this._node_src.io.connections && this._node_dest.io.connections) {\n\t\t\tthis._node_src.io.connections.addOutputConnection(this);\n\t\t\tthis._node_dest.io.connections.addInputConnection(this);\n\t\t}\n\t}\n\tget id() {\n\t\treturn this._id;\n\t}\n\n\tget node_src(): NodeTypeMap[NC] {\n\t\treturn (<unknown>this._node_src) as NodeTypeMap[NC];\n\t}\n\tget node_dest(): NodeTypeMap[NC] {\n\t\treturn (<unknown>this._node_dest) as NodeTypeMap[NC];\n\t}\n\tget output_index() {\n\t\treturn this._output_index;\n\t}\n\tget input_index() {\n\t\treturn this._input_index;\n\t}\n\tsrc_connection_point(): ConnectionPointTypeMap[NC] {\n\t\tconst node_src = this._node_src;\n\t\tconst output_index = this._output_index;\n\t\treturn node_src.io.outputs.named_output_connection_points[output_index];\n\t}\n\tdest_connection_point(): ConnectionPointTypeMap[NC] {\n\t\tconst node_dest = this._node_dest;\n\t\tconst input_index = this._input_index;\n\t\treturn node_dest.io.inputs.named_input_connection_points[input_index];\n\t}\n\n\tdisconnect(options: DisconnectionOptions = {}) {\n\t\tif (this._node_src.io.connections && this._node_dest.io.connections) {\n\t\t\tthis._node_src.io.connections.removeOutputConnection(this);\n\t\t\tthis._node_dest.io.connections.removeInputConnection(this);\n\t\t}\n\n\t\tif (options.setInput === true) {\n\t\t\tthis._node_dest.io.inputs.setInput(this._input_index, null);\n\t\t}\n\t}\n}\n","import {NodeContext} from '../../../../poly/NodeContext';\nimport {InputCloneMode} from '../../../../poly/InputCloneMode';\nimport {InputsController} from '../InputsController';\nimport {TypeAssert} from '../../../../poly/Assert';\nimport {NodeEvent} from '../../../../poly/NodeEvent';\nimport {TypedNode} from '../../../_Base';\nimport {CoreType} from '../../../../../core/Type';\n\nexport class ClonedStatesController<NC extends NodeContext> {\n\t// private _user_inputs_clonable_states: InputCloneMode[] | undefined;\n\tprivate _cloned_states: InputCloneMode[] | undefined;\n\tprivate _cloned_state: InputCloneMode | undefined;\n\tprivate _clone_required_states: boolean[] = [];\n\tprivate _overridden: boolean = false;\n\n\tprivate node: TypedNode<NC, any>;\n\tconstructor(private inputs_controller: InputsController<NC>) {\n\t\tthis.node = inputs_controller.node;\n\t}\n\tinitInputsClonedState(states: InputCloneMode | InputCloneMode[]) {\n\t\t// if (values) {\n\t\t// \tthis._user_inputs_clonable_states = values;\n\t\t// }\n\t\tif (CoreType.isArray(states)) {\n\t\t\tthis._cloned_states = states; //this._user_inputs_clonable_states || this._default_inputs_clonale_state_values();\n\t\t} else {\n\t\t\tthis._cloned_state = states;\n\t\t}\n\n\t\tthis._update_clone_required_state();\n\t}\n\n\toverrideClonedStateAllowed() {\n\t\tif (this._cloned_states) {\n\t\t\tfor (let state of this._cloned_states) {\n\t\t\t\tif (state == InputCloneMode.FROM_NODE) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (this._cloned_state) {\n\t\t\treturn this._cloned_state == InputCloneMode.FROM_NODE;\n\t\t}\n\t\treturn false;\n\t}\n\n\t// private get inputs_clonable_state(): InputCloneMode[] {\n\t// \treturn (this._inputs_clonable_states = this._inputs_clonable_states || this.init_inputs_clonable_state());\n\t// }\n\tcloneRequiredState(index: number): boolean {\n\t\treturn this._clone_required_states[index];\n\t}\n\tcloneRequiredStates(): boolean | boolean[] {\n\t\treturn this._clone_required_states;\n\t}\n\t// inputs_clonable_state_with_override(): boolean[] {\n\t// \t// const list = [];\n\t// \t// const states = this.inputs_clonable_state();\n\t// \t// for (let i = 0; i < states.length; i++) {\n\t// \t// \tlist.push(this.input_clonable_state_with_override(i));\n\t// \t// }\n\t// \t// return list;\n\t// \treturn this._inputs_cloned_state;\n\t// }\n\tprivate _get_clone_required_state(index: number): boolean {\n\t\tconst states = this._cloned_states;\n\t\tif (states) {\n\t\t\tconst state = states[index];\n\t\t\tif (state != null) {\n\t\t\t\treturn this.clone_required_from_state(state);\n\t\t\t}\n\t\t}\n\t\tif (this._cloned_state) {\n\t\t\treturn this.clone_required_from_state(this._cloned_state);\n\t\t}\n\t\treturn true;\n\t}\n\tprivate clone_required_from_state(state: InputCloneMode) {\n\t\tswitch (state) {\n\t\t\tcase InputCloneMode.ALWAYS:\n\t\t\t\treturn true;\n\t\t\tcase InputCloneMode.NEVER:\n\t\t\t\treturn false;\n\t\t\tcase InputCloneMode.FROM_NODE:\n\t\t\t\treturn !this._overridden;\n\t\t}\n\t\treturn TypeAssert.unreachable(state);\n\t}\n\n\t// private _default_inputs_clonale_state_values() {\n\t// \tconst list = [];\n\t// \tfor (let i = 0; i < this.inputs_controller.max_inputs_count; i++) {\n\t// \t\tlist.push(InputCloneMode.ALWAYS);\n\t// \t}\n\t// \treturn list;\n\t// }\n\n\toverrideClonedState(state: boolean) {\n\t\tthis._overridden = state;\n\t\tthis._update_clone_required_state();\n\t\tthis.node.emit(NodeEvent.OVERRIDE_CLONABLE_STATE_UPDATE);\n\t\tthis.node.setDirty();\n\t}\n\toverriden() {\n\t\treturn this._overridden;\n\t}\n\tprivate _update_clone_required_state() {\n\t\tif (this._cloned_states) {\n\t\t\tconst states: boolean[] = [];\n\t\t\tfor (let i = 0; i < this._cloned_states.length; i++) {\n\t\t\t\tstates[i] = this._get_clone_required_state(i);\n\t\t\t}\n\t\t\tthis._clone_required_states = states;\n\t\t\treturn;\n\t\t}\n\t\tif (this._cloned_state) {\n\t\t\tconst max_inputs = this.inputs_controller.maxInputsCount();\n\t\t\tconst states: boolean[] = [];\n\t\t\tfor (let i = 0; i < max_inputs; i++) {\n\t\t\t\tstates[i] = this._get_clone_required_state(i);\n\t\t\t}\n\t\t\tthis._clone_required_states = states;\n\t\t\treturn;\n\t\t}\n\t}\n}\n","import {TypedNodeConnection} from './NodeConnection';\nimport {CoreGraphNode} from '../../../../core/graph/CoreGraphNode';\nimport {NodeEvent} from '../../../poly/NodeEvent';\nimport {NodeContext} from '../../../poly/NodeContext';\nimport {ConnectionPointTypeMap} from './connections/ConnectionMap';\nimport {TypedNode} from '../../_Base';\nimport {ContainerMap, NodeTypeMap} from '../../../containers/utils/ContainerMap';\nimport {ClonedStatesController} from './utils/ClonedStatesController';\nimport {InputCloneMode} from '../../../poly/InputCloneMode';\nimport {BaseConnectionPoint} from './connections/_Base';\nimport {CoreType} from '../../../../core/Type';\n\ntype OnUpdateHook = () => void;\n\nconst MAX_INPUTS_COUNT_UNSET = 0;\nexport class InputsController<NC extends NodeContext> {\n\tprivate _graph_node: CoreGraphNode | undefined;\n\tprivate _graph_node_inputs: CoreGraphNode[] = [];\n\tprivate _inputs: Array<NodeTypeMap[NC] | null> = [];\n\tprivate _has_named_inputs: boolean = false;\n\tprivate _named_input_connection_points: ConnectionPointTypeMap[NC][] | undefined;\n\tprivate _min_inputs_count: number = 0;\n\tprivate _max_inputs_count: number = MAX_INPUTS_COUNT_UNSET;\n\tprivate _maxInputsCountOnInput: number = MAX_INPUTS_COUNT_UNSET;\n\tprivate _depends_on_inputs: boolean = true;\n\n\t// hooks\n\tprivate _on_update_hooks: OnUpdateHook[] | undefined;\n\tprivate _on_update_hook_names: string[] | undefined;\n\n\t// clonable\n\n\tdispose() {\n\t\tif (this._graph_node) {\n\t\t\tthis._graph_node.dispose();\n\t\t}\n\t\tfor (let graph_node of this._graph_node_inputs) {\n\t\t\tif (graph_node) {\n\t\t\t\tgraph_node.dispose();\n\t\t\t}\n\t\t}\n\t\t// hooks\n\t\tthis._on_update_hooks = undefined;\n\t\tthis._on_update_hook_names = undefined;\n\t}\n\n\t// private _user_inputs_clonable_states: InputCloneMode[] | undefined;\n\t// private _inputs_clonable_states: InputCloneMode[] | undefined;\n\t// private _inputs_cloned_state: boolean[] = [];\n\t// private _override_clonable_state: boolean = false;\n\n\tconstructor(public node: TypedNode<NC, any>) {}\n\n\tset_depends_on_inputs(depends_on_inputs: boolean) {\n\t\tthis._depends_on_inputs = depends_on_inputs;\n\t}\n\tprivate set_min_inputs_count(min_inputs_count: number) {\n\t\tthis._min_inputs_count = min_inputs_count;\n\t}\n\n\tprivate set_max_inputs_count(max_inputs_count: number) {\n\t\tif (this._max_inputs_count == MAX_INPUTS_COUNT_UNSET) {\n\t\t\tthis._maxInputsCountOnInput = max_inputs_count;\n\t\t}\n\t\tthis._max_inputs_count = max_inputs_count;\n\t\tthis.init_graph_node_inputs();\n\t}\n\n\tnamed_input_connection_points_by_name(name: string): ConnectionPointTypeMap[NC] | undefined {\n\t\tif (this._named_input_connection_points) {\n\t\t\tfor (let connection_point of this._named_input_connection_points) {\n\t\t\t\tif (connection_point && connection_point.name() == name) {\n\t\t\t\t\treturn connection_point;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tsetNamedInputConnectionPoints(connection_points: ConnectionPointTypeMap[NC][]) {\n\t\tthis._has_named_inputs = true;\n\n\t\tconst connections = this.node.io.connections.inputConnections();\n\t\tif (connections) {\n\t\t\tfor (let connection of connections) {\n\t\t\t\tif (connection) {\n\t\t\t\t\t// assume we only work with indices for now, not with connection point names\n\t\t\t\t\t// so we only need to check again the new max number of connection points.\n\t\t\t\t\tif (connection.input_index >= connection_points.length) {\n\t\t\t\t\t\tconnection.disconnect({setInput: true});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// update connections\n\t\tthis._named_input_connection_points = connection_points;\n\t\tthis.set_min_inputs_count(0);\n\t\tthis.set_max_inputs_count(connection_points.length);\n\t\tthis.init_graph_node_inputs();\n\t\tthis.node.emit(NodeEvent.NAMED_INPUTS_UPDATED);\n\t}\n\t// private _has_connected_inputs() {\n\t// \tfor (let input of this._inputs) {\n\t// \t\tif (input != null) {\n\t// \t\t\treturn true;\n\t// \t\t}\n\t// \t}\n\t// \treturn false;\n\t// }\n\n\t// private _check_name_changed(connection_points: ConnectionPointTypeMap[NC][]) {\n\t// \tif (this._named_input_connection_points) {\n\t// \t\tif (this._named_input_connection_points.length != connection_points.length) {\n\t// \t\t\treturn true;\n\t// \t\t} else {\n\t// \t\t\tfor (let i = 0; i < this._named_input_connection_points.length; i++) {\n\t// \t\t\t\tif (this._named_input_connection_points[i]?.name != connection_points[i]?.name) {\n\t// \t\t\t\t\treturn true;\n\t// \t\t\t\t}\n\t// \t\t\t}\n\t// \t\t}\n\t// \t}\n\t// \treturn false;\n\t// }\n\n\tget has_named_inputs() {\n\t\treturn this._has_named_inputs;\n\t}\n\tget named_input_connection_points(): ConnectionPointTypeMap[NC][] {\n\t\treturn this._named_input_connection_points || [];\n\t}\n\tprivate init_graph_node_inputs() {\n\t\tfor (let i = 0; i < this._max_inputs_count; i++) {\n\t\t\tthis._graph_node_inputs[i] = this._graph_node_inputs[i] || this._create_graph_node_input(i);\n\t\t}\n\t}\n\tprivate _create_graph_node_input(index: number): CoreGraphNode {\n\t\tconst graph_input_node = new CoreGraphNode(this.node.scene(), `input_${index}`);\n\t\t// graph_input_node.set_scene(this.node.scene);\n\t\tif (!this._graph_node) {\n\t\t\tthis._graph_node = new CoreGraphNode(this.node.scene(), 'inputs');\n\t\t\tthis.node.addGraphInput(this._graph_node, false);\n\t\t}\n\n\t\tthis._graph_node.addGraphInput(graph_input_node, false);\n\t\treturn graph_input_node;\n\t}\n\n\tmaxInputsCount(): number {\n\t\treturn this._max_inputs_count || 0;\n\t}\n\tmaxInputsCountOverriden(): boolean {\n\t\treturn this._max_inputs_count != this._maxInputsCountOnInput;\n\t}\n\tinput_graph_node(input_index: number): CoreGraphNode {\n\t\treturn this._graph_node_inputs[input_index];\n\t}\n\n\tsetCount(min: number, max?: number) {\n\t\tif (max == null) {\n\t\t\tmax = min;\n\t\t}\n\t\tthis.set_min_inputs_count(min);\n\t\tthis.set_max_inputs_count(max);\n\n\t\t// this._clonable_states_controller.init_inputs_clonable_state();\n\t\tthis.init_connections_controller_inputs();\n\t}\n\tprivate init_connections_controller_inputs() {\n\t\tthis.node.io.connections.initInputs();\n\t}\n\n\tis_any_input_dirty() {\n\t\treturn this._graph_node?.isDirty() || false;\n\t\t// if (this._max_inputs_count > 0) {\n\t\t// \tfor (let i = 0; i < this._inputs.length; i++) {\n\t\t// \t\tif (this._inputs[i]?.isDirty()) {\n\t\t// \t\t\treturn true;\n\t\t// \t\t}\n\t\t// \t}\n\t\t// } else {\n\t\t// \treturn false;\n\t\t// }\n\t}\n\tasync containers_without_evaluation() {\n\t\tconst containers: Array<ContainerMap[NC] | undefined> = [];\n\t\tfor (let i = 0; i < this._inputs.length; i++) {\n\t\t\tconst input_node = this._inputs[i];\n\t\t\tlet container: ContainerMap[NC] | undefined = undefined;\n\t\t\tif (input_node) {\n\t\t\t\tcontainer = (await input_node.requestContainer()) as ContainerMap[NC];\n\t\t\t}\n\t\t\tcontainers.push(container);\n\t\t}\n\t\treturn containers;\n\t}\n\n\texisting_input_indices() {\n\t\tconst existing_input_indices: number[] = [];\n\t\tif (this._max_inputs_count > 0) {\n\t\t\tfor (let i = 0; i < this._inputs.length; i++) {\n\t\t\t\tif (this._inputs[i]) {\n\t\t\t\t\texisting_input_indices.push(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn existing_input_indices;\n\t}\n\n\tasync eval_required_inputs() {\n\t\tlet containers: Array<ContainerMap[NC] | null | undefined> = [];\n\t\tif (this._max_inputs_count > 0) {\n\t\t\tconst existing_input_indices = this.existing_input_indices();\n\t\t\tif (existing_input_indices.length < this._min_inputs_count) {\n\t\t\t\tthis.node.states.error.set('inputs are missing');\n\t\t\t} else {\n\t\t\t\tif (existing_input_indices.length > 0) {\n\t\t\t\t\tconst promises: Promise<ContainerMap[NC] | null>[] = [];\n\t\t\t\t\tlet input: NodeTypeMap[NC] | null;\n\t\t\t\t\tfor (let i = 0; i < this._inputs.length; i++) {\n\t\t\t\t\t\tinput = this._inputs[i];\n\t\t\t\t\t\tif (input) {\n\t\t\t\t\t\t\t// I tried here to only use a promise for dirty inputs,\n\t\t\t\t\t\t\t// but that messes up with the order\n\t\t\t\t\t\t\t// if (input.isDirty()) {\n\t\t\t\t\t\t\t// \tcontainers.push(input.containerController.container as ContainerMap[NC]);\n\t\t\t\t\t\t\t// } else {\n\t\t\t\t\t\t\tpromises.push(this.eval_required_input(i) as Promise<ContainerMap[NC]>);\n\t\t\t\t\t\t\t// }\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcontainers = await Promise.all(promises);\n\t\t\t\t\t// containers = containers.concat(promised_containers);\n\t\t\t\t\tthis._graph_node?.removeDirtyState();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn containers;\n\t}\n\n\tasync eval_required_input(input_index: number) {\n\t\tlet container: ContainerMap[NC] | undefined = undefined;\n\t\tconst input_node = this.input(input_index);\n\t\t// if (input_node && !input_node.isDirty()) {\n\t\t// \tcontainer = input_node.containerController.container as ContainerMap[NC] | null;\n\t\t// } else {\n\t\t// \tcontainer = await this.node.containerController.requestInputContainer(input_index);\n\t\t// \tthis._graph_node_inputs[input_index].removeDirtyState();\n\t\t// }\n\t\tif (input_node) {\n\t\t\tcontainer = (await input_node.requestContainer()) as ContainerMap[NC];\n\t\t\tthis._graph_node_inputs[input_index].removeDirtyState();\n\t\t}\n\n\t\t// we do not clone here, as we just check if a group is present\n\t\tif (container && container.coreContent()) {\n\t\t\t// return container;\n\t\t} else {\n\t\t\tconst input_node = this.input(input_index);\n\t\t\tif (input_node) {\n\t\t\t\tconst input_error_message = input_node.states.error.message();\n\t\t\t\tif (input_error_message) {\n\t\t\t\t\tthis.node.states.error.set(`input ${input_index} is invalid (error: ${input_error_message})`);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn container;\n\t}\n\n\tget_named_input_index(name: string): number {\n\t\tif (this._named_input_connection_points) {\n\t\t\tfor (let i = 0; i < this._named_input_connection_points.length; i++) {\n\t\t\t\tif (this._named_input_connection_points[i]?.name() == name) {\n\t\t\t\t\treturn i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\tget_input_index(input_index_or_name: number | string): number {\n\t\tif (CoreType.isString(input_index_or_name)) {\n\t\t\tif (this.has_named_inputs) {\n\t\t\t\treturn this.get_named_input_index(input_index_or_name);\n\t\t\t} else {\n\t\t\t\tthrow new Error(`node ${this.node.fullPath()} has no named inputs`);\n\t\t\t}\n\t\t} else {\n\t\t\treturn input_index_or_name;\n\t\t}\n\t}\n\n\tsetInput(\n\t\tinput_index_or_name: number | string,\n\t\tnode: NodeTypeMap[NC] | null,\n\t\toutput_index_or_name: number | string = 0\n\t) {\n\t\tconst input_index = this.get_input_index(input_index_or_name) || 0;\n\t\tif (input_index < 0) {\n\t\t\tconst message = `invalid input (${input_index_or_name}) for node ${this.node.fullPath()}`;\n\t\t\tconsole.warn(message);\n\t\t\tthrow new Error(message);\n\t\t}\n\n\t\tlet output_index = 0;\n\t\tif (node) {\n\t\t\tif (node.io.outputs.has_named_outputs) {\n\t\t\t\toutput_index = node.io.outputs.get_output_index(output_index_or_name);\n\t\t\t\tif (output_index == null || output_index < 0) {\n\t\t\t\t\tconst connection_points = node.io.outputs.named_output_connection_points as BaseConnectionPoint[];\n\t\t\t\t\tconst names = connection_points.map((cp) => cp.name());\n\t\t\t\t\tconsole.warn(\n\t\t\t\t\t\t`node ${node.fullPath()} does not have an output named ${output_index_or_name}. inputs are: ${names.join(\n\t\t\t\t\t\t\t', '\n\t\t\t\t\t\t)}`\n\t\t\t\t\t);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst graph_input_node = this._graph_node_inputs[input_index];\n\t\tif (graph_input_node == null) {\n\t\t\tconst message = `graph_input_node not found at index ${input_index}`;\n\t\t\tconsole.warn(message);\n\t\t\tthrow new Error(message);\n\t\t}\n\n\t\tif (node && this.node.parent() != node.parent()) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst old_input_node = this._inputs[input_index];\n\t\tlet old_output_index: number | null = null;\n\t\tlet old_connection: TypedNodeConnection<NC> | undefined = undefined;\n\t\tif (this.node.io.connections) {\n\t\t\told_connection = this.node.io.connections.inputConnection(input_index);\n\t\t}\n\t\tif (old_connection) {\n\t\t\told_output_index = old_connection.output_index;\n\t\t}\n\n\t\tif (node !== old_input_node || output_index != old_output_index) {\n\t\t\t// TODO: test: add test to make sure this is necessary\n\t\t\tif (old_input_node != null) {\n\t\t\t\tif (this._depends_on_inputs) {\n\t\t\t\t\tgraph_input_node.removeGraphInput(old_input_node);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (node != null) {\n\t\t\t\tif (graph_input_node.addGraphInput(node)) {\n\t\t\t\t\t// we do test if we can create the graph connection\n\t\t\t\t\t// to ensure we are not in a cyclical graph,\n\t\t\t\t\t// but we delete it right after\n\t\t\t\t\tif (!this._depends_on_inputs) {\n\t\t\t\t\t\tgraph_input_node.removeGraphInput(node);\n\t\t\t\t\t}\n\n\t\t\t\t\t//this._input_connections[input_index] = new NodeConnection(node, this.self, output_index, input_index);\n\t\t\t\t\tif (old_connection) {\n\t\t\t\t\t\told_connection.disconnect({setInput: false});\n\t\t\t\t\t}\n\t\t\t\t\tthis._inputs[input_index] = node;\n\t\t\t\t\tnew TypedNodeConnection<NC>(\n\t\t\t\t\t\t(<unknown>node) as TypedNode<NC, any>,\n\t\t\t\t\t\tthis.node,\n\t\t\t\t\t\toutput_index,\n\t\t\t\t\t\tinput_index\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\tconsole.warn(`cannot connect ${node.fullPath()} to ${this.node.fullPath()}`);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis._inputs[input_index] = null;\n\t\t\t\tif (old_connection) {\n\t\t\t\t\told_connection.disconnect({setInput: false});\n\t\t\t\t}\n\t\t\t\t// this._input_connections[input_index] = null;\n\t\t\t}\n\n\t\t\tthis._run_on_set_input_hooks();\n\t\t\tgraph_input_node.setSuccessorsDirty();\n\t\t\t// this.node.set_dirty(node);\n\t\t\tthis.node.emit(NodeEvent.INPUTS_UPDATED);\n\t\t}\n\t}\n\n\tremove_input(node: NodeTypeMap[NC]) {\n\t\tconst inputs = this.inputs();\n\t\tlet input: NodeTypeMap[NC] | null;\n\t\tfor (let i = 0; i < inputs.length; i++) {\n\t\t\tinput = inputs[i];\n\t\t\tif (input != null && node != null) {\n\t\t\t\tif (input.graphNodeId() === node.graphNodeId()) {\n\t\t\t\t\tthis.setInput(i, null);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tinput(input_index: number): NodeTypeMap[NC] | null {\n\t\treturn this._inputs[input_index];\n\t}\n\tnamed_input(input_name: string): NodeTypeMap[NC] | null {\n\t\tif (this.has_named_inputs) {\n\t\t\tconst input_index = this.get_input_index(input_name);\n\t\t\treturn this._inputs[input_index];\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\tnamed_input_connection_point(input_name: string): ConnectionPointTypeMap[NC] | undefined {\n\t\tif (this.has_named_inputs && this._named_input_connection_points) {\n\t\t\tconst input_index = this.get_input_index(input_name);\n\t\t\treturn this._named_input_connection_points[input_index];\n\t\t}\n\t}\n\thas_named_input(name: string): boolean {\n\t\treturn this.get_named_input_index(name) >= 0;\n\t}\n\thas_input(input_index: number): boolean {\n\t\treturn this._inputs[input_index] != null;\n\t}\n\tinputs() {\n\t\treturn this._inputs;\n\t}\n\n\t//\n\t//\n\t// CLONABLE STATES\n\t//\n\t//\n\tprivate _cloned_states_controller: ClonedStatesController<NC> | undefined;\n\tinitInputsClonedState(states: InputCloneMode | InputCloneMode[]) {\n\t\tif (!this._cloned_states_controller) {\n\t\t\tthis._cloned_states_controller = new ClonedStatesController(this);\n\t\t\tthis._cloned_states_controller.initInputsClonedState(states);\n\t\t}\n\t}\n\toverrideClonedStateAllowed(): boolean {\n\t\treturn this._cloned_states_controller?.overrideClonedStateAllowed() || false;\n\t}\n\toverrideClonedState(state: boolean) {\n\t\tthis._cloned_states_controller?.overrideClonedState(state);\n\t}\n\tclonedStateOverriden() {\n\t\treturn this._cloned_states_controller?.overriden() || false;\n\t}\n\tcloneRequired(index: number) {\n\t\tconst state = this._cloned_states_controller?.cloneRequiredState(index);\n\t\tif (state != null) {\n\t\t\treturn state;\n\t\t}\n\t\treturn true;\n\t}\n\tcloneRequiredStates(): boolean | boolean[] {\n\t\tconst states = this._cloned_states_controller?.cloneRequiredStates();\n\t\tif (states != null) {\n\t\t\treturn states;\n\t\t}\n\t\treturn true;\n\t}\n\n\t//\n\t//\n\t// HOOKS\n\t//\n\t//\n\tadd_on_set_input_hook(name: string, hook: OnUpdateHook) {\n\t\tthis._on_update_hooks = this._on_update_hooks || [];\n\t\tthis._on_update_hook_names = this._on_update_hook_names || [];\n\n\t\tif (!this._on_update_hook_names.includes(name)) {\n\t\t\tthis._on_update_hooks.push(hook);\n\t\t\tthis._on_update_hook_names.push(name);\n\t\t} else {\n\t\t\tconsole.warn(`hook with name ${name} already exists`, this.node);\n\t\t}\n\t}\n\tprivate _run_on_set_input_hooks() {\n\t\tif (this._on_update_hooks) {\n\t\t\tfor (let hook of this._on_update_hooks) {\n\t\t\t\thook();\n\t\t\t}\n\t\t}\n\t}\n}\n","import {NodeEvent} from '../../../poly/NodeEvent';\nimport {NodeContext} from '../../../poly/NodeContext';\nimport {ConnectionPointTypeMap} from './connections/ConnectionMap';\nimport {TypedNode} from '../../_Base';\nimport {CoreType} from '../../../../core/Type';\nimport {ArrayUtils} from '../../../../core/ArrayUtils';\nexport class OutputsController<NC extends NodeContext> {\n\tprivate _has_outputs: boolean = false;\n\tprivate _named_output_connection_points: ConnectionPointTypeMap[NC][] | undefined;\n\tprivate _has_named_outputs: boolean = false;\n\n\tconstructor(private node: TypedNode<NC, any>) {}\n\n\tset_has_one_output() {\n\t\tthis._has_outputs = true;\n\t}\n\tset_has_no_output() {\n\t\tthis._has_outputs = false;\n\t}\n\n\tget has_outputs() {\n\t\treturn this._has_outputs;\n\t}\n\tget has_named_outputs() {\n\t\treturn this._has_named_outputs;\n\t}\n\thas_named_output(name: string): boolean {\n\t\treturn this.get_named_output_index(name) >= 0;\n\t}\n\tget named_output_connection_points(): ConnectionPointTypeMap[NC][] {\n\t\treturn this._named_output_connection_points || [];\n\t}\n\tnamed_output_connection(index: number): ConnectionPointTypeMap[NC] | undefined {\n\t\tif (this._named_output_connection_points) {\n\t\t\treturn this._named_output_connection_points[index];\n\t\t}\n\t}\n\n\tget_named_output_index(name: string): number {\n\t\tif (this._named_output_connection_points) {\n\t\t\tfor (let i = 0; i < this._named_output_connection_points.length; i++) {\n\t\t\t\tif (this._named_output_connection_points[i]?.name() == name) {\n\t\t\t\t\treturn i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\tget_output_index(output_index_or_name: number | string): number {\n\t\tif (output_index_or_name != null) {\n\t\t\tif (CoreType.isString(output_index_or_name)) {\n\t\t\t\tif (this.has_named_outputs) {\n\t\t\t\t\treturn this.get_named_output_index(output_index_or_name);\n\t\t\t\t} else {\n\t\t\t\t\tconsole.warn(`node ${this.node.fullPath()} has no named outputs`);\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn output_index_or_name;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\n\tnamed_output_connection_points_by_name(name: string): ConnectionPointTypeMap[NC] | undefined {\n\t\tif (this._named_output_connection_points) {\n\t\t\tfor (let connection_point of this._named_output_connection_points) {\n\t\t\t\tif (connection_point?.name() == name) {\n\t\t\t\t\treturn connection_point;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tsetNamedOutputConnectionPoints(connection_points: ConnectionPointTypeMap[NC][], set_dirty: boolean = true) {\n\t\tthis._has_named_outputs = true;\n\n\t\tconst connections = this.node.io.connections.outputConnections();\n\t\tif (connections) {\n\t\t\tfor (let connection of connections) {\n\t\t\t\tif (connection) {\n\t\t\t\t\t// assume we only work with indices for now, not with connection point names\n\t\t\t\t\t// so we only need to check again the new max number of connection points.\n\t\t\t\t\tif (connection.output_index >= connection_points.length) {\n\t\t\t\t\t\tconnection.disconnect({setInput: true});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// update connections\n\t\tthis._named_output_connection_points = connection_points;\n\t\tif (set_dirty && this.node.scene()) {\n\t\t\t// why do I need this set dirty here?\n\t\t\t// I currently have to have a flag to optionally prevent this,\n\t\t\t// for instance from gl nodes which have their outputs updated in a post dirty hook\n\t\t\tthis.node.setDirty(this.node);\n\t\t}\n\t\tthis.node.emit(NodeEvent.NAMED_OUTPUTS_UPDATED);\n\t}\n\tused_output_names(): string[] {\n\t\tconst connections_controller = this.node.io.connections;\n\t\tif (connections_controller) {\n\t\t\tconst output_connections = connections_controller.outputConnections();\n\t\t\tlet output_indices = output_connections.map((connection) => (connection ? connection.output_index : null));\n\t\t\toutput_indices = ArrayUtils.uniq(output_indices);\n\t\t\tconst used_output_indices: number[] = [];\n\t\t\toutput_indices.forEach((index) => {\n\t\t\t\tif (CoreType.isNumber(index)) {\n\t\t\t\t\tused_output_indices.push(index);\n\t\t\t\t}\n\t\t\t});\n\t\t\tconst used_output_names: string[] = [];\n\t\t\tfor (let index of used_output_indices) {\n\t\t\t\tconst name = this.named_output_connection_points[index]?.name();\n\t\t\t\tif (name) {\n\t\t\t\t\tused_output_names.push(name);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn used_output_names;\n\t\t} else {\n\t\t\treturn [];\n\t\t}\n\t}\n}\n","import {TypedNodeConnection} from './NodeConnection';\nimport {NodeContext} from '../../../poly/NodeContext';\nimport {TypedNode} from '../../_Base';\nimport {ArrayUtils} from '../../../../core/ArrayUtils';\n\nexport class ConnectionsController<NC extends NodeContext> {\n\tprivate _input_connections: Array<TypedNodeConnection<NC> | undefined> | undefined;\n\tprivate _output_connections: Map<number, Map<number, TypedNodeConnection<NC>>> = new Map();\n\n\tconstructor(protected _node: TypedNode<NC, any>) {}\n\n\tinitInputs() {\n\t\tconst count = this._node.io.inputs.maxInputsCount();\n\t\tthis._input_connections = this._input_connections || new Array(count);\n\t\t// adjust the array if this method is called more than once\n\t\t// which can be the case for nodes that have adjustable input counts\n\t\t// such as sop/merge\n\t\twhile (this._input_connections.length < count) {\n\t\t\tthis._input_connections.push(undefined);\n\t\t}\n\t}\n\n\t//\n\t//\n\t// INPUT CONNECTIONS\n\t//\n\t//\n\taddInputConnection(connection: TypedNodeConnection<NC>) {\n\t\tif (this._input_connections) {\n\t\t\t// if (connection.input_index < this._input_connections.length) {\n\t\t\tthis._input_connections[connection.input_index] = connection;\n\t\t\t// } else {\n\t\t\t// \tconsole.warn(`attempt to add an input connection at index ${connection.input_index}`);\n\t\t\t// }\n\t\t} else {\n\t\t\tconsole.warn(`input connections array not initialized`);\n\t\t}\n\t}\n\tremoveInputConnection(connection: TypedNodeConnection<NC>) {\n\t\tif (this._input_connections) {\n\t\t\tif (connection.input_index < this._input_connections.length) {\n\t\t\t\tthis._input_connections[connection.input_index] = undefined;\n\t\t\t\t// if all connections after are also undefined, we can safely shrink the array\n\t\t\t\tlet all_connections_after_are_undefined = true;\n\t\t\t\tfor (let i = connection.input_index; i < this._input_connections.length; i++) {\n\t\t\t\t\tif (this._input_connections[i]) {\n\t\t\t\t\t\tall_connections_after_are_undefined = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (all_connections_after_are_undefined) {\n\t\t\t\t\tthis._input_connections = this._input_connections.slice(0, connection.input_index);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconsole.warn(`attempt to remove an input connection at index ${connection.input_index}`);\n\t\t\t}\n\t\t} else {\n\t\t\tconsole.warn(`input connections array not initialized`);\n\t\t}\n\t}\n\tinputConnection(index: number): TypedNodeConnection<NC> | undefined {\n\t\tif (this._input_connections) {\n\t\t\treturn this._input_connections[index];\n\t\t}\n\t}\n\tfirstInputConnection(): TypedNodeConnection<NC> | null {\n\t\tif (this._input_connections) {\n\t\t\treturn ArrayUtils.compact(this._input_connections)[0];\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\tinputConnections() {\n\t\treturn this._input_connections;\n\t}\n\n\t//\n\t//\n\t// OUTPUT CONNECTIONS\n\t//\n\t//\n\taddOutputConnection(connection: TypedNodeConnection<NC>) {\n\t\tconst output_index = connection.output_index;\n\t\tconst id = connection.id;\n\t\tlet connections_by_id = this._output_connections.get(output_index);\n\t\tif (!connections_by_id) {\n\t\t\tconnections_by_id = new Map<number, TypedNodeConnection<NC>>();\n\t\t\tthis._output_connections.set(output_index, connections_by_id);\n\t\t}\n\t\tconnections_by_id.set(id, connection);\n\t\t// this._output_connections[output_index] = this._output_connections[output_index] || {};\n\t\t// this._output_connections[output_index][id] = connection;\n\t}\n\tremoveOutputConnection(connection: TypedNodeConnection<NC>) {\n\t\tconst output_index = connection.output_index;\n\t\tconst id = connection.id;\n\t\tlet connections_by_id = this._output_connections.get(output_index);\n\t\tif (connections_by_id) {\n\t\t\tconnections_by_id.delete(id);\n\t\t}\n\t\t// delete this._output_connections[output_index][id];\n\t}\n\n\toutputConnections() {\n\t\tlet list: TypedNodeConnection<NC>[] = [];\n\n\t\tthis._output_connections.forEach((connections_by_id, output_index) => {\n\t\t\tconnections_by_id.forEach((connection, id) => {\n\t\t\t\tif (connection) {\n\t\t\t\t\tlist.push(connection);\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t\t// Object.keys(this._output_connections).forEach((index) => {\n\t\t// \tconst connections_for_index = this._output_connections[index];\n\t\t// \tObject.keys(connections_for_index).forEach((id) => {\n\t\t// \t\tlist.push(connections_for_index[id]);\n\t\t// \t});\n\t\t// });\n\t\treturn list;\n\t}\n}\n","import {NodeContext} from '../../../poly/NodeContext';\nimport {TypedNode} from '../../_Base';\nimport {BaseConnectionPointData} from './connections/_Base';\n\nexport class SavedConnectionPointsDataController<NC extends NodeContext> {\n\tprivate _in: BaseConnectionPointData[] | undefined;\n\tprivate _out: BaseConnectionPointData[] | undefined;\n\n\tconstructor(protected _node: TypedNode<NC, any>) {}\n\n\tset_in(data: BaseConnectionPointData[]) {\n\t\tthis._in = data;\n\t}\n\tset_out(data: BaseConnectionPointData[]) {\n\t\tthis._out = data;\n\t}\n\tclear() {\n\t\tthis._in = undefined;\n\t\tthis._out = undefined;\n\t}\n\tin() {\n\t\treturn this._in;\n\t}\n\tout() {\n\t\treturn this._out;\n\t}\n}\n","import {ParamInitValuesTypeMap} from '../../../../params/types/ParamInitValuesTypeMap';\nimport {ParamType} from '../../../../poly/ParamType';\n\nexport enum JsConnectionPointType {\n\tBOOL = 'bool',\n\tINT = 'int',\n\tFLOAT = 'float',\n\tVEC2 = 'vec2',\n\tVEC3 = 'vec3',\n\tVEC4 = 'vec4',\n\t// MAT3 = 'mat3',\n\t// MAT4 = 'mat4',\n}\n\n//\n//\n// ALL GL Data types in an array\n//\n//\nexport const JS_CONNECTION_POINT_TYPES: Array<JsConnectionPointType> = [\n\tJsConnectionPointType.BOOL,\n\tJsConnectionPointType.INT,\n\tJsConnectionPointType.FLOAT,\n\tJsConnectionPointType.VEC2,\n\tJsConnectionPointType.VEC3,\n\tJsConnectionPointType.VEC4,\n\t// JsConnectionPointType.MAT3,\n\t// JsConnectionPointType.MAT4,\n];\n\n//\n//\n// Map to convert from a Js Data type to a ParamType\n//\n//\ntype ConnectionPointTypeToParamTypeMapGeneric = {[key in JsConnectionPointType]: ParamType | undefined};\nexport interface IConnectionPointTypeToParamTypeMap extends ConnectionPointTypeToParamTypeMapGeneric {\n\t[JsConnectionPointType.BOOL]: ParamType.BOOLEAN;\n\t[JsConnectionPointType.INT]: ParamType.INTEGER;\n\t[JsConnectionPointType.FLOAT]: ParamType.FLOAT;\n\t[JsConnectionPointType.VEC2]: ParamType.VECTOR2;\n\t[JsConnectionPointType.VEC3]: ParamType.VECTOR3;\n\t[JsConnectionPointType.VEC4]: ParamType.VECTOR4;\n\t// [JsConnectionPointType.MAT3]: undefined;\n\t// [JsConnectionPointType.MAT4]: undefined;\n}\nexport const JsConnectionPointTypeToParamTypeMap: IConnectionPointTypeToParamTypeMap = {\n\t[JsConnectionPointType.BOOL]: ParamType.BOOLEAN,\n\t[JsConnectionPointType.INT]: ParamType.INTEGER,\n\t[JsConnectionPointType.FLOAT]: ParamType.FLOAT,\n\t[JsConnectionPointType.VEC2]: ParamType.VECTOR2,\n\t[JsConnectionPointType.VEC3]: ParamType.VECTOR3,\n\t[JsConnectionPointType.VEC4]: ParamType.VECTOR4,\n\t// [JsConnectionPointType.MAT3]: undefined,\n\t// [JsConnectionPointType.MAT4]: undefined,\n};\n\n//\n//\n// Map to convert from a ParamType to GL Data type\n//\n//\ntype JsParamTypeToConnectionPointTypeMapGeneric = {[key in ParamType]: JsConnectionPointType | undefined};\nexport interface IJsParamTypeToConnectionPointTypeMap extends JsParamTypeToConnectionPointTypeMapGeneric {\n\t[ParamType.BOOLEAN]: JsConnectionPointType.BOOL;\n\t[ParamType.COLOR]: JsConnectionPointType.VEC3;\n\t[ParamType.INTEGER]: JsConnectionPointType.INT;\n\t[ParamType.FLOAT]: JsConnectionPointType.FLOAT;\n\t[ParamType.FOLDER]: undefined;\n\t[ParamType.VECTOR2]: JsConnectionPointType.VEC2;\n\t[ParamType.VECTOR3]: JsConnectionPointType.VEC3;\n\t[ParamType.VECTOR4]: JsConnectionPointType.VEC4;\n\t[ParamType.BUTTON]: undefined;\n\t[ParamType.OPERATOR_PATH]: undefined;\n\t[ParamType.PARAM_PATH]: undefined;\n\t[ParamType.NODE_PATH]: undefined;\n\t[ParamType.RAMP]: undefined;\n\t[ParamType.SEPARATOR]: undefined;\n\t[ParamType.STRING]: undefined;\n}\nexport const JsParamTypeToConnectionPointTypeMap: IJsParamTypeToConnectionPointTypeMap = {\n\t[ParamType.BOOLEAN]: JsConnectionPointType.BOOL,\n\t[ParamType.COLOR]: JsConnectionPointType.VEC3,\n\t[ParamType.INTEGER]: JsConnectionPointType.INT,\n\t[ParamType.FLOAT]: JsConnectionPointType.FLOAT,\n\t[ParamType.FOLDER]: undefined,\n\t[ParamType.VECTOR2]: JsConnectionPointType.VEC2,\n\t[ParamType.VECTOR3]: JsConnectionPointType.VEC3,\n\t[ParamType.VECTOR4]: JsConnectionPointType.VEC4,\n\t[ParamType.BUTTON]: undefined,\n\t[ParamType.OPERATOR_PATH]: undefined,\n\t[ParamType.PARAM_PATH]: undefined,\n\t[ParamType.NODE_PATH]: undefined,\n\t[ParamType.RAMP]: undefined,\n\t[ParamType.SEPARATOR]: undefined,\n\t[ParamType.STRING]: undefined,\n};\n\n//\n//\n// Map of Js Data type default values\n//\n//\nexport type ConnectionPointInitValueMapGeneric = {\n\t[key in JsConnectionPointType]: ParamInitValuesTypeMap[IConnectionPointTypeToParamTypeMap[key]];\n};\nexport const JsConnectionPointInitValueMap: ConnectionPointInitValueMapGeneric = {\n\t[JsConnectionPointType.BOOL]: false,\n\t[JsConnectionPointType.INT]: 0,\n\t[JsConnectionPointType.FLOAT]: 0,\n\t[JsConnectionPointType.VEC2]: [0, 0],\n\t[JsConnectionPointType.VEC3]: [0, 0, 0],\n\t[JsConnectionPointType.VEC4]: [0, 0, 0, 0],\n\t// [JsConnectionPointType.MAT3]: [0],\n\t// [JsConnectionPointType.MAT4]: [0],\n};\n\n//\n//\n// Map of Js Data type component counts\n//\n//\nexport type ConnectionPointComponentsCountMapGeneric = {\n\t[key in JsConnectionPointType]: number;\n};\nexport const GlConnectionPointComponentsCountMap: ConnectionPointComponentsCountMapGeneric = {\n\t[JsConnectionPointType.BOOL]: 1,\n\t[JsConnectionPointType.INT]: 1,\n\t[JsConnectionPointType.FLOAT]: 1,\n\t[JsConnectionPointType.VEC2]: 2,\n\t[JsConnectionPointType.VEC3]: 3,\n\t[JsConnectionPointType.VEC4]: 4,\n};\n\nexport interface JsConnectionPointData<T extends JsConnectionPointType> {\n\tname: string;\n\ttype: T;\n}\n\nimport {BaseConnectionPoint} from './_Base';\nexport class JsConnectionPoint<T extends JsConnectionPointType> extends BaseConnectionPoint {\n\tprotected _json: JsConnectionPointData<T> | undefined;\n\tprotected _init_value: any;\n\n\tconstructor(\n\t\tprotected _name: string,\n\t\tprotected _type: T // protected _init_value?: ConnectionPointInitValueMapGeneric[T]\n\t) {\n\t\tsuper(_name, _type);\n\t\t// if (this._init_value === undefined) {\n\t\tthis._init_value = JsConnectionPointInitValueMap[this._type];\n\t\t// }\n\t}\n\ttype() {\n\t\treturn this._type;\n\t}\n\tare_types_matched(src_type: string, dest_type: string): boolean {\n\t\treturn src_type == dest_type;\n\t}\n\tget param_type(): IConnectionPointTypeToParamTypeMap[T] {\n\t\treturn JsConnectionPointTypeToParamTypeMap[this._type];\n\t}\n\tget init_value() {\n\t\treturn this._init_value;\n\t}\n\n\ttoJSON(): JsConnectionPointData<T> {\n\t\treturn (this._json = this._json || this._create_json());\n\t}\n\tprotected _create_json(): JsConnectionPointData<T> {\n\t\treturn {\n\t\t\tname: this._name,\n\t\t\ttype: this._type,\n\t\t};\n\t}\n}\n\nexport type BaseJsConnectionPoint = JsConnectionPoint<JsConnectionPointType>;\n","import {NodeContext, NodeContextUnion} from '../../../../poly/NodeContext';\nimport {\n\tBaseGlConnectionPoint,\n\tGlConnectionPointType,\n\tGlConnectionPoint,\n\tGLParamTypeToConnectionPointTypeMap,\n} from './Gl';\nimport {\n\tBaseJsConnectionPoint,\n\tJsConnectionPointType,\n\tJsConnectionPoint,\n\tJsParamTypeToConnectionPointTypeMap,\n} from './Js';\nimport {BaseEventConnectionPoint, EventConnectionPoint, EventConnectionPointType} from './Event';\n\ntype ConnectionPointTypeMapGeneric = {\n\t[key in NodeContext]: BaseEventConnectionPoint | BaseGlConnectionPoint | BaseJsConnectionPoint | undefined;\n};\n\nexport interface ConnectionPointTypeMap extends ConnectionPointTypeMapGeneric {\n\t[NodeContext.ANIM]: undefined;\n\t[NodeContext.COP]: undefined;\n\t[NodeContext.EVENT]: BaseEventConnectionPoint;\n\t[NodeContext.GL]: BaseGlConnectionPoint;\n\t[NodeContext.JS]: BaseJsConnectionPoint;\n\t[NodeContext.MANAGER]: undefined;\n\t[NodeContext.MAT]: undefined;\n\t[NodeContext.OBJ]: undefined;\n\t[NodeContext.POST]: undefined;\n\t[NodeContext.ROP]: undefined;\n\t[NodeContext.SOP]: undefined;\n}\ntype ConnectionPointEnumMapGeneric = {\n\t[key in NodeContext]: EventConnectionPointType | GlConnectionPointType | JsConnectionPointType | undefined;\n};\n\nexport interface ConnectionPointEnumMap extends ConnectionPointEnumMapGeneric {\n\t[NodeContext.ANIM]: undefined;\n\t[NodeContext.COP]: undefined;\n\t[NodeContext.EVENT]: EventConnectionPointType;\n\t[NodeContext.GL]: GlConnectionPointType;\n\t[NodeContext.JS]: JsConnectionPointType;\n\t[NodeContext.MANAGER]: undefined;\n\t[NodeContext.MAT]: undefined;\n\t[NodeContext.OBJ]: undefined;\n\t[NodeContext.POST]: undefined;\n\t[NodeContext.ROP]: undefined;\n\t[NodeContext.SOP]: undefined;\n}\n\ntype IConnectionPointEnumMap = {[key in NodeContextUnion]: ConnectionPointEnumMap[key]};\n\nexport const DEFAULT_CONNECTION_POINT_ENUM_MAP: IConnectionPointEnumMap = {\n\t[NodeContext.ANIM]: undefined,\n\t[NodeContext.COP]: undefined,\n\t[NodeContext.EVENT]: EventConnectionPointType.BASE,\n\t[NodeContext.GL]: GlConnectionPointType.FLOAT,\n\t[NodeContext.JS]: JsConnectionPointType.FLOAT,\n\t[NodeContext.MANAGER]: undefined,\n\t[NodeContext.MAT]: undefined,\n\t[NodeContext.OBJ]: undefined,\n\t[NodeContext.POST]: undefined,\n\t[NodeContext.ROP]: undefined,\n\t[NodeContext.SOP]: undefined,\n};\n\nexport function create_connection_point<NC extends NodeContext>(\n\tcontext: NC,\n\tname: string,\n\ttype: ConnectionPointEnumMap[NC]\n) {\n\tswitch (context) {\n\t\tcase NodeContext.EVENT: {\n\t\t\treturn new EventConnectionPoint(name, type as EventConnectionPointType);\n\t\t}\n\t\tcase NodeContext.GL: {\n\t\t\treturn new GlConnectionPoint(name, type as GlConnectionPointType);\n\t\t}\n\t\tcase NodeContext.JS: {\n\t\t\treturn new JsConnectionPoint(name, type as JsConnectionPointType);\n\t\t}\n\t\tdefault: {\n\t\t\treturn undefined;\n\t\t}\n\t}\n}\n\nexport function param_type_to_connection_point_type_map<NC extends NodeContext>(context: NC) {\n\tswitch (context) {\n\t\tcase NodeContext.EVENT: {\n\t\t\treturn undefined;\n\t\t}\n\t\tcase NodeContext.GL: {\n\t\t\treturn GLParamTypeToConnectionPointTypeMap;\n\t\t}\n\t\tcase NodeContext.JS: {\n\t\t\treturn JsParamTypeToConnectionPointTypeMap;\n\t\t}\n\t\tdefault: {\n\t\t\treturn undefined;\n\t\t}\n\t}\n}\n","import {Number2} from '../../../../types/GlobalTypes';\nimport {\n\tConnectionPointTypeMap,\n\tConnectionPointEnumMap,\n\tparam_type_to_connection_point_type_map,\n\tcreate_connection_point,\n} from './connections/ConnectionMap';\nimport {ParamType} from '../../../poly/ParamType';\nimport {ParamsUpdateOptions} from '../params/ParamsController';\nimport {ParamInitValueSerialized} from '../../../params/types/ParamInitValueSerialized';\nimport {NodeContext} from '../../../poly/NodeContext';\nimport {TypedNode} from '../../_Base';\nimport {CoreType} from '../../../../core/Type';\nimport {ObjectUtils} from '../../../../core/ObjectUtils';\n\n/*\nGlNodeSpareParamsController creates spare params from inputs on gl nodes\n*/\nexport class ConnectionPointsSpareParamsController<NC extends NodeContext> {\n\t// private _allow_inputs_created_from_params: boolean = true;\n\tprivate _inputless_param_names: string[] | undefined;\n\tprivate _raw_input_serialized_by_param_name: Map<string, ParamInitValueSerialized> = new Map();\n\tprivate _default_value_serialized_by_param_name: Map<string, ParamInitValueSerialized> = new Map();\n\tconstructor(private node: TypedNode<NC, any>, private _context: NC) {}\n\n\t// disallow_inputs_created_from_params() {\n\t// \tthis._allow_inputs_created_from_params = false;\n\t// }\n\n\tprivate _initialized = false;\n\tinitializeNode() {\n\t\tif (this._initialized) {\n\t\t\tconsole.warn('already initialized', this.node);\n\t\t\treturn;\n\t\t}\n\t\tthis._initialized = true;\n\t\tthis.node.params.onParamsCreated('create_inputs_from_params', this.create_inputs_from_params.bind(this));\n\t}\n\tinitialized() {\n\t\treturn this._initialized;\n\t}\n\n\tcreate_inputs_from_params() {\n\t\t// if (!this._allow_inputs_created_from_params) {\n\t\t// \treturn;\n\t\t// }\n\t\tconst connection_type_map = param_type_to_connection_point_type_map(this._context);\n\t\tif (!connection_type_map) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst connection_points: ConnectionPointTypeMap[NC][] = [];\n\t\tfor (let param_name of this.node.params.names) {\n\t\t\tlet add_input = true;\n\t\t\tif (\n\t\t\t\tthis._inputless_param_names &&\n\t\t\t\tthis._inputless_param_names.length > 0 &&\n\t\t\t\tthis._inputless_param_names.includes(param_name)\n\t\t\t) {\n\t\t\t\tadd_input = false;\n\t\t\t}\n\t\t\tif (add_input) {\n\t\t\t\tif (this.node.params.has(param_name)) {\n\t\t\t\t\tconst param = this.node.params.get(param_name);\n\t\t\t\t\tif (param && !param.parent_param) {\n\t\t\t\t\t\tconst connection_type = connection_type_map[param.type()] as ConnectionPointEnumMap[NC];\n\t\t\t\t\t\tif (connection_type) {\n\t\t\t\t\t\t\tconst connection_point = create_connection_point(\n\t\t\t\t\t\t\t\tthis._context,\n\t\t\t\t\t\t\t\tparam.name(),\n\t\t\t\t\t\t\t\tconnection_type\n\t\t\t\t\t\t\t) as ConnectionPointTypeMap[NC];\n\t\t\t\t\t\t\tif (connection_point) {\n\t\t\t\t\t\t\t\tconnection_points.push(connection_point);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthis.node.io.inputs.setNamedInputConnectionPoints(connection_points);\n\t}\n\n\tset_inputless_param_names(names: string[]) {\n\t\treturn (this._inputless_param_names = names);\n\t}\n\n\t//\n\t// Create spare params on gl nodes\n\t//\n\tcreate_spare_parameters() {\n\t\tif (this.node.scene().loadingController.isLoading()) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst current_param_names: string[] = this.node.params.spare_names;\n\t\tconst params_update_options: ParamsUpdateOptions = {};\n\n\t\tfor (let param_name of current_param_names) {\n\t\t\tif (this.node.params.has(param_name)) {\n\t\t\t\tconst param = this.node.params.get(param_name);\n\t\t\t\tif (param) {\n\t\t\t\t\tthis._raw_input_serialized_by_param_name.set(param_name, param.rawInputSerialized());\n\t\t\t\t\tthis._default_value_serialized_by_param_name.set(param_name, param.defaultValueSerialized());\n\t\t\t\t\tparams_update_options.names_to_delete = params_update_options.names_to_delete || [];\n\t\t\t\t\tparams_update_options.names_to_delete.push(param_name);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (let connection_point of this.node.io.inputs.named_input_connection_points) {\n\t\t\tif (connection_point) {\n\t\t\t\tconst param_name = connection_point.name();\n\t\t\t\tconst param_type: ParamType = connection_point.param_type;\n\t\t\t\tlet init_value = connection_point.init_value;\n\n\t\t\t\tconst last_param_init_value = this._default_value_serialized_by_param_name.get(param_name);\n\t\t\t\tlet default_value_from_name = this.node.param_default_value(param_name);\n\n\t\t\t\tif (default_value_from_name != null) {\n\t\t\t\t\tinit_value = default_value_from_name;\n\t\t\t\t} else {\n\t\t\t\t\tif (last_param_init_value != null) {\n\t\t\t\t\t\tinit_value = last_param_init_value;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tinit_value = connection_point.init_value;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (CoreType.isArray(connection_point.init_value)) {\n\t\t\t\t\t// if we need to use an init_value from a float to an array\n\t\t\t\t\tif (CoreType.isNumber(init_value)) {\n\t\t\t\t\t\tconst array = new Array(connection_point.init_value.length) as Number2;\n\t\t\t\t\t\tarray.fill(init_value);\n\t\t\t\t\t\tinit_value = array;\n\t\t\t\t\t}\n\t\t\t\t\t// if we need to use an init_value from a array to an array, we need to check their length.\n\t\t\t\t\t// if they are different, we need to match them.\n\t\t\t\t\telse if (CoreType.isArray(init_value)) {\n\t\t\t\t\t\t// if (init_value.length < connection_point.init_value.length) {\n\t\t\t\t\t\t// }\n\t\t\t\t\t\t// if (init_value.length > connection_point.init_value.length) {\n\t\t\t\t\t\t// }\n\t\t\t\t\t\tif (init_value.length == connection_point.init_value.length) {\n\t\t\t\t\t\t\tif (last_param_init_value != null) {\n\t\t\t\t\t\t\t\tinit_value = connection_point.init_value;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (init_value != null) {\n\t\t\t\t\tparams_update_options.to_add = params_update_options.to_add || [];\n\t\t\t\t\tparams_update_options.to_add.push({\n\t\t\t\t\t\tname: param_name,\n\t\t\t\t\t\ttype: param_type,\n\t\t\t\t\t\t// TODO: I should really treat differently init_value and raw_input here\n\t\t\t\t\t\tinit_value: ObjectUtils.clone(init_value as any),\n\t\t\t\t\t\traw_input: ObjectUtils.clone(init_value as any),\n\t\t\t\t\t\toptions: {\n\t\t\t\t\t\t\tspare: true,\n\t\t\t\t\t\t},\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// if (!this.node.scene.loading_controller.isLoading()) {\n\t\tthis.node.params.update_params(params_update_options);\n\n\t\tfor (let spare_param of this.node.params.spare) {\n\t\t\tif (!spare_param.parent_param) {\n\t\t\t\tconst raw_input = this._raw_input_serialized_by_param_name.get(spare_param.name());\n\t\t\t\tif (raw_input) {\n\t\t\t\t\tspare_param.set(raw_input as any);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// }\n\t}\n}\n","import {CoreGraphNode} from '../../../../core/graph/CoreGraphNode';\nimport {\n\tConnectionPointTypeMap,\n\tConnectionPointEnumMap,\n\tDEFAULT_CONNECTION_POINT_ENUM_MAP,\n\tcreate_connection_point,\n} from './connections/ConnectionMap';\nimport {TypedNode} from '../../_Base';\nimport {ConnectionPointsSpareParamsController} from './ConnectionPointsSpareParamsController';\nimport {NodeContext, NetworkChildNodeType} from '../../../poly/NodeContext';\n\ntype IONameFunction = (index: number) => string;\ntype ExpectedConnectionTypesFunction<NC extends NodeContext> = () => ConnectionPointEnumMap[NC][];\n\nexport class ConnectionPointsController<NC extends NodeContext> {\n\tprivate _spare_params_controller: ConnectionPointsSpareParamsController<NC>;\n\tprivate _create_spare_params_from_inputs = true;\n\tprivate _functions_overridden = false;\n\n\tconstructor(private node: TypedNode<NC, any>, private _context: NC) {\n\t\tthis._spare_params_controller = new ConnectionPointsSpareParamsController(this.node, this._context);\n\t}\n\n\tprivate _input_name_function: IONameFunction = (index: number) => {\n\t\treturn `in${index}`;\n\t};\n\tprivate _output_name_function: IONameFunction = (index: number) => {\n\t\treturn index == 0 ? 'val' : `val${index}`;\n\t};\n\t// private _default_input_type: ConnectionPointType = ConnectionPointType.FLOAT;\n\tprivate _expected_input_types_function: ExpectedConnectionTypesFunction<NC> = () => {\n\t\tconst type = this.first_input_connection_type() || this.default_connection_type();\n\t\treturn [type, type];\n\t};\n\tprivate _expected_output_types_function: ExpectedConnectionTypesFunction<NC> = () => {\n\t\treturn [this._expected_input_types_function()[0]];\n\t};\n\tprotected default_connection_type(): ConnectionPointEnumMap[NC] {\n\t\treturn DEFAULT_CONNECTION_POINT_ENUM_MAP[this._context];\n\t}\n\tprotected create_connection_point(name: string, type: ConnectionPointEnumMap[NC]): ConnectionPointTypeMap[NC] {\n\t\treturn create_connection_point(this._context, name, type) as ConnectionPointTypeMap[NC];\n\t}\n\n\tfunctions_overridden(): boolean {\n\t\treturn this._functions_overridden;\n\t}\n\tinitialized(): boolean {\n\t\treturn this._initialized;\n\t}\n\n\tset_create_spare_params_from_inputs(state: boolean) {\n\t\tthis._create_spare_params_from_inputs = state;\n\t}\n\n\tset_input_name_function(func: IONameFunction) {\n\t\tthis._initialize_if_required();\n\t\tthis._input_name_function = func;\n\t}\n\tset_output_name_function(func: IONameFunction) {\n\t\tthis._initialize_if_required();\n\t\tthis._output_name_function = func;\n\t}\n\n\t// set_default_input_type(type: ConnectionPointType) {\n\t// \tthis._default_input_type = type;\n\t// }\n\tset_expected_input_types_function(func: ExpectedConnectionTypesFunction<NC>) {\n\t\tthis._initialize_if_required();\n\t\tthis._functions_overridden = true;\n\t\tthis._expected_input_types_function = func;\n\t}\n\tset_expected_output_types_function(func: ExpectedConnectionTypesFunction<NC>) {\n\t\tthis._initialize_if_required();\n\t\tthis._functions_overridden = true;\n\t\tthis._expected_output_types_function = func;\n\t}\n\n\tinput_name(index: number) {\n\t\treturn this._wrapped_input_name_function(index);\n\t}\n\toutput_name(index: number) {\n\t\treturn this._wrapped_output_name_function(index);\n\t}\n\n\tprivate _update_signature_if_required_bound = this.update_signature_if_required.bind(this);\n\tprivate _initialized: boolean = false;\n\tinitializeNode() {\n\t\t// I don't want this check here, as I should refactor to have the has_named_inputs\n\t\t// be initialized from here\n\t\t// if (!this.node.io.inputs.has_named_inputs) {\n\t\t// \treturn;\n\t\t// }\n\n\t\tif (this._initialized) {\n\t\t\tconsole.warn('already initialized', this.node);\n\t\t\treturn;\n\t\t}\n\t\tthis._initialized = true;\n\n\t\t// hooks\n\t\tthis.node.io.inputs.add_on_set_input_hook(\n\t\t\t'_update_signature_if_required',\n\t\t\tthis._update_signature_if_required_bound\n\t\t);\n\t\t// this.node.lifecycle.add_on_add_hook(this._update_signature_if_required_bound);\n\t\tthis.node.params.addOnSceneLoadHook('_update_signature_if_required', this._update_signature_if_required_bound);\n\t\tthis.node.params.onParamsCreated(\n\t\t\t'_update_signature_if_required_bound',\n\t\t\tthis._update_signature_if_required_bound\n\t\t);\n\t\tthis.node.addPostDirtyHook('_update_signature_if_required', this._update_signature_if_required_bound);\n\n\t\tif (!this._spare_params_controller.initialized()) {\n\t\t\tthis._spare_params_controller.initializeNode();\n\t\t}\n\t}\n\tprivate _initialize_if_required() {\n\t\tif (!this._initialized) {\n\t\t\tthis.initializeNode();\n\t\t}\n\t}\n\n\tget spare_params() {\n\t\treturn this._spare_params_controller;\n\t}\n\n\tupdate_signature_if_required(dirty_trigger?: CoreGraphNode) {\n\t\tif (!this.node.lifecycle.creation_completed || !this._connections_match_inputs()) {\n\t\t\tthis.update_connection_types();\n\t\t\tthis.node.removeDirtyState();\n\n\t\t\t// no need to update the successors when loading,\n\t\t\t// since the connection point types are stored in the scene data\n\t\t\tif (!this.node.scene().loadingController.isLoading()) {\n\t\t\t\tthis.make_successors_update_signatures();\n\t\t\t}\n\t\t}\n\t}\n\t// used when a node changes its signature, adn the output nodes need to adapt their own signatures\n\tprivate make_successors_update_signatures() {\n\t\tconst successors = this.node.graphAllSuccessors();\n\t\tif (this.node.childrenAllowed()) {\n\t\t\tconst subnet_inputs = this.node.nodesByType(NetworkChildNodeType.INPUT);\n\t\t\tconst subnet_outputs = this.node.nodesByType(NetworkChildNodeType.OUTPUT);\n\t\t\tfor (let subnet_input of subnet_inputs) {\n\t\t\t\tsuccessors.push(subnet_input);\n\t\t\t}\n\t\t\tfor (let subnet_output of subnet_outputs) {\n\t\t\t\tsuccessors.push(subnet_output);\n\t\t\t}\n\t\t}\n\n\t\tfor (let graph_node of successors) {\n\t\t\tconst node = graph_node as TypedNode<NC, any>;\n\t\t\t// we need to check if node.io exists to be sure it is a node, not just a graph_node\n\t\t\tif (node.io && node.io.has_connection_points_controller && node.io.connection_points.initialized()) {\n\t\t\t\tnode.io.connection_points.update_signature_if_required(this.node);\n\t\t\t}\n\t\t}\n\t\t// we also need to have subnet_output nodes update their parents\n\t\t// if (this.node.type == NetworkChildNodeType.OUTPUT) {\n\t\t// this.node.parent?.io.connection_points.update_signature_if_required(this.node);\n\t\t// }\n\t}\n\n\tupdate_connection_types() {\n\t\tconst set_dirty = false;\n\t\tconst expected_input_types = this._wrapped_expected_input_types_function();\n\t\tconst expected_output_types = this._wrapped_expected_output_types_function();\n\n\t\tconst named_input_connection_points: ConnectionPointTypeMap[NC][] = [];\n\t\tfor (let i = 0; i < expected_input_types.length; i++) {\n\t\t\tconst type = expected_input_types[i];\n\t\t\tconst point = this.create_connection_point(this._wrapped_input_name_function(i), type);\n\t\t\tnamed_input_connection_points.push(point);\n\t\t}\n\t\tconst named_output_connect_points: ConnectionPointTypeMap[NC][] = [];\n\t\tfor (let i = 0; i < expected_output_types.length; i++) {\n\t\t\tconst type = expected_output_types[i];\n\t\t\tconst point = this.create_connection_point(this._wrapped_output_name_function(i), type);\n\t\t\tnamed_output_connect_points.push(point);\n\t\t}\n\n\t\tthis.node.io.inputs.setNamedInputConnectionPoints(named_input_connection_points);\n\n\t\tthis.node.io.outputs.setNamedOutputConnectionPoints(named_output_connect_points, set_dirty);\n\t\tif (this._create_spare_params_from_inputs) {\n\t\t\tthis._spare_params_controller.create_spare_parameters();\n\t\t}\n\t}\n\n\tprotected _connections_match_inputs(): boolean {\n\t\tconst current_input_types = this.node.io.inputs.named_input_connection_points.map((c) => c?.type());\n\t\tconst current_output_types = this.node.io.outputs.named_output_connection_points.map((c) => c?.type());\n\t\tconst expected_input_types = this._wrapped_expected_input_types_function();\n\t\tconst expected_output_types = this._wrapped_expected_output_types_function();\n\n\t\tif (expected_input_types.length != current_input_types.length) {\n\t\t\treturn false;\n\t\t}\n\t\tif (expected_output_types.length != current_output_types.length) {\n\t\t\treturn false;\n\t\t}\n\n\t\tfor (let i = 0; i < current_input_types.length; i++) {\n\t\t\tif (current_input_types[i] != expected_input_types[i]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tfor (let i = 0; i < current_output_types.length; i++) {\n\t\t\tif (current_output_types[i] != expected_output_types[i]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t//\n\t//\n\t// WRAPPPED METHOD\n\t// the goal here is to use the types data saved in the scene file\n\t// when the scene is loading. That has 2 purposes:\n\t// - avoid an update cascade during loading, where nodes with many inputs are updated\n\t//\t several times.\n\t// - allow the subnet_input to load with the connection_points it had on save,\n\t//   which in turn allows connected nodes to not lose their connections.\n\t//\n\tprivate _wrapped_expected_input_types_function() {\n\t\tif (this.node.scene().loadingController.isLoading()) {\n\t\t\tconst in_data = this.node.io.saved_connection_points_data.in();\n\t\t\tif (in_data) {\n\t\t\t\treturn in_data.map((d) => d.type as ConnectionPointEnumMap[NC]);\n\t\t\t}\n\t\t}\n\t\treturn this._expected_input_types_function();\n\t}\n\tprivate _wrapped_expected_output_types_function() {\n\t\tif (this.node.scene().loadingController.isLoading()) {\n\t\t\tconst out_data = this.node.io.saved_connection_points_data.out();\n\t\t\tif (out_data) {\n\t\t\t\treturn out_data.map((d) => d.type as ConnectionPointEnumMap[NC]);\n\t\t\t}\n\t\t}\n\t\treturn this._expected_output_types_function();\n\t}\n\tprivate _wrapped_input_name_function(index: number) {\n\t\tif (this.node.scene().loadingController.isLoading()) {\n\t\t\tconst in_data = this.node.io.saved_connection_points_data.in();\n\t\t\tif (in_data) {\n\t\t\t\treturn in_data[index].name;\n\t\t\t}\n\t\t}\n\t\treturn this._input_name_function(index);\n\t}\n\tprivate _wrapped_output_name_function(index: number) {\n\t\tif (this.node.scene().loadingController.isLoading()) {\n\t\t\tconst out_data = this.node.io.saved_connection_points_data.out();\n\t\t\tif (out_data) {\n\t\t\t\treturn out_data[index].name;\n\t\t\t}\n\t\t}\n\t\treturn this._output_name_function(index);\n\t}\n\n\t// protected input_connection_type() {\n\t// \treturn this.first_input_connection_type();\n\t// }\n\t// protected output_connection_type() {\n\t// \treturn this.first_input_connection_type();\n\t// }\n\n\tfirst_input_connection_type(): ConnectionPointEnumMap[NC] | undefined {\n\t\treturn this.input_connection_type(0);\n\t}\n\tinput_connection_type(index: number): ConnectionPointEnumMap[NC] | undefined {\n\t\tconst connections = this.node.io.connections.inputConnections();\n\t\tif (connections) {\n\t\t\tconst connection = connections[index];\n\t\t\tif (connection) {\n\t\t\t\treturn connection.src_connection_point()!.type() as ConnectionPointEnumMap[NC];\n\t\t\t}\n\t\t}\n\t}\n\t// input_connection_point_from_connection(connection: TypedNodeConnection<NC>): ConnectionPointTypeMap[NC] {\n\t// \tconst node_dest = connection.node_dest;\n\t// \tconst output_index = connection.output_index;\n\t// \treturn node_dest.io.outputs.named_output_connection_points[output_index] as ConnectionPointTypeMap[NC];\n\t// }\n\t// output_connection_point_from_connection(connection: TypedNodeConnection<NC>): ConnectionPointTypeMap[NC] {\n\t// \tconst node_src = connection.node_src;\n\t// \tconst output_index = connection.output_index;\n\t// \treturn node_src.io.outputs.named_output_connection_points[output_index] as ConnectionPointTypeMap[NC];\n\t// }\n\t// connection_point_type_from_connection(connection: TypedNodeConnection<NC>): ConnectionPointEnumMap[NC] {\n\t// \treturn connection.dest_connection_point()?.type as ConnectionPointEnumMap[NC];\n\t// \t// const connection_point = this.output_connection_point_from_connection(connection)!;\n\t// \t// return connection_point.type as ConnectionPointEnumMap[NC];\n\t// }\n\t// connection_point_name_from_connection(connection: TypedNodeConnection<NC>): string {\n\t// \treturn connection.dest_connection_point()!.name\n\t// \t// const connection_point = this.output_connection_point_from_connection(connection)!;\n\t// \t// return connection_point.name;\n\t// }\n}\n","import {InputsController} from './InputsController';\nimport {OutputsController} from './OutputsController';\nimport {ConnectionsController} from './ConnectionsController';\nimport {SavedConnectionPointsDataController} from './SavedConnectionPointsDataController';\nimport {NodeContext} from '../../../poly/NodeContext';\nimport {TypedNode} from '../../_Base';\nimport {ConnectionPointsController} from './ConnectionPointsController';\nimport {ParamType} from '../../../poly/ParamType';\nimport {ParamInitValueSerializedTypeMap} from '../../../params/types/ParamInitValueSerializedTypeMap';\nimport {ParamOptions} from '../../../params/utils/OptionsController';\nimport {PolyDictionary} from '../../../../types/GlobalTypes';\n\nexport type OverridenOptions = PolyDictionary<string | number>;\n\nexport type SimpleParamJsonExporterData<T extends ParamType> = ParamInitValueSerializedTypeMap[T];\n\nexport interface ComplexParamJsonExporterData<T extends ParamType> {\n\ttype?: T;\n\tdefault_value?: ParamInitValueSerializedTypeMap[T];\n\traw_input?: ParamInitValueSerializedTypeMap[T];\n\toptions?: ParamOptions;\n\toverriden_options?: OverridenOptions;\n\t// components?: ParamJsonExporterDataByName;\n\t// expression?: string;\n}\nexport type ParamJsonExporterData<T extends ParamType> =\n\t| SimpleParamJsonExporterData<T>\n\t| ComplexParamJsonExporterData<T>;\nexport type ParamJsonExporterDataByName = PolyDictionary<ParamJsonExporterData<ParamType>>;\n\nexport type ParamsJsonExporterData = PolyDictionary<ParamJsonExporterData<ParamType>>;\n\nexport interface ParamInitData<T extends ParamType> {\n\traw_input?: ParamInitValueSerializedTypeMap[T];\n\tsimple_data?: SimpleParamJsonExporterData<T>;\n\tcomplex_data?: ComplexParamJsonExporterData<T>;\n}\nexport type ParamsInitData = PolyDictionary<ParamInitData<ParamType>>;\n\nexport class IOController<NC extends NodeContext> {\n\tprotected _inputs: InputsController<NC> | undefined;\n\tprotected _outputs: OutputsController<NC> | undefined;\n\tprotected _connections: ConnectionsController<NC> = new ConnectionsController(this.node);\n\tprotected _saved_connection_points_data: SavedConnectionPointsDataController<NC> | undefined;\n\tprotected _connection_points: ConnectionPointsController<NC> | undefined;\n\n\tconstructor(protected node: TypedNode<NC, any>) {}\n\n\tget connections() {\n\t\treturn this._connections;\n\t}\n\n\t//\n\t//\n\t// inputs\n\t//\n\t//\n\tget inputs(): InputsController<NC> {\n\t\treturn (this._inputs = this._inputs || new InputsController(this.node));\n\t}\n\thas_inputs() {\n\t\treturn this._inputs != null;\n\t}\n\n\t//\n\t//\n\t// outputs\n\t//\n\t//\n\tget outputs(): OutputsController<NC> {\n\t\treturn (this._outputs = this._outputs || new OutputsController(this.node));\n\t}\n\thas_outputs() {\n\t\treturn this._outputs != null;\n\t}\n\n\t//\n\t//\n\t// connection_points\n\t//\n\t//\n\tget connection_points(): ConnectionPointsController<NC> {\n\t\treturn (this._connection_points =\n\t\t\tthis._connection_points || new ConnectionPointsController(this.node, this.node.nodeContext() as NC));\n\t}\n\tget has_connection_points_controller(): boolean {\n\t\treturn this._connection_points != null;\n\t}\n\n\t//\n\t//\n\t// saved connection points data\n\t//\n\t//\n\tget saved_connection_points_data() {\n\t\treturn (this._saved_connection_points_data =\n\t\t\tthis._saved_connection_points_data || new SavedConnectionPointsDataController(this.node));\n\t}\n\tclear_saved_connection_points_data() {\n\t\tif (this._saved_connection_points_data) {\n\t\t\tthis._saved_connection_points_data.clear();\n\t\t\tthis._saved_connection_points_data = undefined;\n\t\t}\n\t}\n}\n","import {NodeParamsConfig} from './ParamsConfig';\n// import {ParamValuesTypeMap} from './ParamsController';\n// import {ParamType} from '../../../poly/ParamType';\n\n// function getProperty<T, K extends keyof T>(o: T, propertyName: K): T[K] {\n// \treturn o[propertyName]; // o[propertyName] is of type T[K]\n// }\n\n// let t: getProperty(ParamConfig, 'type')\n// function prop<T, K extends keyof T>(obj: T, key: K) {\n// \treturn typeof obj[key];\n// }\n// type test = Pick<ParamConfig<ParamType.FLOAT>, 'default_value'>;\n\nexport type ParamsAccessorType<T extends NodeParamsConfig> = {\n\treadonly [P in keyof T]: T[P]['param_class'];\n};\n\nexport class ParamsAccessor<T extends NodeParamsConfig> {\n\tconstructor() {\n\t\t// console.log('accessor', this);\n\t}\n}\n","import {PolyScene} from '../scene/PolyScene';\nimport {CoreGraphNode} from '../../core/graph/CoreGraphNode';\nimport {UIData} from './utils/UIData';\nimport {FlagsController, FlagsControllerD} from './utils/FlagsController';\nimport {StatesController} from './utils/StatesController';\nimport {HierarchyParentController} from './utils/hierarchy/ParentController';\nimport {HierarchyChildrenController} from './utils/hierarchy/ChildrenController';\nimport {LifeCycleController} from './utils/LifeCycleController';\nimport {TypedContainerController} from './utils/ContainerController';\nimport {NodeCookController} from './utils/CookController';\nimport {NameController} from './utils/NameController';\nimport {NodeSerializer, NodeSerializerData} from './utils/Serializer';\nimport {ParamsController} from './utils/params/ParamsController';\nimport {ParamConstructorMap} from '../params/types/ParamConstructorMap';\nimport {ParamInitValuesTypeMap} from '../params/types/ParamInitValuesTypeMap';\nimport {NodeParamsConfig} from './utils/params/ParamsConfig';\nimport {ParamsValueAccessor, ParamsValueAccessorType} from './utils/params/ParamsValueAccessor';\n// import {ProcessingContext} from './utils/ProcessingContext';\nimport {IOController, ParamsInitData} from './utils/io/IOController';\nimport {NodeEvent} from '../poly/NodeEvent';\nimport {NodeContext} from '../poly/NodeContext';\nimport {ParamsAccessorType, ParamsAccessor} from './utils/params/ParamsAccessor';\n\nexport interface NodeDeletedEmitData {\n\tparent_id: CoreGraphNodeId;\n}\nexport interface NodeCreatedEmitData {\n\tchild_node_json: NodeSerializerData;\n}\ntype EmitDataByNodeEventMapGeneric = {[key in NodeEvent]: any};\nexport interface EmitDataByNodeEventMap extends EmitDataByNodeEventMapGeneric {\n\t[NodeEvent.CREATED]: NodeCreatedEmitData;\n\t[NodeEvent.DELETED]: NodeDeletedEmitData;\n\t[NodeEvent.ERROR_UPDATED]: undefined;\n}\nexport interface IntegrationData {\n\tname: string;\n\tdata: PolyDictionary<string>;\n}\n\n// import {ContainerMap, ContainerType} from '../containers/utils/ContainerMap';\nimport {ContainableMap} from '../containers/utils/ContainableMap';\nimport {ParamOptions} from '../params/utils/OptionsController';\nimport {ParamType} from '../poly/ParamType';\nimport {DisplayNodeController} from './utils/DisplayNodeController';\nimport {NodeTypeMap} from '../containers/utils/ContainerMap';\nimport {ParamInitValueSerialized} from '../params/types/ParamInitValueSerialized';\nimport {ModuleName} from '../poly/registers/modules/_BaseRegister';\nimport {BasePersistedConfig} from './utils/PersistedConfig';\nimport {AssemblerName} from '../poly/registers/assemblers/_BaseRegister';\nimport {PolyNodeController} from './utils/poly/PolyNodeController';\nimport {CoreGraphNodeId} from '../../core/graph/CoreGraph';\nimport {PolyDictionary} from '../../types/GlobalTypes';\n\nexport class TypedNode<NC extends NodeContext, K extends NodeParamsConfig> extends CoreGraphNode {\n\tcontainerController: TypedContainerController<NC> = new TypedContainerController<NC>(this);\n\n\tprivate _parent_controller: HierarchyParentController | undefined;\n\n\tprivate _ui_data: UIData | undefined;\n\n\tprivate _states: StatesController | undefined;\n\tprivate _lifecycle: LifeCycleController | undefined;\n\tprivate _serializer: NodeSerializer | undefined;\n\tprivate _cook_controller: NodeCookController<NC> | undefined;\n\tpublic readonly flags: FlagsController | undefined;\n\tpublic readonly displayNodeController: DisplayNodeController | undefined;\n\tpublic readonly persisted_config: BasePersistedConfig | undefined;\n\n\tprivate _params_controller: ParamsController | undefined;\n\treadonly params_config: K | undefined;\n\treadonly pv: ParamsValueAccessorType<K> = (<unknown>new ParamsValueAccessor<K>()) as ParamsValueAccessorType<K>;\n\t// readonly pv: ParamsValueAccessor<K> = new ParamsValueAccessor<K>(this);\n\treadonly p: ParamsAccessorType<K> = (<unknown>new ParamsAccessor<K>()) as ParamsAccessorType<K>;\n\tcopy_param_values(node: TypedNode<NC, K>) {\n\t\tconst non_spare = this.params.non_spare;\n\t\tfor (let param of non_spare) {\n\t\t\tconst other_param = node.params.get(param.name());\n\t\t\tif (other_param) {\n\t\t\t\tparam.copy_value(other_param);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate _name_controller: NameController | undefined;\n\tget parentController(): HierarchyParentController {\n\t\treturn (this._parent_controller = this._parent_controller || new HierarchyParentController(this));\n\t}\n\tstatic displayedInputNames(): string[] {\n\t\treturn [];\n\t}\n\n\tprivate _children_controller: HierarchyChildrenController | undefined;\n\tprotected _children_controller_context: NodeContext | undefined;\n\tget childrenControllerContext() {\n\t\treturn this._children_controller_context;\n\t}\n\tprivate _create_children_controller(): HierarchyChildrenController | undefined {\n\t\tif (this._children_controller_context) {\n\t\t\treturn new HierarchyChildrenController(this, this._children_controller_context);\n\t\t}\n\t}\n\tget childrenController(): HierarchyChildrenController | undefined {\n\t\treturn (this._children_controller = this._children_controller || this._create_children_controller());\n\t}\n\tchildrenAllowed(): boolean {\n\t\treturn this._children_controller_context != null;\n\t}\n\n\tget uiData(): UIData {\n\t\treturn (this._ui_data = this._ui_data || new UIData(this));\n\t}\n\n\tget states(): StatesController {\n\t\treturn (this._states = this._states || new StatesController(this));\n\t}\n\tget lifecycle(): LifeCycleController {\n\t\treturn (this._lifecycle = this._lifecycle || new LifeCycleController(this));\n\t}\n\tget serializer(): NodeSerializer {\n\t\treturn (this._serializer = this._serializer || new NodeSerializer(this));\n\t}\n\n\tget cookController(): NodeCookController<NC> {\n\t\treturn (this._cook_controller = this._cook_controller || new NodeCookController(this));\n\t}\n\tprotected _io: IOController<NC> | undefined;\n\tget io(): IOController<NC> {\n\t\treturn (this._io = this._io || new IOController(this));\n\t}\n\tget nameController(): NameController {\n\t\treturn (this._name_controller = this._name_controller || new NameController(this));\n\t}\n\tsetName(name: string) {\n\t\tthis.nameController.setName(name);\n\t}\n\t_set_core_name(name: string) {\n\t\tthis._name = name;\n\t}\n\tget params(): ParamsController {\n\t\treturn (this._params_controller = this._params_controller || new ParamsController(this));\n\t}\n\t// get processing_context(): ProcessingContext {\n\t// \treturn (this._processing_context = this._processing_context || new ProcessingContext(this));\n\t// }\n\n\tconstructor(scene: PolyScene, name: string = 'BaseNode', public params_init_value_overrides?: ParamsInitData) {\n\t\tsuper(scene, name);\n\t}\n\n\tprivate _initialized: boolean = false;\n\tpublic initialize_base_and_node() {\n\t\tif (!this._initialized) {\n\t\t\tthis._initialized = true;\n\n\t\t\tthis.displayNodeController?.initializeNode();\n\n\t\t\tthis.initializeBaseNode(); // for base classes of Sop, Obj...\n\t\t\tthis.initializeNode(); // for Derivated node clases, like BoxSop, TransformSop...\n\t\t\tif (this.polyNodeController) {\n\t\t\t\tthis.polyNodeController.initializeNode();\n\t\t\t}\n\t\t} else {\n\t\t\tconsole.warn('node already initialized');\n\t\t}\n\t}\n\tprotected initializeBaseNode() {}\n\tprotected initializeNode() {}\n\n\tstatic type(): string {\n\t\tthrow 'type to be overriden';\n\t}\n\ttype() {\n\t\tconst c = this.constructor as typeof BaseNodeClass;\n\t\treturn c.type();\n\t}\n\tstatic nodeContext(): NodeContext {\n\t\tconsole.error('node has no node_context', this);\n\t\tthrow 'node_context requires override';\n\t}\n\tnodeContext(): NodeContext {\n\t\tconst c = this.constructor as typeof BaseNodeClass;\n\t\treturn c.nodeContext();\n\t}\n\n\tstatic require_webgl2(): boolean {\n\t\treturn false;\n\t}\n\trequire_webgl2(): boolean {\n\t\tconst c = this.constructor as typeof BaseNodeClass;\n\t\treturn c.require_webgl2();\n\t}\n\n\tsetParent(parent: BaseNodeType | null) {\n\t\tthis.parentController.setParent(parent);\n\t}\n\tparent() {\n\t\treturn this.parentController.parent();\n\t}\n\troot() {\n\t\treturn this._scene.root();\n\t}\n\tfullPath(relative_to_parent?: BaseNodeType): string {\n\t\treturn this.parentController.fullPath(relative_to_parent);\n\t}\n\n\t// params\n\tcreate_params() {}\n\taddParam<T extends ParamType>(\n\t\ttype: T,\n\t\tname: string,\n\t\tdefault_value: ParamInitValuesTypeMap[T],\n\t\toptions?: ParamOptions\n\t): ParamConstructorMap[T] | undefined {\n\t\treturn this._params_controller?.addParam(type, name, default_value, options);\n\t}\n\tparam_default_value(name: string): ParamInitValueSerialized {\n\t\treturn null;\n\t}\n\n\t// cook\n\tcook(input_contents: any[]): any {\n\t\treturn null;\n\t}\n\n\t// container\n\tasync requestContainer() {\n\t\tif (!this.isDirty()) {\n\t\t\treturn this.containerController.container;\n\t\t} else {\n\t\t\treturn await this.containerController.requestContainer();\n\t\t}\n\t}\n\tsetContainer(content: ContainableMap[NC], message: string | null = null) {\n\t\t// TODO: typescript: why is this a type of never\n\t\tthis.containerController.container.set_content(content as never); //, this.self.cook_eval_key());\n\t\tif (content != null) {\n\t\t\tif (!(content as any).name) {\n\t\t\t\t(content as any).name = this.fullPath();\n\t\t\t}\n\t\t\tif (!(content as any).node) {\n\t\t\t\t(content as any).node = this;\n\t\t\t}\n\t\t}\n\t\tthis.cookController.end_cook(message);\n\t}\n\n\t// hierarchy\n\tcreateNode(node_class: any, params_init_value_overrides?: ParamsInitData) {\n\t\treturn this.childrenController?.createNode(node_class, params_init_value_overrides);\n\t}\n\tcreate_operation_container(\n\t\ttype: string,\n\t\toperation_container_name: string,\n\t\tparams_init_value_overrides?: ParamsInitData\n\t) {\n\t\treturn this.childrenController?.create_operation_container(\n\t\t\ttype,\n\t\t\toperation_container_name,\n\t\t\tparams_init_value_overrides\n\t\t);\n\t}\n\tremoveNode(node: BaseNodeType) {\n\t\tthis.childrenController?.removeNode(node);\n\t}\n\tdispose() {\n\t\tsuper.dispose();\n\t\tthis.setParent(null);\n\t\tthis.io.inputs.dispose();\n\t\tthis.lifecycle.dispose();\n\t\tthis.displayNodeController?.dispose();\n\t\tthis.nameController.dispose();\n\t\tthis.childrenController?.dispose();\n\t\tthis.params.dispose();\n\t}\n\n\tchildren() {\n\t\treturn this.childrenController?.children() || [];\n\t}\n\tnode(path: string) {\n\t\treturn this.parentController?.find_node(path) || null;\n\t}\n\tnodeSibbling(name: string): NodeTypeMap[NC] | null {\n\t\tconst parent = this.parent();\n\t\tif (parent) {\n\t\t\tconst node = parent.childrenController?.child_by_name(name);\n\t\t\tif (node) {\n\t\t\t\treturn node as NodeTypeMap[NC];\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\tnodesByType(type: string) {\n\t\treturn this.childrenController?.nodesByType(type) || [];\n\t}\n\n\t// inputs\n\tsetInput(\n\t\tinput_index_or_name: number | string,\n\t\tnode: NodeTypeMap[NC] | null,\n\t\toutput_index_or_name: number | string = 0\n\t) {\n\t\tthis.io.inputs.setInput(input_index_or_name, node, output_index_or_name);\n\t}\n\n\t// emit\n\temit(event_name: NodeEvent.CREATED, data: EmitDataByNodeEventMap[NodeEvent.CREATED]): void;\n\temit(event_name: NodeEvent.DELETED, data: EmitDataByNodeEventMap[NodeEvent.DELETED]): void;\n\temit(event_name: NodeEvent.NAME_UPDATED): void;\n\temit(event_name: NodeEvent.OVERRIDE_CLONABLE_STATE_UPDATE): void;\n\temit(event_name: NodeEvent.NAMED_INPUTS_UPDATED): void;\n\temit(event_name: NodeEvent.NAMED_OUTPUTS_UPDATED): void;\n\temit(event_name: NodeEvent.INPUTS_UPDATED): void;\n\temit(event_name: NodeEvent.PARAMS_UPDATED): void;\n\temit(event_name: NodeEvent.UI_DATA_POSITION_UPDATED): void;\n\temit(event_name: NodeEvent.UI_DATA_COMMENT_UPDATED): void;\n\temit(event_name: NodeEvent.ERROR_UPDATED): void;\n\temit(event_name: NodeEvent.FLAG_BYPASS_UPDATED): void;\n\temit(event_name: NodeEvent.FLAG_DISPLAY_UPDATED): void;\n\temit(event_name: NodeEvent.FLAG_OPTIMIZE_UPDATED): void;\n\temit(event_name: NodeEvent.SELECTION_UPDATED): void;\n\temit(event_name: NodeEvent, data: object | null = null): void {\n\t\tthis.scene().dispatchController.dispatch(this, event_name, data);\n\t}\n\n\t// serializer\n\ttoJSON(include_param_components: boolean = false) {\n\t\treturn this.serializer.toJSON(include_param_components);\n\t}\n\n\t// modules\n\tpublic async requiredModules(): Promise<ModuleName[] | void> {}\n\tpublic usedAssembler(): AssemblerName | void {}\n\tpublic integrationData(): IntegrationData | void {}\n\n\t// poly nodes\n\tpublic readonly polyNodeController: PolyNodeController | undefined;\n}\n\nexport type BaseNodeType = TypedNode<any, any>;\nexport class BaseNodeClass extends TypedNode<any, any> {}\n\nexport class BaseNodeClassWithDisplayFlag extends TypedNode<any, any> {\n\tpublic readonly flags: FlagsControllerD = new FlagsControllerD(this);\n}\n","import {BaseNodeType} from '../../_Base';\n\ntype FlagHookCallback = () => void;\n\nexport class BaseFlag {\n\tprotected _state: boolean = true;\n\tprotected _hooks: FlagHookCallback[] | null = null;\n\tconstructor(protected node: BaseNodeType) {}\n\n\tonUpdate(hook: FlagHookCallback) {\n\t\tthis._hooks = this._hooks || [];\n\t\tthis._hooks.push(hook);\n\t}\n\tprotected _on_update() {}\n\tset(new_state: boolean) {\n\t\tif (this._state != new_state) {\n\t\t\tthis._state = new_state;\n\t\t\tthis._on_update();\n\t\t\tthis.runHooks();\n\t\t}\n\t}\n\tactive() {\n\t\treturn this._state;\n\t}\n\ttoggle() {\n\t\tthis.set(!this._state);\n\t}\n\tprivate runHooks() {\n\t\tif (this._hooks) {\n\t\t\tfor (let hook of this._hooks) {\n\t\t\t\thook();\n\t\t\t}\n\t\t}\n\t}\n}\n","import {BaseFlag} from './Base';\nimport {NodeEvent} from '../../../poly/NodeEvent';\n\nexport class BypassFlag extends BaseFlag {\n\tprotected _state: boolean = false;\n\tprotected _on_update() {\n\t\tthis.node.emit(NodeEvent.FLAG_BYPASS_UPDATED);\n\t\tthis.node.setDirty();\n\t}\n}\n","import {BaseFlag} from './Base';\nimport {NodeEvent} from '../../../poly/NodeEvent';\n\nexport class DisplayFlag extends BaseFlag {\n\tprotected _on_update() {\n\t\tthis.node.emit(NodeEvent.FLAG_DISPLAY_UPDATED);\n\t\t// this.node.setDirty();\n\t}\n}\n","import {BaseFlag} from './Base';\nimport {NodeEvent} from '../../../poly/NodeEvent';\n\nexport class OptimizeFlag extends BaseFlag {\n\tprotected _state: boolean = false;\n\tprotected _on_update() {\n\t\tthis.node.emit(NodeEvent.FLAG_OPTIMIZE_UPDATED);\n\t}\n}\n","import {Constructor} from '../../../types/GlobalTypes';\nimport {BaseNodeType} from '../_Base';\nimport {BypassFlag} from './flags/Bypass';\nimport {DisplayFlag} from './flags/Display';\nimport {OptimizeFlag} from './flags/Optimize';\n\nexport class FlagsController {\n\tpublic readonly bypass: DisplayFlag | undefined;\n\tpublic readonly display: BypassFlag | undefined;\n\tpublic readonly optimize: OptimizeFlag | undefined;\n\tconstructor(protected node: BaseNodeType) {}\n\thas_display(): boolean {\n\t\treturn false;\n\t}\n\thas_bypass(): boolean {\n\t\treturn false;\n\t}\n\thas_optimize(): boolean {\n\t\treturn false;\n\t}\n}\n\nfunction Display<TBase extends Constructor>(Base: TBase) {\n\treturn class Mixin extends Base {\n\t\tprotected node!: BaseNodeType;\n\t\tpublic display: DisplayFlag = new DisplayFlag(this.node);\n\t\thas_display(): boolean {\n\t\t\treturn true;\n\t\t}\n\t};\n}\nfunction Bypass<TBase extends Constructor>(Base: TBase) {\n\treturn class Mixin extends Base {\n\t\tprotected node!: BaseNodeType;\n\t\tpublic readonly bypass: BypassFlag = new BypassFlag(this.node);\n\t\thas_bypass(): boolean {\n\t\t\treturn true;\n\t\t}\n\t};\n}\nfunction Optimize<TBase extends Constructor>(Base: TBase) {\n\treturn class Mixin extends Base {\n\t\tprotected node!: BaseNodeType;\n\t\tpublic readonly optimize: OptimizeFlag = new OptimizeFlag(this.node);\n\t\thas_optimize(): boolean {\n\t\t\treturn true;\n\t\t}\n\t};\n}\n\nexport class FlagsControllerD extends Display(FlagsController) {}\nexport class FlagsControllerB extends Bypass(FlagsController) {}\nexport class FlagsControllerDB extends Bypass(Display(FlagsController)) {}\nexport class FlagsControllerBO extends Optimize(Bypass(FlagsController)) {}\nexport class FlagsControllerDBO extends Optimize(Bypass(Display(FlagsController))) {}\n","// import {BaseNode} from '../../_Base';\nimport {Number2, Number3, Number4, PolyDictionary} from '../../../../types/GlobalTypes';\nimport {ParamType} from '../../../poly/ParamType';\nimport {ParamOptions} from '../../../params/utils/OptionsController';\nimport {RampParam} from '../../../params/Ramp';\nimport {ParamValuesTypeMap} from '../../../params/types/ParamValuesTypeMap';\nimport {ParamInitValuesTypeMap} from '../../../params/types/ParamInitValuesTypeMap';\nimport {ParamConstructorMap} from '../../../params/types/ParamConstructorMap';\nimport {ParamOptionsByTypeMap} from '../../../params/types/ParamOptionsByTypeMap';\nimport {Color} from 'three/src/math/Color';\nimport {Vector2} from 'three/src/math/Vector2';\nimport {Vector3} from 'three/src/math/Vector3';\nimport {Vector4} from 'three/src/math/Vector4';\n\n// function _ParamCheckNameConsistency<T extends BaseNode>(name: string, target: T, key: keyof T, type: ParamType) {\n// \tconst key_s = key as string;\n// \tif (key_s != `_param_${name}`) {\n// \t\tconsole.warn('param name inconsistent');\n// \t}\n// \tconst param = target.params.get(name);\n// \tif (param && param.type != type) {\n// \t\tconsole.warn('param type inconsistent');\n// \t}\n// }\n// export const _ParamBoolean = function ParamF(name: string) {\n// \treturn <T extends BaseNode>(target: T, key: keyof T) => {\n// \t\t_ParamCheckNameConsistency(name, target, key, ParamType.BOOLEAN);\n// \t\tObject.defineProperty(target, key, {\n// \t\t\tget: () => target.params.boolean(name),\n// \t\t});\n// \t};\n// };\n// export const _ParamFloat = function ParamF(name: string) {\n// \treturn <T extends BaseNode>(target: T, key: keyof T) => {\n// \t\t_ParamCheckNameConsistency(name, target, key, ParamType.FLOAT);\n// \t\tObject.defineProperty(target, key, {\n// \t\t\tget: () => target.params.float(name),\n// \t\t});\n// \t};\n// };\n// export const _ParamFloat = function ParamF(default_value: number, options?: ParamOptions) {\n// \treturn <T extends NodeParamsConfig>(target: T, key: string) => {\n// \t\t// _ParamCheckNameConsistency(name, target, key, ParamType.FLOAT);\n// \t\t// const config = new ParamConfig(ParamType.FLOAT, default_value, options);\n// \t\t// target.add_config(key, config);\n// \t\t// target.set_default_value(key, default_value);\n// \t\t// target.set_options(key, options);\n// \t\t// Object.defineProperty(target.options, key, {\n// \t\t// \tget: () => target.params.float(name),\n// \t\t// });\n// \t};\n// };\n// export const _ParamString = function ParamF(name: string) {\n// \treturn <T extends BaseNode>(target: T, key: keyof T) => {\n// \t\t_ParamCheckNameConsistency(name, target, key, ParamType.STRING);\n// \t\tObject.defineProperty(target, key, {\n// \t\t\tget: () => target.params.string(name),\n// \t\t});\n// \t};\n// };\n// export const _ParamVector2 = function ParamF(name: string) {\n// \treturn <T extends BaseNode>(target: T, key: keyof T) => {\n// \t\t_ParamCheckNameConsistency(name, target, key, ParamType.VECTOR2);\n// \t\tObject.defineProperty(target, key, {\n// \t\t\tget: () => target.params.vector2(name),\n// \t\t});\n// \t};\n// };\n// export const _ParamVector3 = function ParamF(name: string) {\n// \treturn <T extends BaseNode>(target: T, key: keyof T) => {\n// \t\t_ParamCheckNameConsistency(name, target, key, ParamType.VECTOR3);\n// \t\tObject.defineProperty(target, key, {\n// \t\t\tget: () => target.params.vector3(name),\n// \t\t});\n// \t};\n// };\n// export const _ParamColor = function ParamF(name: string) {\n// \treturn <T extends BaseNode>(target: T, key: keyof T) => {\n// \t\t_ParamCheckNameConsistency(name, target, key, ParamType.COLOR);\n// \t\tObject.defineProperty(target, key, {\n// \t\t\tget: () => target.params.color(name),\n// \t\t});\n// \t};\n// };\n// declare global {\n// \tconst ParamB: typeof _ParamBoolean;\n// \tconst ParamF: typeof _ParamFloat;\n// \tconst ParamS: typeof _ParamString;\n// \tconst ParamV2: typeof _ParamVector2;\n// \tconst ParamV3: typeof _ParamVector3;\n// \tconst ParamC: typeof _ParamColor;\n// }\n// class ParamConfig<T extends ParamType> {\n// \tconstructor(readonly type: T, readonly default_value: ParamValuesTypeMap[T], readonly options: ParamOptions = {}) {}\n// }\nexport class ParamTemplate<T extends ParamType> {\n\treadonly value_type!: ParamValuesTypeMap[T];\n\treadonly param_class!: ParamConstructorMap[T];\n\t// readonly options?: ParamOptions;\n\n\tconstructor(public type: T, public init_value: ParamInitValuesTypeMap[T], public options?: ParamOptions) {}\n}\n\n// class Test1 {\n// \ta: number\n// \tb: string\n// }\n// type test = Extract<typeof Test1, string>;\n// type test2 = Pick<typeof Test1, 'b'>;\n// type test3 = Test1['b'];\n// type test2 = keyof BoxSopParamConfig;\nexport class ParamConfig {\n\t// static _GENERIC<T extends ParamType> (type: T, init_value: ParamInitValuesTypeMap[T], options?: ParamOptions) {\n\t// \treturn new ParamTemplate<T>(type, init_value, options);\n\t// }\n\t// static BUTTON(init_value: ParamInitValuesTypeMap[ParamType.BUTTON], options?: ParamOptions) {\n\t// \treturn this._GENERIC<ParamType.BUTTON>(ParamType.BUTTON, init_value, options)\n\t// }\n\tstatic BUTTON(\n\t\tinit_value: ParamInitValuesTypeMap[ParamType.BUTTON],\n\t\toptions?: ParamOptionsByTypeMap[ParamType.BUTTON]\n\t) {\n\t\treturn new ParamTemplate<ParamType.BUTTON>(ParamType.BUTTON, init_value, options);\n\t}\n\tstatic BOOLEAN(\n\t\tinit_value: ParamInitValuesTypeMap[ParamType.BOOLEAN],\n\t\toptions?: ParamOptionsByTypeMap[ParamType.BOOLEAN]\n\t) {\n\t\treturn new ParamTemplate<ParamType.BOOLEAN>(ParamType.BOOLEAN, init_value, options);\n\t}\n\tstatic COLOR(\n\t\tinit_value: ParamInitValuesTypeMap[ParamType.COLOR],\n\t\toptions?: ParamOptionsByTypeMap[ParamType.COLOR]\n\t) {\n\t\tif (init_value instanceof Color) {\n\t\t\tinit_value = init_value.toArray() as Number3;\n\t\t}\n\t\treturn new ParamTemplate<ParamType.COLOR>(ParamType.COLOR, init_value, options);\n\t}\n\tstatic FLOAT(\n\t\tinit_value: ParamInitValuesTypeMap[ParamType.FLOAT],\n\t\toptions?: ParamOptionsByTypeMap[ParamType.FLOAT]\n\t) {\n\t\treturn new ParamTemplate<ParamType.FLOAT>(ParamType.FLOAT, init_value, options);\n\t}\n\tstatic FOLDER(\n\t\tinit_value: ParamInitValuesTypeMap[ParamType.FOLDER] = null,\n\t\toptions?: ParamOptionsByTypeMap[ParamType.FOLDER]\n\t) {\n\t\treturn new ParamTemplate<ParamType.FOLDER>(ParamType.FOLDER, init_value, options);\n\t}\n\tstatic INTEGER(\n\t\tinit_value: ParamInitValuesTypeMap[ParamType.INTEGER],\n\t\toptions?: ParamOptionsByTypeMap[ParamType.INTEGER]\n\t) {\n\t\treturn new ParamTemplate<ParamType.INTEGER>(ParamType.INTEGER, init_value, options);\n\t}\n\tstatic RAMP(\n\t\tinit_value: ParamInitValuesTypeMap[ParamType.RAMP] = RampParam.DEFAULT_VALUE,\n\t\toptions?: ParamOptionsByTypeMap[ParamType.RAMP]\n\t) {\n\t\treturn new ParamTemplate<ParamType.RAMP>(ParamType.RAMP, init_value, options);\n\t}\n\tstatic SEPARATOR(\n\t\tinit_value: ParamInitValuesTypeMap[ParamType.SEPARATOR] = null,\n\t\toptions?: ParamOptionsByTypeMap[ParamType.SEPARATOR]\n\t) {\n\t\treturn new ParamTemplate<ParamType.SEPARATOR>(ParamType.SEPARATOR, init_value, options);\n\t}\n\tstatic STRING(\n\t\tinit_value: ParamInitValuesTypeMap[ParamType.STRING] = '',\n\t\toptions?: ParamOptionsByTypeMap[ParamType.STRING]\n\t) {\n\t\treturn new ParamTemplate<ParamType.STRING>(ParamType.STRING, init_value, options);\n\t}\n\tstatic VECTOR2(\n\t\tinit_value: ParamInitValuesTypeMap[ParamType.VECTOR2],\n\t\toptions?: ParamOptionsByTypeMap[ParamType.VECTOR2]\n\t) {\n\t\tif (init_value instanceof Vector2) {\n\t\t\tinit_value = init_value.toArray() as Number2;\n\t\t}\n\t\treturn new ParamTemplate<ParamType.VECTOR2>(ParamType.VECTOR2, init_value, options);\n\t}\n\tstatic VECTOR3(\n\t\tinit_value: ParamInitValuesTypeMap[ParamType.VECTOR3],\n\t\toptions?: ParamOptionsByTypeMap[ParamType.VECTOR3]\n\t) {\n\t\tif (init_value instanceof Vector3) {\n\t\t\tinit_value = init_value.toArray() as Number3;\n\t\t}\n\t\treturn new ParamTemplate<ParamType.VECTOR3>(ParamType.VECTOR3, init_value, options);\n\t}\n\tstatic VECTOR4(\n\t\tinit_value: ParamInitValuesTypeMap[ParamType.VECTOR4],\n\t\toptions?: ParamOptionsByTypeMap[ParamType.VECTOR4]\n\t) {\n\t\tif (init_value instanceof Vector4) {\n\t\t\tinit_value = init_value.toArray() as Number4;\n\t\t}\n\t\treturn new ParamTemplate<ParamType.VECTOR4>(ParamType.VECTOR4, init_value, options);\n\t}\n\n\t//\n\t//\n\t// PATH PARAMS\n\t//\n\t//\n\tstatic OPERATOR_PATH(\n\t\tinit_value: ParamInitValuesTypeMap[ParamType.OPERATOR_PATH],\n\t\toptions?: ParamOptionsByTypeMap[ParamType.OPERATOR_PATH]\n\t) {\n\t\treturn new ParamTemplate<ParamType.OPERATOR_PATH>(ParamType.OPERATOR_PATH, init_value, options);\n\t}\n\tstatic NODE_PATH(\n\t\tinit_value: ParamInitValuesTypeMap[ParamType.NODE_PATH],\n\t\toptions?: ParamOptionsByTypeMap[ParamType.NODE_PATH]\n\t) {\n\t\treturn new ParamTemplate<ParamType.NODE_PATH>(ParamType.NODE_PATH, init_value, options);\n\t}\n\tstatic PARAM_PATH(\n\t\tinit_value: ParamInitValuesTypeMap[ParamType.PARAM_PATH],\n\t\toptions?: ParamOptionsByTypeMap[ParamType.PARAM_PATH]\n\t) {\n\t\treturn new ParamTemplate<ParamType.PARAM_PATH>(ParamType.PARAM_PATH, init_value, options);\n\t}\n}\n\nexport class NodeParamsConfig implements PolyDictionary<ParamTemplate<ParamType>> {\n\t[name: string]: ParamTemplate<ParamType>;\n}\n// export class NodeParamsConfig {}\n\n// interface ParamConfig {\n// \ttype: ParamType;\n// \tvalue: any;\n// \toptions?: ParamOptions;\n// }\n// export type ParamConfigsArray = ParamConfig[];\n\n// declare global {\n// \tinterface Window {\n// \t\tParamB: typeof _ParamB;\n// \t\tParamC: typeof _ParamC;\n// \t}\n// }\n// window.ParamC = _ParamC;\n","import {AttribValue, ColorLike, NumericAttribValue, Vector2Like, Vector3Like} from '../../types/GlobalTypes';\nimport {Vector4} from 'three/src/math/Vector4';\nimport {Vector3} from 'three/src/math/Vector3';\nimport {Vector2} from 'three/src/math/Vector2';\nimport {BufferGeometry} from 'three/src/core/BufferGeometry';\nimport {CoreAttribute} from './Attribute';\nimport {CoreGeometry} from './Geometry';\nimport {CoreEntity} from './Entity';\nimport {CoreType} from '../Type';\nimport {Matrix4} from 'three/src/math/Matrix4';\n\nconst ATTRIB_NAMES = {\n\tPOSITION: 'position',\n\tNORMAL: 'normal',\n};\n\nenum ComponentName {\n\tx = 'x',\n\ty = 'y',\n\tz = 'z',\n\tw = 'w',\n\tr = 'r',\n\tg = 'g',\n\tb = 'b',\n}\nconst COMPONENT_INDICES = {\n\tx: 0,\n\ty: 1,\n\tz: 2,\n\tw: 3,\n\tr: 0,\n\tg: 1,\n\tb: 2,\n};\n\nconst PTNUM = 'ptnum';\nconst DOT = '.';\n\nexport class CorePoint extends CoreEntity {\n\t_geometry: BufferGeometry;\n\t_position: Vector3 | undefined;\n\t_normal: Vector3 | undefined;\n\n\tconstructor(private _core_geometry: CoreGeometry, _index: number) {\n\t\tsuper(_index);\n\t\tthis._geometry = this._core_geometry.geometry();\n\t}\n\tapplyMatrix4(matrix: Matrix4) {\n\t\tthis.position().applyMatrix4(matrix);\n\t}\n\n\tcore_geometry() {\n\t\treturn this._core_geometry;\n\t}\n\tgeometry() {\n\t\treturn (this._geometry = this._geometry || this._core_geometry.geometry());\n\t}\n\n\tattribSize(name: string): number {\n\t\tname = CoreAttribute.remap_name(name);\n\t\treturn this._geometry.getAttribute(name).itemSize;\n\t}\n\n\thasAttrib(name: string): boolean {\n\t\tconst remapped_name = CoreAttribute.remap_name(name);\n\t\treturn this._core_geometry.hasAttrib(remapped_name);\n\t}\n\n\tattribValue(name: string, target?: Vector2 | Vector3 | Vector4): AttribValue {\n\t\tif (name === PTNUM) {\n\t\t\treturn this.index();\n\t\t} else {\n\t\t\tlet component_name = null;\n\t\t\tlet component_index = null;\n\t\t\tif (name[name.length - 2] === DOT) {\n\t\t\t\tcomponent_name = name[name.length - 1] as ComponentName;\n\t\t\t\tcomponent_index = COMPONENT_INDICES[component_name];\n\t\t\t\tname = name.substring(0, name.length - 2);\n\t\t\t}\n\t\t\tconst remaped_name = CoreAttribute.remap_name(name);\n\n\t\t\tconst attrib = this._geometry.getAttribute(remaped_name);\n\t\t\tif (attrib) {\n\t\t\t\tconst {array} = attrib;\n\t\t\t\tif (this._core_geometry.isAttribIndexed(remaped_name)) {\n\t\t\t\t\treturn this.indexedAttribValue(remaped_name);\n\t\t\t\t} else {\n\t\t\t\t\tconst size = attrib.itemSize;\n\t\t\t\t\tconst start_index = this._index * size;\n\n\t\t\t\t\tif (component_index == null) {\n\t\t\t\t\t\tswitch (size) {\n\t\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\t\treturn array[start_index];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\t\ttarget = target || new Vector2();\n\t\t\t\t\t\t\t\ttarget.fromArray(array, start_index);\n\t\t\t\t\t\t\t\treturn target;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 3:\n\t\t\t\t\t\t\t\ttarget = target || new Vector3();\n\t\t\t\t\t\t\t\ttarget.fromArray(array, start_index);\n\t\t\t\t\t\t\t\treturn target;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 4:\n\t\t\t\t\t\t\t\ttarget = target || new Vector4();\n\t\t\t\t\t\t\t\ttarget.fromArray(array, start_index);\n\t\t\t\t\t\t\t\treturn target;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tthrow `size not valid (${size})`;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tswitch (size) {\n\t\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\t\treturn array[start_index];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\treturn array[start_index + component_index];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst message = `attrib ${name} not found. availables are: ${Object.keys(\n\t\t\t\t\tthis._geometry.attributes || {}\n\t\t\t\t).join(',')}`;\n\t\t\t\tconsole.warn(message);\n\t\t\t\tthrow message;\n\t\t\t}\n\t\t}\n\t}\n\n\tindexedAttribValue(name: string): string {\n\t\tconst value_index = this.attribValueIndex(name); //attrib.value()\n\t\treturn this._core_geometry.userDataAttrib(name)[value_index];\n\t}\n\tstringAttribValue(name: string) {\n\t\treturn this.indexedAttribValue(name);\n\t}\n\n\tattribValueIndex(name: string): number {\n\t\tif (this._core_geometry.isAttribIndexed(name)) {\n\t\t\treturn this._geometry.getAttribute(name).array[this._index];\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t}\n\tisAttribIndexed(name: string) {\n\t\treturn this._core_geometry.isAttribIndexed(name);\n\t}\n\n\tposition() {\n\t\treturn this._position || (this._position = this._findPosition(new Vector3()));\n\t}\n\tprivate _findPosition(target: Vector3): Vector3 {\n\t\tconst {array} = this._geometry.getAttribute(ATTRIB_NAMES.POSITION);\n\t\treturn target.fromArray(array, this._index * 3);\n\t}\n\tgetPosition(target: Vector3): Vector3 {\n\t\tconst {array} = this._geometry.getAttribute(ATTRIB_NAMES.POSITION);\n\t\treturn target.fromArray(array, this._index * 3);\n\t}\n\tsetPosition(new_position: Vector3) {\n\t\tthis.setAttribValueVector3(ATTRIB_NAMES.POSITION, new_position);\n\t}\n\n\tnormal(): Vector3 {\n\t\tconst {array} = this._geometry.getAttribute(ATTRIB_NAMES.NORMAL);\n\t\tthis._normal = this._normal || new Vector3();\n\t\treturn this._normal.fromArray(array, this._index * 3);\n\t}\n\tsetNormal(new_normal: Vector3) {\n\t\treturn this.setAttribValueVector3(ATTRIB_NAMES.NORMAL, new_normal);\n\t}\n\n\tsetAttribValue(name: string, value: NumericAttribValue | string) {\n\t\t// TODO: this fails if the value is null\n\t\tif (value == null) {\n\t\t\treturn;\n\t\t}\n\t\tif (name == null) {\n\t\t\tthrow 'Point.set_attrib_value requires a name';\n\t\t}\n\n\t\tconst attrib = this._geometry.getAttribute(name);\n\t\tconst array = attrib.array as number[];\n\t\tconst attrib_size = attrib.itemSize;\n\n\t\tif (CoreType.isArray(value)) {\n\t\t\tfor (let i = 0; i < attrib_size; i++) {\n\t\t\t\tarray[this._index * attrib_size + i] = value[i];\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tswitch (attrib_size) {\n\t\t\tcase 1:\n\t\t\t\tarray[this._index] = value as number;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tconst v2 = value as Vector2Like;\n\t\t\t\tarray[this._index * 2 + 0] = v2.x;\n\t\t\t\tarray[this._index * 2 + 1] = v2.y;\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tconst is_color = (value as ColorLike).r != null;\n\t\t\t\tif (is_color) {\n\t\t\t\t\tconst col = value as ColorLike;\n\t\t\t\t\tarray[this._index * 3 + 0] = col.r;\n\t\t\t\t\tarray[this._index * 3 + 1] = col.g;\n\t\t\t\t\tarray[this._index * 3 + 2] = col.b;\n\t\t\t\t} else {\n\t\t\t\t\tconst v3 = value as Vector3Like;\n\t\t\t\t\tarray[this._index * 3 + 0] = v3.x;\n\t\t\t\t\tarray[this._index * 3 + 1] = v3.y;\n\t\t\t\t\tarray[this._index * 3 + 2] = v3.z;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tconsole.warn(`Point.set_attrib_value does not yet allow attrib size ${attrib_size}`);\n\t\t\t\tthrow `attrib size ${attrib_size} not implemented`;\n\t\t}\n\t}\n\tsetAttribValueVector3(name: string, value: Vector3) {\n\t\t// TODO: this fails if the value is null\n\t\tif (value == null) {\n\t\t\treturn;\n\t\t}\n\t\tif (name == null) {\n\t\t\tthrow 'Point.set_attrib_value requires a name';\n\t\t}\n\n\t\tconst attrib = this._geometry.getAttribute(name);\n\t\tconst array = attrib.array as number[];\n\t\tconst i = this._index * 3;\n\n\t\tarray[i] = value.x;\n\t\tarray[i + 1] = value.y;\n\t\tarray[i + 2] = value.z;\n\t}\n\n\tsetAttribIndex(name: string, new_value_index: number) {\n\t\tconst array = this._geometry.getAttribute(name).array as number[];\n\t\treturn (array[this._index] = new_value_index);\n\t}\n}\n","import {NumericAttribValue} from '../../types/GlobalTypes';\nimport {Vector3} from 'three/src/math/Vector3';\nimport {Vector2} from 'three/src/math/Vector2';\nimport {Triangle} from 'three/src/math/Triangle';\nimport {BufferGeometry} from 'three/src/core/BufferGeometry';\nimport {BufferAttribute} from 'three/src/core/BufferAttribute';\nimport {CorePoint} from './Point';\nimport {CoreGeometry} from './Geometry';\nimport {CoreMath} from '../math/_Module';\nimport {ArrayUtils} from '../ArrayUtils';\nimport {Matrix4} from 'three/src/math/Matrix4';\n\ninterface FaceLike {\n\ta: number;\n\tb: number;\n\tc: number;\n}\n\ntype CorePointArray3 = [CorePoint, CorePoint, CorePoint];\ntype Vector3Array2 = [Vector3, Vector3];\ntype Vector3Array3 = [Vector3, Vector3, Vector3];\n\nexport class CoreFace {\n\t_geometry: BufferGeometry;\n\t_points: CorePointArray3 | undefined;\n\t_triangle: Triangle | undefined;\n\t_positions: Vector3Array3 | undefined;\n\t_deltas: Vector3Array2 | undefined;\n\n\tconstructor(private _core_geometry: CoreGeometry, private _index: number) {\n\t\tthis._geometry = this._core_geometry.geometry();\n\t}\n\tindex() {\n\t\treturn this._index;\n\t}\n\tpoints() {\n\t\treturn (this._points = this._points || this._get_points());\n\t}\n\tapplyMatrix4(matrix: Matrix4) {\n\t\tfor (let point of this.points()) {\n\t\t\tpoint.applyMatrix4(matrix);\n\t\t}\n\t}\n\tprivate _get_points(): CorePointArray3 {\n\t\tconst index_array = this._geometry.index?.array || [];\n\t\tconst start = this._index * 3;\n\t\treturn [\n\t\t\tnew CorePoint(this._core_geometry, index_array[start + 0]),\n\t\t\tnew CorePoint(this._core_geometry, index_array[start + 1]),\n\t\t\tnew CorePoint(this._core_geometry, index_array[start + 2]),\n\t\t];\n\t}\n\tpositions() {\n\t\treturn (this._positions = this._positions || this._get_positions());\n\t}\n\tprivate _get_positions(): Vector3Array3 {\n\t\tconst points = this.points();\n\t\treturn [points[0].position(), points[1].position(), points[2].position()];\n\t}\n\ttriangle() {\n\t\treturn (this._triangle = this._triangle || this._get_triangle());\n\t}\n\tprivate _get_triangle(): Triangle {\n\t\tconst positions = this.positions();\n\t\treturn new Triangle(positions[0], positions[1], positions[2]);\n\t}\n\tdeltas() {\n\t\treturn (this._deltas = this._deltas || this._get_deltas());\n\t}\n\tprivate _get_deltas(): Vector3Array2 {\n\t\tconst positions = this.positions();\n\t\treturn [positions[1].clone().sub(positions[0]), positions[2].clone().sub(positions[0])];\n\t}\n\n\tarea(): number {\n\t\treturn this.triangle().getArea();\n\t}\n\tcenter(target: Vector3) {\n\t\tconst positions = this.positions();\n\t\ttarget.x = (positions[0].x + positions[1].x + positions[2].x) / 3;\n\t\ttarget.y = (positions[0].y + positions[1].y + positions[2].y) / 3;\n\t\ttarget.z = (positions[0].z + positions[1].z + positions[2].z) / 3;\n\n\t\treturn target;\n\t}\n\n\trandom_position(seed: number) {\n\t\tlet weights = [CoreMath.randFloat(seed), CoreMath.randFloat(seed * 6541)];\n\n\t\tif (weights[0] + weights[1] > 1) {\n\t\t\tweights[0] = 1 - weights[0];\n\t\t\tweights[1] = 1 - weights[1];\n\t\t}\n\t\treturn this.positions()[0]\n\t\t\t.clone()\n\t\t\t.add(this.deltas()[0].clone().multiplyScalar(weights[0]))\n\t\t\t.add(this.deltas()[1].clone().multiplyScalar(weights[1]));\n\t}\n\t// random_position(seed: number){\n\t// \tlet weights = [\n\t// \t\tCoreMath.rand_float(seed),\n\t// \t\tCoreMath.rand_float(seed*524),\n\t// \t\tCoreMath.rand_float(seed*4631)\n\t// \t]\n\t// \tconst sum = ArrayUtils.sum(weights)\n\t// \tweights = weights.map(w=>w/sum)\n\t// \tconst pos = new Vector3()\n\t// \tlet positions = this.positions().map((p,i)=> p.multiplyScalar(weights[i]))\n\t// \tpositions.forEach(p=>{\n\t// \t\tpos.add(p)\n\t// \t})\n\t// \treturn pos\n\t// }\n\n\tattrib_value_at_position(attrib_name: string, position: Vector3) {\n\t\t// const weights = CoreInterpolate._weights_from_3(position, this._positions)\n\t\tconst barycentric_coordinates = new Vector3();\n\t\tthis.triangle().getBarycoord(position, barycentric_coordinates);\n\t\tconst weights = barycentric_coordinates.toArray();\n\n\t\tconst attrib = this._geometry.attributes[attrib_name];\n\t\tconst attrib_size = attrib.itemSize;\n\t\tconst point_values = this.points().map((point) => point.attribValue(attrib_name));\n\n\t\tlet new_attrib_value;\n\t\tlet sum;\n\t\tlet index = 0;\n\t\tswitch (attrib_size) {\n\t\t\tcase 1: {\n\t\t\t\tsum = 0;\n\t\t\t\tfor (let point_value of point_values as number[]) {\n\t\t\t\t\tsum += point_value * weights[index];\n\t\t\t\t\tindex++;\n\t\t\t\t}\n\t\t\t\tnew_attrib_value = sum;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault: {\n\t\t\t\tfor (let point_value of point_values as Vector3[]) {\n\t\t\t\t\tconst weighted_value = point_value.multiplyScalar(weights[index]);\n\t\t\t\t\tif (sum) {\n\t\t\t\t\t\tsum.add(weighted_value);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsum = weighted_value;\n\t\t\t\t\t}\n\t\t\t\t\tindex++;\n\t\t\t\t}\n\t\t\t\tnew_attrib_value = sum;\n\t\t\t}\n\t\t}\n\t\treturn new_attrib_value;\n\t}\n\n\tstatic interpolated_value(\n\t\tgeometry: BufferGeometry,\n\t\tface: FaceLike,\n\t\tintersect_point: Vector3,\n\t\tattrib: BufferAttribute\n\t) {\n\t\t// let point_index, i, sum\n\t\tconst point_indices = [face.a, face.b, face.c];\n\t\tconst position_attrib = geometry.getAttribute('position');\n\t\tconst position_attrib_array = position_attrib.array;\n\t\tconst point_positions = point_indices.map(\n\t\t\t(point_index) =>\n\t\t\t\tnew Vector3(\n\t\t\t\t\tposition_attrib_array[point_index * 3 + 0],\n\t\t\t\t\tposition_attrib_array[point_index * 3 + 1],\n\t\t\t\t\tposition_attrib_array[point_index * 3 + 2]\n\t\t\t\t)\n\t\t);\n\n\t\tconst attrib_size = attrib.itemSize;\n\t\tconst attrib_array = attrib.array;\n\t\tlet attrib_values: NumericAttribValue[] = [];\n\t\tswitch (attrib_size) {\n\t\t\tcase 1:\n\t\t\t\tattrib_values = point_indices.map((point_index) => attrib_array[point_index]);\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tattrib_values = point_indices.map(\n\t\t\t\t\t(point_index) => new Vector2(attrib_array[point_index * 2 + 0], attrib_array[point_index * 2 + 1])\n\t\t\t\t);\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tattrib_values = point_indices.map(\n\t\t\t\t\t(point_index) =>\n\t\t\t\t\t\tnew Vector3(\n\t\t\t\t\t\t\tattrib_array[point_index * 3 + 0],\n\t\t\t\t\t\t\tattrib_array[point_index * 3 + 1],\n\t\t\t\t\t\t\tattrib_array[point_index * 3 + 2]\n\t\t\t\t\t\t)\n\t\t\t\t);\n\t\t\t\tbreak;\n\t\t}\n\n\t\tconst dist_to_points = point_indices.map((point_index, i) => intersect_point.distanceTo(point_positions[i]));\n\n\t\t// https://math.stackexchange.com/questions/1336386/weighted-average-distance-between-3-or-more-points\n\t\t// TODO: replace this with Core.Math.Interpolate\n\t\tconst distance_total = ArrayUtils.sum([\n\t\t\tdist_to_points[0] * dist_to_points[1],\n\t\t\tdist_to_points[0] * dist_to_points[2],\n\t\t\tdist_to_points[1] * dist_to_points[2],\n\t\t]);\n\n\t\tconst weights = [\n\t\t\t(dist_to_points[1] * dist_to_points[2]) / distance_total,\n\t\t\t(dist_to_points[0] * dist_to_points[2]) / distance_total,\n\t\t\t(dist_to_points[0] * dist_to_points[1]) / distance_total,\n\t\t];\n\n\t\tlet new_attrib_value;\n\t\tswitch (attrib_size) {\n\t\t\tcase 1:\n\t\t\t\tnew_attrib_value = ArrayUtils.sum(\n\t\t\t\t\tpoint_indices.map((point_indx, i) => weights[i] * (attrib_values[i] as number))\n\t\t\t\t);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tvar values = point_indices.map((point_index, i) =>\n\t\t\t\t\t(attrib_values[i] as Vector3).multiplyScalar(weights[i])\n\t\t\t\t);\n\t\t\t\tnew_attrib_value = null;\n\t\t\t\tfor (let value of values) {\n\t\t\t\t\tif (new_attrib_value) {\n\t\t\t\t\t\tnew_attrib_value.add(value);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnew_attrib_value = value;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t}\n\n\t\treturn new_attrib_value;\n\t}\n}\n","import {CorePoint} from '../Point';\nimport {BufferGeometry} from 'three/src/core/BufferGeometry';\nimport {CoreGeometry} from '../Geometry';\nimport {Float32BufferAttribute} from 'three/src/core/BufferAttribute';\nimport {Vector3} from 'three/src/math/Vector3';\nimport {ArrayUtils} from '../../ArrayUtils';\nimport {PolyDictionary} from '../../../types/GlobalTypes';\n\nexport abstract class CoreGeometryBuilderBase {\n\tfrom_points(points: CorePoint[]) {\n\t\tpoints = this._filter_points(points);\n\t\tconst geometry = new BufferGeometry();\n\t\tconst core_geometry = new CoreGeometry(geometry);\n\n\t\tconst first_point = points[0];\n\t\tif (first_point != null) {\n\t\t\tconst old_geometry = first_point.geometry();\n\t\t\tconst old_core_geometry = first_point.core_geometry();\n\n\t\t\t// index\n\t\t\tconst new_index_by_old_index: PolyDictionary<number> = {};\n\t\t\tfor (let i = 0; i < points.length; i++) {\n\t\t\t\tnew_index_by_old_index[points[i].index()] = i;\n\t\t\t}\n\n\t\t\tconst indices = this._indices_from_points(new_index_by_old_index, old_geometry);\n\t\t\tif (indices) {\n\t\t\t\tgeometry.setIndex(indices);\n\t\t\t}\n\n\t\t\t// attributes\n\t\t\tconst {attributes} = old_geometry;\n\t\t\t// const new_attributes = {}\n\t\t\tfor (let attribute_name of Object.keys(attributes)) {\n\t\t\t\tconst attrib_values = old_core_geometry.userDataAttribs()[attribute_name];\n\t\t\t\tconst is_attrib_indexed = attrib_values != null;\n\n\t\t\t\tif (is_attrib_indexed) {\n\t\t\t\t\tconst new_values: string[] = ArrayUtils.uniq(\n\t\t\t\t\t\tpoints.map((point) => point.indexedAttribValue(attribute_name))\n\t\t\t\t\t);\n\t\t\t\t\tconst new_index_by_value: PolyDictionary<number> = {};\n\t\t\t\t\tnew_values.forEach((new_value, i) => (new_index_by_value[new_value] = i));\n\n\t\t\t\t\tcore_geometry.userDataAttribs()[attribute_name] = new_values;\n\n\t\t\t\t\t// const old_attrib = old_geometry.getAttribute(attribute_name)\n\t\t\t\t\t// const old_attrib_array = old_attrib.array\n\t\t\t\t\tconst new_attrib_indices = [];\n\t\t\t\t\tfor (let point of points) {\n\t\t\t\t\t\t// const old_index = old_attrib_array[point.index()]\n\t\t\t\t\t\tconst new_index = new_index_by_value[point.indexedAttribValue(attribute_name)];\n\t\t\t\t\t\tnew_attrib_indices.push(new_index);\n\t\t\t\t\t}\n\n\t\t\t\t\tgeometry.setAttribute(attribute_name, new Float32BufferAttribute(new_attrib_indices, 1));\n\t\t\t\t} else {\n\t\t\t\t\tconst attrib_size = attributes[attribute_name].itemSize;\n\t\t\t\t\tconst values: number[] = new Array(points.length * attrib_size);\n\t\t\t\t\tswitch (attrib_size) {\n\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\tfor (let i = 0; i < points.length; i++) {\n\t\t\t\t\t\t\t\tvalues[i] = points[i].attribValue(attribute_name) as number;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tlet value: Vector3;\n\t\t\t\t\t\t\tfor (let i = 0; i < points.length; i++) {\n\t\t\t\t\t\t\t\tvalue = points[i].attribValue(attribute_name) as Vector3;\n\t\t\t\t\t\t\t\tvalue.toArray(values, i * attrib_size);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tgeometry.setAttribute(attribute_name, new Float32BufferAttribute(values, attrib_size));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn geometry;\n\t}\n\n\tprotected abstract _filter_points(points: CorePoint[]): CorePoint[];\n\tprotected abstract _indices_from_points(\n\t\tnew_index_by_old_index: PolyDictionary<number>,\n\t\told_geometry: BufferGeometry\n\t): number[] | undefined;\n}\n","import {BufferAttribute} from 'three/src/core/BufferAttribute';\nimport {BufferGeometry} from 'three/src/core/BufferGeometry';\nimport {Float32BufferAttribute} from 'three/src/core/BufferAttribute';\nimport {InterleavedBuffer} from 'three/src/core/InterleavedBuffer';\nimport {InterleavedBufferAttribute} from 'three/src/core/InterleavedBufferAttribute';\nimport {TriangleFanDrawMode} from 'three/src/constants';\nimport {TriangleStripDrawMode} from 'three/src/constants';\nimport {TrianglesDrawMode} from 'three/src/constants';\nimport {Vector3} from 'three/src/math/Vector3';\n\nvar BufferGeometryUtils = {\n\n\tcomputeTangents: function ( geometry ) {\n\n\t\tgeometry.computeTangents();\n\t\tconsole.warn( 'THREE.BufferGeometryUtils: .computeTangents() has been removed. Use BufferGeometry.computeTangents() instead.' );\n\n\t},\n\n\t/**\n\t * @param  {Array<BufferGeometry>} geometries\n\t * @param  {Boolean} useGroups\n\t * @return {BufferGeometry}\n\t */\n\tmergeBufferGeometries: function ( geometries, useGroups ) {\n\n\t\tvar isIndexed = geometries[ 0 ].index !== null;\n\n\t\tvar attributesUsed = new Set( Object.keys( geometries[ 0 ].attributes ) );\n\t\tvar morphAttributesUsed = new Set( Object.keys( geometries[ 0 ].morphAttributes ) );\n\n\t\tvar attributes = {};\n\t\tvar morphAttributes = {};\n\n\t\tvar morphTargetsRelative = geometries[ 0 ].morphTargetsRelative;\n\n\t\tvar mergedGeometry = new BufferGeometry();\n\n\t\tvar offset = 0;\n\n\t\tfor ( var i = 0; i < geometries.length; ++ i ) {\n\n\t\t\tvar geometry = geometries[ i ];\n\t\t\tvar attributesCount = 0;\n\n\t\t\t// ensure that all geometries are indexed, or none\n\n\t\t\tif ( isIndexed !== ( geometry.index !== null ) ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\t// gather attributes, exit early if they're different\n\n\t\t\tfor ( var name in geometry.attributes ) {\n\n\t\t\t\tif ( ! attributesUsed.has( name ) ) {\n\n\t\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. All geometries must have compatible attributes; make sure \"' + name + '\" attribute exists among all geometries, or in none of them.' );\n\t\t\t\t\treturn null;\n\n\t\t\t\t}\n\n\t\t\t\tif ( attributes[ name ] === undefined ) attributes[ name ] = [];\n\n\t\t\t\tattributes[ name ].push( geometry.attributes[ name ] );\n\n\t\t\t\tattributesCount ++;\n\n\t\t\t}\n\n\t\t\t// ensure geometries have the same number of attributes\n\n\t\t\tif ( attributesCount !== attributesUsed.size ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. Make sure all geometries have the same number of attributes.' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\t// gather morph attributes, exit early if they're different\n\n\t\t\tif ( morphTargetsRelative !== geometry.morphTargetsRelative ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. .morphTargetsRelative must be consistent throughout all geometries.' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tfor ( var name in geometry.morphAttributes ) {\n\n\t\t\t\tif ( ! morphAttributesUsed.has( name ) ) {\n\n\t\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '.  .morphAttributes must be consistent throughout all geometries.' );\n\t\t\t\t\treturn null;\n\n\t\t\t\t}\n\n\t\t\t\tif ( morphAttributes[ name ] === undefined ) morphAttributes[ name ] = [];\n\n\t\t\t\tmorphAttributes[ name ].push( geometry.morphAttributes[ name ] );\n\n\t\t\t}\n\n\t\t\t// gather .userData\n\n\t\t\tmergedGeometry.userData.mergedUserData = mergedGeometry.userData.mergedUserData || [];\n\t\t\tmergedGeometry.userData.mergedUserData.push( geometry.userData );\n\n\t\t\tif ( useGroups ) {\n\n\t\t\t\tvar count;\n\n\t\t\t\tif ( isIndexed ) {\n\n\t\t\t\t\tcount = geometry.index.count;\n\n\t\t\t\t} else if ( geometry.attributes.position !== undefined ) {\n\n\t\t\t\t\tcount = geometry.attributes.position.count;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. The geometry must have either an index or a position attribute' );\n\t\t\t\t\treturn null;\n\n\t\t\t\t}\n\n\t\t\t\tmergedGeometry.addGroup( offset, count, i );\n\n\t\t\t\toffset += count;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// merge indices\n\n\t\tif ( isIndexed ) {\n\n\t\t\tvar indexOffset = 0;\n\t\t\tvar mergedIndex = [];\n\n\t\t\tfor ( var i = 0; i < geometries.length; ++ i ) {\n\n\t\t\t\tvar index = geometries[ i ].index;\n\n\t\t\t\tfor ( var j = 0; j < index.count; ++ j ) {\n\n\t\t\t\t\tmergedIndex.push( index.getX( j ) + indexOffset );\n\n\t\t\t\t}\n\n\t\t\t\tindexOffset += geometries[ i ].attributes.position.count;\n\n\t\t\t}\n\n\t\t\tmergedGeometry.setIndex( mergedIndex );\n\n\t\t}\n\n\t\t// merge attributes\n\n\t\tfor ( var name in attributes ) {\n\n\t\t\tvar mergedAttribute = this.mergeBufferAttributes( attributes[ name ] );\n\n\t\t\tif ( ! mergedAttribute ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the ' + name + ' attribute.' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tmergedGeometry.setAttribute( name, mergedAttribute );\n\n\t\t}\n\n\t\t// merge morph attributes\n\n\t\tfor ( var name in morphAttributes ) {\n\n\t\t\tvar numMorphTargets = morphAttributes[ name ][ 0 ].length;\n\n\t\t\tif ( numMorphTargets === 0 ) break;\n\n\t\t\tmergedGeometry.morphAttributes = mergedGeometry.morphAttributes || {};\n\t\t\tmergedGeometry.morphAttributes[ name ] = [];\n\n\t\t\tfor ( var i = 0; i < numMorphTargets; ++ i ) {\n\n\t\t\t\tvar morphAttributesToMerge = [];\n\n\t\t\t\tfor ( var j = 0; j < morphAttributes[ name ].length; ++ j ) {\n\n\t\t\t\t\tmorphAttributesToMerge.push( morphAttributes[ name ][ j ][ i ] );\n\n\t\t\t\t}\n\n\t\t\t\tvar mergedMorphAttribute = this.mergeBufferAttributes( morphAttributesToMerge );\n\n\t\t\t\tif ( ! mergedMorphAttribute ) {\n\n\t\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the ' + name + ' morphAttribute.' );\n\t\t\t\t\treturn null;\n\n\t\t\t\t}\n\n\t\t\t\tmergedGeometry.morphAttributes[ name ].push( mergedMorphAttribute );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn mergedGeometry;\n\n\t},\n\n\t/**\n\t * @param {Array<BufferAttribute>} attributes\n\t * @return {BufferAttribute}\n\t */\n\tmergeBufferAttributes: function ( attributes ) {\n\n\t\tvar TypedArray;\n\t\tvar itemSize;\n\t\tvar normalized;\n\t\tvar arrayLength = 0;\n\n\t\tfor ( var i = 0; i < attributes.length; ++ i ) {\n\n\t\t\tvar attribute = attributes[ i ];\n\n\t\t\tif ( attribute.isInterleavedBufferAttribute ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. InterleavedBufferAttributes are not supported.' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tif ( TypedArray === undefined ) TypedArray = attribute.array.constructor;\n\t\t\tif ( TypedArray !== attribute.array.constructor ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes.' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tif ( itemSize === undefined ) itemSize = attribute.itemSize;\n\t\t\tif ( itemSize !== attribute.itemSize ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes.' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tif ( normalized === undefined ) normalized = attribute.normalized;\n\t\t\tif ( normalized !== attribute.normalized ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes.' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tarrayLength += attribute.array.length;\n\n\t\t}\n\n\t\tvar array = new TypedArray( arrayLength );\n\t\tvar offset = 0;\n\n\t\tfor ( var i = 0; i < attributes.length; ++ i ) {\n\n\t\t\tarray.set( attributes[ i ].array, offset );\n\n\t\t\toffset += attributes[ i ].array.length;\n\n\t\t}\n\n\t\treturn new BufferAttribute( array, itemSize, normalized );\n\n\t},\n\n\t/**\n\t * @param {Array<BufferAttribute>} attributes\n\t * @return {Array<InterleavedBufferAttribute>}\n\t */\n\tinterleaveAttributes: function ( attributes ) {\n\n\t\t// Interleaves the provided attributes into an InterleavedBuffer and returns\n\t\t// a set of InterleavedBufferAttributes for each attribute\n\t\tvar TypedArray;\n\t\tvar arrayLength = 0;\n\t\tvar stride = 0;\n\n\t\t// calculate the the length and type of the interleavedBuffer\n\t\tfor ( var i = 0, l = attributes.length; i < l; ++ i ) {\n\n\t\t\tvar attribute = attributes[ i ];\n\n\t\t\tif ( TypedArray === undefined ) TypedArray = attribute.array.constructor;\n\t\t\tif ( TypedArray !== attribute.array.constructor ) {\n\n\t\t\t\tconsole.error( 'AttributeBuffers of different types cannot be interleaved' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tarrayLength += attribute.array.length;\n\t\t\tstride += attribute.itemSize;\n\n\t\t}\n\n\t\t// Create the set of buffer attributes\n\t\tvar interleavedBuffer = new InterleavedBuffer( new TypedArray( arrayLength ), stride );\n\t\tvar offset = 0;\n\t\tvar res = [];\n\t\tvar getters = [ 'getX', 'getY', 'getZ', 'getW' ];\n\t\tvar setters = [ 'setX', 'setY', 'setZ', 'setW' ];\n\n\t\tfor ( var j = 0, l = attributes.length; j < l; j ++ ) {\n\n\t\t\tvar attribute = attributes[ j ];\n\t\t\tvar itemSize = attribute.itemSize;\n\t\t\tvar count = attribute.count;\n\t\t\tvar iba = new InterleavedBufferAttribute( interleavedBuffer, itemSize, offset, attribute.normalized );\n\t\t\tres.push( iba );\n\n\t\t\toffset += itemSize;\n\n\t\t\t// Move the data for each attribute into the new interleavedBuffer\n\t\t\t// at the appropriate offset\n\t\t\tfor ( var c = 0; c < count; c ++ ) {\n\n\t\t\t\tfor ( var k = 0; k < itemSize; k ++ ) {\n\n\t\t\t\t\tiba[ setters[ k ] ]( c, attribute[ getters[ k ] ]( c ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn res;\n\n\t},\n\n\t/**\n\t * @param {Array<BufferGeometry>} geometry\n\t * @return {number}\n\t */\n\testimateBytesUsed: function ( geometry ) {\n\n\t\t// Return the estimated memory used by this geometry in bytes\n\t\t// Calculate using itemSize, count, and BYTES_PER_ELEMENT to account\n\t\t// for InterleavedBufferAttributes.\n\t\tvar mem = 0;\n\t\tfor ( var name in geometry.attributes ) {\n\n\t\t\tvar attr = geometry.getAttribute( name );\n\t\t\tmem += attr.count * attr.itemSize * attr.array.BYTES_PER_ELEMENT;\n\n\t\t}\n\n\t\tvar indices = geometry.getIndex();\n\t\tmem += indices ? indices.count * indices.itemSize * indices.array.BYTES_PER_ELEMENT : 0;\n\t\treturn mem;\n\n\t},\n\n\t/**\n\t * @param {BufferGeometry} geometry\n\t * @param {number} tolerance\n\t * @return {BufferGeometry>}\n\t */\n\tmergeVertices: function ( geometry, tolerance = 1e-4 ) {\n\n\t\ttolerance = Math.max( tolerance, Number.EPSILON );\n\n\t\t// Generate an index buffer if the geometry doesn't have one, or optimize it\n\t\t// if it's already available.\n\t\tvar hashToIndex = {};\n\t\tvar indices = geometry.getIndex();\n\t\tvar positions = geometry.getAttribute( 'position' );\n\t\tvar vertexCount = indices ? indices.count : positions.count;\n\n\t\t// next value for triangle indices\n\t\tvar nextIndex = 0;\n\n\t\t// attributes and new attribute arrays\n\t\tvar attributeNames = Object.keys( geometry.attributes );\n\t\tvar attrArrays = {};\n\t\tvar morphAttrsArrays = {};\n\t\tvar newIndices = [];\n\t\tvar getters = [ 'getX', 'getY', 'getZ', 'getW' ];\n\n\t\t// initialize the arrays\n\t\tfor ( var i = 0, l = attributeNames.length; i < l; i ++ ) {\n\n\t\t\tvar name = attributeNames[ i ];\n\n\t\t\tattrArrays[ name ] = [];\n\n\t\t\tvar morphAttr = geometry.morphAttributes[ name ];\n\t\t\tif ( morphAttr ) {\n\n\t\t\t\tmorphAttrsArrays[ name ] = new Array( morphAttr.length ).fill().map( () => [] );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// convert the error tolerance to an amount of decimal places to truncate to\n\t\tvar decimalShift = Math.log10( 1 / tolerance );\n\t\tvar shiftMultiplier = Math.pow( 10, decimalShift );\n\t\tfor ( var i = 0; i < vertexCount; i ++ ) {\n\n\t\t\tvar index = indices ? indices.getX( i ) : i;\n\n\t\t\t// Generate a hash for the vertex attributes at the current index 'i'\n\t\t\tvar hash = '';\n\t\t\tfor ( var j = 0, l = attributeNames.length; j < l; j ++ ) {\n\n\t\t\t\tvar name = attributeNames[ j ];\n\t\t\t\tvar attribute = geometry.getAttribute( name );\n\t\t\t\tvar itemSize = attribute.itemSize;\n\n\t\t\t\tfor ( var k = 0; k < itemSize; k ++ ) {\n\n\t\t\t\t\t// double tilde truncates the decimal value\n\t\t\t\t\thash += `${ ~ ~ ( attribute[ getters[ k ] ]( index ) * shiftMultiplier ) },`;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// Add another reference to the vertex if it's already\n\t\t\t// used by another index\n\t\t\tif ( hash in hashToIndex ) {\n\n\t\t\t\tnewIndices.push( hashToIndex[ hash ] );\n\n\t\t\t} else {\n\n\t\t\t\t// copy data to the new index in the attribute arrays\n\t\t\t\tfor ( var j = 0, l = attributeNames.length; j < l; j ++ ) {\n\n\t\t\t\t\tvar name = attributeNames[ j ];\n\t\t\t\t\tvar attribute = geometry.getAttribute( name );\n\t\t\t\t\tvar morphAttr = geometry.morphAttributes[ name ];\n\t\t\t\t\tvar itemSize = attribute.itemSize;\n\t\t\t\t\tvar newarray = attrArrays[ name ];\n\t\t\t\t\tvar newMorphArrays = morphAttrsArrays[ name ];\n\n\t\t\t\t\tfor ( var k = 0; k < itemSize; k ++ ) {\n\n\t\t\t\t\t\tvar getterFunc = getters[ k ];\n\t\t\t\t\t\tnewarray.push( attribute[ getterFunc ]( index ) );\n\n\t\t\t\t\t\tif ( morphAttr ) {\n\n\t\t\t\t\t\t\tfor ( var m = 0, ml = morphAttr.length; m < ml; m ++ ) {\n\n\t\t\t\t\t\t\t\tnewMorphArrays[ m ].push( morphAttr[ m ][ getterFunc ]( index ) );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\thashToIndex[ hash ] = nextIndex;\n\t\t\t\tnewIndices.push( nextIndex );\n\t\t\t\tnextIndex ++;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Generate typed arrays from new attribute arrays and update\n\t\t// the attributeBuffers\n\t\tconst result = geometry.clone();\n\t\tfor ( var i = 0, l = attributeNames.length; i < l; i ++ ) {\n\n\t\t\tvar name = attributeNames[ i ];\n\t\t\tvar oldAttribute = geometry.getAttribute( name );\n\n\t\t\tvar buffer = new oldAttribute.array.constructor( attrArrays[ name ] );\n\t\t\tvar attribute = new BufferAttribute( buffer, oldAttribute.itemSize, oldAttribute.normalized );\n\n\t\t\tresult.setAttribute( name, attribute );\n\n\t\t\t// Update the attribute arrays\n\t\t\tif ( name in morphAttrsArrays ) {\n\n\t\t\t\tfor ( var j = 0; j < morphAttrsArrays[ name ].length; j ++ ) {\n\n\t\t\t\t\tvar oldMorphAttribute = geometry.morphAttributes[ name ][ j ];\n\n\t\t\t\t\tvar buffer = new oldMorphAttribute.array.constructor( morphAttrsArrays[ name ][ j ] );\n\t\t\t\t\tvar morphAttribute = new BufferAttribute( buffer, oldMorphAttribute.itemSize, oldMorphAttribute.normalized );\n\t\t\t\t\tresult.morphAttributes[ name ][ j ] = morphAttribute;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// indices\n\n\t\tresult.setIndex( newIndices );\n\n\t\treturn result;\n\n\t},\n\n\t/**\n\t * @param {BufferGeometry} geometry\n\t * @param {number} drawMode\n\t * @return {BufferGeometry>}\n\t */\n\ttoTrianglesDrawMode: function ( geometry, drawMode ) {\n\n\t\tif ( drawMode === TrianglesDrawMode ) {\n\n\t\t\tconsole.warn( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles.' );\n\t\t\treturn geometry;\n\n\t\t}\n\n\t\tif ( drawMode === TriangleFanDrawMode || drawMode === TriangleStripDrawMode ) {\n\n\t\t\tvar index = geometry.getIndex();\n\n\t\t\t// generate index if not present\n\n\t\t\tif ( index === null ) {\n\n\t\t\t\tvar indices = [];\n\n\t\t\t\tvar position = geometry.getAttribute( 'position' );\n\n\t\t\t\tif ( position !== undefined ) {\n\n\t\t\t\t\tfor ( var i = 0; i < position.count; i ++ ) {\n\n\t\t\t\t\t\tindices.push( i );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tgeometry.setIndex( indices );\n\t\t\t\t\tindex = geometry.getIndex();\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.' );\n\t\t\t\t\treturn geometry;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tvar numberOfTriangles = index.count - 2;\n\t\t\tvar newIndices = [];\n\n\t\t\tif ( drawMode === TriangleFanDrawMode ) {\n\n\t\t\t\t// gl.TRIANGLE_FAN\n\n\t\t\t\tfor ( var i = 1; i <= numberOfTriangles; i ++ ) {\n\n\t\t\t\t\tnewIndices.push( index.getX( 0 ) );\n\t\t\t\t\tnewIndices.push( index.getX( i ) );\n\t\t\t\t\tnewIndices.push( index.getX( i + 1 ) );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// gl.TRIANGLE_STRIP\n\n\t\t\t\tfor ( var i = 0; i < numberOfTriangles; i ++ ) {\n\n\t\t\t\t\tif ( i % 2 === 0 ) {\n\n\t\t\t\t\t\tnewIndices.push( index.getX( i ) );\n\t\t\t\t\t\tnewIndices.push( index.getX( i + 1 ) );\n\t\t\t\t\t\tnewIndices.push( index.getX( i + 2 ) );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tnewIndices.push( index.getX( i + 2 ) );\n\t\t\t\t\t\tnewIndices.push( index.getX( i + 1 ) );\n\t\t\t\t\t\tnewIndices.push( index.getX( i ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( ( newIndices.length / 3 ) !== numberOfTriangles ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.' );\n\n\t\t\t}\n\n\t\t\t// build final geometry\n\n\t\t\tvar newGeometry = geometry.clone();\n\t\t\tnewGeometry.setIndex( newIndices );\n\t\t\tnewGeometry.clearGroups();\n\n\t\t\treturn newGeometry;\n\n\t\t} else {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:', drawMode );\n\t\t\treturn geometry;\n\n\t\t}\n\n\t},\n\n\t/**\n\t * Calculates the morphed attributes of a morphed/skinned BufferGeometry.\n\t * Helpful for Raytracing or Decals.\n\t * @param {Mesh | Line | Points} object An instance of Mesh, Line or Points.\n\t * @return {Object} An Object with original position/normal attributes and morphed ones.\n\t */\n\tcomputeMorphedAttributes: function ( object ) {\n\n\t\tif ( object.geometry.isBufferGeometry !== true ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: Geometry is not of type BufferGeometry.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tvar _vA = new Vector3();\n\t\tvar _vB = new Vector3();\n\t\tvar _vC = new Vector3();\n\n\t\tvar _tempA = new Vector3();\n\t\tvar _tempB = new Vector3();\n\t\tvar _tempC = new Vector3();\n\n\t\tvar _morphA = new Vector3();\n\t\tvar _morphB = new Vector3();\n\t\tvar _morphC = new Vector3();\n\n\t\tfunction _calculateMorphedAttributeData(\n\t\t\tobject,\n\t\t\tmaterial,\n\t\t\tattribute,\n\t\t\tmorphAttribute,\n\t\t\tmorphTargetsRelative,\n\t\t\ta,\n\t\t\tb,\n\t\t\tc,\n\t\t\tmodifiedAttributeArray\n\t\t) {\n\n\t\t\t_vA.fromBufferAttribute( attribute, a );\n\t\t\t_vB.fromBufferAttribute( attribute, b );\n\t\t\t_vC.fromBufferAttribute( attribute, c );\n\n\t\t\tvar morphInfluences = object.morphTargetInfluences;\n\n\t\t\tif ( material.morphTargets && morphAttribute && morphInfluences ) {\n\n\t\t\t\t_morphA.set( 0, 0, 0 );\n\t\t\t\t_morphB.set( 0, 0, 0 );\n\t\t\t\t_morphC.set( 0, 0, 0 );\n\n\t\t\t\tfor ( var i = 0, il = morphAttribute.length; i < il; i ++ ) {\n\n\t\t\t\t\tvar influence = morphInfluences[ i ];\n\t\t\t\t\tvar morphAttribute = morphAttribute[ i ];\n\n\t\t\t\t\tif ( influence === 0 ) continue;\n\n\t\t\t\t\t_tempA.fromBufferAttribute( morphAttribute, a );\n\t\t\t\t\t_tempB.fromBufferAttribute( morphAttribute, b );\n\t\t\t\t\t_tempC.fromBufferAttribute( morphAttribute, c );\n\n\t\t\t\t\tif ( morphTargetsRelative ) {\n\n\t\t\t\t\t\t_morphA.addScaledVector( _tempA, influence );\n\t\t\t\t\t\t_morphB.addScaledVector( _tempB, influence );\n\t\t\t\t\t\t_morphC.addScaledVector( _tempC, influence );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t_morphA.addScaledVector( _tempA.sub( _vA ), influence );\n\t\t\t\t\t\t_morphB.addScaledVector( _tempB.sub( _vB ), influence );\n\t\t\t\t\t\t_morphC.addScaledVector( _tempC.sub( _vC ), influence );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t_vA.add( _morphA );\n\t\t\t\t_vB.add( _morphB );\n\t\t\t\t_vC.add( _morphC );\n\n\t\t\t}\n\n\t\t\tif ( object.isSkinnedMesh ) {\n\n\t\t\t\tobject.boneTransform( a, _vA );\n\t\t\t\tobject.boneTransform( b, _vB );\n\t\t\t\tobject.boneTransform( c, _vC );\n\n\t\t\t}\n\n\t\t\tmodifiedAttributeArray[ a * 3 + 0 ] = _vA.x;\n\t\t\tmodifiedAttributeArray[ a * 3 + 1 ] = _vA.y;\n\t\t\tmodifiedAttributeArray[ a * 3 + 2 ] = _vA.z;\n\t\t\tmodifiedAttributeArray[ b * 3 + 0 ] = _vB.x;\n\t\t\tmodifiedAttributeArray[ b * 3 + 1 ] = _vB.y;\n\t\t\tmodifiedAttributeArray[ b * 3 + 2 ] = _vB.z;\n\t\t\tmodifiedAttributeArray[ c * 3 + 0 ] = _vC.x;\n\t\t\tmodifiedAttributeArray[ c * 3 + 1 ] = _vC.y;\n\t\t\tmodifiedAttributeArray[ c * 3 + 2 ] = _vC.z;\n\n\t\t}\n\n\t\tvar geometry = object.geometry;\n\t\tvar material = object.material;\n\n\t\tvar a, b, c;\n\t\tvar index = geometry.index;\n\t\tvar positionAttribute = geometry.attributes.position;\n\t\tvar morphPosition = geometry.morphAttributes.position;\n\t\tvar morphTargetsRelative = geometry.morphTargetsRelative;\n\t\tvar normalAttribute = geometry.attributes.normal;\n\t\tvar morphNormal = geometry.morphAttributes.position;\n\n\t\tvar groups = geometry.groups;\n\t\tvar drawRange = geometry.drawRange;\n\t\tvar i, j, il, jl;\n\t\tvar group, groupMaterial;\n\t\tvar start, end;\n\n\t\tvar modifiedPosition = new Float32Array( positionAttribute.count * positionAttribute.itemSize );\n\t\tvar modifiedNormal = new Float32Array( normalAttribute.count * normalAttribute.itemSize );\n\n\t\tif ( index !== null ) {\n\n\t\t\t// indexed buffer geometry\n\n\t\t\tif ( Array.isArray( material ) ) {\n\n\t\t\t\tfor ( i = 0, il = groups.length; i < il; i ++ ) {\n\n\t\t\t\t\tgroup = groups[ i ];\n\t\t\t\t\tgroupMaterial = material[ group.materialIndex ];\n\n\t\t\t\t\tstart = Math.max( group.start, drawRange.start );\n\t\t\t\t\tend = Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) );\n\n\t\t\t\t\tfor ( j = start, jl = end; j < jl; j += 3 ) {\n\n\t\t\t\t\t\ta = index.getX( j );\n\t\t\t\t\t\tb = index.getX( j + 1 );\n\t\t\t\t\t\tc = index.getX( j + 2 );\n\n\t\t\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\t\t\tobject,\n\t\t\t\t\t\t\tgroupMaterial,\n\t\t\t\t\t\t\tpositionAttribute,\n\t\t\t\t\t\t\tmorphPosition,\n\t\t\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\t\t\ta, b, c,\n\t\t\t\t\t\t\tmodifiedPosition\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\t\t\tobject,\n\t\t\t\t\t\t\tgroupMaterial,\n\t\t\t\t\t\t\tnormalAttribute,\n\t\t\t\t\t\t\tmorphNormal,\n\t\t\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\t\t\ta, b, c,\n\t\t\t\t\t\t\tmodifiedNormal\n\t\t\t\t\t\t);\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tstart = Math.max( 0, drawRange.start );\n\t\t\t\tend = Math.min( index.count, ( drawRange.start + drawRange.count ) );\n\n\t\t\t\tfor ( i = start, il = end; i < il; i += 3 ) {\n\n\t\t\t\t\ta = index.getX( i );\n\t\t\t\t\tb = index.getX( i + 1 );\n\t\t\t\t\tc = index.getX( i + 2 );\n\n\t\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\t\tobject,\n\t\t\t\t\t\tmaterial,\n\t\t\t\t\t\tpositionAttribute,\n\t\t\t\t\t\tmorphPosition,\n\t\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\t\ta, b, c,\n\t\t\t\t\t\tmodifiedPosition\n\t\t\t\t\t);\n\n\t\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\t\tobject,\n\t\t\t\t\t\tmaterial,\n\t\t\t\t\t\tnormalAttribute,\n\t\t\t\t\t\tmorphNormal,\n\t\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\t\ta, b, c,\n\t\t\t\t\t\tmodifiedNormal\n\t\t\t\t\t);\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else if ( positionAttribute !== undefined ) {\n\n\t\t\t// non-indexed buffer geometry\n\n\t\t\tif ( Array.isArray( material ) ) {\n\n\t\t\t\tfor ( i = 0, il = groups.length; i < il; i ++ ) {\n\n\t\t\t\t\tgroup = groups[ i ];\n\t\t\t\t\tgroupMaterial = material[ group.materialIndex ];\n\n\t\t\t\t\tstart = Math.max( group.start, drawRange.start );\n\t\t\t\t\tend = Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) );\n\n\t\t\t\t\tfor ( j = start, jl = end; j < jl; j += 3 ) {\n\n\t\t\t\t\t\ta = j;\n\t\t\t\t\t\tb = j + 1;\n\t\t\t\t\t\tc = j + 2;\n\n\t\t\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\t\t\tobject,\n\t\t\t\t\t\t\tgroupMaterial,\n\t\t\t\t\t\t\tpositionAttribute,\n\t\t\t\t\t\t\tmorphPosition,\n\t\t\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\t\t\ta, b, c,\n\t\t\t\t\t\t\tmodifiedPosition\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\t\t\tobject,\n\t\t\t\t\t\t\tgroupMaterial,\n\t\t\t\t\t\t\tnormalAttribute,\n\t\t\t\t\t\t\tmorphNormal,\n\t\t\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\t\t\ta, b, c,\n\t\t\t\t\t\t\tmodifiedNormal\n\t\t\t\t\t\t);\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tstart = Math.max( 0, drawRange.start );\n\t\t\t\tend = Math.min( positionAttribute.count, ( drawRange.start + drawRange.count ) );\n\n\t\t\t\tfor ( i = start, il = end; i < il; i += 3 ) {\n\n\t\t\t\t\ta = i;\n\t\t\t\t\tb = i + 1;\n\t\t\t\t\tc = i + 2;\n\n\t\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\t\tobject,\n\t\t\t\t\t\tmaterial,\n\t\t\t\t\t\tpositionAttribute,\n\t\t\t\t\t\tmorphPosition,\n\t\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\t\ta, b, c,\n\t\t\t\t\t\tmodifiedPosition\n\t\t\t\t\t);\n\n\t\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\t\tobject,\n\t\t\t\t\t\tmaterial,\n\t\t\t\t\t\tnormalAttribute,\n\t\t\t\t\t\tmorphNormal,\n\t\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\t\ta, b, c,\n\t\t\t\t\t\tmodifiedNormal\n\t\t\t\t\t);\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar morphedPositionAttribute = new Float32BufferAttribute( modifiedPosition, 3 );\n\t\tvar morphedNormalAttribute = new Float32BufferAttribute( modifiedNormal, 3 );\n\n\t\treturn {\n\n\t\t\tpositionAttribute: positionAttribute,\n\t\t\tnormalAttribute: normalAttribute,\n\t\t\tmorphedPositionAttribute: morphedPositionAttribute,\n\t\t\tmorphedNormalAttribute: morphedNormalAttribute\n\n\t\t};\n\n\t}\n\n};\n\nexport { BufferGeometryUtils };\n","import {\n\tColorLike,\n\tNumericAttribValue,\n\tPolyDictionary,\n\tVector2Like,\n\tVector3Like,\n\tVector4Like,\n} from '../../types/GlobalTypes';\nimport {Vector3} from 'three/src/math/Vector3';\nimport {Int32BufferAttribute} from 'three/src/core/BufferAttribute';\nimport {Float32BufferAttribute} from 'three/src/core/BufferAttribute';\nimport {BufferGeometry} from 'three/src/core/BufferGeometry';\nimport {Box3} from 'three/src/math/Box3';\nimport {CorePoint} from './Point';\nimport {CoreFace} from './Face';\nimport {ObjectType, AttribType, AttribSize} from './Constant';\nimport {CoreAttribute} from './Attribute';\nimport {CoreAttributeData} from './AttributeData';\nimport {CoreGeometryBuilderPoints} from './builders/Points';\nimport {CoreGeometryBuilderMerge} from './builders/Merge';\nimport {CoreGeometryBuilderMesh} from './builders/Mesh';\nimport {CoreGeometryBuilderLineSegments} from './builders/LineSegments';\nimport {TypeAssert} from '../../engine/poly/Assert';\nimport {CoreType} from '../Type';\nimport {ArrayUtils} from '../ArrayUtils';\nimport {ObjectUtils} from '../ObjectUtils';\nimport {CoreString} from '../String';\nimport {GroupString} from './Group';\n\nconst IS_INSTANCE_KEY = 'isInstance';\n\nexport class CoreGeometry {\n\t_bounding_box: Box3 | undefined;\n\n\tconstructor(private _geometry: BufferGeometry) {}\n\n\tgeometry() {\n\t\treturn this._geometry;\n\t}\n\tuuid() {\n\t\treturn this._geometry.uuid;\n\t}\n\n\tboundingBox() {\n\t\treturn (this._bounding_box = this._bounding_box || this._create_bounding_box());\n\t}\n\tprivate _create_bounding_box() {\n\t\tthis._geometry.computeBoundingBox();\n\t\tif (this._geometry.boundingBox) {\n\t\t\treturn this._geometry.boundingBox;\n\t\t}\n\t}\n\n\tmarkAsInstance() {\n\t\tthis._geometry.userData[IS_INSTANCE_KEY] = true;\n\t}\n\tstatic markedAsInstance(geometry: BufferGeometry): boolean {\n\t\treturn geometry.userData[IS_INSTANCE_KEY] === true;\n\t}\n\tmarkedAsInstance(): boolean {\n\t\treturn CoreGeometry.markedAsInstance(this._geometry);\n\t}\n\tpositionAttribName() {\n\t\tlet name = 'position';\n\t\tif (this.markedAsInstance()) {\n\t\t\tname = 'instancePosition';\n\t\t}\n\t\treturn name;\n\t}\n\n\tcomputeVertexNormals() {\n\t\tthis._geometry.computeVertexNormals();\n\t}\n\n\tuserDataAttribs() {\n\t\tconst key = 'indexed_attrib_values';\n\t\treturn (this._geometry.userData[key] = this._geometry.userData[key] || {});\n\t}\n\tindexedAttributeNames() {\n\t\treturn Object.keys(this.userDataAttribs() || {});\n\t}\n\tuserDataAttrib(name: string) {\n\t\tname = CoreAttribute.remap_name(name);\n\t\treturn this.userDataAttribs()[name];\n\t}\n\tisAttribIndexed(name: string): boolean {\n\t\tname = CoreAttribute.remap_name(name);\n\t\treturn this.userDataAttrib(name) != null;\n\t}\n\n\thasAttrib(name: string): boolean {\n\t\tif (name === 'ptnum') {\n\t\t\treturn true;\n\t\t}\n\t\tname = CoreAttribute.remap_name(name);\n\t\treturn this._geometry.attributes[name] != null;\n\t}\n\tattribType(name: string) {\n\t\tif (this.isAttribIndexed(name)) {\n\t\t\treturn AttribType.STRING;\n\t\t} else {\n\t\t\treturn AttribType.NUMERIC;\n\t\t}\n\t}\n\n\tstatic attribNames(geometry: BufferGeometry): string[] {\n\t\treturn Object.keys(geometry.attributes);\n\t}\n\tattribNames(): string[] {\n\t\treturn CoreGeometry.attribNames(this._geometry);\n\t}\n\tstatic attribNamesMatchingMask(geometry: BufferGeometry, masks_string: GroupString) {\n\t\tconst masks = CoreString.attribNames(masks_string);\n\n\t\tconst matching_attrib_names: string[] = [];\n\t\tfor (let attrib_name of this.attribNames(geometry)) {\n\t\t\tfor (let mask of masks) {\n\t\t\t\tif (CoreString.matchMask(attrib_name, mask)) {\n\t\t\t\t\tmatching_attrib_names.push(attrib_name);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn ArrayUtils.uniq(matching_attrib_names);\n\t}\n\n\tattribSizes() {\n\t\tconst h: PolyDictionary<AttribSize> = {};\n\t\tfor (let attrib_name of this.attribNames()) {\n\t\t\th[attrib_name] = this._geometry.attributes[attrib_name].itemSize;\n\t\t}\n\t\treturn h;\n\t}\n\tattribSize(name: string): number {\n\t\tlet attrib;\n\t\tname = CoreAttribute.remap_name(name);\n\t\tif ((attrib = this._geometry.attributes[name]) != null) {\n\t\t\treturn attrib.itemSize;\n\t\t} else {\n\t\t\tif (name === 'ptnum') {\n\t\t\t\t// to ensure attrib copy with ptnum as source works\n\t\t\t\treturn 1;\n\t\t\t} else {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tsetIndexedAttributeValues(name: string, values: string[]) {\n\t\tthis.userDataAttribs()[name] = values;\n\t}\n\n\tsetIndexedAttribute(name: string, values: string[], indices: number[]) {\n\t\tthis.setIndexedAttributeValues(name, values);\n\t\tthis._geometry.setAttribute(name, new Int32BufferAttribute(indices, 1));\n\t}\n\n\taddNumericAttrib(name: string, size: number = 1, default_value: NumericAttribValue = 0) {\n\t\tconst values = [];\n\n\t\tlet attribute_added = false;\n\t\tif (CoreType.isNumber(default_value)) {\n\t\t\t// adding number\n\t\t\tfor (let i = 0; i < this.pointsCount(); i++) {\n\t\t\t\tfor (let j = 0; j < size; j++) {\n\t\t\t\t\tvalues.push(default_value);\n\t\t\t\t}\n\t\t\t}\n\t\t\tattribute_added = true;\n\t\t} else {\n\t\t\tif (size > 1) {\n\t\t\t\tif (CoreType.isArray(default_value)) {\n\t\t\t\t\t// adding array\n\t\t\t\t\tfor (let i = 0; i < this.pointsCount(); i++) {\n\t\t\t\t\t\tfor (let j = 0; j < size; j++) {\n\t\t\t\t\t\t\tvalues.push(default_value[j]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tattribute_added = true;\n\t\t\t\t} else {\n\t\t\t\t\t// adding Vector2\n\t\t\t\t\tconst vec2 = default_value as Vector2Like;\n\t\t\t\t\tif (size == 2 && vec2.x != null && vec2.y != null) {\n\t\t\t\t\t\tfor (let i = 0; i < this.pointsCount(); i++) {\n\t\t\t\t\t\t\tvalues.push(vec2.x);\n\t\t\t\t\t\t\tvalues.push(vec2.y);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tattribute_added = true;\n\t\t\t\t\t}\n\t\t\t\t\t// adding Vector3\n\t\t\t\t\tconst vec3 = default_value as Vector3Like;\n\t\t\t\t\tif (size == 3 && vec3.x != null && vec3.y != null && vec3.z != null) {\n\t\t\t\t\t\tfor (let i = 0; i < this.pointsCount(); i++) {\n\t\t\t\t\t\t\tvalues.push(vec3.x);\n\t\t\t\t\t\t\tvalues.push(vec3.y);\n\t\t\t\t\t\t\tvalues.push(vec3.z);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tattribute_added = true;\n\t\t\t\t\t}\n\t\t\t\t\t// adding Color\n\t\t\t\t\tconst col = default_value as ColorLike;\n\t\t\t\t\tif (size == 3 && col.r != null && col.g != null && col.b != null) {\n\t\t\t\t\t\tfor (let i = 0; i < this.pointsCount(); i++) {\n\t\t\t\t\t\t\tvalues.push(col.r);\n\t\t\t\t\t\t\tvalues.push(col.g);\n\t\t\t\t\t\t\tvalues.push(col.b);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tattribute_added = true;\n\t\t\t\t\t}\n\t\t\t\t\t// adding Vector4\n\t\t\t\t\tconst vec4 = default_value as Vector4Like;\n\t\t\t\t\tif (size == 4 && vec4.x != null && vec4.y != null && vec4.z != null && vec4.w != null) {\n\t\t\t\t\t\tfor (let i = 0; i < this.pointsCount(); i++) {\n\t\t\t\t\t\t\tvalues.push(vec4.x);\n\t\t\t\t\t\t\tvalues.push(vec4.y);\n\t\t\t\t\t\t\tvalues.push(vec4.z);\n\t\t\t\t\t\t\tvalues.push(vec4.w);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tattribute_added = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (attribute_added) {\n\t\t\tthis._geometry.setAttribute(name.trim(), new Float32BufferAttribute(values, size));\n\t\t} else {\n\t\t\tconsole.warn(default_value);\n\t\t\tthrow `CoreGeometry.add_numeric_attrib error: no other default value allowed for now in add_numeric_attrib (default given: ${default_value})`;\n\t\t}\n\t}\n\n\tinitPositionAttribute(points_count: number, default_value?: Vector3) {\n\t\tconst values = [];\n\t\tif (default_value == null) {\n\t\t\tdefault_value = new Vector3();\n\t\t}\n\n\t\tfor (let i = 0; i < points_count; i++) {\n\t\t\tvalues.push(default_value.x);\n\t\t\tvalues.push(default_value.y);\n\t\t\tvalues.push(default_value.z);\n\t\t}\n\n\t\treturn this._geometry.setAttribute('position', new Float32BufferAttribute(values, 3));\n\t}\n\n\taddAttribute(name: string, attrib_data: CoreAttributeData) {\n\t\tswitch (attrib_data.type()) {\n\t\t\tcase AttribType.STRING:\n\t\t\t\treturn console.log('TODO: to implement');\n\t\t\tcase AttribType.NUMERIC:\n\t\t\t\treturn this.addNumericAttrib(name, attrib_data.size());\n\t\t}\n\t}\n\n\trenameAttrib(old_name: string, new_name: string) {\n\t\tif (this.isAttribIndexed(old_name)) {\n\t\t\tthis.userDataAttribs()[new_name] = ObjectUtils.clone(this.userDataAttribs()[old_name]);\n\t\t\tdelete this.userDataAttribs()[old_name];\n\t\t}\n\n\t\tconst old_attrib = this._geometry.getAttribute(old_name);\n\t\tthis._geometry.setAttribute(new_name.trim(), new Float32BufferAttribute(old_attrib.array, old_attrib.itemSize));\n\t\treturn this._geometry.deleteAttribute(old_name);\n\t}\n\n\tdeleteAttribute(name: string) {\n\t\tif (this.isAttribIndexed(name)) {\n\t\t\tdelete this.userDataAttribs()[name];\n\t\t}\n\n\t\treturn this._geometry.deleteAttribute(name);\n\t}\n\n\tclone(): BufferGeometry {\n\t\treturn CoreGeometry.clone(this._geometry);\n\t}\n\n\tstatic clone(src_geometry: BufferGeometry): BufferGeometry {\n\t\tlet src_userData;\n\n\t\t// monkey path\n\t\t// for (let attribute_name of Object.keys(src_geometry.attributes)) {\n\t\t// \tconst attribute = src_geometry.getAttribute(attribute_name);\n\t\t// \tif (attribute.constructor.name == InterleavedBufferAttribute.name) {\n\t\t// \t\tMonkeyPatcher.patch(attribute as InterleavedBufferAttribute);\n\t\t// \t}\n\t\t// }\n\n\t\tconst new_geometry = src_geometry.clone();\n\t\tif ((src_userData = src_geometry.userData) != null) {\n\t\t\tnew_geometry.userData = ObjectUtils.cloneDeep(src_userData);\n\t\t}\n\t\treturn new_geometry;\n\t}\n\n\tpointsCount(): number {\n\t\treturn CoreGeometry.pointsCount(this._geometry);\n\t}\n\n\tstatic pointsCount(geometry: BufferGeometry): number {\n\t\tlet position;\n\t\tlet count = 0;\n\t\tconst core_geometry = new this(geometry);\n\t\tlet position_attrib_name = 'position';\n\t\tif (core_geometry.markedAsInstance()) {\n\t\t\tposition_attrib_name = 'instancePosition';\n\t\t}\n\n\t\tif ((position = geometry.getAttribute(position_attrib_name)) != null) {\n\t\t\tlet array;\n\t\t\tif ((array = position.array) != null) {\n\t\t\t\tcount = array.length / 3;\n\t\t\t}\n\t\t}\n\n\t\treturn count;\n\t}\n\n\tpoints(): CorePoint[] {\n\t\t// do not cache, as this gives unexpected results\n\t\t// when the points are updated internaly\n\t\treturn this.pointsFromGeometry();\n\t}\n\tpointsFromGeometry(): CorePoint[] {\n\t\tconst points = [];\n\t\tconst position_attrib = this._geometry.getAttribute(this.positionAttribName());\n\n\t\tif (position_attrib != null) {\n\t\t\tconst points_count = position_attrib.array.length / 3;\n\t\t\tfor (let point_index = 0; point_index < points_count; point_index++) {\n\t\t\t\tconst point = new CorePoint(this, point_index);\n\n\t\t\t\tpoints.push(point);\n\t\t\t}\n\t\t}\n\n\t\treturn points;\n\t}\n\n\tprivate static _mesh_builder = new CoreGeometryBuilderMesh();\n\tprivate static _points_builder = new CoreGeometryBuilderPoints();\n\tprivate static _lines_segment_builder = new CoreGeometryBuilderLineSegments();\n\tstatic geometryFromPoints(points: CorePoint[], object_type: ObjectType) {\n\t\tswitch (object_type) {\n\t\t\tcase ObjectType.MESH:\n\t\t\t\treturn this._mesh_builder.from_points(points);\n\t\t\tcase ObjectType.POINTS:\n\t\t\t\treturn this._points_builder.from_points(points);\n\t\t\tcase ObjectType.LINE_SEGMENTS:\n\t\t\t\treturn this._lines_segment_builder.from_points(points);\n\t\t\tcase ObjectType.OBJECT3D:\n\t\t\t\treturn null;\n\t\t\tcase ObjectType.LOD:\n\t\t\t\treturn null;\n\t\t}\n\t\tTypeAssert.unreachable(object_type);\n\t}\n\n\tstatic merge_geometries(geometries: BufferGeometry[]) {\n\t\treturn CoreGeometryBuilderMerge.merge(geometries);\n\t}\n\n\tsegments() {\n\t\tconst index: Array<number> = (this.geometry().index?.array || []) as Array<number>;\n\t\treturn ArrayUtils.chunk(index, 2);\n\t}\n\n\tfaces(): CoreFace[] {\n\t\treturn this.facesFromGeometry();\n\t}\n\tfacesFromGeometry(): CoreFace[] {\n\t\tconst index_array = this.geometry().index?.array || [];\n\t\tconst faces_count = index_array.length / 3;\n\t\treturn ArrayUtils.range(faces_count).map((i) => new CoreFace(this, i));\n\t}\n}\n","import {BufferGeometry} from 'three/src/core/BufferGeometry';\nimport {CoreGeometry} from '../Geometry';\nimport {BufferGeometryUtils} from '../../../modules/three/examples/jsm/utils/BufferGeometryUtils';\nimport {CoreGeometryIndexBuilder} from '../util/IndexBuilder';\nimport {PolyDictionary} from '../../../types/GlobalTypes';\n\nexport class CoreGeometryBuilderMerge {\n\tstatic merge(geometries: BufferGeometry[]) {\n\t\tif (geometries.length === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\t//\n\t\t// 1/4. add indices if none\n\t\t//\n\t\tfor (let geometry of geometries) {\n\t\t\tCoreGeometryIndexBuilder.create_index_if_none(geometry);\n\t\t}\n\n\t\t//\n\t\t// 2/4. set the new attrib indices for the indexed attributes\n\t\t//\n\t\tconst core_geometries = geometries.map((geometry) => new CoreGeometry(geometry));\n\t\tconst indexed_attribute_names = core_geometries[0].indexedAttributeNames();\n\n\t\tconst new_values_by_attribute_name: PolyDictionary<string[]> = {};\n\t\tfor (let indexed_attribute_name of indexed_attribute_names) {\n\t\t\tconst index_by_values: PolyDictionary<number> = {};\n\t\t\tconst all_geometries_points = [];\n\t\t\tfor (let core_geometry of core_geometries) {\n\t\t\t\tconst geometry_points = core_geometry.points();\n\t\t\t\tfor (let point of geometry_points) {\n\t\t\t\t\tall_geometries_points.push(point);\n\t\t\t\t\tconst value: string = point.indexedAttribValue(indexed_attribute_name);\n\t\t\t\t\t//value_index = point.attribValueIndex(indexed_attribute_name)\n\t\t\t\t\t// TODO: typescript: that doesn't seem right\n\t\t\t\t\tindex_by_values[value] != null\n\t\t\t\t\t\t? index_by_values[value]\n\t\t\t\t\t\t: (index_by_values[value] = Object.keys(index_by_values).length);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst values = Object.keys(index_by_values);\n\t\t\tfor (let point of all_geometries_points) {\n\t\t\t\tconst value = point.indexedAttribValue(indexed_attribute_name);\n\t\t\t\tconst new_index = index_by_values[value];\n\t\t\t\tpoint.setAttribIndex(indexed_attribute_name, new_index);\n\t\t\t}\n\n\t\t\tnew_values_by_attribute_name[indexed_attribute_name] = values;\n\t\t}\n\n\t\t//\n\t\t// 3/4. merge the geos\n\t\t//\n\t\tconst merged_geometry = BufferGeometryUtils.mergeBufferGeometries(geometries);\n\n\t\t//\n\t\t// 4/4. add the index attrib values\n\t\t//\n\n\t\tconst merged_core_geometry = new CoreGeometry(merged_geometry);\n\t\tObject.keys(new_values_by_attribute_name).forEach((indexed_attribute_name) => {\n\t\t\tconst values = new_values_by_attribute_name[indexed_attribute_name];\n\t\t\tmerged_core_geometry.setIndexedAttributeValues(indexed_attribute_name, values);\n\t\t});\n\n\t\tif (merged_geometry) {\n\t\t\tdelete merged_geometry.userData.mergedUserData;\n\t\t}\n\n\t\treturn merged_geometry;\n\t}\n}\n","import {BufferGeometry} from 'three/src/core/BufferGeometry';\nimport {CoreGeometryBuilderBase} from './_Base';\nimport {CorePoint} from '../Point';\nimport {PolyDictionary} from '../../../types/GlobalTypes';\n\nexport class CoreGeometryBuilderMesh extends CoreGeometryBuilderBase {\n\tprotected _filter_points(points: CorePoint[]) {\n\t\t// ensures we only keep points that form a full face.\n\t\t// if a single point from a face is discarded, we remove all 3\n\n\t\tconst first_point = points[0];\n\t\tif (first_point) {\n\t\t\tconst geometry = first_point.geometry();\n\t\t\tconst indices = geometry.getIndex()?.array;\n\n\t\t\tif (indices) {\n\t\t\t\tconst points_by_index: PolyDictionary<CorePoint> = {};\n\t\t\t\tfor (let point of points) {\n\t\t\t\t\tpoints_by_index[point.index()] = point;\n\t\t\t\t}\n\t\t\t\tconst filtered_points: CorePoint[] = [];\n\n\t\t\t\tconst index_length = indices.length;\n\t\t\t\tlet pt0: CorePoint;\n\t\t\t\tlet pt1: CorePoint;\n\t\t\t\tlet pt2: CorePoint;\n\t\t\t\tfor (let i = 0; i < index_length; i += 3) {\n\t\t\t\t\tpt0 = points_by_index[indices[i + 0]];\n\t\t\t\t\tpt1 = points_by_index[indices[i + 1]];\n\t\t\t\t\tpt2 = points_by_index[indices[i + 2]];\n\t\t\t\t\tif (pt0 && pt1 && pt2) {\n\t\t\t\t\t\tfiltered_points.push(pt0);\n\t\t\t\t\t\tfiltered_points.push(pt1);\n\t\t\t\t\t\tfiltered_points.push(pt2);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn filtered_points;\n\t\t\t}\n\t\t}\n\t\treturn [];\n\t}\n\n\tprotected _indices_from_points(new_index_by_old_index: PolyDictionary<number>, old_geometry: BufferGeometry) {\n\t\tconst index_attrib = old_geometry.index;\n\t\tif (index_attrib != null) {\n\t\t\tconst old_indices = index_attrib.array;\n\n\t\t\tconst new_indices: number[] = [];\n\n\t\t\tlet old_index0: number;\n\t\t\tlet old_index1: number;\n\t\t\tlet old_index2: number;\n\t\t\tlet new_index0: number;\n\t\t\tlet new_index1: number;\n\t\t\tlet new_index2: number;\n\t\t\tfor (let i = 0; i < old_indices.length; i += 3) {\n\t\t\t\told_index0 = old_indices[i + 0];\n\t\t\t\told_index1 = old_indices[i + 1];\n\t\t\t\told_index2 = old_indices[i + 2];\n\t\t\t\tnew_index0 = new_index_by_old_index[old_index0];\n\t\t\t\tnew_index1 = new_index_by_old_index[old_index1];\n\t\t\t\tnew_index2 = new_index_by_old_index[old_index2];\n\t\t\t\tif (new_index0 != null && new_index1 != null && new_index2 != null) {\n\t\t\t\t\tnew_indices.push(new_index0);\n\t\t\t\t\tnew_indices.push(new_index1);\n\t\t\t\t\tnew_indices.push(new_index2);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn new_indices;\n\t\t}\n\t}\n}\n","import {BufferGeometry} from 'three/src/core/BufferGeometry';\nimport {CoreGeometryBuilderBase} from './_Base';\nimport {CorePoint} from '../Point';\nimport {PolyDictionary} from '../../../types/GlobalTypes';\n\nexport class CoreGeometryBuilderPoints extends CoreGeometryBuilderBase {\n\tprotected _filter_points(points: CorePoint[]) {\n\t\treturn points;\n\t}\n\n\tprotected _indices_from_points(new_index_by_old_index: PolyDictionary<number>, old_geometry: BufferGeometry) {\n\t\tconst index_attrib = old_geometry.index;\n\t\tif (index_attrib != null) {\n\t\t\tconst old_indices = index_attrib.array;\n\n\t\t\tconst new_indices: number[] = [];\n\n\t\t\tlet old_index: number;\n\t\t\tlet new_index: number;\n\t\t\tfor (let i = 0; i < old_indices.length; i++) {\n\t\t\t\told_index = old_indices[i];\n\t\t\t\tnew_index = new_index_by_old_index[old_index];\n\t\t\t\tif (new_index != null) {\n\t\t\t\t\tnew_indices.push(new_index);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn new_indices;\n\t\t}\n\t}\n}\n","import {BufferGeometry} from 'three/src/core/BufferGeometry';\nimport {CoreGeometryBuilderBase} from './_Base';\nimport {CorePoint} from '../Point';\nimport {PolyDictionary} from '../../../types/GlobalTypes';\n\nexport class CoreGeometryBuilderLineSegments extends CoreGeometryBuilderBase {\n\tprotected _filter_points(points: CorePoint[]) {\n\t\t// ensures we only keep points that form a full segment.\n\t\t// if a single point from a segment is discarded, we remove both\n\n\t\tconst first_point = points[0];\n\t\tif (first_point) {\n\t\t\tconst geometry = first_point.geometry();\n\t\t\tconst indices = geometry.getIndex()?.array;\n\n\t\t\tif (indices) {\n\t\t\t\tconst points_by_index: PolyDictionary<CorePoint> = {};\n\t\t\t\tfor (let point of points) {\n\t\t\t\t\tpoints_by_index[point.index()] = point;\n\t\t\t\t}\n\t\t\t\tconst filtered_points: CorePoint[] = [];\n\n\t\t\t\tconst index_length = indices.length;\n\t\t\t\tlet pt0: CorePoint;\n\t\t\t\tlet pt1: CorePoint;\n\t\t\t\tfor (let i = 0; i < index_length; i += 2) {\n\t\t\t\t\tpt0 = points_by_index[indices[i + 0]];\n\t\t\t\t\tpt1 = points_by_index[indices[i + 1]];\n\t\t\t\t\tif (pt0 && pt1) {\n\t\t\t\t\t\tfiltered_points.push(pt0);\n\t\t\t\t\t\tfiltered_points.push(pt1);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn filtered_points;\n\t\t\t}\n\t\t}\n\t\treturn [];\n\t}\n\n\tprotected _indices_from_points(new_index_by_old_index: PolyDictionary<number>, old_geometry: BufferGeometry) {\n\t\tconst index_attrib = old_geometry.index;\n\t\tif (index_attrib != null) {\n\t\t\tconst old_indices = index_attrib.array;\n\n\t\t\tconst new_indices: number[] = [];\n\n\t\t\tlet old_index0: number;\n\t\t\tlet old_index1: number;\n\t\t\tlet new_index0: number;\n\t\t\tlet new_index1: number;\n\t\t\tfor (let i = 0; i < old_indices.length; i += 2) {\n\t\t\t\told_index0 = old_indices[i];\n\t\t\t\told_index1 = old_indices[i + 1];\n\t\t\t\tnew_index0 = new_index_by_old_index[old_index0];\n\t\t\t\tnew_index1 = new_index_by_old_index[old_index1];\n\t\t\t\tif (new_index0 != null && new_index1 != null) {\n\t\t\t\t\tnew_indices.push(new_index0);\n\t\t\t\t\tnew_indices.push(new_index1);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn new_indices;\n\t\t}\n\t}\n}\n","import {BaseParamType} from '../_Base';\nimport {ParamEvent} from '../../poly/ParamEvent';\nimport {PolyDictionary} from '../../../types/GlobalTypes';\n\nexport class EmitController {\n\t_blocked_emit: boolean = false;\n\t_blocked_parent_emit: boolean = false;\n\t_count_by_event_name: PolyDictionary<number> = {};\n\tconstructor(protected param: BaseParamType) {}\n\n\temitAllowed(): boolean {\n\t\tif (this._blocked_emit === true) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (this.param.scene().loadingController.isLoading()) {\n\t\t\treturn false;\n\t\t}\n\t\t// TODO: should I also prevent nodes from updating\n\t\t// when they are being called in a loop such as from the Copy SOP?\n\t\t//node = this.node()\n\t\t//node? && !node.is_cooking() && this.scene().emit_allowed() # this prevents a camera from updating its param for instance\n\t\t// although maybe I should send a dirty to the store, and then that store queries the param?\n\t\treturn this.param.scene().dispatchController.emitAllowed();\n\t}\n\n\tblockEmit() {\n\t\tthis._blocked_emit = true;\n\t\tif (this.param.isMultiple() && this.param.components) {\n\t\t\tfor (let component of this.param.components) {\n\t\t\t\tcomponent.emitController.blockEmit();\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\tunblockEmit() {\n\t\tthis._blocked_emit = false;\n\t\tif (this.param.isMultiple() && this.param.components) {\n\t\t\tfor (let component of this.param.components) {\n\t\t\t\tcomponent.emitController.unblockEmit();\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\tblockParentEmit() {\n\t\tthis._blocked_parent_emit = true;\n\t\treturn true;\n\t}\n\tunblockParentEmit() {\n\t\tthis._blocked_parent_emit = false;\n\t\treturn true;\n\t}\n\n\tincrementCount(event_name: ParamEvent) {\n\t\tthis._count_by_event_name[event_name] = this._count_by_event_name[event_name] || 0;\n\t\tthis._count_by_event_name[event_name] += 1;\n\t}\n\teventsCount(event_name: ParamEvent): number {\n\t\treturn this._count_by_event_name[event_name] || 0;\n\t}\n\n\temit(event: ParamEvent) {\n\t\tif (this.emitAllowed()) {\n\t\t\tthis.param.emit(event);\n\n\t\t\tif (this.param.parent_param != null && this._blocked_parent_emit !== true) {\n\t\t\t\tthis.param.parent_param.emit(event);\n\t\t\t}\n\t\t}\n\t}\n}\n","import {CoreGraphNodeId} from '../../../core/graph/CoreGraph';\nimport {TypedParam} from '../_Base';\nimport {\n\tParamValueSerializedTypeMap,\n\tParamValuePreConversionSerializedTypeMap,\n} from '../types/ParamValueSerializedTypeMap';\nimport {ParamType} from '../../poly/ParamType';\nimport {ParamInitValueSerializedTypeMap} from '../types/ParamInitValueSerializedTypeMap';\n\nexport interface ParamSerializerData<T extends ParamType> {\n\tname: string;\n\ttype: T;\n\traw_input: ParamInitValueSerializedTypeMap[T];\n\tvalue: ParamValueSerializedTypeMap[T];\n\tvalue_pre_conversion: ParamValuePreConversionSerializedTypeMap[T];\n\texpression?: string;\n\tgraph_node_id: CoreGraphNodeId;\n\t// is_dirty: boolean;\n\terror_message?: string;\n\tis_visible: boolean;\n\tfolder_name?: string;\n\tcomponents?: CoreGraphNodeId[];\n}\n\nexport class ParamSerializer<T extends ParamType> {\n\tconstructor(protected param: TypedParam<T>) {}\n\n\ttoJSON(): ParamSerializerData<T> {\n\t\tconst data: ParamSerializerData<T> = {\n\t\t\tname: this.param.name(),\n\t\t\ttype: this.param.type(),\n\t\t\traw_input: this.rawInput(),\n\t\t\tvalue: this.value(),\n\t\t\tvalue_pre_conversion: this.value_pre_conversion(),\n\t\t\texpression: this.expression(),\n\t\t\tgraph_node_id: this.param.graphNodeId(),\n\t\t\t// is_dirty: this.param.isDirty(),\n\t\t\terror_message: this.error_message(),\n\t\t\tis_visible: this.is_visible(),\n\t\t\t// folder_name: this.param.uiData.folder_name,\n\t\t\tcomponents: undefined,\n\t\t};\n\n\t\tif (this.param.isMultiple() && this.param.components) {\n\t\t\tdata['components'] = this.param.components.map((component) => component.graphNodeId());\n\t\t}\n\n\t\treturn data;\n\t}\n\n\trawInput() {\n\t\treturn this.param.rawInputSerialized();\n\t}\n\tvalue() {\n\t\treturn this.param.valueSerialized();\n\t}\n\tvalue_pre_conversion() {\n\t\treturn this.param.valuePreConversionSerialized();\n\t}\n\texpression() {\n\t\treturn this.param.hasExpression() ? this.param.expressionController?.expression() : undefined;\n\t}\n\terror_message() {\n\t\treturn this.param.states.error.message();\n\t}\n\tis_visible() {\n\t\treturn this.param.options.is_visible();\n\t}\n}\n","import {BaseParamType} from '../../_Base';\n\nexport class TimeDependentState {\n\tconstructor(protected param: BaseParamType) {}\n\n\tactive(): boolean {\n\t\tconst frame_graph_node_id = this.param.scene().timeController.graphNode.graphNodeId();\n\n\t\treturn this.param.graphPredecessorIds().includes(frame_graph_node_id);\n\t}\n}\n","import {BaseParamType} from '../../_Base';\nimport {ParamEvent} from '../../../poly/ParamEvent';\n\nexport class ErrorState {\n\tprivate _message: string | undefined;\n\tconstructor(private param: BaseParamType) {}\n\n\tset(message: string | undefined) {\n\t\tif (this._message != message) {\n\t\t\tthis._message = message;\n\t\t\tif (this._message) {\n\t\t\t\tconsole.warn(this.param.fullPath(), this._message);\n\t\t\t}\n\t\t\tthis.param.emitController.emit(ParamEvent.ERROR_UPDATED);\n\t\t}\n\t}\n\tmessage() {\n\t\treturn this._message;\n\t}\n\tclear() {\n\t\tthis.set(undefined);\n\t}\n\tactive(): boolean {\n\t\treturn this._message != null;\n\t}\n}\n","import {BaseParamType} from '../_Base';\n\nimport {TimeDependentState} from './states/TimeDependent';\nimport {ErrorState} from './states/Error';\n\nexport class StatesController {\n\ttime_dependent = new TimeDependentState(this.param);\n\terror = new ErrorState(this.param);\n\tconstructor(protected param: BaseParamType) {}\n}\n","import {CoreWalker} from '../../core/Walker';\nimport {CoreGraphNode} from '../../core/graph/CoreGraphNode';\nimport {BaseNodeType} from '../nodes/_Base';\nimport {OptionsController} from './utils/OptionsController';\nimport {ExpressionController} from './utils/ExpressionController';\nimport {EmitController} from './utils/EmitController';\nimport {ParamSerializer} from './utils/Serializer';\nimport {StatesController} from './utils/StatesController';\nimport {TypedMultipleParam} from './_Multiple';\nimport {FloatParam} from './Float';\nimport {ParamType} from '../poly/ParamType';\nimport {ParamEvent} from '../poly/ParamEvent';\nimport {PolyScene} from '../scene/PolyScene';\nimport {ParamInitValuesTypeMap} from '../params/types/ParamInitValuesTypeMap';\nimport {ParamValuesTypeMap} from '../params/types/ParamValuesTypeMap';\nimport {\n\tParamValueSerializedTypeMap,\n\tParamValuePreConversionSerializedTypeMap,\n} from '../params/types/ParamValueSerializedTypeMap';\nimport {ParamInitValueSerializedTypeMap} from './types/ParamInitValueSerializedTypeMap';\nimport {MethodDependency} from '../expressions/MethodDependency';\n\ntype ComputeCallback = (value: void) => void;\nconst TYPED_PARAM_DEFAULT_COMPONENT_NAMES: Readonly<string[]> = [];\n\nexport abstract class TypedParam<T extends ParamType> extends CoreGraphNode {\n\tprotected _default_value!: ParamInitValuesTypeMap[T];\n\tprotected _raw_input!: ParamInitValuesTypeMap[T];\n\tprotected _value!: ParamValuesTypeMap[T];\n\tprotected _node: BaseNodeType;\n\tprotected _parent_param: TypedMultipleParam<any> | undefined;\n\tprotected _components: FloatParam[] | undefined;\n\tprotected _compute_resolves: ComputeCallback[] | undefined;\n\n\tprivate _options: OptionsController = new OptionsController(this);\n\tget options(): OptionsController {\n\t\treturn (this._options = this._options || new OptionsController(this));\n\t}\n\tprivate _emit_controller: EmitController = new EmitController(this);\n\tget emitController(): EmitController {\n\t\treturn (this._emit_controller = this._emit_controller || new EmitController(this));\n\t}\n\tprotected _expression_controller: ExpressionController<T> | undefined;\n\tget expressionController(): ExpressionController<T> | undefined {\n\t\treturn this._expression_controller; // =\n\t\t//this._expression_controller || new ExpressionController(this);\n\t}\n\tprivate _serializer: ParamSerializer<T> | undefined;\n\tget serializer(): ParamSerializer<T> {\n\t\treturn (this._serializer = this._serializer || new ParamSerializer(this));\n\t}\n\tprivate _states: StatesController | undefined;\n\tget states(): StatesController {\n\t\treturn (this._states = this._states || new StatesController(this));\n\t}\n\t// private _ui_data: UIData | undefined;\n\t// get ui_data(): UIData {\n\t// \treturn (this._ui_data = this._ui_data || new UIData(this.scene, this));\n\t// }\n\n\tconstructor(scene: PolyScene, node: BaseNodeType) {\n\t\tsuper(scene, 'BaseParam');\n\t\tthis._node = node;\n\t\tthis.initialize_param();\n\t}\n\tdispose() {\n\t\t// if any direct predecessor is a MethodDependency,\n\t\t// it must be disposed here\n\t\tconst predecessors = this.graphPredecessors();\n\t\tfor (let predecessor of predecessors) {\n\t\t\tif (predecessor instanceof MethodDependency) {\n\t\t\t\tpredecessor.dispose();\n\t\t\t}\n\t\t}\n\t\tthis._expression_controller?.dispose();\n\t\tsuper.dispose();\n\t\tthis._options?.dispose();\n\t}\n\tinitialize_param() {}\n\t// \t// this.addPostDirtyHook(this._remove_node_param_cache.bind(this))\n\t// }\n\t// initialize() {\n\t// \tthis.initComponents();\n\t// \t// this.init_expression()\n\t// \t// this._init_ui_data()\n\t// }\n\t// accepts_visitor<T extends ParamVisitor>(visitor: T): ReturnType<T['visit_param']> {\n\t// \treturn visitor.visit_param(this);\n\t// }\n\n\t//\n\t// init_expression() {}\n\n\t// type\n\tstatic type(): ParamType {\n\t\treturn ParamType.FLOAT; // adding a type here, but just to not have a compile error\n\t}\n\ttype(): T {\n\t\treturn (this.constructor as typeof BaseParamClass).type() as T;\n\t}\n\tisNumeric(): boolean {\n\t\treturn false;\n\t}\n\n\t// name\n\tsetName(name: string) {\n\t\tsuper.setName(name);\n\t}\n\n\tget value(): ParamValuesTypeMap[T] {\n\t\treturn this._value;\n\t}\n\tabstract defaultValueSerialized(): ParamInitValueSerializedTypeMap[T];\n\tabstract rawInputSerialized(): ParamInitValueSerializedTypeMap[T];\n\tabstract valueSerialized(): ParamValueSerializedTypeMap[T];\n\tcopy_value(param: BaseParamType) {\n\t\tif (param.type() == this.type()) {\n\t\t\tthis._copy_value(param as TypedParam<T>);\n\t\t} else {\n\t\t\tconsole.warn(`cannot copy value from ${param.type()} to ${this.type()}`);\n\t\t}\n\t}\n\tprotected _copy_value(param: TypedParam<T>) {\n\t\tthrow 'abstract method param._copy_value';\n\t}\n\tvaluePreConversionSerialized(): ParamValuePreConversionSerializedTypeMap[T] {\n\t\treturn undefined as never;\n\t}\n\tconvert(raw_val: any): ParamValuesTypeMap[T] | null {\n\t\treturn null;\n\t}\n\tstatic are_raw_input_equal(val1: any, val2: any) {\n\t\treturn false;\n\t}\n\tis_raw_input_equal(other_raw_input: ParamInitValuesTypeMap[T]) {\n\t\treturn (this.constructor as any).are_raw_input_equal(this._raw_input, other_raw_input);\n\t}\n\tstatic are_values_equal(val1: any, val2: any) {\n\t\treturn false;\n\t}\n\tis_value_equal(other_val: ParamValuesTypeMap[T]) {\n\t\treturn (this.constructor as any).are_values_equal(this.value, other_val);\n\t}\n\tprotected _clone_raw_input(raw_input: ParamInitValuesTypeMap[T]): ParamInitValuesTypeMap[T] {\n\t\treturn raw_input;\n\t}\n\tset(raw_input: ParamInitValuesTypeMap[T]): void {\n\t\tthis._raw_input = this._clone_raw_input(this._prefilter_invalid_raw_input(raw_input));\n\t\tthis.emitController.emit(ParamEvent.RAW_INPUT_UPDATED);\n\t\tthis.processRawInput();\n\t}\n\tprotected _prefilter_invalid_raw_input(raw_input: any): ParamInitValuesTypeMap[T] {\n\t\treturn raw_input as ParamInitValuesTypeMap[T];\n\t}\n\tdefaultValue() {\n\t\treturn this._default_value;\n\t}\n\tisDefault(): boolean {\n\t\treturn this._raw_input == this._default_value;\n\t}\n\trawInput() {\n\t\treturn this._raw_input;\n\t}\n\n\tprotected processRawInput() {}\n\tprivate _is_computing: boolean = false;\n\tasync compute(): Promise<void> {\n\t\tif (this.scene().loadingController.isLoading()) {\n\t\t\tconsole.warn(`param attempt to compute ${this.fullPath()}`);\n\t\t}\n\n\t\tif (this.isDirty()) {\n\t\t\tif (!this._is_computing) {\n\t\t\t\tthis._is_computing = true;\n\t\t\t\tawait this.process_computation();\n\t\t\t\tthis._is_computing = false;\n\n\t\t\t\tif (this._compute_resolves) {\n\t\t\t\t\tlet callback: ComputeCallback | undefined;\n\t\t\t\t\twhile ((callback = this._compute_resolves.pop())) {\n\t\t\t\t\t\tcallback();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn new Promise((resolve, reject) => {\n\t\t\t\t\tthis._compute_resolves = this._compute_resolves || [];\n\t\t\t\t\tthis._compute_resolves.push(resolve);\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n\tprotected async process_computation(): Promise<void> {}\n\t// set_default_value(default_value: ParamValuesTypeMap[T]) {\n\t// \tthis._default_value = default_value;\n\t// }\n\tsetInitValue(init_value: ParamInitValuesTypeMap[T]) {\n\t\tthis._default_value = this._clone_raw_input(this._prefilter_invalid_raw_input(init_value));\n\t\t// this._raw_input = this._clone_raw_input(init_value);\n\n\t\t// if (this.isMultiple()) {\n\t\t// \tthis.initComponents();\n\t\t// }\n\n\t\t// this.set(init_value);\n\t}\n\t// eval_p(): Promise<ParamValuesTypeMap[T]> {\n\t// \treturn new Promise((resolve, reject) => {\n\t// \t\tresolve();\n\t// \t});\n\t// }\n\n\t// node\n\t_setup_node_dependencies(node: BaseNodeType | null) {\n\t\tif (!node) {\n\t\t\tif (this._node) {\n\t\t\t\tthis._node.params.params_node?.removeGraphInput(this);\n\t\t\t}\n\t\t} else {\n\t\t\t// allow callbacks after the value is set,\n\t\t\t// so that the param does not trigger the node to recompute\n\t\t\t// before all params are added\n\t\t\tthis.options.allowCallback();\n\t\t\tif (this.options.makes_node_dirty_when_dirty() && !this.parent_param) {\n\t\t\t\tnode.params.params_node?.addGraphInput(this, false);\n\t\t\t}\n\t\t}\n\n\t\tif (this.components) {\n\t\t\tfor (let c of this.components) {\n\t\t\t\tc._setup_node_dependencies(node);\n\t\t\t}\n\t\t}\n\t}\n\tget node() {\n\t\treturn this._node;\n\t}\n\tparent() {\n\t\treturn this.node;\n\t}\n\n\t// hierarchy\n\tset_parent_param(param: TypedMultipleParam<any>) {\n\t\tparam.addGraphInput(this, false);\n\t\tthis._parent_param = param;\n\t}\n\tget parent_param(): TypedMultipleParam<any> | undefined {\n\t\treturn this._parent_param;\n\t}\n\thas_parent_param(): boolean {\n\t\treturn this._parent_param != null;\n\t}\n\tfullPath(): string {\n\t\treturn this.node?.fullPath() + '/' + this.name();\n\t}\n\tpathRelativeTo(node: BaseNodeType): string {\n\t\tconst nodeRelativePath = CoreWalker.relativePath(node, this.node);\n\n\t\tif (nodeRelativePath.length > 0) {\n\t\t\treturn `${nodeRelativePath}${CoreWalker.SEPARATOR}${this.name()}`;\n\t\t} else {\n\t\t\treturn this.name();\n\t\t}\n\t}\n\n\t// emit\n\temit(event_name: ParamEvent): void {\n\t\tif (this.emitController.emitAllowed()) {\n\t\t\tthis.emitController.incrementCount(event_name);\n\t\t\tthis.scene().dispatchController.dispatch(this, event_name);\n\t\t}\n\t}\n\n\t// multiple\n\tget components() {\n\t\treturn this._components;\n\t}\n\tcomponentNames(): Readonly<string[]> {\n\t\treturn TYPED_PARAM_DEFAULT_COMPONENT_NAMES;\n\t}\n\tisMultiple(): boolean {\n\t\treturn this.componentNames().length > 0;\n\t}\n\t// create_components() {}\n\tinitComponents() {}\n\n\t// expression\n\t// set_expression(expression: string | null) {\n\t// \tthis.expressionController.set_expression(expression);\n\t// }\n\thasExpression(): boolean {\n\t\treturn this.expressionController != null && this.expressionController.active(); // use this._expression_controller to avoid creating it\n\t}\n\n\t// serialize\n\ttoJSON() {\n\t\treturn this.serializer.toJSON();\n\t}\n}\nexport type BaseParamType = TypedParam<ParamType>;\nexport class BaseParamClass extends TypedParam<ParamType> {\n\tdefaultValueSerialized() {\n\t\treturn 'BaseParamClass.defaultValueSerialized overriden';\n\t}\n\trawInputSerialized() {\n\t\treturn 'BaseParamClass.rawInputSerialized overriden';\n\t}\n\tvalueSerialized() {\n\t\treturn 'BaseParamClass.valueSerialized overriden';\n\t}\n}\n","export class MapUtils {\n\tstatic push_on_array_at_entry<K, V>(map: Map<K, V[]>, key: K, new_element: V) {\n\t\tlet has_entry = map.has(key);\n\t\tif (has_entry) {\n\t\t\tmap.get(key)!.push(new_element);\n\t\t} else {\n\t\t\tmap.set(key, [new_element]);\n\t\t}\n\t}\n\tstatic pop_from_array_at_entry<K, V>(map: Map<K, V[]>, key: K, element_to_remove: V) {\n\t\tlet has_entry = map.has(key);\n\t\tif (has_entry) {\n\t\t\tconst array = map.get(key)!;\n\t\t\tconst index = array.indexOf(element_to_remove);\n\t\t\tif (index >= 0) {\n\t\t\t\tarray.splice(index, 1);\n\t\t\t}\n\t\t}\n\t}\n\tstatic unshift_on_array_at_entry<K, V>(map: Map<K, V[]>, key: K, new_element: V) {\n\t\tlet has_entry = map.has(key);\n\t\tif (has_entry) {\n\t\t\tmap.get(key)!.unshift(new_element);\n\t\t} else {\n\t\t\tmap.set(key, [new_element]);\n\t\t}\n\t}\n\tstatic concat_on_array_at_entry<K, V>(map: Map<K, V[]>, key: K, new_elements: V[]) {\n\t\tlet has_entry = map.has(key);\n\t\tif (has_entry) {\n\t\t\tlet array: V[] = map.get(key)!;\n\t\t\tfor (let element of new_elements) {\n\t\t\t\tarray.push(element);\n\t\t\t}\n\t\t} else {\n\t\t\tmap.set(key, new_elements);\n\t\t}\n\t}\n}\n","//\n//\n// Event Data types\n//\n//\n\nexport enum EventConnectionPointType {\n\tBASE = 'base',\n\tKEYBOARD = 'keyboard',\n\tMOUSE = 'mouse',\n\tPOINTER = 'pointer',\n}\n// interface IEventConnectionPointType {\n// \t[EventConnectionPointType.BASE]: Readonly<'base'>;\n// \t[EventConnectionPointType.KEYBOARD]: Readonly<'keyboard'>;\n// \t[EventConnectionPointType.MOUSE]: Readonly<'mouse'>;\n// }\n\n// export const ConnectionPointTypeGL: IEventConnectionPointType = {\n// \t[EventConnectionPointType.BASE]: 'base',\n// \t[EventConnectionPointType.KEYBOARD]: 'keyboard',\n// \t[EventConnectionPointType.MOUSE]: 'mouse',\n// };\n\n//\n//\n// ALL Event Data types in an array\n//\n//\n// export const ConnectionPointTypesEVENT: Array<EventConnectionPointType> = [\n// \tEventConnectionPointType.BASE,\n// \tEventConnectionPointType.KEYBOARD,\n// \tEventConnectionPointType.MOUSE,\n// ];\n\nexport interface EventConnectionPointData<T extends EventConnectionPointType> {\n\tname: string;\n\ttype: T;\n}\n\nimport {BaseConnectionPoint} from './_Base';\nimport {EventContext} from '../../../../scene/utils/events/_BaseEventsController';\nimport {ParamType} from '../../../../poly/ParamType';\nexport class EventConnectionPoint<T extends EventConnectionPointType> extends BaseConnectionPoint {\n\tprotected _json: EventConnectionPointData<T> | undefined;\n\n\tconstructor(\n\t\tprotected _name: string,\n\t\tprotected _type: T, // protected _init_value?: ConnectionPointInitValueMapGeneric[T]\n\t\tprotected _event_listener?: (event_context: EventContext<any>) => void\n\t) {\n\t\tsuper(_name, _type);\n\t\t// if (this._init_value === undefined) {\n\t\t// this._init_value = null\n\t\t// }\n\t}\n\ttype() {\n\t\treturn this._type;\n\t}\n\tget param_type() {\n\t\treturn ParamType.FLOAT; // should never be used anyway\n\t}\n\tare_types_matched(src_type: string, dest_type: string): boolean {\n\t\tif (dest_type == EventConnectionPointType.BASE) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn src_type == dest_type;\n\t\t}\n\t}\n\tget event_listener() {\n\t\treturn this._event_listener;\n\t}\n\t// get param_type(): IConnectionPointTypeToParamTypeMap[T] {\n\t// \treturn ConnectionPointTypeToParamTypeMap[this._type];\n\t// }\n\t// get init_value() {\n\t// \treturn this._init_value;\n\t// }\n\n\ttoJSON(): EventConnectionPointData<T> {\n\t\treturn (this._json = this._json || this._create_json());\n\t}\n\tprotected _create_json(): EventConnectionPointData<T> {\n\t\treturn {\n\t\t\tname: this._name,\n\t\t\ttype: this._type,\n\t\t};\n\t}\n}\n\nexport type BaseEventConnectionPoint = EventConnectionPoint<EventConnectionPointType>;\n","import {LngLatLike, Vector2Like} from '../../types/GlobalTypes';\nimport {Vector3} from 'three/src/math/Vector3';\nimport {Triangle} from 'three/src/math/Triangle';\nimport {Easing} from './Easing';\nimport {CoreType} from '../Type';\n\nconst RAD_DEG_RATIO = Math.PI / 180;\nconst RAND_A = 12.9898;\nconst RAND_B = 78.233;\nconst RAND_C = 43758.5453;\n\nexport class CoreMath {\n\t// static Octree = Octree\n\t// static Interpolate = Interpolate\n\tstatic Easing = Easing; // used in expressins\n\n\tstatic clamp(val: number, min: number, max: number): number {\n\t\tif (val < min) {\n\t\t\treturn min;\n\t\t} else if (val > max) {\n\t\t\treturn max;\n\t\t} else {\n\t\t\treturn val;\n\t\t}\n\t}\n\n\tstatic fit01(val: number, dest_min: number, dest_max: number): number {\n\t\t// const size = max - min;\n\t\t// return (val - min) / size;\n\t\treturn this.fit(val, 0, 1, dest_min, dest_max);\n\t}\n\n\tstatic fit(val: number, src_min: number, src_max: number, dest_min: number, dest_max: number): number {\n\t\tconst src_range = src_max - src_min;\n\t\tconst dest_range = dest_max - dest_min;\n\n\t\tconst r = (val - src_min) / src_range;\n\t\treturn r * dest_range + dest_min;\n\t}\n\tstatic blend(num0: number, num1: number, blend: number) {\n\t\treturn (1 - blend) * num0 + blend * num1;\n\t}\n\n\tstatic degrees_to_radians(degrees: number): number {\n\t\treturn degrees * RAD_DEG_RATIO;\n\t}\n\tstatic radians_to_degrees(radians: number): number {\n\t\treturn radians / RAD_DEG_RATIO;\n\t}\n\tstatic deg2rad(deg: number): number {\n\t\treturn this.degrees_to_radians(deg);\n\t}\n\tstatic rad2deg(rad: number): number {\n\t\treturn this.radians_to_degrees(rad);\n\t}\n\n\tstatic fract = (number: number) => number - Math.floor(number);\n\n\t// from threejs glsl rand\n\tstatic rand(number: number): number {\n\t\tif (CoreType.isNumber(number)) {\n\t\t\treturn this.randFloat(number);\n\t\t} else {\n\t\t\treturn this.randVec2(number);\n\t\t}\n\t}\n\n\tstatic round(number: number, step_size: number): number {\n\t\tconst steps_count = number / step_size;\n\t\tconst rounded_steps_count = number < 0 ? Math.ceil(steps_count) : Math.floor(steps_count);\n\t\treturn rounded_steps_count * step_size;\n\t}\n\n\tstatic highest_even(number: number): number {\n\t\treturn 2 * Math.ceil(number * 0.5);\n\t}\n\n\tprivate static _vec = {x: 0, y: 136574};\n\tstatic randFloat(x: number, y: number = 136574): number {\n\t\tthis._vec.x = x;\n\t\tthis._vec.y = y;\n\t\treturn this.randVec2(this._vec);\n\t}\n\n\tstatic randVec2(uv: Vector2Like) {\n\t\tconst dt = uv.x * RAND_A + uv.y * RAND_B; //dot( uv.xy, vec2( a,b ) )\n\t\tconst sn = dt % Math.PI;\n\t\treturn this.fract(Math.sin(sn) * RAND_C);\n\t}\n\n\t// https://www.movable-type.co.uk/scripts/latlong.html\n\tstatic geodesic_distance(lnglat1: LngLatLike, lnglat2: LngLatLike): number {\n\t\tvar R = 6371e3; // metres\n\t\tvar d1 = this.deg2rad(lnglat1.lat);\n\t\tvar d2 = this.deg2rad(lnglat2.lat);\n\t\tvar ad1 = this.deg2rad(lnglat2.lat - lnglat1.lat);\n\t\tvar ad2 = this.deg2rad(lnglat2.lng - lnglat1.lng);\n\n\t\tvar a =\n\t\t\tMath.sin(ad1 / 2) * Math.sin(ad1 / 2) + Math.cos(d1) * Math.cos(d2) * Math.sin(ad2 / 2) * Math.sin(ad2 / 2);\n\t\tvar c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n\n\t\tvar d = R * c;\n\t\treturn d;\n\t}\n\n\tprivate static _triangle_mid = new Vector3();\n\tprivate static _triangle_mid_to_corner = new Vector3();\n\tstatic expand_triangle(triangle: Triangle, margin: number) {\n\t\ttriangle.getMidpoint(this._triangle_mid);\n\n\t\t// a\n\t\tthis._triangle_mid_to_corner.copy(triangle.a).sub(this._triangle_mid);\n\t\tthis._triangle_mid_to_corner.normalize().multiplyScalar(margin);\n\t\ttriangle.a.add(this._triangle_mid_to_corner);\n\t\t// b\n\t\tthis._triangle_mid_to_corner.copy(triangle.b).sub(this._triangle_mid);\n\t\tthis._triangle_mid_to_corner.normalize().multiplyScalar(margin);\n\t\ttriangle.b.add(this._triangle_mid_to_corner);\n\t\t// c\n\t\tthis._triangle_mid_to_corner.copy(triangle.c).sub(this._triangle_mid);\n\t\tthis._triangle_mid_to_corner.normalize().multiplyScalar(margin);\n\t\ttriangle.c.add(this._triangle_mid_to_corner);\n\t}\n\n\tstatic nearestPower2(num: number) {\n\t\treturn Math.pow(2, Math.ceil(Math.log(num) / Math.log(2)));\n\t}\n}\n","import {ArrayUtils} from './ArrayUtils';\nimport {CoreType} from './Type';\nimport lodash_cloneDeep from 'lodash/cloneDeep';\nimport lodash_clone from 'lodash/clone';\n\nexport class ObjectUtils {\n\t// static isObject(value: any): boolean {\n\t// \tvar type = typeof value;\n\t// \treturn value != null && (type == 'object' || type == 'function');\n\t// }\n\tstatic isEqual(object0: any, object1: any): boolean {\n\t\tif (CoreType.isObject(object0) && CoreType.isObject(object1)) {\n\t\t\tconst keys0 = Object.keys(object0);\n\t\t\tconst keys1 = Object.keys(object1);\n\t\t\tif (!ArrayUtils.isEqual(keys0, keys1)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn JSON.stringify(object0) == JSON.stringify(object1);\n\t\t}\n\t\treturn false;\n\t}\n\tstatic merge(object0: object, object1: object): object {\n\t\treturn Object.assign(object0, object1);\n\t}\n\tstatic clone<T extends Array<any> | object | undefined>(value: T): T {\n\t\t// return this.cloneDeep(value);\n\t\treturn lodash_clone(value);\n\t\t// if (value) {\n\t\t// \tif (CoreType.isArray(value)) {\n\t\t// \t\tconst newValues: Array<any> = value.map((v) => v);\n\t\t// \t\treturn newValues as T;\n\t\t// \t} else {\n\t\t// \t\treturn {...value};\n\t\t// \t}\n\t\t// }\n\t\t// return value;\n\t}\n\tstatic cloneDeep<T extends object | number | string | boolean | undefined>(value: T): T {\n\t\t// https://github.com/you-dont-need/You-Dont-Need-Lodash-Underscore/issues/121\n\t\t// let target = {};\n\t\t// for (const prop in src) {\n\t\t// \tif (src.hasOwnProperty(prop)) {\n\t\t// \t\tif ((src as any)[prop] != null && typeof (src as any)[prop] === 'object') {\n\t\t// \t\t\t(target as any)[prop] = this.cloneDeep((src as any)[prop]);\n\t\t// \t\t} else {\n\t\t// \t\t\t(target as any)[prop] = (src as any)[prop];\n\t\t// \t\t}\n\t\t// \t}\n\t\t// }\n\t\t// return target as T;\n\n\t\treturn lodash_cloneDeep(value);\n\t\t// if (CoreType.isString(value) || CoreType.isNumber(value) || CoreType.isBoolean(value)) {\n\t\t// \treturn value;\n\t\t// }\n\t\t// if (this.isObject(value)) {\n\t\t// be careful, as this does not clone functions\n\t\t// \treturn JSON.parse(JSON.stringify(value));\n\t\t// }\n\t\t// return value;\n\t}\n}\n","import {StringOrNumber} from '../../types/GlobalTypes';\nimport {TypedParam} from './_Base';\nimport {FloatParam} from './Float';\nimport {ParamType} from '../poly/ParamType';\nimport {ParamEvent} from '../poly/ParamEvent';\nimport {ParamInitValueSerializedTypeMap} from './types/ParamInitValueSerializedTypeMap';\nimport {ParamInitValuesTypeMap} from './types/ParamInitValuesTypeMap';\nimport {CoreType} from '../../core/Type';\n\nexport abstract class TypedMultipleParam<T extends ParamType> extends TypedParam<T> {\n\tprivate _components_contructor = FloatParam;\n\tprotected _components!: FloatParam[];\n\tget components() {\n\t\treturn this._components;\n\t}\n\tisNumeric() {\n\t\treturn true;\n\t}\n\tisDefault() {\n\t\tfor (let c of this.components) {\n\t\t\tif (!c.isDefault()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\trawInput() {\n\t\treturn this._components.map((c) => c.rawInput()) as ParamInitValueSerializedTypeMap[T];\n\t}\n\trawInputSerialized() {\n\t\treturn this._components.map((c) => c.rawInputSerialized()) as ParamInitValueSerializedTypeMap[T];\n\t}\n\tprotected _copy_value(param: TypedMultipleParam<T>) {\n\t\tfor (let i = 0; i < this.components.length; i++) {\n\t\t\tconst component = this.components[i];\n\t\t\tconst src_component = param.components[i];\n\t\t\tcomponent.copy_value(src_component);\n\t\t}\n\t}\n\n\tinitComponents() {\n\t\tif (this._components != null) {\n\t\t\treturn;\n\t\t}\n\t\tlet index = 0;\n\t\tthis._components = new Array(this.componentNames().length);\n\t\tfor (let component_name of this.componentNames()) {\n\t\t\tconst component = new this._components_contructor(this.scene(), this._node); //, `${this.name}${name}`);\n\t\t\tlet default_val;\n\t\t\tif (CoreType.isArray(this._default_value)) {\n\t\t\t\tdefault_val = this._default_value[index];\n\t\t\t} else {\n\t\t\t\tdefault_val = (this._default_value as any)[component_name];\n\t\t\t}\n\t\t\tcomponent.options.copy(this.options);\n\t\t\tcomponent.setInitValue(default_val);\n\n\t\t\t// component.set_scene(this.scene);\n\t\t\tcomponent.setName(`${this.name()}${component_name}`);\n\t\t\tcomponent.set_parent_param(this);\n\n\t\t\t// this.addGraphInput(component, false); // already called in set_parent_param\n\t\t\t// component.initialize();\n\t\t\tthis._components[index] = component;\n\t\t\tindex++;\n\t\t}\n\t\t// this.compute();\n\t}\n\n\tprotected async process_computation(): Promise<void> {\n\t\tawait this.compute_components();\n\t\tthis.set_value_from_components();\n\t}\n\tset_value_from_components() {}\n\t// set_raw_input_from_components() {}\n\n\thasExpression() {\n\t\tfor (let c of this.components) {\n\t\t\tif (c.expressionController?.active()) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tprivate async compute_components() {\n\t\tconst components = this.components;\n\t\tconst promises = [];\n\t\tfor (let c of components) {\n\t\t\tif (c.isDirty()) {\n\t\t\t\tpromises.push(c.compute());\n\t\t\t}\n\t\t}\n\t\tawait Promise.all(promises);\n\t\tthis.removeDirtyState();\n\t}\n\t// TODO: refactor this, so that nodes with vector or color params\n\t// can be initialized with DEFAULT.color\n\t// and not DEFAULT.color.toArray()\n\t// and this could also maybe fix the .set() calls\n\t// where an array currently needs to be used\n\tprotected _prefilter_invalid_raw_input(raw_input: any): ParamInitValuesTypeMap[T] {\n\t\tif (!CoreType.isArray(raw_input)) {\n\t\t\tconst number_or_string = raw_input as number | string;\n\t\t\tconst raw_input_wrapped_in_array: StringOrNumber[] = this.componentNames().map(() => number_or_string);\n\t\t\treturn raw_input_wrapped_in_array as ParamInitValuesTypeMap[T];\n\t\t} else {\n\t\t\treturn raw_input as ParamInitValuesTypeMap[T];\n\t\t}\n\t}\n\n\tprotected processRawInput() {\n\t\tconst cooker = this.scene().cooker;\n\t\tcooker.block();\n\t\tconst components = this.components;\n\t\tfor (let c of components) {\n\t\t\tc.emitController.blockParentEmit();\n\t\t}\n\n\t\t// if (CoreType.isArray(values)) {\n\t\tconst value = this._raw_input;\n\t\tlet prev_value: number = 0;\n\t\tif (CoreType.isArray(value)) {\n\t\t\tfor (let i = 0; i < components.length; i++) {\n\t\t\t\tlet component_value = (value as any)[i];\n\t\t\t\t// use the prev value, in case we give an array that is too short\n\t\t\t\tif (component_value == null) {\n\t\t\t\t\tcomponent_value = prev_value;\n\t\t\t\t}\n\t\t\t\tcomponents[i].set(component_value);\n\t\t\t\tprev_value = component_value;\n\t\t\t}\n\t\t} else {\n\t\t\tfor (let i = 0; i < components.length; i++) {\n\t\t\t\tconst component_name = this.componentNames()[i];\n\t\t\t\tlet component_value = (value as any)[component_name];\n\t\t\t\t// use the prev value, in case we give a vec2 instead of vec3\n\t\t\t\tif (component_value == null) {\n\t\t\t\t\tcomponent_value = prev_value;\n\t\t\t\t}\n\t\t\t\tcomponents[i].set(component_value);\n\t\t\t\tprev_value = component_value;\n\t\t\t}\n\t\t}\n\t\t// } else {\n\t\t// \tconst component_names = this.componentNames()()\n\t\t// \tfor (let i = 0; i < components.length; i++) {\n\t\t// \t\tcomponents[i].set(values[component_names[i]])\n\t\t// \t}\n\t\t// }\n\n\t\tcooker.unblock();\n\n\t\tfor (let i = 0; i < components.length; i++) {\n\t\t\tcomponents[i].emitController.unblockParentEmit();\n\t\t}\n\t\t// this.emit(ParamEvent.UPDATED);\n\n\t\tthis.emitController.emit(ParamEvent.VALUE_UPDATED);\n\t}\n}\n\n// class BaseMultipleParam extends TypedMultipleParam<Vector> {}\n","import {Vector2} from 'three/src/math/Vector2';\nimport {Vector3} from 'three/src/math/Vector3';\nimport {Vector4} from 'three/src/math/Vector4';\n\nexport class CoreType {\n\tstatic isNumber(value: any): value is number {\n\t\treturn typeof value == 'number';\n\t}\n\tstatic isVector(value: any): value is Vector2 | Vector3 | Vector4 {\n\t\treturn value instanceof Vector2 || value instanceof Vector3 || value instanceof Vector4;\n\t}\n\tstatic isString(value: any): value is string {\n\t\treturn typeof value == 'string';\n\t}\n\tstatic isBoolean(value: any): value is boolean {\n\t\treturn value === true || value === false;\n\t}\n\tstatic isNaN(value: any): boolean {\n\t\treturn isNaN(value);\n\t}\n\tstatic isArray(value: any): value is any[] {\n\t\treturn Array.isArray(value);\n\t}\n\tstatic isObject(value: any): value is object {\n\t\tvar type = typeof value;\n\t\treturn value != null && (type == 'object' || type == 'function');\n\t}\n}\n","import {AttribValue, NumericAttribValue, PolyDictionary} from '../../types/GlobalTypes';\nimport {Vector2} from 'three/src/math/Vector2';\nimport {Vector3} from 'three/src/math/Vector3';\nimport {Vector4} from 'three/src/math/Vector4';\nimport {Object3D} from 'three/src/core/Object3D';\nimport {Mesh} from 'three/src/objects/Mesh';\nimport {Color} from 'three/src/math/Color';\nimport {BufferGeometry} from 'three/src/core/BufferGeometry';\nimport {AnimationClip} from 'three/src/animation/AnimationClip';\nimport {Material} from 'three/src/materials/Material';\nimport {SkinnedMesh} from 'three/src/objects/SkinnedMesh';\nimport {Bone} from 'three/src/objects/Bone';\nimport {CoreGeometry} from './Geometry';\nimport {GroupString} from './Group';\nimport {CoreAttribute} from './Attribute';\nimport {CoreConstant, AttribType, AttribSize} from './Constant';\nimport {CorePoint} from './Point';\nimport {CoreMaterial, ShaderMaterialWithCustomMaterials} from './Material';\nimport {CoreString} from '../String';\nimport {CoreEntity} from './Entity';\nimport {CoreType} from '../Type';\nimport {ObjectUtils} from '../ObjectUtils';\nconst PTNUM = 'ptnum';\nconst NAME_ATTR = 'name';\nconst ATTRIBUTES = 'attributes';\n\ninterface Object3DWithAnimations extends Object3D {\n\tanimations: AnimationClip[];\n}\ninterface MaterialWithColor extends Material {\n\tcolor: Color;\n}\n// interface SkinnedMeshWithisSkinnedMesh extends SkinnedMesh {\n// \treadonly isSkinnedMesh: boolean;\n// }\n\nexport class CoreObject extends CoreEntity {\n\tconstructor(private _object: Object3D, index: number) {\n\t\tsuper(index);\n\t\tif (this._object.userData[ATTRIBUTES] == null) {\n\t\t\tthis._object.userData[ATTRIBUTES] = {};\n\t\t}\n\t}\n\n\t// set_index(i: number) {\n\t// \tthis._index = i;\n\t// }\n\n\tobject() {\n\t\treturn this._object;\n\t}\n\tgeometry(): BufferGeometry | null {\n\t\treturn (this._object as Mesh).geometry as BufferGeometry | null;\n\t}\n\tcoreGeometry(): CoreGeometry | null {\n\t\tconst geo = this.geometry();\n\t\tif (geo) {\n\t\t\treturn new CoreGeometry(geo);\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t\t// const geo = this.geometry()\n\t\t// if (geo) {\n\t\t// \treturn new CoreGeometry(geo)\n\t\t// } else {\n\t\t// \treturn null\n\t\t// }\n\t}\n\tpoints() {\n\t\treturn this.coreGeometry()?.points() || [];\n\t}\n\tpointsFromGroup(group: GroupString): CorePoint[] {\n\t\tif (group) {\n\t\t\tconst indices = CoreString.indices(group);\n\t\t\tif (indices) {\n\t\t\t\tconst points = this.points();\n\t\t\t\treturn indices.map((i) => points[i]);\n\t\t\t} else {\n\t\t\t\treturn [];\n\t\t\t}\n\t\t} else {\n\t\t\treturn this.points();\n\t\t}\n\t}\n\tstatic isInGroup(groupString: string, object: Object3D) {\n\t\tconst group = groupString.trim();\n\t\tif (group.length == 0) {\n\t\t\treturn true;\n\t\t}\n\t\tconst elements = group.split('=');\n\t\tconst attribNameWithPrefix = elements[0];\n\t\tif (attribNameWithPrefix[0] == '@') {\n\t\t\tconst attribName = attribNameWithPrefix.substr(1);\n\t\t\tconst expectedAttribValue = elements[1];\n\t\t\tconst currentAttribValue = this.attribValue(object, attribName);\n\t\t\treturn expectedAttribValue == currentAttribValue;\n\t\t}\n\t\treturn false;\n\t}\n\n\tcomputeVertexNormals() {\n\t\tthis.coreGeometry()?.computeVertexNormals();\n\t}\n\n\tprivate static _convert_array_to_vector(value: number[]) {\n\t\tswitch (value.length) {\n\t\t\tcase 1:\n\t\t\t\treturn value[0];\n\t\t\tcase 2:\n\t\t\t\treturn new Vector2(value[0], value[1]);\n\t\t\tcase 3:\n\t\t\t\treturn new Vector3(value[0], value[1], value[2]);\n\t\t\tcase 4:\n\t\t\t\treturn new Vector4(value[0], value[1], value[2], value[3]);\n\t\t}\n\t}\n\n\tstatic addAttribute(object: Object3D, attrib_name: string, value: AttribValue) {\n\t\tif (CoreType.isArray(value)) {\n\t\t\tconst converted_value = this._convert_array_to_vector(value);\n\t\t\tif (!converted_value) {\n\t\t\t\tconst message = `attribute_value invalid`;\n\t\t\t\tconsole.error(message, value);\n\t\t\t\tthrow new Error(message);\n\t\t\t}\n\t\t}\n\n\t\t// let data: ParamInitValueSerialized;\n\t\t// if (value != null && !CoreType.isNumber(value) && !CoreType.isArray(value) && !CoreType.isString(value)) {\n\t\t// \tdata = (value as Vector3).toArray() as Number3;\n\t\t// } else {\n\t\t// \tdata = value;\n\t\t// }\n\t\tconst data = value;\n\t\tconst user_data = object.userData;\n\t\tuser_data[ATTRIBUTES] = user_data[ATTRIBUTES] || {};\n\t\tuser_data[ATTRIBUTES][attrib_name] = data;\n\t}\n\taddAttribute(name: string, value: AttribValue) {\n\t\tCoreObject.addAttribute(this._object, name, value);\n\t}\n\taddNumericAttrib(name: string, value: NumericAttribValue) {\n\t\tthis.addAttribute(name, value);\n\t}\n\tsetAttribValue(name: string, value: AttribValue) {\n\t\tthis.addAttribute(name, value);\n\t}\n\taddNumericVertexAttrib(name: string, size: number, default_value: NumericAttribValue) {\n\t\tif (default_value == null) {\n\t\t\tdefault_value = CoreAttribute.default_value(size);\n\t\t}\n\t\tthis.coreGeometry()?.addNumericAttrib(name, size, default_value);\n\t}\n\n\tattributeNames(): string[] {\n\t\t// TODO: to remove\n\t\treturn Object.keys(this._object.userData[ATTRIBUTES]);\n\t}\n\tattribNames(): string[] {\n\t\treturn this.attributeNames();\n\t}\n\n\thasAttrib(name: string): boolean {\n\t\treturn this.attributeNames().includes(name);\n\t}\n\n\trenameAttrib(old_name: string, new_name: string) {\n\t\tconst current_value = this.attribValue(old_name);\n\t\tif (current_value != null) {\n\t\t\tthis.addAttribute(new_name, current_value);\n\t\t\tthis.deleteAttribute(old_name);\n\t\t} else {\n\t\t\tconsole.warn(`attribute ${old_name} not found`);\n\t\t}\n\t}\n\n\tdeleteAttribute(name: string) {\n\t\tdelete this._object.userData[ATTRIBUTES][name];\n\t}\n\tstatic attribValue(\n\t\tobject: Object3D,\n\t\tname: string,\n\t\tindex: number = 0,\n\t\ttarget?: Vector2 | Vector3 | Vector4\n\t): AttribValue | undefined {\n\t\tif (name === PTNUM) {\n\t\t\treturn index;\n\t\t}\n\t\tif (object.userData && object.userData[ATTRIBUTES]) {\n\t\t\tconst val = object.userData[ATTRIBUTES][name] as AttribValue;\n\t\t\tif (val == null) {\n\t\t\t\tif (name == NAME_ATTR) {\n\t\t\t\t\treturn object.name;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (CoreType.isArray(val) && target) {\n\t\t\t\t\ttarget.fromArray(val);\n\t\t\t\t\treturn target;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn val;\n\t\t}\n\t\tif (name == NAME_ATTR) {\n\t\t\treturn object.name;\n\t\t}\n\t}\n\tstatic stringAttribValue(object: Object3D, name: string, index: number = 0): string | undefined {\n\t\tconst str = this.attribValue(object, name, index);\n\t\tif (str != null) {\n\t\t\tif (CoreType.isString(str)) {\n\t\t\t\treturn str;\n\t\t\t} else {\n\t\t\t\treturn `${str}`;\n\t\t\t}\n\t\t}\n\t}\n\tattribValue(name: string, target?: Vector2 | Vector3 | Vector4): AttribValue | undefined {\n\t\treturn CoreObject.attribValue(this._object, name, this._index, target);\n\t}\n\tstringAttribValue(name: string) {\n\t\treturn CoreObject.stringAttribValue(this._object, name, this._index);\n\t}\n\tname(): string {\n\t\treturn this.attribValue(NAME_ATTR) as string;\n\t}\n\thumanType(): string {\n\t\treturn CoreConstant.CONSTRUCTOR_NAMES_BY_CONSTRUCTOR_NAME[this._object.constructor.name];\n\t}\n\tattribTypes() {\n\t\tconst h: PolyDictionary<AttribType> = {};\n\t\tfor (let attrib_name of this.attribNames()) {\n\t\t\tconst type = this.attribType(attrib_name);\n\t\t\tif (type != null) {\n\t\t\t\th[attrib_name] = type;\n\t\t\t}\n\t\t}\n\t\treturn h;\n\t}\n\tattribType(name: string) {\n\t\tconst val = this.attribValue(name);\n\t\tif (CoreType.isString(val)) {\n\t\t\treturn AttribType.STRING;\n\t\t} else {\n\t\t\treturn AttribType.NUMERIC;\n\t\t}\n\t}\n\tattribSizes() {\n\t\tconst h: PolyDictionary<AttribSize> = {};\n\t\tfor (let attrib_name of this.attribNames()) {\n\t\t\tconst size = this.attribSize(attrib_name);\n\t\t\tif (size != null) {\n\t\t\t\th[attrib_name] = size;\n\t\t\t}\n\t\t}\n\t\treturn h;\n\t}\n\tattribSize(name: string): AttribSize | null {\n\t\tconst val = this.attribValue(name);\n\t\tif (val == null) {\n\t\t\treturn null;\n\t\t}\n\t\treturn CoreAttribute.attribSizeFromValue(val);\n\t}\n\n\tclone() {\n\t\treturn CoreObject.clone(this._object);\n\t}\n\n\tstatic clone(src_object: Object3D) {\n\t\tconst new_object = src_object.clone();\n\n\t\tvar sourceLookup = new Map<Object3D, Object3D>();\n\t\tvar cloneLookup = new Map<Object3D, Object3D>();\n\t\tCoreObject.parallelTraverse(src_object, new_object, function (sourceNode: Object3D, clonedNode: Object3D) {\n\t\t\tsourceLookup.set(clonedNode, sourceNode);\n\t\t\tcloneLookup.set(sourceNode, clonedNode);\n\t\t});\n\t\tnew_object.traverse(function (node) {\n\t\t\tconst src_node = sourceLookup.get(node) as SkinnedMesh;\n\t\t\tconst mesh_node = node as Mesh;\n\n\t\t\tif (mesh_node.geometry) {\n\t\t\t\tconst src_node_geometry = src_node.geometry as BufferGeometry;\n\t\t\t\tmesh_node.geometry = CoreGeometry.clone(src_node_geometry);\n\t\t\t\tconst mesh_node_geometry = mesh_node.geometry as BufferGeometry;\n\t\t\t\tif (mesh_node_geometry.userData) {\n\t\t\t\t\tmesh_node_geometry.userData = ObjectUtils.cloneDeep(src_node_geometry.userData);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (mesh_node.material) {\n\t\t\t\tmesh_node.material = src_node.material;\n\t\t\t\tCoreMaterial.apply_custom_materials(node, mesh_node.material as ShaderMaterialWithCustomMaterials);\n\n\t\t\t\t// prevents crashes for linesegments with shader material such as the line dashed instance\n\t\t\t\t// TODO: test\n\t\t\t\tconst material_with_color = mesh_node.material as MaterialWithColor;\n\t\t\t\tif (material_with_color.color == null) {\n\t\t\t\t\tmaterial_with_color.color = new Color(1, 1, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (src_object.userData) {\n\t\t\t\tnode.userData = ObjectUtils.cloneDeep(src_node.userData);\n\t\t\t}\n\n\t\t\tconst src_node_with_animations = (<unknown>src_node) as Object3DWithAnimations;\n\t\t\tif (src_node_with_animations.animations) {\n\t\t\t\t(node as Object3DWithAnimations).animations = src_node_with_animations.animations.map((animation) =>\n\t\t\t\t\tanimation.clone()\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tconst skinned_node = node as SkinnedMesh;\n\t\t\tif (skinned_node.isSkinnedMesh) {\n\t\t\t\tvar clonedMesh = skinned_node;\n\t\t\t\tvar sourceMesh = src_node;\n\t\t\t\tvar sourceBones = sourceMesh.skeleton.bones;\n\n\t\t\t\tclonedMesh.skeleton = sourceMesh.skeleton.clone();\n\t\t\t\tclonedMesh.bindMatrix.copy(sourceMesh.bindMatrix);\n\n\t\t\t\tconst new_bones = sourceBones.map(function (bone) {\n\t\t\t\t\treturn cloneLookup.get(bone);\n\t\t\t\t}) as Bone[];\n\n\t\t\t\tclonedMesh.skeleton.bones = new_bones;\n\n\t\t\t\tclonedMesh.bind(clonedMesh.skeleton, clonedMesh.bindMatrix);\n\t\t\t}\n\t\t});\n\n\t\treturn new_object;\n\t}\n\n\tstatic parallelTraverse(a: Object3D, b: Object3D, callback: (a: Object3D, b: Object3D) => void) {\n\t\tcallback(a, b);\n\t\tfor (var i = 0; i < a.children.length; i++) {\n\t\t\tthis.parallelTraverse(a.children[i], b.children[i], callback);\n\t\t}\n\t}\n}\n","import {MathUtils} from 'three/src/math/MathUtils';\n\nexport interface RampPointJson {\n\tposition: number;\n\tvalue: number;\n}\nexport interface RampValueJson {\n\tpoints: RampPointJson[];\n\tinterpolation: string;\n}\n\nexport class RampPoint {\n\tconstructor(private _position: number = 0, private _value: number = 0) {}\n\n\ttoJSON(): RampPointJson {\n\t\treturn {\n\t\t\tposition: this._position,\n\t\t\tvalue: this._value,\n\t\t};\n\t}\n\tget position() {\n\t\treturn this._position;\n\t}\n\tget value() {\n\t\treturn this._value;\n\t}\n\tcopy(point: RampPoint) {\n\t\tthis._position = point.position;\n\t\tthis._value = point.value;\n\t}\n\tclone() {\n\t\tconst point = new RampPoint();\n\t\tpoint.copy(this);\n\t\treturn point;\n\t}\n\tis_equal(other_point: RampPoint) {\n\t\treturn this._position == other_point.position && this._value == other_point.value;\n\t}\n\tis_equal_json(json: RampPointJson) {\n\t\treturn this._position == json.position && this._value == json.value;\n\t}\n\tfrom_json(json: RampPointJson) {\n\t\tthis._position = json.position;\n\t\tthis._value = json.value;\n\t}\n\tstatic are_equal_json(json1: RampPointJson, json2: RampPointJson) {\n\t\treturn json1.position == json2.position && json1.value == json2.value;\n\t}\n\tstatic from_json(json: RampPointJson) {\n\t\treturn new RampPoint(json.position, json.value);\n\t}\n}\n\nexport enum RampInterpolation {\n\tLINEAR = 'linear',\n}\nexport class RampValue {\n\tprivate _uuid: string;\n\n\tconstructor(private _interpolation: string = RampInterpolation.LINEAR, private _points: RampPoint[] = []) {\n\t\tthis._uuid = MathUtils.generateUUID();\n\t}\n\n\tget uuid() {\n\t\treturn this._uuid;\n\t}\n\tget interpolation() {\n\t\treturn this._interpolation;\n\t}\n\tget points() {\n\t\treturn this._points;\n\t}\n\tstatic from_json(json: RampValueJson): RampValue {\n\t\tconst points = [];\n\t\tfor (let json_point of json.points) {\n\t\t\tpoints.push(RampPoint.from_json(json_point));\n\t\t}\n\t\treturn new RampValue(json.interpolation, points);\n\t}\n\ttoJSON(): RampValueJson {\n\t\treturn {\n\t\t\tinterpolation: this._interpolation,\n\t\t\tpoints: this._points.map((p) => p.toJSON()),\n\t\t};\n\t}\n\tclone(): RampValue {\n\t\tconst ramp = new RampValue();\n\t\tramp.copy(this);\n\t\treturn ramp;\n\t}\n\tcopy(ramp: RampValue) {\n\t\tthis._interpolation = ramp.interpolation;\n\t\tlet index = 0;\n\t\tfor (let point of ramp.points) {\n\t\t\tconst current_point = this._points[index];\n\t\t\tif (current_point) {\n\t\t\t\tcurrent_point.copy(point);\n\t\t\t} else {\n\t\t\t\tthis._points.push(point.clone());\n\t\t\t}\n\t\t\tindex += 1;\n\t\t}\n\t}\n\n\tis_equal(other_ramp_value: RampValue): boolean {\n\t\tif (this._interpolation != other_ramp_value.interpolation) {\n\t\t\treturn false;\n\t\t}\n\t\tconst other_points = other_ramp_value.points;\n\t\tif (this._points.length != other_points.length) {\n\t\t\treturn false;\n\t\t}\n\t\tlet index = 0;\n\t\tfor (let point of this._points) {\n\t\t\tconst other_point = other_points[index];\n\t\t\tif (!point.is_equal(other_point)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tindex += 1;\n\t\t}\n\n\t\treturn true;\n\t}\n\tis_equal_json(json: RampValueJson) {\n\t\tif (this._interpolation != json.interpolation) {\n\t\t\treturn false;\n\t\t}\n\t\tif (this._points.length != json.points.length) {\n\t\t\treturn false;\n\t\t}\n\t\tlet index = 0;\n\t\tfor (let point of this._points) {\n\t\t\tconst other_point = json.points[index];\n\t\t\tif (!point.is_equal_json(other_point)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tindex += 1;\n\t\t}\n\t\treturn true;\n\t}\n\tstatic are_json_equal(json1: RampValueJson, json2: RampValueJson) {\n\t\tif (json1.interpolation != json2.interpolation) {\n\t\t\treturn false;\n\t\t}\n\t\tif (json1.points.length != json2.points.length) {\n\t\t\treturn false;\n\t\t}\n\t\tlet index = 0;\n\t\tfor (let point1 of json1.points) {\n\t\t\tconst point2 = json2.points[index];\n\t\t\tif (!RampPoint.are_equal_json(point1, point2)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tindex += 1;\n\t\t}\n\t\treturn true;\n\t}\n\tfrom_json(json: RampValueJson) {\n\t\tthis._interpolation = json.interpolation;\n\n\t\tlet index = 0;\n\t\tfor (let json_point of json.points) {\n\t\t\tconst current_point = this._points[index];\n\t\t\tif (current_point) {\n\t\t\t\tcurrent_point.from_json(json_point);\n\t\t\t} else {\n\t\t\t\tthis._points.push(RampPoint.from_json(json_point));\n\t\t\t}\n\t\t\tindex += 1;\n\t\t}\n\t}\n}\n","import {RGBFormat} from 'three/src/constants';\nimport {DataTexture} from 'three/src/textures/DataTexture';\nimport {CubicInterpolant} from 'three/src/math/interpolants/CubicInterpolant';\nimport {TypedParam} from './_Base';\nimport {RampValue, RampPoint, RampValueJson, RampInterpolation} from './ramp/RampValue';\nimport {ParamType} from '../poly/ParamType';\nimport {ParamInitValuesTypeMap} from './types/ParamInitValuesTypeMap';\nimport {ParamValuesTypeMap} from './types/ParamValuesTypeMap';\nimport {ParamEvent} from '../poly/ParamEvent';\nimport {ArrayUtils} from '../../core/ArrayUtils';\n\n// interface RampParamVisitor extends TypedParamVisitor {\n// \tvisit_ramp_param: (param: RampParam) => any;\n// }\nconst TEXTURE_WIDTH = 1024;\nconst TEXTURE_HEIGHT = 1;\nconst TEXTURE_SIZE = TEXTURE_WIDTH * TEXTURE_HEIGHT;\n\nexport class RampParam extends TypedParam<ParamType.RAMP> {\n\tstatic type() {\n\t\treturn ParamType.RAMP;\n\t}\n\n\tprivate _ramp_interpolant: CubicInterpolant | undefined;\n\tprivate _texture_data = new Uint8Array(3 * TEXTURE_SIZE);\n\tprivate _ramp_texture = new DataTexture(this._texture_data, TEXTURE_WIDTH, TEXTURE_HEIGHT, RGBFormat);\n\n\tstatic DEFAULT_VALUE = new RampValue(RampInterpolation.LINEAR, [new RampPoint(0, 0), new RampPoint(1, 1)]);\n\tstatic DEFAULT_VALUE_JSON: RampValueJson = RampParam.DEFAULT_VALUE.toJSON();\n\n\tdefaultValueSerialized() {\n\t\tif (this._default_value instanceof RampValue) {\n\t\t\treturn this._default_value.toJSON();\n\t\t} else {\n\t\t\treturn this._default_value;\n\t\t}\n\t}\n\tprotected _clone_raw_input(raw_input: ParamInitValuesTypeMap[ParamType.RAMP]) {\n\t\tif (raw_input instanceof RampValue) {\n\t\t\treturn raw_input.clone();\n\t\t} else {\n\t\t\treturn RampValue.from_json(raw_input).toJSON();\n\t\t}\n\t}\n\trawInputSerialized() {\n\t\tif (this._raw_input instanceof RampValue) {\n\t\t\treturn this._raw_input.toJSON();\n\t\t} else {\n\t\t\treturn RampValue.from_json(this._raw_input).toJSON();\n\t\t}\n\t}\n\tvalueSerialized() {\n\t\treturn this.value.toJSON();\n\t}\n\tprotected _copy_value(param: RampParam) {\n\t\tthis.set(param.valueSerialized());\n\t}\n\n\tstatic are_raw_input_equal(\n\t\traw_input1: ParamInitValuesTypeMap[ParamType.RAMP],\n\t\traw_input2: ParamInitValuesTypeMap[ParamType.RAMP]\n\t) {\n\t\tif (raw_input1 instanceof RampValue) {\n\t\t\tif (raw_input2 instanceof RampValue) {\n\t\t\t\treturn raw_input1.is_equal(raw_input2);\n\t\t\t} else {\n\t\t\t\treturn raw_input1.is_equal_json(raw_input2);\n\t\t\t}\n\t\t} else {\n\t\t\tif (raw_input2 instanceof RampValue) {\n\t\t\t\treturn raw_input2.is_equal_json(raw_input1);\n\t\t\t} else {\n\t\t\t\treturn RampValue.are_json_equal(raw_input1, raw_input2);\n\t\t\t}\n\t\t}\n\t}\n\tstatic are_values_equal(val1: ParamValuesTypeMap[ParamType.RAMP], val2: ParamValuesTypeMap[ParamType.RAMP]) {\n\t\treturn val1.is_equal(val2);\n\t}\n\t// initialize_param() {\n\t// \tthis.addPostDirtyHook(\n\t// \t\t'_reset_ramp_interpolant_and_texture',\n\t// \t\tthis.reset_ramp_interpolant.bind(this)\n\t// \t);\n\t// }\n\t// accepts_visitor(visitor: RampParamVisitor) {\n\t// \treturn visitor.visit_ramp_param(this);\n\t// }\n\tisDefault(): boolean {\n\t\tif (this._default_value instanceof RampValue) {\n\t\t\treturn this.value.is_equal(this._default_value);\n\t\t} else {\n\t\t\treturn this.value.is_equal_json(this._default_value);\n\t\t}\n\t}\n\tprotected processRawInput() {\n\t\tif (this._raw_input instanceof RampValue) {\n\t\t\tif (!this._value) {\n\t\t\t\tthis._value = this._raw_input;\n\t\t\t} else {\n\t\t\t\tthis._value.copy(this._raw_input);\n\t\t\t}\n\t\t} else {\n\t\t\tif (!this._value) {\n\t\t\t\tthis._value = RampValue.from_json(this._raw_input);\n\t\t\t} else {\n\t\t\t\tthis._value.from_json(this._raw_input);\n\t\t\t}\n\t\t}\n\n\t\tthis._reset_ramp_interpolant();\n\t\tthis._update_ramp_texture();\n\t\tthis.options.execute_callback();\n\t\tthis.emitController.emit(ParamEvent.VALUE_UPDATED);\n\t\tthis.setSuccessorsDirty(this);\n\t}\n\n\t// convert_value(v) {\n\t// \tlet is_json = false\n\n\t// \tif (CoreType.isString(v)) {\n\t// \t\tv = JSON.parse(v)\n\t// \t\tis_json = true\n\t// \t}\n\n\t// \tif (!is_json) {\n\t// \t\tif (v.interpolation && v.points) {\n\t// \t\t\tif (CoreType.isArray(v.points)) {\n\t// \t\t\t\tis_json = true\n\t// \t\t\t}\n\t// \t\t}\n\t// \t}\n\t// \tif (is_json) {\n\t// \t\tv = RampValue.from_json(v)\n\t// \t}\n\n\t// \treturn v\n\t// }\n\t// convert_default_value(v) {\n\t// \treturn this.convert_value(v)\n\t// }\n\n\thasExpression() {\n\t\treturn false;\n\t}\n\n\tprivate _reset_ramp_interpolant() {\n\t\tthis._ramp_interpolant = undefined;\n\t\t// this._ramp_texture = undefined;\n\t}\n\tramp_texture() {\n\t\treturn this._ramp_texture;\n\t}\n\tprivate _update_ramp_texture() {\n\t\tthis._update_ramp_texture_data();\n\t\tthis.ramp_texture().needsUpdate = true;\n\t}\n\tprivate _update_ramp_texture_data() {\n\t\tlet stride = 0;\n\t\tlet position = 0;\n\t\tlet value = 0;\n\t\tfor (var i = 0; i < TEXTURE_SIZE; i++) {\n\t\t\tstride = i * 3;\n\t\t\tposition = i / TEXTURE_WIDTH;\n\t\t\tvalue = this.value_at_position(position);\n\t\t\tthis._texture_data[stride] = value * 255; // if I set 256, a value of 1 will become 0\n\t\t\t// data[ stride+1 ] = 1\n\t\t\t// data[ stride+2 ] = 2\n\t\t}\n\t}\n\n\tstatic create_interpolant(positions: Float32Array, values: Float32Array) {\n\t\tconst values_count = 1;\n\t\tconst interpolated_values = new Float32Array(values_count);\n\t\treturn new CubicInterpolant(positions, values, values_count, interpolated_values);\n\t}\n\tinterpolant() {\n\t\treturn (this._ramp_interpolant = this._ramp_interpolant || this._create_interpolant());\n\t}\n\t_create_interpolant() {\n\t\tconst points = this.value.points;\n\t\tconst sorted_points = ArrayUtils.sortBy(points, (point) => point.position);\n\t\tconst positions = new Float32Array(sorted_points.length);\n\t\tconst values = new Float32Array(sorted_points.length);\n\n\t\tlet i = 0;\n\t\tfor (let sorted_point of sorted_points) {\n\t\t\tpositions[i] = sorted_point.position;\n\t\t\tvalues[i] = sorted_point.value;\n\t\t\ti++;\n\t\t}\n\n\t\treturn RampParam.create_interpolant(positions, values);\n\t}\n\n\tvalue_at_position(position: number): number {\n\t\treturn (<unknown>this.interpolant().evaluate(position)[0]) as number;\n\t}\n}\n","// nodes\nimport {BaseSopNodeType} from '../nodes/sop/_Base';\nimport {BaseAnimNodeType} from '../nodes/anim/_Base';\nimport {BaseCopNodeType} from '../nodes/cop/_Base';\nimport {BaseEventNodeType} from '../nodes/event/_Base';\nimport {BaseGlNodeType} from '../nodes/gl/_Base';\nimport {BaseJsNodeType} from '../nodes/js/_Base';\nimport {BaseManagerNodeType} from '../nodes/manager/_Base';\nimport {BaseMatNodeType} from '../nodes/mat/_Base';\nimport {BaseObjNodeType} from '../nodes/obj/_Base';\nimport {BasePostProcessNodeType} from '../nodes/post/_Base';\nimport {BaseRopNodeType} from '../nodes/rop/_Base';\n// registers\nimport {GeoNodeChildrenMap} from './registers/nodes/Sop';\nimport {GlNodeChildrenMap} from './registers/nodes/Gl';\nimport {EventNodeChildrenMap} from './registers/nodes/Event';\nimport {CopNodeChildrenMap} from './registers/nodes/Cop';\nimport {AnimNodeChildrenMap} from './registers/nodes/Anim';\nimport {MatNodeChildrenMap} from './registers/nodes/Mat';\nimport {ObjNodeChildrenMap} from './registers/nodes/Obj';\nimport {PostNodeChildrenMap} from './registers/nodes/Post';\nimport {RopNodeChildrenMap} from './registers/nodes/Rop';\n\nexport enum NodeContext {\n\tANIM = 'anim',\n\tCOP = 'cop',\n\tEVENT = 'event',\n\tGL = 'gl',\n\tJS = 'js',\n\tMANAGER = 'manager',\n\tMAT = 'mat',\n\tOBJ = 'obj',\n\tPOST = 'post',\n\tROP = 'rop',\n\tSOP = 'sop',\n}\n\nexport type NodeContextUnion =\n\t| NodeContext.ANIM\n\t| NodeContext.COP\n\t| NodeContext.EVENT\n\t| NodeContext.GL\n\t| NodeContext.JS\n\t| NodeContext.MANAGER\n\t| NodeContext.MAT\n\t| NodeContext.OBJ\n\t| NodeContext.POST\n\t| NodeContext.ROP\n\t| NodeContext.SOP;\n\nexport enum NetworkNodeType {\n\tANIM = 'animations',\n\tCOP = 'cop',\n\tEVENT = 'events',\n\tMAT = 'materials',\n\tPOST = 'postProcess',\n\tROP = 'renderers',\n}\nexport enum NetworkChildNodeType {\n\tINPUT = 'subnetInput',\n\tOUTPUT = 'subnetOutput',\n}\nexport enum CameraNodeType {\n\tPERSPECTIVE = 'perspectiveCamera',\n\tORTHOGRAPHIC = 'orthographicCamera',\n}\nexport enum GlNodeType {\n\tATTRIBUTE = 'attribute',\n}\n\nexport enum CameraControlsNodeType {\n\tDEVICE_ORIENTATION = 'cameraDeviceOrientationControls',\n\tMAP = 'cameraMapControls',\n\tORBIT = 'cameraOrbitControls',\n\tFIRST_PERSON = 'firstPersonControls',\n}\nexport const CAMERA_CONTROLS_NODE_TYPES: Readonly<string[]> = [\n\tCameraControlsNodeType.DEVICE_ORIENTATION,\n\tCameraControlsNodeType.MAP,\n\tCameraControlsNodeType.ORBIT,\n\tCameraControlsNodeType.FIRST_PERSON,\n];\n\nexport interface BaseNodeByContextMap {\n\t[NodeContext.ANIM]: BaseAnimNodeType;\n\t[NodeContext.COP]: BaseCopNodeType;\n\t[NodeContext.EVENT]: BaseEventNodeType;\n\t[NodeContext.GL]: BaseGlNodeType;\n\t[NodeContext.JS]: BaseJsNodeType;\n\t[NodeContext.MANAGER]: BaseManagerNodeType;\n\t[NodeContext.MAT]: BaseMatNodeType;\n\t[NodeContext.OBJ]: BaseObjNodeType;\n\t[NodeContext.POST]: BasePostProcessNodeType;\n\t[NodeContext.SOP]: BaseSopNodeType;\n\t[NodeContext.ROP]: BaseRopNodeType;\n}\nexport interface ChildrenNodeMapByContextMap {\n\t[NodeContext.ANIM]: AnimNodeChildrenMap;\n\t[NodeContext.COP]: CopNodeChildrenMap;\n\t[NodeContext.EVENT]: EventNodeChildrenMap;\n\t[NodeContext.GL]: GlNodeChildrenMap;\n\t[NodeContext.JS]: BaseJsNodeType;\n\t[NodeContext.MANAGER]: {};\n\t[NodeContext.MAT]: MatNodeChildrenMap;\n\t[NodeContext.OBJ]: ObjNodeChildrenMap;\n\t[NodeContext.POST]: PostNodeChildrenMap;\n\t[NodeContext.SOP]: GeoNodeChildrenMap;\n\t[NodeContext.ROP]: RopNodeChildrenMap;\n}\n\nexport interface NodeContextAndType {\n\tcontext: NodeContext;\n\ttype: string;\n}\n","import {BaseNodeType} from '../engine/nodes/_Base';\nimport {BaseParamType} from '../engine/params/_Base';\nimport {CoreWalker} from './Walker';\nimport {CoreGraphNodeId} from './graph/CoreGraph';\ntype NodeOrParam = BaseNodeType | BaseParamType;\n\nexport class DecomposedPath {\n\tprivate _index = -1;\n\tprivate _path_elements: (string | null)[] = [];\n\tprivate _named_nodes: (NodeOrParam | null)[] = [];\n\tprivate _graph_node_ids: CoreGraphNodeId[] = [];\n\tprivate _node_element_by_graph_node_id: Map<CoreGraphNodeId, string> = new Map();\n\n\tconstructor() {}\n\treset() {\n\t\tthis._index = -1;\n\t\tthis._path_elements = [];\n\t\tthis._named_nodes = [];\n\t\tthis._graph_node_ids = [];\n\t\tthis._node_element_by_graph_node_id.clear();\n\t}\n\n\tadd_node(name: string, node: NodeOrParam) {\n\t\tthis._index += 1;\n\t\tif (name == node.name()) {\n\t\t\tthis._named_nodes[this._index] = node;\n\t\t}\n\n\t\tthis._graph_node_ids[this._index] = node.graphNodeId();\n\t\tthis._node_element_by_graph_node_id.set(node.graphNodeId(), name);\n\t}\n\tadd_path_element(path_element: string) {\n\t\tthis._index += 1;\n\t\tthis._path_elements[this._index] = path_element;\n\t}\n\n\tnamed_graph_nodes() {\n\t\treturn this._named_nodes;\n\t}\n\tnamed_nodes() {\n\t\tconst nodes: BaseNodeType[] = [];\n\t\tfor (let graph_node of this._named_nodes) {\n\t\t\tif (graph_node) {\n\t\t\t\tconst node = graph_node as BaseNodeType;\n\t\t\t\tif (node.nameController) {\n\t\t\t\t\tnodes.push(node);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn nodes;\n\t}\n\n\tupdate_from_name_change(node: NodeOrParam) {\n\t\tconst named_graph_node_ids = this._named_nodes.map((n) => n?.graphNodeId());\n\n\t\tif (named_graph_node_ids.includes(node.graphNodeId())) {\n\t\t\tthis._node_element_by_graph_node_id.set(node.graphNodeId(), node.name());\n\t\t}\n\t}\n\n\tto_path(): string {\n\t\tconst elements = new Array<string>(this._index);\n\t\tfor (let i = 0; i <= this._index; i++) {\n\t\t\tconst node = this._named_nodes[i];\n\t\t\tif (node) {\n\t\t\t\tconst node_name = this._node_element_by_graph_node_id.get(node.graphNodeId());\n\t\t\t\tif (node_name) {\n\t\t\t\t\telements[i] = node_name;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst path_element = this._path_elements[i];\n\t\t\t\tif (path_element) {\n\t\t\t\t\telements[i] = path_element;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tlet joined_path = elements.join(CoreWalker.SEPARATOR);\n\t\t// if the first character is a letter, we need to prefix with /\n\t\tconst first_char = joined_path[0];\n\t\tif (first_char) {\n\t\t\tif (!CoreWalker.NON_LETTER_PREFIXES.includes(first_char)) {\n\t\t\t\tjoined_path = `${CoreWalker.SEPARATOR}${joined_path}`;\n\t\t\t}\n\t\t}\n\t\treturn joined_path;\n\t}\n}\n","module.exports = function(module) {\n\tif (!module.webpackPolyfill) {\n\t\tmodule.deprecate = function() {};\n\t\tmodule.paths = [];\n\t\t// module.parent = undefined by default\n\t\tif (!module.children) module.children = [];\n\t\tObject.defineProperty(module, \"loaded\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.l;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"id\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.i;\n\t\t\t}\n\t\t});\n\t\tmodule.webpackPolyfill = 1;\n\t}\n\treturn module;\n};\n","import {ShaderMaterial} from 'three/src/materials/ShaderMaterial';\nimport {Object3D} from 'three/src/core/Object3D';\nimport {Mesh} from 'three/src/objects/Mesh';\nimport {Material} from 'three/src/materials/Material';\nimport {PolyScene} from '../../engine/scene/PolyScene';\nimport {IUniform} from 'three/src/renderers/shaders/UniformsLib';\nimport {UniformsUtils} from 'three/src/renderers/shaders/UniformsUtils';\nexport interface IUniforms {\n\t[uniform: string]: IUniform;\n}\nexport interface MaterialWithUniforms extends Material {\n\tuniforms: IUniforms;\n}\n\nenum CustomMaterialName {\n\tcustomDistanceMaterial = 'customDistanceMaterial',\n\tcustomDepthMaterial = 'customDepthMaterial',\n\tcustomDepthDOFMaterial = 'customDepthDOFMaterial',\n}\nexport interface ObjectWithCustomMaterials extends Mesh {\n\t// customDistanceMaterial?: Material;\n\t// customDepthMaterial?: Material;\n\tcustomDepthDOFMaterial?: Material;\n}\nexport interface ShaderMaterialWithCustomMaterials extends ShaderMaterial {\n\tcustom_materials: {\n\t\t[key in CustomMaterialName]?: ShaderMaterial;\n\t};\n}\nexport interface MaterialWithSkinning extends Material {\n\tskinning: boolean;\n\tmorphTargets: boolean;\n}\n\nimport {WebGLRenderer} from 'three/src/renderers/WebGLRenderer';\nimport {Scene} from 'three/src/scenes/Scene';\nimport {Camera} from 'three/src/cameras/Camera';\nimport {BufferGeometry} from 'three/src/core/BufferGeometry';\nimport {Geometry} from '../../modules/three/examples/jsm/deprecated/Geometry';\nimport {Group} from 'three/src/objects/Group';\n\nexport type RenderHook = (\n\trenderer: WebGLRenderer,\n\tscene: Scene,\n\tcamera: Camera,\n\tgeometry: BufferGeometry | Geometry,\n\tmaterial: Material,\n\tgroup: Group | null // it's only 'Group', and not 'Group|null' in threejs types, but got null sometimes\n) => void;\nexport type RenderHookWithObject = (\n\trenderer: WebGLRenderer,\n\tscene: Scene,\n\tcamera: Camera,\n\tgeometry: BufferGeometry | Geometry,\n\tmaterial: Material,\n\tgroup: Group | null, // it's only 'Group', and not 'Group|null' in threejs types, but got null sometimes\n\tobject: Object3D\n) => void;\nconst RENDER_HOOK_USER_DATA_KEY = 'POLY_render_hook';\n\ninterface MaterialWithRenderHook {\n\tuserData: {\n\t\t[RENDER_HOOK_USER_DATA_KEY]: RenderHookWithObject;\n\t};\n}\n\nconst EMPTY_RENDER_HOOK: RenderHook = (\n\trenderer: WebGLRenderer,\n\tscene: Scene,\n\tcamera: Camera,\n\tgeometry: BufferGeometry | Geometry,\n\tmaterial: Material,\n\tgroup: Group | null\n) => {};\n\nexport class CoreMaterial {\n\tstatic node(scene: PolyScene, material: Material) {\n\t\treturn scene.node(material.name);\n\t}\n\n\tstatic clone(src_material: Material | ShaderMaterial) {\n\t\tconst cloned_material = src_material.clone();\n\t\tconst src_uniforms = (src_material as ShaderMaterial).uniforms;\n\t\tif (src_uniforms) {\n\t\t\t(cloned_material as ShaderMaterial).uniforms = UniformsUtils.clone(src_uniforms);\n\t\t}\n\t\treturn cloned_material;\n\t}\n\n\t// static clone_single(src_material: Material) {\n\t// \tconst material = src_material.clone();\n\t// \t// linewidth doesn't seem cloned correctly for ShaderMaterial\n\t// \t(material as LineBasicMaterial).linewidth = (src_material as LineBasicMaterial).linewidth;\n\n\t// \treturn material;\n\t// }\n\n\tstatic add_user_data_render_hook(material: Material, render_hook: RenderHookWithObject) {\n\t\tmaterial.userData[RENDER_HOOK_USER_DATA_KEY] = render_hook;\n\t}\n\n\tstatic apply_render_hook(object: Object3D, material: MaterialWithRenderHook) {\n\t\tif (material.userData) {\n\t\t\tconst render_hook: RenderHookWithObject = material.userData[RENDER_HOOK_USER_DATA_KEY];\n\t\t\tif (render_hook) {\n\t\t\t\tobject.onBeforeRender = (\n\t\t\t\t\trenderer: WebGLRenderer,\n\t\t\t\t\tscene: Scene,\n\t\t\t\t\tcamera: Camera,\n\t\t\t\t\tgeometry: BufferGeometry | Geometry,\n\t\t\t\t\tmaterial: Material,\n\t\t\t\t\tgroup: Group | null\n\t\t\t\t) => {\n\t\t\t\t\trender_hook(renderer, scene, camera, geometry, material, group, object);\n\t\t\t\t};\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t// make sure to reset the render hook if apply to a material that does not have any\n\t\tobject.onBeforeRender = EMPTY_RENDER_HOOK;\n\t}\n\n\tstatic apply_custom_materials(object: Object3D, material: Material) {\n\t\tconst material_with_custom = material as ShaderMaterialWithCustomMaterials;\n\t\tif (material_with_custom.custom_materials) {\n\t\t\tfor (let name of Object.keys(material_with_custom.custom_materials)) {\n\t\t\t\tconst mat_name = name as CustomMaterialName;\n\t\t\t\t// http://blog.edankwan.com/post/three-js-advanced-tips-shadow\n\t\t\t\tconst custom_material = material_with_custom.custom_materials[mat_name];\n\t\t\t\tif (custom_material) {\n\t\t\t\t\t(object as ObjectWithCustomMaterials)[mat_name] = custom_material;\n\t\t\t\t\tcustom_material.needsUpdate = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// object.material = material.custom_materials.customDepthDOFMaterial\n\t\t\t// object.material = material.custom_materials.customDepthMaterial\n\t\t\t// object.material = material.custom_materials.customDistanceMaterial\n\t\t}\n\t}\n\tstatic assign_custom_uniforms(mat: Material, uniform_name: string, uniform_value: any) {\n\t\tconst material = mat as ShaderMaterialWithCustomMaterials;\n\t\tif (material.custom_materials) {\n\t\t\tfor (let name of Object.keys(material.custom_materials)) {\n\t\t\t\tconst mat_name = name as CustomMaterialName;\n\t\t\t\tconst custom_material = material.custom_materials[mat_name];\n\t\t\t\tif (custom_material) {\n\t\t\t\t\tcustom_material.uniforms[uniform_name].value = uniform_value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tstatic init_custom_material_uniforms(mat: Material, uniform_name: string, uniform_value: any) {\n\t\tconst material = mat as ShaderMaterialWithCustomMaterials;\n\t\tif (material.custom_materials) {\n\t\t\tfor (let name of Object.keys(material.custom_materials)) {\n\t\t\t\tconst mat_name = name as CustomMaterialName;\n\t\t\t\tconst custom_material = material.custom_materials[mat_name];\n\t\t\t\tif (custom_material) {\n\t\t\t\t\tcustom_material.uniforms[uniform_name] = custom_material.uniforms[uniform_name] || uniform_value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n","import {TypedParam} from './_Base';\nimport {ParamType} from '../poly/ParamType';\nimport {ExpressionController} from './utils/ExpressionController';\nimport {ParamEvent} from '../poly/ParamEvent';\nimport {ParamValuesTypeMap} from './types/ParamValuesTypeMap';\nimport {ParamInitValuesTypeMap} from './types/ParamInitValuesTypeMap';\nimport {CoreType} from '../../core/Type';\n\nexport abstract class TypedNumericParam<T extends ParamType> extends TypedParam<T> {\n\tisNumeric() {\n\t\treturn true;\n\t}\n\tisDefault(): boolean {\n\t\treturn this._raw_input == this._default_value;\n\t}\n\n\tprotected _prefilter_invalid_raw_input(raw_input: any): ParamInitValuesTypeMap[T] {\n\t\tif (CoreType.isArray(raw_input)) {\n\t\t\treturn raw_input[0] as ParamInitValuesTypeMap[T];\n\t\t} else {\n\t\t\treturn raw_input;\n\t\t}\n\t}\n\n\tprotected processRawInput() {\n\t\tthis.states.error.clear();\n\n\t\tconst converted = this.convert(this._raw_input);\n\t\tif (converted != null) {\n\t\t\tif (this._expression_controller) {\n\t\t\t\tthis._expression_controller.set_expression(undefined, false);\n\t\t\t\tthis.emitController.emit(ParamEvent.EXPRESSION_UPDATED); // ensure expression is considered removed\n\t\t\t}\n\t\t\tif (converted != this._value) {\n\t\t\t\tthis._update_value(converted);\n\t\t\t\tthis.setSuccessorsDirty(this);\n\t\t\t}\n\t\t} else {\n\t\t\tif (CoreType.isString(this._raw_input)) {\n\t\t\t\tthis._expression_controller = this._expression_controller || new ExpressionController(this);\n\t\t\t\tif (this._raw_input != this._expression_controller.expression()) {\n\t\t\t\t\tthis._expression_controller.set_expression(this._raw_input);\n\t\t\t\t\tthis.emitController.emit(ParamEvent.EXPRESSION_UPDATED);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.states.error.set(`param input is invalid (${this.fullPath()})`);\n\t\t\t}\n\t\t}\n\t}\n\tprotected async process_computation(): Promise<void> {\n\t\tif (this.expressionController?.active() && !this.expressionController.requires_entities()) {\n\t\t\tconst expression_result = await this.expressionController.compute_expression();\n\t\t\tif (this.expressionController.is_errored()) {\n\t\t\t\tthis.states.error.set(\n\t\t\t\t\t`expression error: \"${this.expressionController.expression()}\" (${this.expressionController.error_message()})`\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tconst converted = this.convert(expression_result);\n\t\t\t\tif (converted != null) {\n\t\t\t\t\tif (this.states.error.active()) {\n\t\t\t\t\t\tthis.states.error.clear();\n\t\t\t\t\t}\n\t\t\t\t\tthis._update_value(converted);\n\t\t\t\t} else {\n\t\t\t\t\tthis.states.error.set(\n\t\t\t\t\t\t`expression returns an invalid type (${expression_result}) (${this.expressionController.expression()})`\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprivate _update_value(new_value: ParamValuesTypeMap[T]) {\n\t\tthis._value = new_value;\n\t\tif (this.parent_param) {\n\t\t\tthis.parent_param.set_value_from_components();\n\t\t}\n\t\tthis.options.execute_callback();\n\t\tthis.emitController.emit(ParamEvent.VALUE_UPDATED);\n\t\tthis.removeDirtyState();\n\t}\n}\n","import {MathUtils} from 'three/src/math/MathUtils';\nimport {Color} from 'three/src/math/Color';\n\nexport enum ColorConversion {\n\tNONE = 'no conversion',\n\tGAMMA_TO_LINEAR = 'gamma -> linear',\n\tLINEAR_TO_GAMMA = 'linear -> gamma',\n\tSRGB_TO_LINEAR = 'sRGB -> linear',\n\tLINEAR_TO_SRGB = 'linear -> sRGB',\n}\nexport const COLOR_CONVERSIONS: ColorConversion[] = [\n\tColorConversion.NONE,\n\tColorConversion.GAMMA_TO_LINEAR,\n\tColorConversion.LINEAR_TO_GAMMA,\n\tColorConversion.SRGB_TO_LINEAR,\n\tColorConversion.LINEAR_TO_SRGB,\n];\nexport class CoreColor {\n\t// use color.toStyle() if needed\n\t// static to_css(color: Color): string {\n\t// \tconst color_elements = color.toArray().map((e) => e * 255)\n\t// \treturn `rgb(${color_elements.join(', ')})`\n\t// }\n\n\t// from THREE.js examples ColorConverter.js\n\tstatic set_hsv(h: number, s: number, v: number, target: Color) {\n\t\th = MathUtils.euclideanModulo(h, 1);\n\t\ts = MathUtils.clamp(s, 0, 1);\n\t\tv = MathUtils.clamp(v, 0, 1);\n\n\t\ttarget.setHSL(h, (s * v) / ((h = (2 - s) * v) < 1 ? h : 2 - h), h * 0.5);\n\t}\n}\n"],"sourceRoot":""}