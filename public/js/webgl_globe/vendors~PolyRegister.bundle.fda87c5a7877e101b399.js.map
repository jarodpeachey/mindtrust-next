{"version":3,"sources":["webpack:///./node_modules/@polygonjs/polygonjs/src/core/BooleanValue.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/operations/sop/_Base.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/nodes/sop/_Base.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/nodes/mat/_Base.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/nodes/obj/_Base.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/core/Transform.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/nodes/mat/utils/_BaseController.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/nodes/obj/utils/TransformController.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/nodes/obj/utils/HierarchyController.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/core/geometry/Group.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/nodes/mat/utils/SideController.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/nodes/mat/utils/DepthController.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/nodes/mat/utils/SkinningController.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/nodes/mat/utils/TextureMapController.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/nodes/mat/utils/TextureAlphaMapController.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/nodes/utils/DisplayNodeController.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/nodes/rop/WebGLRenderer.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/nodes/rop/_BaseManager.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/modules/three/examples/jsm/postprocessing/Pass.js","webpack:///./node_modules/@polygonjs/polygonjs/src/modules/three/examples/jsm/shaders/CopyShader.js","webpack:///./node_modules/@polygonjs/polygonjs/src/modules/three/examples/jsm/postprocessing/ShaderPass.js","webpack:///./node_modules/@polygonjs/polygonjs/src/modules/three/examples/jsm/postprocessing/MaskPass.js","webpack:///./node_modules/@polygonjs/polygonjs/src/modules/three/examples/jsm/postprocessing/EffectComposer.js","webpack:///./node_modules/@polygonjs/polygonjs/src/modules/three/examples/jsm/postprocessing/RenderPass.js","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/nodes/post/utils/EffectsComposerController.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/poly/registers/nodes/Rop.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/nodes/obj/Scene.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/nodes/obj/utils/cameras/RenderController.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/core/geometry/Instancer.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/core/UserAgent.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/core/cop/ConstantFilter.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/nodes/mat/utils/ColorsController.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/nodes/mat/utils/_BaseTextureController.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/nodes/obj/_BaseManager.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/nodes/obj/utils/ChildrenDisplayController.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/nodes/obj/utils/helpers/_BaseLightHelper.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/nodes/obj/_BaseLight.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/nodes/obj/utils/HelperController.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/nodes/rop/_Base.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/modules/core/objects/CSS2DObject.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/operations/sop/AttribCreate.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/nodes/sop/_BaseManager.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/operations/sop/Merge.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/operations/sop/Null.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/nodes/gl/code/globals/_Base.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/core/ThreeToGl.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/nodes/gl/_Base.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/nodes/gl/Attribute.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/nodes/gl/utils/GLDefinitionCollection.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/nodes/gl/utils/GLDefinition.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/nodes/utils/shaders/ShaderName.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/nodes/gl/code/globals/Geometry.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/nodes/utils/CopyStamp.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/nodes/sop/utils/CopyStamp.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/nodes/sop/Copy.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/modules/core/renderers/CSS2DRenderer.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/nodes/rop/CSS2DRenderer.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/nodes/mat/MeshLambert.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/nodes/obj/Cop.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/nodes/obj/Geo.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/nodes/obj/Materials.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/nodes/obj/Null.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/nodes/sop/AttribCreate.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/nodes/sop/Events.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/nodes/sop/Merge.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/nodes/sop/Normals.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/nodes/sop/Null.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/nodes/sop/ObjectMerge.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/nodes/sop/OperationsComposer.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/nodes/sop/Point.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/nodes/sop/Renderers.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/operations/sop/CSS2DObject.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/operations/sop/Add.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/operations/sop/AttribAddMult.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/operations/sop/AttribCopy.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/operations/sop/AttribNormalize.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/operations/sop/AttribPromote.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/operations/sop/Center.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/operations/sop/Instance.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/operations/sop/Material.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/operations/sop/ObjectProperties.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/operations/sop/Plane.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/operations/sop/PolarTransform.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/operations/sop/Sphere.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/operations/sop/Transform.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/expressions/methods/_Base.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/expressions/methods/bbox.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/expressions/methods/centroid.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/expressions/methods/ch.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/expressions/methods/copy.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/expressions/methods/copRes.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/expressions/methods/js.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/expressions/methods/object.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/expressions/methods/objectsCount.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/expressions/methods/opdigits.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/expressions/methods/padzero.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/expressions/methods/point.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/expressions/methods/pointsCount.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/expressions/methods/strCharsCount.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/expressions/methods/strConcat.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/expressions/methods/strIndex.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/expressions/methods/strSub.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/poly/registers/expressions/All.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/nodes/event/utils/CameraControlConfig.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/nodes/obj/utils/cameras/ControlsController.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/nodes/obj/utils/LayersController.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/nodes/obj/utils/cameras/PostProcessController.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/viewers/utils/ControlsController.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/viewers/utils/CamerasController.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/viewers/utils/EventsController.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/viewers/utils/WebglController.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/viewers/_Base.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/viewers/Threejs.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/nodes/obj/_BaseCamera.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/nodes/obj/PerspectiveCamera.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/nodes/cop/_Base.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/core/loader/AssetsUtils.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/core/loader/Texture.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/nodes/cop/utils/RendererController.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/nodes/cop/utils/TextureParamsController.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/nodes/cop/utils/FileTypeController.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/nodes/cop/Image.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/nodes/mat/utils/UniformsColorsController.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/nodes/utils/PersistedConfig.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/nodes/utils/code/configs/ParamConfig.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/nodes/gl/code/utils/ParamConfig.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/nodes/gl/code/assemblers/materials/PersistedConfig.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/nodes/mat/_BaseBuilder.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/nodes/mat/MeshBasicBuilder.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/nodes/sop/utils/delete/EntitySelectionHelper.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/nodes/sop/utils/delete/ByAttributeHelper.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/nodes/sop/utils/delete/ByExpressionHelper.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/nodes/sop/utils/delete/ByBboxHelper.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/nodes/sop/utils/delete/ByObjectTypeHelper.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/nodes/sop/Delete.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/nodes/event/_BaseCameraControls.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/modules/core/controls/OrbitControls.js","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/nodes/event/CameraOrbitControls.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/nodes/obj/_BaseLightTransformed.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/nodes/obj/utils/helpers/SpotLightHelper.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/nodes/obj/SpotLight.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/core/geometry/AttributeData.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/core/loader/geometry/JsonData.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/nodes/sop/Data.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/core/geometry/operation/AttribFromTexture.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/core/Image.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/operations/sop/AttribFromTexture.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/core/geometry/operation/Polyhedron.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/core/geometry/operation/Icosahedron.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/operations/sop/Icosahedron.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/nodes/mat/utils/WireframeController.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/nodes/mat/MeshBasic.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/nodes/obj/utils/helpers/HemisphereLightHelper.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/nodes/obj/HemisphereLight.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/core/geometry/operation/Circle3Points.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/nodes/sop/Circle3Points.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/engine/operations/sop/Circle.ts","webpack:///./node_modules/@polygonjs/polygonjs/src/core/geometry/util/Circle.ts"],"names":["isBooleanTrue","value","BaseSopOperation","SOP","input_contents","params","objects","core_group","setObjects","geometry","type","MESH","object","create_object","this","create_core_group_from_objects","material","create_index_if_none","object_constructor","MATERIALS","clone","castShadow","receiveShadow","frustumCulled","matrixAutoUpdate","MESSAGE","DEFAULT_INPUT_NAMES","TypedSopNode","flags","display","set","onUpdate","active","parent","displayNodeController","setDisplayNode","io","outputs","set_has_one_output","setContainer","FROM_SET_CORE_GROUP","set_container_objects","FROM_SET_OBJECT","FROM_SET_OBJECTS","FROM_SET_GEOMETRY","geometries","push","FROM_SET_GEOMETRIES","message","containerController","container","coreContent","touch","points_count","getAttribute","array","length","indices","Array","i","setIndex","TypedMatNode","_cook_main_without_inputs_when_dirty_bound","_cook_main_without_inputs_when_dirty","bind","MAT","super","initializeBaseNode","nameController","add_post_set_fullPath_hook","set_material_name","addPostDirtyHook","setTimeout","cookController","cook_main_without_inputs","_material","name","fullPath","createMaterial","ObjNodeRenderOrder","TypedObjNode","renderOrder","MANAGER","_children_group","_create_children_group","_attachableToHierarchy","_used_in_scene","OBJ","group","attachableToHierarchy","add","remove","_object","_create_object_with_attributes","set_object_name","node","displayNode","isCooking","TransformTargetType","TRANSFORM_TARGET_TYPES","GEOMETRIES","OBJECTS","RotationOrder","ROTATION_ORDERS","XYZ","XZY","YXZ","YZX","ZXY","ZYX","CoreTransform","_translation_matrix","_translation_matrix_q","_translation_matrix_s","_matrix","identity","_matrix_q","_matrix_euler","_matrix_s","_rotate_geometry_m","_rotate_geometry_q","_rotate_geometry_vec_dest","matrix","options","update_scale","decompose","set_params_from_matrix_position","set_params_from_matrix_quaternion","set_params_from_matrix_scale","set_params_from_matrix_euler","setFromQuaternion","toVector3","set_params_from_matrix_rotation","divideScalar","Math","PI","toArray","set_params_from_matrix_t","set_params_from_matrix_r","set_params_from_matrix_s","scene","batchUpdates","set_vector3","set_float","position","set_params_from_object_position_array","rotation","set_params_from_object_rotation_array","set_params_from_object_rotation_deg","fromArray","multiplyScalar","t","compose","r","s","scale","rotation_order","degToRad","x","y","z","setFromEuler","copy","vec_origin","vec_dest","normalize","setFromUnitVectors","makeRotationFromQuaternion","applyMatrix4","quaternion","BaseController","TransformedParamConfig","Base","default_params","transform","FOLDER","keepPosWhenParenting","BOOLEAN","rotationOrder","INTEGER","indexOf","menu","entries","map","order","v","VECTOR3","FLOAT","updateTransformFromObject","BUTTON","callback","TransformController","PARAM_CALLBACK_update_transform_from_object","HOOK_NAME","_core_transform","_keep_pos_when_parenting_m_object","_keep_pos_when_parenting_m_new_parent_inv","dirtyController","has_hook","update_transform_with_matrix","pv","equals","_update_matrix_from_params_with_core_transform","dispatchEvent","prev_auto_update","_apply_look_at","updateMatrix","set_params_from_matrix","new_parent_object","transformController","update_node_transform_params_if_required","loadingController","loaded","updateMatrixWorld","matrixWorld","invert","premultiply","update_matrix","update_node_transform_params_from_object","HierarchyController","inputs","setCount","set_depends_on_inputs","add_on_set_input_hook","on_input_updated","parent_object","root","getParentForNode","input","addToParentTransform","removeFromParentTransform","CoreGroup","_objects","_objects_with_geo","_timestamp","performance","now","reset","_bounding_box","undefined","_core_geometries","_core_objects","filter","obj","_create_core_objects","_objectData","pointsCount","constructor","children_count","children","list","core_object","coreObjects","_createCoreGeometries","isMesh","isLine","isPoints","faces","objectsWithGeo","geoFaces","geoFace","coreGeometries","g","points","flat","sum","traverse","compact","group_name","coreObjectsFromGroup","co","trim","index","parseInt","isNaN","matchMask","_compute_bounding_box","center","boundingBox","getCenter","size","getSize","bbox","computeBoundingBox","expandByObject","computeVertexNormals","first_geometry","hasAttrib","first_core_geometry","attribType","first_core_object","old_name","new_name","attrib_class","ATTRIB_CLASS","VERTEX","child","geometryFromObject","renameAttrib","OBJECT","attribNames","first_object","masks_string","masks","matching_attrib_names","attrib_name","mask","uniq","attribSizes","attribSize","default_value","core_geometry","addNumericAttrib","src_group","new_group","forEach","src_object","new_object","SideParamConfig","doubleSided","front","visibleIf","SideController","single_side","new_side","mat","side","needsUpdate","DepthParamConfig","depthWrite","cook","param","DepthController","update","depthTest","depth_controller","SkinningParamConfig","skinning","SkinningController","new_skinning","TextureMapParamConfig","useMap","TextureMapController","OPERATOR_PATH","NODE","UV","_update_options","add_hooks","p","_update","texture_map_controller","TextureAlphaMapParamConfig","useAlphaMap","TextureAlphaMapController","alphaMap","texture_alpha_map_controller","DisplayNodeController","callbacks","_initialized","_display_node","_graph_node","_on_display_node_remove_callback","onDisplayNodeRemove","_on_display_node_set_callback","onDisplayNodeSet","_on_display_node_update_callback","onDisplayNodeUpdate","dispose","console","error","lifecycle","add_on_child_add_hook","child_node","add_on_child_remove_hook","graphNodeId","last_child","new_display_node","old_display_node","removeGraphInput","addGraphInput","RendererPrecision","PowerPreference","EncodingName","EncodingValue","ENCODING_NAMES","Linear","sRGB","Gamma","RGBE","LogLuv","RGBM7","RGBM16","RGBD","ENCODING_VALUES","DEFAULT_OUTPUT_ENCODING","ToneMappingName","ToneMappingValue","TONE_MAPPING_NAMES","No","Reinhard","Cineon","ACESFilmic","TONE_MAPPING_VALUES","DEFAULT_TONE_MAPPING","TONE_MAPPING_MENU_ENTRIES","ShadowMapTypeName","ShadowMapTypeValue","SHADOW_MAP_TYPE_NAMES","Basic","PCF","PCFSoft","VSM","SHADOW_MAP_TYPE_VALUES","DEFAULT_SHADOW_MAP_TYPE","DEFAULT_PARAMS","alpha","precision","highp","premultipliedAlpha","antialias","stencil","preserveDrawingBuffer","powerPreference","DEFAULT","depth","logarithmicDepthBuffer","WebGLRendererRopParamsConfig","toneMapping","toneMappingExposure","range","outputEncoding","physicallyCorrectLights","sortObjects","tpixelRatio","pixelRatio","rangeLocked","tshadowMap","shadowMapAutoUpdate","shadowMapNeedsUpdate","shadowMapType","ParamsConfig","WebGLRendererRopNode","params_config","_renderers_by_canvas_id","WEBGL","canvas","gl","keys","Object","k","context","renderer","renderersController","printDebug","printDebugMessage","_update_renderer","id","ids","_traverse_scene_and_update_materials","end_cook","shadowMap","enabled","autoUpdate","defaultPixelRatio","setPixelRatio","threejsScene","isArray","camera","FullScreenQuad","CopyShader","uniforms","vertexShader","join","fragmentShader","Pass","needsSwap","clear","renderToScreen","assign","prototype","setSize","render","OrthographicCamera","PlaneGeometry","_mesh","Mesh","defineProperty","get","ShaderPass","shader","textureID","call","ShaderMaterial","UniformsUtils","defines","fsQuad","create","writeBuffer","readBuffer","texture","setRenderTarget","autoClearColor","autoClearDepth","autoClearStencil","MaskPass","inverse","writeValue","clearValue","getContext","state","buffers","color","setMask","setLocked","setTest","setOp","REPLACE","setFunc","ALWAYS","setClear","EQUAL","KEEP","ClearMaskPass","EffectComposer","renderTarget","parameters","minFilter","magFilter","format","Vector2","_pixelRatio","getPixelRatio","_width","width","_height","height","WebGLRenderTarget","renderTarget1","renderTarget2","passes","copyPass","clock","Clock","swapBuffers","tmp","addPass","pass","insertPass","splice","removePass","isLastEnabledPass","passIndex","deltaTime","getDelta","currentRenderTarget","getRenderTarget","maskActive","il","NOTEQUAL","effectiveWidth","effectiveHeight","RenderPass","overrideMaterial","clearColor","clearAlpha","clearDepth","_oldClearColor","Color","oldClearAlpha","oldOverrideMaterial","oldAutoClear","autoClear","getClearColor","getClearAlpha","setClearColor","RopType","BackgroundMode","BACKGROUND_MODES","NONE","COLOR","TEXTURE","FogType","FOG_TYPES","LINEAR","EXPONENTIAL","backgroundMode","mode","bgColor","bgTexture","nodeSelection","NodeContext","COP","dependentOnFoundNode","useEnvironment","environment","useFog","fogType","fogColor","fogNear","fogFar","fogDensity","useOverrideMaterial","hierarchyController","Scene","initializeNode","_update_background","_update_fog","_update_enviromment","_update_material_override","background","found_node","nodeContext","requestContainer","then","states","fog","fog2","near","far","fogExp2","density","_fog","Fog","_fogExp2","FogExp2","CameraRenderParamConfig","setScene","types","setRenderer","ROP","setCSSRenderer","CSSRenderer","Rop","CSS2D","CSS3D","_resolution_by_canvas_id","_super_sampling_size","aspect","doPostProcess","postProcessController","render_with_renderer","_resolved_cssRenderer_rop","_resolved_scene","cssRenderer","update_scene","update_renderer","update_cssRenderer","isDirty","find_target","found_node_with_context_and_type","_resolved_renderer_rop","Poly","renderingContext","create_renderer","_createDefaultRenderer","registerRenderer","set_renderer_size","isMobile","max","window","devicePixelRatio","WebGLRenderer","deregisterRenderer","update_style","SCALE","PSCALE","EYE","UP","DEFAULT_COLOR","DEFAULT_UV","CoreInstancer","_group_wrapper","_matrices","_point_scale","_point_normal","_point_up","_is_pscale_present","_is_scale_present","_is_normal_present","_is_up_present","_do_rotate_matrices","point","_matrix_from_point","attribValue","pscale","scale_matrix","makeScale","translate_matrix","makeTranslation","multiply","rotate_matrix","eye","lookAt","geometry_to_instance","template_core_group","attributes_to_copy","instance_pts","instanceCount","Infinity","instances_count","positions","Float32Array","colors","scales","orients","has_color","instance_matrices","matrices","instance_pt","index3","index4","_point_color","has_uv","uvs","index2","_point_uv","setAttribute","attribNamesMatchingMask","attrib_size","values","pt","isNumber","markAsInstance","CoreUserAgent","navigator","userAgent","test","MAG_FILTERS","LinearFilter","NearestFilter","MIN_FILTERS","NearestMipMapNearestFilter","NearestMipMapLinearFilter","LinearMipMapNearestFilter","LinearMipMapLinearFilter","MAG_FILTER_DEFAULT_VALUE","MIN_FILTER_DEFAULT_VALUE","MAG_FILTER_MENU_ENTRIES","m","MIN_FILTER_MENU_ENTRIES","ColorParamConfig","useVertexColors","transparent","opacity","alphaTest","ColorsController","newVertexColor","vertexColors","BooleanParamOptions","controller_class","OperatorPathOptions","controller","use_map_name","BaseTextureMapController","use_map_param","path_param","mat_attrib_name","shader_material","attr_name","_update_texture_on_uniforms","direct_params","_update_texture_on_material","_update_required_attribute","_apply_texture_on_uniforms","_remove_texture_from_uniforms","has_texture","new_texture_is_different","uuid","_apply_texture_on_material","_remove_texture_from_material","texture_owner","update_callback","remove_callback","compute","texture_node","BaseManagerObjNode","ParamLessBaseManagerObjNode","ChildrenDisplayController","_children_uuids_dict","_children_length","_sop_group","_create_sop_group","remove_children","request_display_node_container","sopGroup","set_sop_group_name","display_flag","_updateSopGroupHierarchy","usedInScene","visible","has_active_param","has","is_active_param_on","boolean","used_in_scene","display_flag_on","_set_content_under_sop_group","display_node","new_objects","new_objects_are_different","BaseLightHelper","_name","createObject","wireframe","buildHelper","TypedLightObjNode","LIGHT","_color_with_intensity","_light","create_light","update_light_attachment","light","shadow","create_shadow_params","update_light_params","update_shadow_params","intensity","float","HelperController","_helper_constructor","_helper","_create_helper","showHelper","helper","build","TypedRopNode","CSS2DObject","_element","style","addEventListener","_on_removed","element","Element","parentNode","removeChild","source","recursive","cloneNode","AttribCreateSopOperation","_add_attribute","class","attrib_type","add_point_attribute","add_object_attribute","unreachable","core_objects","NUMERIC","add_numeric_attribute_to_points","STRING","add_string_attribute_to_points","add_numeric_attribute_to_object","add_string_attribute_to_object","coreGeometry","value1","value2","value3","value4","addNumericVertexAttrib","setAttribValue","pointsFromGroup","string","string_values","index_data","array_to_indexed_arrays","setIndexedAttribute","INPUT_CLONED_STATE","FROM_NODE","BaseNetworkSopNode","ParamLessBaseNetworkSopNode","MergeSopOperation","all_objects","input_core_group","_make_compact","o","materials_by_object_type","Map","objects_by_type","ordered_object_types","object3d","object_type","includes","push_on_array_at_entry","merged_objects","merged_geometry","merge_geometries","e","NullSopOperation","GlobalsBaseController","_id","__next_id","globals_node","output_name","shaders_collection_controller","isString","isBoolean","ensureFloat","numeric_array","Vector3","Vector4","values_str","vec","num","vector3","w","REGEX_PATH_SANITIZE","GL","uiData","setLayoutHorizontal","connections","initInputs","connection_points","spare_params","warn","material_node","assemblerController","set_compilation_required_and_dirty","replace","input_index","get_input_index","connection","inputConnection","input_node","node_src","output_connection_point","named_output_connection_points","output_index","gl_var_name","any","connection_point","named_input_connection_points","init_value","_param_configs_controller","ATTRIBUTE_NODE_AVAILABLE_GL_TYPES","Gl","VEC2","VEC3","VEC4","texport_when_connected","hidden","export_when_connected","_on_create_set_name_if_none_bound","_on_create_set_name_if_none","ATTRIBUTE","_set_mat_to_recompile_if_is_exporting","add_on_create_hook","set_expected_input_types_function","allow_attribute_exports","set_input_name_function","INPUT_NAME","set_expected_output_types_function","dispatchController","onAddListener","onParamsCreated","label","init","addOnSceneLoadHook","OUTPUT_NAME","assembler","set_node_lines_attribute","named_input","named_input_connection_point","named_output_connection_points_by_name","used_output_names","is_exporting","_set_mat_to_recompile","TypedGLDefinitionCollection","_definitions","_errored","_error_message","definitions_by_name","names","definition","existing","data_type","uniq_definitions","GLDefinitionType","_definition_type","_data_type","_node","AttributeGLDefinition","VaryingGLDefinition","VARYING","ShaderName","PARTICLES_0","PARTICLES_1","PARTICLES_2","PARTICLES_3","PARTICLES_4","PARTICLES_5","PARTICLES_6","PARTICLES_7","PARTICLES_8","PARTICLES_9","VARIABLE_CONFIG_DEFAULT_BY_NAME","var_name","gl_type","add_definitions","shader_config","current_shader_name","dependencies","body_line","dependency","add_body_lines","variable_name","variable_config_default","read_attribute","PRE_DEFINED_ATTRIBUTES","shader_name","FRAGMENT","varying_definition","definitions_by_shader_name","body_lines_by_shader_name","MapUtils","set_varying_body_line","definitions","body_lines","IF_RULE","uv","CoreGraphNode","_global_index","setDirty","removeDirtyState","_point","TransformMode","TRANSFORM_MODES","GEOMETRY","TransformModeMenuEntries","count","transformOnly","transformMode","copyAttributes","attributesToCopy","useCopyExpr","_attribute_names_to_copy","_object_position","initInputsClonedState","InputCloneMode","NEVER","core_group0","has_input","cook_without_template","core_group1","cook_with_template","instance_core_group","template_points","q","Quaternion","_copy_moved_objects_on_template_points","point_index","_copy_moved_object_on_template_point","template_point","stamp_node","set_point","moved_objects","_get_moved_objects_for_template_point","moved_object","_copyAttributes_from_template","_apply_matrix_to_object_or_geometry","_apply_matrix_to_object","stamped_instance_core_group","_stamp_instance_group_if_required","ArrayUtils","container0","requestInputContainer","stamp_value","_copy_moved_objects_for_instance","set_global_index","_copy_moved_objects_for_each_instance","attrib_value","addAttribute","_stamp_node","create_stamp_node","set_forbidden_trigger_nodes","_widthHalf","_heightHalf","vector","viewMatrix","Matrix4","viewProjectionMatrix","cache_distanceToCameraSquared","WeakMap","domElement","document","createElement","_sort_objects","_use_fog","_fog_near","_fog_far","a","b","classList","setFromMatrixPosition","webkitTransform","dist_to_squared","getDistanceToSquared","dist","sqrt","dist_remapped","fit","clamp","appendChild","l","renderObject","object1","object2","distanceToSquared","result","matrixWorldInverse","multiplyMatrices","projectionMatrix","zOrder","sorted","filterAndFlatten","sort","distanceA","distanceB","zMax","zIndex","css","multiline","parentElement","prepend","top","left","pointerEvents","_update_css","set_sorting","set_use_fog","set_fog_range","css_element","innerHTML","_css_element","_find_element","_create_element","getElementById","_css_element_id","createTextNode","head","MeshLambertMatParamsConfig","MeshLambertMatNode","set_material","CopObjNode","_children_controller_context","node_class","params_init_value_overrides","createNode","nodesByType","GeoObjParamConfig","GeoObjNode","childrenDisplayController","displayNodeControllerCallbacks","_on_child_add_bound","_on_child_add","MaterialsObjNode","NullObjParamConfig","NullObjNode","_updateHelperHierarchy","COMPONENT_NAMES","AttribCreateSopParamsConfig","expression","forEntities","VECTOR2","VECTOR4","AttribCreateSopNode","_x_arrays_by_geometry_uuid","_y_arrays_by_geometry_uuid","_z_arrays_by_geometry_uuid","_w_arrays_by_geometry_uuid","_is_using_expression","_operation","setCoreGroup","hasExpression","expressionController","compute_expression_for_points","components","tmp_arrays","component_param","arrays_by_geometry_uuid","_init_array_if_required","j","tmp_array","compute_expression_for_objects","values_by_core_object_index","init_vector","_vector_by_attrib_size","component_index","component_name","current_array","EventsSopNode","EVENT","MergeSopParamsConfig","inputsCount","MergeSopNode","PARAM_CALLBACK_setInputsCount","_callbackUpdateInputsCount","emit","INPUTS_UPDATED","NormalsSopParamsConfig","edit","updateX","updateY","updateZ","recompute","NormalsSopNode","_eval_expressions_for_core_group","_invert_normals","_eval_expressions_for_core_object","attrib","NORMAL","normal_attrib","attributes","NullSopParamsConfig","NullSopNode","ObjectMergeSopParamsConfig","ObjectMergeSopNode","input_containers","geometry_node","import_input","coreContentCloned","OperationsComposerSopParamConfig","OperationsComposerSopNode","_input_configs_by_operation_container","operation_container","_output_operation_container","operation","input_config","existing_map","operation_input_index","node_input_index","_operation_containers_requiring_resolve","resolve_path_params","PointSopParamsConfig","updateNormals","PointSopNode","cloneRequired","tmp_array_x","_update_from_param","tmp_array_y","tmp_array_z","_commit_tmp_values","do_update_param","value_param","param_value","offset","do_update","new_array","_array_for_component","src_array","target_array","RenderersSopNode","ATTRIBUTE_NAME","CSS2DObjectSopOperation","_create_objects_from_input_points","_create_object_from_scratch","useIdAttrib","className","useClassAttrib","html","useHtmlAttrib","create_css_object","attrib_names","AddSopOperation","_create_point","_create_polygon","createPoint","POINTS","connectInputPoints","_create_polygon_open","connectToLastPoint","last_index","LINE_SEGMENTS","AttribAddMultSopOperation","_update_attrib","attribute","preAdd","mult","postAdd","AttribCopySopOperation","core_group_dest","core_group_src","copy_vertex_attribute_between_core_groups","src_objects","dest_objects","dest_geometry","src_geometry","copy_vertex_attribute_between_geometries","src_attrib","itemSize","src_points_count","dest_points_count","dest_name","tnewName","newName","dest_attribute","_fill_dest_array","dest_array","slice","src_attribute","dest_array_size","dest_item_size","src_item_size","srcOffset","destOffset","copyArray","NormalizeMode","NORMALIZE_MODES","MIN_MAX_TO_01","VECTOR_TO_LENGTH_1","AttribNormalizeSopOperation","min3","max3","_vec","dest_attrib","changeName","_normalize_attribute","_normalize_from_min_max_to_01","_normalize_vectors","minf","min","maxf","xs","ys","zs","elements_count","AttribPromoteMode","AttribPromoteSopOperation","_values_per_attrib_name","_filtered_values_per_attrib_name","_core_group","_core_object","find_values","filter_values","set_values","_find_values_for_attrib_name","classFrom","find_values_from_points","find_values_from_object","first_point","isAttribIndexed","MIN","MAX","FIRST_FOUND","new_value","classTo","set_values_to_points","set_values_to_object","attribSizeFromValue","CenterSopOperation","_geo_center","fill","InstanceSopOperation","core_group_to_instance","_geometry","object_to_instance","_create_instance","applyMaterial","_get_material","_applyMaterial","ensure_node_context","_globals_handler","matNodeAssemblerController","set_assembler_globals_handler","apply_custom_materials","create_instance_buffer_geo","MaterialSopOperation","_old_mat_by_old_new_id","_materials_by_uuid","_apply_materials","_swap_textures","assignMat","assembler_controller","applyToChildren","grand_child","_apply_material","objectsFromGroup","swapCurrentTex","mat_uuid","_swap_texture","src_material","isInGroup","used_material","cloneMat","uniform_name","object_with_material","apply_render_hook","target_mat","texSrc0","texDest0","src_mat","src_tex","shareUniforms","ObjectPropertiesSopOperation","_update_object","tname","trenderOrder","tfrustumCulled","tmatrixAutoUpdate","tvisible","tcastShadow","treceiveShadow","DEFAULT_UP","ROTATE_START","ROTATE_END","PlaneSopOperation","_cook_with_input","_cook_without_input","_create_plane","rotate_geometry","direction","translation_matrix","create_core_group_from_geometry","size2d","segments_count","useSegmentsCount","floor","segments","stepSize","AXIS_VERTICAL","AXIS_HORIZONTAL","PolarTransformSopOperation","_centerMatrix","_longitudeMatrix","_latitudeMatrix","_depthMatrix","_fullMatrix","_decomposed","_apply_transform","applyOn","_apply_matrix_to_geometries","_apply_matrix_to_objects","makeRotationAxis","longitude","latitude","SphereType","SPHERE_TYPE","ISOCAHEDRON","SphereSopOperation","_create_required_geometry","translate","sub","_create_default_sphere","_create_default_isocahedron","open","radius","resolution","phiStart","phiLength","thetaStart","thetaLength","detail","TransformSopOperation","_point_pos","pivot","_fromObjects","getPosition","setPosition","_require_dependency","required_arguments","min_allowed_arguments_count","optional_arguments","max_allowed_arguments_count","args","index_or_path","referenced_node","get_referenced_node","path","decomposed_path","find_param","input_graph_node","current_node","find_node","DecomposedPath","find_referenced_graph_node","create_dependency","MethodDependency","VECTOR_NAMES","create_dependency_from_index_or_path","Promise","async","resolve","reject","vector_name","get_referenced_node_container","_get_value_from_container","get_referenced_param","val","ref","attribute_name","Copy","arg","_function","_create_function","content","Function","object_index","coreObject","objectsCount","graph_node","name_node","tailDigits","pad","padStart","sub_string","range_start","range_size","substr","poly","expressionsRegister","register","CameraControlsConfig","_camera_node_id","_controls_node","_controls","_update_required","update_required","other_config","camera_node_id","controls_node","_applied_controls_by_element_id","controls_param","controls","raw_input","rawInput","_dispose_control_refs","viewer","_controlsEndEventName","endEventName","controls_id","controls_aleady_applied","map_for_element","apply_controls","config","set_controls_events","element_id","_dispose_controls_for_element_id","html_element_id","dispose_controls_for_html_element_id","delete","html_element","update_mode","UPDATE_FROM_CONTROLS_MODES","updateFromControlsMode","UpdateFromControlsMode","ON_END","_set_controls_events_to_update_on_end","_set_controls_events_to_update_always","_reset","controls_change_listener","removeEventListener","controls_end_listener","update_transform_params_from_object","LayerParamConfig","layer","LayersController","layers","enable","integer","POST_PROCESS_PARAM_OPTIONS","BaseThreejsCameraObjNodeClass","PARAM_CALLBACK_reset_effects_composer","CameraPostProcessParamConfig","postProcessNode","NODE_PATH","POST","_composers_by_canvas_id","_add_param_dirty_hook","composer","_create_composer","renderController","resolved_scene","post_process_network","canvas_resolution","effectsComposerController","createEffectsComposer","requester","camera_node","_active","_bound_on_controls_start","_on_controls_start","_bound_on_controls_end","_on_controls_end","_update_graph_node","dispose_controls","_config","cameraControlsController","graphDisconnectPredecessors","cameraNode","_create_graph_node","controlsController","create_controls","_viewer","_size","_aspect","_update_size","uniforms_controller","update_resolution_dependent_uniform_owners","_get_aspect","offsetWidth","offsetHeight","setup_for_aspect_ratio","_update_from_camera_container","updateCameraAspect","ViewerEventsController","_bound_process_event","process_event","_bound_listener_map_by_event_controller_type","events_controller","controller_type","listener","event_type","event","activeEventTypes","camerasController","eventsDispatcher","traverseControllers","updateEvents","event_context","processEvent","WebGLController","onwebglcontextlost","_on_webglcontextlost","onwebglcontextrestored","_on_webglcontextrestored","frame","request_animation_frame_id","cancelAnimationFrame","log","_container","_scene","_camera_node","_next_viewer_id","viewersRegister","registerViewer","_cameras_controller","_controls_controller","_events_controller","_webgl_controller","_canvas","unregisterViewer","eventsController","_properties","_do_render","_animate_method","animate","autoRender","random","outline","_build","_set_events","_init_display","activate","_onBeforeTick","_onAfterTick","_onBeforeRender","_onAfterRender","_cancel_animate","controls_controller","webglController","onresize","onResize","computeSizeAndAspect","createRenderer","prepareCurrentCamera","_request_animation_frame_id","requestAnimationFrame","timeController","incrementTimeIfPlaying","delete_renderer","EVENT_CHANGE","BASE_CAMERA_DEFAULT","CameraMasterCameraParamConfig","setMasterCamera","BaseCameraObjNodeClass","PARAM_CALLBACK_setMasterCamera","ThreejsCameraTransformParamConfig","computeOnDirty","PARAM_CALLBACK_update_near_far_from_param","CAMERA","update_camera","mouse","raycaster","set_as_master_camera","setMasterCameraNodePath","set_params_from_object","FlagsController","_layers_controller","_render_controller","RenderController","_post_process_controller","setFromCamera","layers_controller","update_near_far","update_controls","updateProjectionMatrix","_update_for_aspect_ratio","viewer_properties","fov","PerspectiveCameraObjParamConfigMixin","PERSPECTIVE","PerspectiveCamera","data","Uint16Array","EMPTY_DATA_TEXTURE","DataTexture","BaseCopNodeClass","ASSETS_ROOT","Extension","JPEG","JPG","PNG","EXR","BASIS","HDR","_param","url","substring","node_path","load_url","texture_as_env","set_texture_for_mapping","graphPredecessors","ext","get_extension","assets_root","assets","VIDEO_EXTENSIONS","_load_as_video","loader_for_ext","loader","increment_in_progress_loads_count","wait_for_max_concurrent_loads_queue_freed","load","decrement_in_progress_loads_count","EXRLoader","RGBELoader","BasisTextureLoader","toLowerCase","_exr_loader","_hdr_loader","_basis_loader","TextureLoader","module","modulesRegister","tdataType","setDataType","dataType","setTranscoderPath","waitForRenderer","detectSupport","video","onloadedmetadata","pause","VideoTexture","original_source","original_ext","VIDEO_SOURCE_TYPE_BY_EXT","_default_video_source_type","secondary_url","replace_extension","secondary_source","secondary_ext","img","image","drawImage","getImageData","elements","split","new_extension","url_elements","pop","isChrome","MAX_CONCURRENT_LOADS_COUNT","in_progress_loads_count","queued_resolve","_queue","delay","CONCURRENT_LOADS_DELAY","PARAM_DEFAULT","PARAM_ENV_DEFAULT","ogg","ogv","mp4","_init_max_concurrent_loads_count","_init_concurrent_loads_delay","useCameraRenderer","camera_renderer","_renderer","_create_renderer","firstRenderer","make_linear","FORMATS","AlphaFormat","RedFormat","RedIntegerFormat","RGFormat","RGIntegerFormat","RGBFormat","RGBIntegerFormat","RGBAFormat","RGBAIntegerFormat","LuminanceFormat","LuminanceAlphaFormat","DepthFormat","DepthStencilFormat","TYPES","UnsignedByteType","ByteType","ShortType","UnsignedShortType","IntType","UnsignedIntType","FloatType","HalfFloatType","UnsignedShort4444Type","UnsignedShort5551Type","UnsignedShort565Type","UnsignedInt248Type","MAPPINGS","UVMapping","CubeReflectionMapping","CubeRefractionMapping","EquirectangularReflectionMapping","EquirectangularRefractionMapping","CubeUVReflectionMapping","CubeUVRefractionMapping","ENCODINGS","LinearEncoding","sRGBEncoding","GammaEncoding","RGBEEncoding","LogLuvEncoding","RGBM7Encoding","RGBM16Encoding","RGBDEncoding","BasicDepthPacking","RGBADepthPacking","WRAPPINGS","ClampToEdgeWrapping","RepeatWrapping","MirroredRepeatWrapping","TextureParamConfig","tencoding","encoding","tmapping","mapping","twrap","wrapS","wrapT","wrapSep","SEPARATOR","tminFilter","tmagFilter","tanisotropy","useRendererMaxAnisotropy","anisotropy","anisotropySep","tflipY","flipY","ttransform","PARAM_CALLBACK_update_offset","repeat","PARAM_CALLBACK_update_repeat","PARAM_CALLBACK_update_rotation","PARAM_CALLBACK_update_center","tadvanced","tformat","ttype","_update_anisotropy","_update_texture_transform","_renderer_controller","max_anisotropy","capabilities","getMaxAnisotropy","_update_offset","_update_repeat","_update_rotation","_update_center","texture_params_controller","fileBrowse","TEXTURE_IMAGE","reload","PARAM_CALLBACK_reload","ImageCopParamConfig","module_names","is_static_image_url","cook_for_image","_load_texture","set_texture","clear_texture","param_callback_reload","url_param","_texture_loader","load_texture_from_url_or_op","Material","POSSIBLE_MAP_NAMES","_type","_default_value","defaultValue","callback_bound","_callback","ParamType","_uniform_name","_uniform","_create_uniform","uniform_by_type","uniform","RAMP","ramp_texture","set_uniform_value_from_texture","PARAM_PATH","_found_uniform_texture_by_id","_found_uniform_textures_id_by_uniform_name","_found_param_texture_by_id","_found_param_textures_id_by_uniform_name","_unassign_textures","material_data","toJSON","err","lights","_reassign_textures","uniform_names_needing_reassignment","param_names_needing_reassignment","texture_id","MaterialLoader","parse","uv2Transform","mat4_to_mat3","uvTransform","mat4","mat3","Matrix3","custom_materials_data","custom_materials","custom_material_names","custom_material","_material_to_json","param_uniform_pairs","param_configs","param_config","uniforms_time_dependent","uniforms_resolution_dependent","resolution_dependent","_load_material","custom_mat_data","custom_mat","add_time_dependent_uniform_owner","add_resolution_dependent_uniform_owner","pair","set_option","playerMode","persisted_config","_assembler_controller","_create_assembler_controller","childrenAllowed","markAsReadOnly","compile_required","_compile","compile_material","post_compile","GL_MESH_BASIC","assemblersRegister","usedAssembler","compile_if_required","selected_state","_entities_count","_selected_entities_count","entities","entity","_entities_for_state","required_state","array_size","ComparisonOperator","COMPARISON_OPERATORS","LESS_THAN","EQUAL_OR_LESS_THAN","EQUAL_OR_GREATER_THAN","GREATER_THAN","DIFFERENT","COMPARE_METHOD_FLOAT","n1","n2","ComparisonOperatorMenuEntries","_eval_for_numeric","_eval_for_string","stringAttribValue","attribName","attrib_string","entity_selection_helper","select","_eval_for_points_numeric_float","_eval_for_points_numeric_vector2","_eval_for_points_numeric_vector3","_eval_for_points_numeric_vector4","compared_value","attribValue1","comparison_operator","attribComparisonOperator","compare_method","attribValue2","target","attribValue3","attribValue4","eval_expressions_for_points_with_expression","eval_expressions_without_expression","compute_expression_for_entities","_point_position","_bbox","containsPoint","_bbox_cache","Box3","bboxCenter","bboxSize","objectType","byObjectType","separatorObjectType","byExpression","separatorExpression","byAttrib","attribString","separatorAttrib","byBbox","separatorBbox","keepPoints","_marked_for_deletion_per_object_index","byBbox_helper","byExpression_helper","byAttribute_helper","byObjectType_helper","_eval_for_points","_eval_for_objects","eval_for_entities","eval_for_objects","objects_to_keep","entities_to_keep","core_objects_to_delete","entities_to_delete","core_object_to_delete","point_object","_point_object","pointsFromGeometry","init_points_count","eval_for_points","kept_points","new_geo","geometryFromPoints","core_points","_controls_by_viewer","create_controls_instance","current_controls","timestamp","eval_all","setup_controls","JSON","stringify","all","valueSerialized","OrbitControls","quat","quatInverse","lastPosition","lastQuaternion","twoPI","dampingEndEventSent","minDistance","maxDistance","minZoom","maxZoom","minPolarAngle","maxPolarAngle","minAzimuthAngle","maxAzimuthAngle","enableDamping","dampingFactor","enableZoom","zoomSpeed","enableRotate","rotateSpeed","enablePan","panSpeed","screenSpacePanning","keyPanSpeed","autoRotate","autoRotateSpeed","enableKeys","keyMode","keyRotateSpeedVertical","keyRotateSpeedHorizontal","LEFT","RIGHT","BOTTOM","mouseButtons","ROTATE","MIDDLE","DOLLY","PAN","touches","ONE","TWO","DOLLY_PAN","target0","position0","zoom0","zoom","getPolarAngle","spherical","phi","getAzimuthalAngle","theta","saveState","scope","changeEvent","STATE","up","applyQuaternion","setFromVector3","rotateLeft","thetaDelta","sphericalDelta","phiDelta","EPS","endEvent","isFinite","makeSafe","addScaledVector","panOffset","setFromSpherical","zoomChanged","dot","onContextMenu","onPointerDown","onMouseWheel","onTouchStart","onTouchEnd","onTouchMove","ownerDocument","onPointerMove","onPointerUp","onKeyDown","startEvent","TOUCH_ROTATE","TOUCH_PAN","TOUCH_DOLLY_PAN","TOUCH_DOLLY_ROTATE","Spherical","rotateStart","rotateEnd","rotateDelta","panStart","panEnd","panDelta","dollyStart","dollyEnd","dollyDelta","getZoomScale","pow","angle","rotateUp","panLeft","distance","objectMatrix","setFromMatrixColumn","panUp","crossVectors","pan","deltaX","deltaY","isPerspectiveCamera","targetDistance","tan","clientHeight","isOrthographicCamera","right","clientWidth","bottom","dollyOut","dollyScale","dollyIn","handleMouseDownRotate","clientX","clientY","handleMouseDownPan","handleTouchStartRotate","pageX","pageY","handleTouchStartPan","handleTouchStartDolly","dx","dy","handleTouchMoveRotate","subVectors","handleTouchMovePan","handleTouchMoveDolly","pointerType","mouseAction","preventDefault","focus","button","handleMouseDownDolly","ctrlKey","metaKey","shiftKey","onMouseDown","handleMouseMoveRotate","handleMouseMoveDolly","handleMouseMovePan","onMouseMove","onMouseUp","stopPropagation","handleMouseWheel","keyCode","handleKeyDown","handleTouchStartDollyPan","DOLLY_ROTATE","handleTouchStartDollyRotate","handleTouchMoveDollyPan","handleTouchMoveDollyRotate","tabIndex","EventDispatcher","MapControls","KeysMode","KEYS_MODES","allowPan","allowRotate","allowZoom","tdamping","damping","limitAzimuthAngle","azimuthAngleRange","polarAngleRange","PARAM_CALLBACK_update_target","keysMode","keysPanSpeed","keysRotateSpeedVertical","keysRotateSpeedHorizontal","_controls_by_element_id","_target_array","ORBIT","setNamedOutputConnectionPoints","Event","BASE","_bind_listeners_to_controls_instance","dispatch_event_to_output","_set_azimuth_angle","_update_target","src_target","control","dest_target","_cone","LineSegments","_line_material","LineBasicMaterial","_matrix_scale","BufferGeometry","p1","p2","cos","sin","coneLength","helperSize","coneWidth","makeRotationX","conversion","SRGB_TO_LINEAR","penumbra","decay","shadowAutoUpdate","shadowUpdateOnNextRender","shadowRes","shadowBias","shadowNear","shadowFar","_helper_controller","SpotLight","bias","mapSize","_target_target","THREE","Float32BufferAttribute","Points","_attribute_datas_by_name","_options","dataKeysPrefix","skipEntries","doConvert","convertToNumeric","success_callback","progress_callback","error_callback","fetch","response","_json","json","get_prefixed_json","catch","prefixes","first_prefix","shift","core_geo","initPositionAttribute","_find_attributes","convert_to_numeric_masks","geo_attrib_name","remap_name","attrib_values","_attribute_values_for_name","matchesOneMask","numerical_attrib_values","parseFloat","first_pt","_value_has_subentries","key","deep_attrib_name","deep_attrib_value","from_value","json_element","prefix","isObject","DEFAULT_DATA_STR","set_json","setGeometry","targetAttribSize","texture_data","_data_from_texture","resx","resy","texture_component_size","uvAttribName","uv_stride","uvx","uvy","c","targetAttribName","BufferAttribute","_data_from_data_texture","_data_from_default_texture","image_data","img0","img1","datauri","toDataURL","Image","onload","src","beginPath","rect","fillStyle","src_img","ratio","is_landscape","margin","xhr","XMLHttpRequest","responseType","onerror","status","statusText","send","crossOrigin","data_from_image","_set_position_from_data_texture","uvAttrib","set_attrib","inclination","atan2","vertices","points_only","vertexBuffer","uvBuffer","vertices_by_pos","subdivideFace","cols","aj","lerp","bj","rows","pushVertex","vertex","mx","my","Set","getVertexByIndex","stride","subdivide","applyRadius","u","generateUVs","normalizeNormals","pointsOnly","LineCapType","LINE_CAP_TYPES","ROUND","BUTT","SQUARE","LineJoinType","LINE_JOIN_TYPES","BEVEL","MITER","WireframeParamConfig","wireframeLinecap","wireframeLinejoin","MeshBasicMaterial","_quat","_default_position","_color1","_color2","rotateZ","setRotationFromQuaternion","setScalar","groundColor","setXYZ","skyColor","HemisphereLight","PointsCountMode","POINTS_COUNT_MODE","SEGMENTS_COUNT","SEGMENTS_LENGTH","JoinMode","JOIN_MODES","ABC","ACB","AB","AC","BC","an","bn","cn","ac","ab","ab_x_ac","part0","part1","divider","a_center","normal","angle_ab","angle_ac","angle_bc","x_rotated","_created_geometries","_compute_axis","_create_arc","_create_center","_compute_angle","_points_count","angle_increment","applyAxisAngle","full","addIdAttribute","addIdnAttribute","idns","arc","cross","lengthSq","_set_x_from_joinMode","angleTo","_set_angle_from_joinMode","pointsCountMode","segmentsCount","perimeter","abs","ceil","segmentsLength","joinMode","_create_circle","circle3points","created_geometries","_create_disk","arc_angle","radian_per_segment","degrees_to_radians","point_radian","positions_2d","position_2d","arcAngle"],"mappings":"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","file":"vendors~PolyRegister.bundle.fda87c5a7877e101b399.js","sourcesContent":["// a simple way to test the type and value of a param value\nexport function isBooleanTrue(value: boolean) {\n\treturn value;\n}\n","import {CoreGroup} from '../../../core/geometry/Group';\nimport {BaseOperation} from '../_Base';\nimport {NodeContext} from '../../../engine/poly/NodeContext';\nimport {BufferGeometry} from 'three/src/core/BufferGeometry';\nimport {\n\tObjectType,\n\tObjectByObjectType,\n\tOBJECT_CONSTRUCTOR_BY_OBJECT_TYPE,\n\tCoreConstant,\n} from '../../../core/geometry/Constant';\nimport {CoreGeometryIndexBuilder} from '../../../core/geometry/util/IndexBuilder';\nimport {Material} from 'three/src/materials/Material';\nimport {Mesh} from 'three/src/objects/Mesh';\nimport {Object3D} from 'three/src/core/Object3D';\nexport class BaseSopOperation extends BaseOperation {\n\tstatic context() {\n\t\treturn NodeContext.SOP;\n\t}\n\tcook(input_contents: CoreGroup[], params: any): CoreGroup | Promise<CoreGroup> | void {}\n\n\t//\n\t//\n\t// UTILS\n\t//\n\t//\n\tprotected create_core_group_from_objects(objects: Object3D[]) {\n\t\tconst core_group = new CoreGroup();\n\t\tcore_group.setObjects(objects);\n\t\treturn core_group;\n\t}\n\tprotected create_core_group_from_geometry(geometry: BufferGeometry, type: ObjectType = ObjectType.MESH) {\n\t\tconst object = BaseSopOperation.create_object(geometry, type);\n\t\treturn this.create_core_group_from_objects([object]);\n\t}\n\tprotected create_object<OT extends ObjectType>(\n\t\tgeometry: BufferGeometry,\n\t\ttype: OT,\n\t\tmaterial?: Material\n\t): ObjectByObjectType[OT] {\n\t\treturn BaseSopOperation.create_object(geometry, type, material);\n\t}\n\tstatic create_object<OT extends ObjectType>(\n\t\tgeometry: BufferGeometry,\n\t\ttype: OT,\n\t\tmaterial?: Material\n\t): ObjectByObjectType[OT] {\n\t\t// ensure it has an index\n\t\tthis.create_index_if_none(geometry);\n\n\t\tconst object_constructor = OBJECT_CONSTRUCTOR_BY_OBJECT_TYPE[type] as any; //THREE[type];\n\t\tmaterial = material || CoreConstant.MATERIALS[type].clone();\n\t\tconst object: Mesh = new object_constructor(geometry, material);\n\t\tobject.castShadow = true;\n\t\tobject.receiveShadow = true;\n\t\tobject.frustumCulled = false;\n\t\tobject.matrixAutoUpdate = false;\n\n\t\treturn object as ObjectByObjectType[OT];\n\t}\n\tprotected create_index_if_none(geometry: BufferGeometry) {\n\t\tBaseSopOperation.create_index_if_none(geometry);\n\t}\n\tstatic create_index_if_none(geometry: BufferGeometry) {\n\t\tCoreGeometryIndexBuilder.create_index_if_none(geometry);\n\t}\n}\n","import {Object3D} from 'three/src/core/Object3D';\nimport {Material} from 'three/src/materials/Material';\nimport {BufferGeometry} from 'three/src/core/BufferGeometry';\nimport {TypedNode} from '../_Base';\nimport {ObjectByObjectType} from '../../../core/geometry/Constant';\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {ObjectType} from '../../../core/geometry/Constant';\nimport {NodeContext} from '../../poly/NodeContext';\nimport {NodeParamsConfig} from '../utils/params/ParamsConfig';\nimport {FlagsControllerDBO} from '../utils/FlagsController';\nimport {BaseSopOperation} from '../../operations/sop/_Base';\n\nenum MESSAGE {\n\tFROM_SET_CORE_GROUP = 'from set_core_group',\n\tFROM_SET_GROUP = 'from set_group',\n\tFROM_SET_OBJECTS = 'from set_objects',\n\tFROM_SET_OBJECT = 'from set_object',\n\tFROM_SET_GEOMETRIES = 'from set_geometries',\n\tFROM_SET_GEOMETRY = 'from set_geometry',\n}\n\nconst INPUT_GEOMETRY_NAME = 'input geometry';\nconst DEFAULT_INPUT_NAMES = [INPUT_GEOMETRY_NAME, INPUT_GEOMETRY_NAME, INPUT_GEOMETRY_NAME, INPUT_GEOMETRY_NAME];\n\n// class ParamLessNetworkSopParamsConfig extends NodeParamsConfig {}\n// export class BaseNetworkSopNode<K extends NodeParamsConfig> extends TypedNode<NodeContext.SOP, K> {\n// \tstatic node_context(): NodeContext {\n// \t\treturn NodeContext.SOP;\n// \t}\n// \t// initializeBaseNode() {\n// \t// \tthis.children_controller?.init({dependent: false});\n// \t// }\n// \tcook() {\n// \t\tthis.cookController.end_cook();\n// \t}\n// }\n// export class ParamLessBaseNetworkSopNode extends BaseNetworkSopNode<ParamLessNetworkSopParamsConfig> {}\n\nexport class TypedSopNode<K extends NodeParamsConfig> extends TypedNode<NodeContext.SOP, K> {\n\tstatic nodeContext(): NodeContext {\n\t\treturn NodeContext.SOP;\n\t}\n\tpublic readonly flags: FlagsControllerDBO = new FlagsControllerDBO(this);\n\n\tstatic displayedInputNames(): string[] {\n\t\treturn DEFAULT_INPUT_NAMES;\n\t}\n\n\tinitializeBaseNode() {\n\t\tthis.flags.display.set(false);\n\t\tthis.flags.display.onUpdate(() => {\n\t\t\tif (this.flags.display.active()) {\n\t\t\t\tconst parent = this.parent();\n\t\t\t\tif (parent && parent.displayNodeController) {\n\t\t\t\t\tparent.displayNodeController.setDisplayNode(this);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\tthis.io.outputs.set_has_one_output();\n\t}\n\n\tsetCoreGroup(core_group: CoreGroup) {\n\t\t// const objects = core_group.objects();\n\t\t// for (let object of objects) {\n\t\t// \tthis._set_object_attributes(object);\n\t\t// }\n\t\tthis.setContainer(core_group, MESSAGE.FROM_SET_CORE_GROUP);\n\t}\n\n\tsetObject(object: Object3D) {\n\t\t// this._set_object_attributes(object);\n\t\tthis.set_container_objects([object], MESSAGE.FROM_SET_OBJECT);\n\t}\n\tsetObjects(objects: Object3D[]) {\n\t\t// for (let object of objects) {\n\t\t// \tthis._set_object_attributes(object);\n\t\t// }\n\t\tthis.set_container_objects(objects, MESSAGE.FROM_SET_OBJECTS);\n\t}\n\n\tsetGeometry(geometry: BufferGeometry, type: ObjectType = ObjectType.MESH) {\n\t\tconst object = this.create_object(geometry, type);\n\t\tthis.set_container_objects([object], MESSAGE.FROM_SET_GEOMETRY);\n\t}\n\n\tsetGeometries(geometries: BufferGeometry[], type: ObjectType = ObjectType.MESH) {\n\t\tconst objects: Object3D[] = [];\n\t\tlet object;\n\t\tfor (let geometry of geometries) {\n\t\t\tobject = this.create_object(geometry, type);\n\t\t\t// this._set_object_attributes(object);\n\t\t\tobjects.push(object);\n\t\t}\n\t\tthis.set_container_objects(objects, MESSAGE.FROM_SET_GEOMETRIES);\n\t}\n\n\tset_container_objects(objects: Object3D[], message: MESSAGE) {\n\t\tconst core_group = this.containerController.container.coreContent() || new CoreGroup();\n\t\tcore_group.setObjects(objects);\n\t\tcore_group.touch();\n\t\tthis.setContainer(core_group);\n\t}\n\n\tstatic create_object<OT extends ObjectType>(\n\t\tgeometry: BufferGeometry,\n\t\ttype: OT,\n\t\tmaterial?: Material\n\t): ObjectByObjectType[OT] {\n\t\treturn BaseSopOperation.create_object(geometry, type, material);\n\t}\n\n\tcreate_object<OT extends ObjectType>(\n\t\tgeometry: BufferGeometry,\n\t\ttype: OT,\n\t\tmaterial?: Material\n\t): ObjectByObjectType[OT] {\n\t\treturn TypedSopNode.create_object(geometry, type, material);\n\t}\n\n\tstatic create_index_if_none(geometry: BufferGeometry) {\n\t\tBaseSopOperation.create_index_if_none(geometry);\n\t}\n\tprotected _create_index_if_none(geometry: BufferGeometry) {\n\t\tTypedSopNode.create_index_if_none(geometry);\n\t}\n\n\t// protected _set_object_attributes(object: Object3D) {\n\t// \tconst material: Material = (object as Mesh).material as Material;\n\t// \tif (material) {\n\t// \t\tif (!this.scene) {\n\t// \t\t\tconsole.log('no scene');\n\t// \t\t\tthrow 'no scene';\n\t// \t\t}\n\t// \t\t// const material_node = CoreMaterial.node(this.scene, material) as BaseMatNodeType;\n\t// \t\t// if (material_node) {\n\t// \t\t// \tmaterial_node.add_render_hook(object);\n\t// \t\t// }\n\t// \t}\n\t// }\n\n\tprotected _add_index(geometry: BufferGeometry) {\n\t\tconst position_attrib = geometry.getAttribute('position');\n\t\tconst position_array = position_attrib.array;\n\t\tconst points_count = position_array.length / 3;\n\t\tconst indices: number[] = new Array(points_count);\n\t\tfor (let i = 0; i < points_count; i++) {\n\t\t\tindices[i] = i;\n\t\t}\n\n\t\tgeometry.setIndex(indices);\n\t}\n}\n\nexport type BaseSopNodeType = TypedSopNode<NodeParamsConfig>;\nexport class BaseSopNodeClass extends TypedSopNode<NodeParamsConfig> {}\n","import {TypedNode} from '../_Base';\nimport {Material} from 'three/src/materials/Material';\nimport {NodeContext} from '../../poly/NodeContext';\nimport {NodeParamsConfig} from '../utils/params/ParamsConfig';\n\nexport abstract class TypedMatNode<M extends Material, K extends NodeParamsConfig> extends TypedNode<\n\tNodeContext.MAT,\n\tK\n> {\n\tstatic nodeContext(): NodeContext {\n\t\treturn NodeContext.MAT;\n\t}\n\n\tprotected _material: M | undefined;\n\n\tinitializeBaseNode() {\n\t\tsuper.initializeBaseNode();\n\n\t\tthis.nameController.add_post_set_fullPath_hook(this.set_material_name.bind(this));\n\n\t\tthis.addPostDirtyHook('_cook_main_without_inputs_when_dirty', () => {\n\t\t\tsetTimeout(this._cook_main_without_inputs_when_dirty_bound, 0);\n\t\t});\n\t}\n\n\tprivate _cook_main_without_inputs_when_dirty_bound = this._cook_main_without_inputs_when_dirty.bind(this);\n\tprivate async _cook_main_without_inputs_when_dirty() {\n\t\tawait this.cookController.cook_main_without_inputs();\n\t}\n\n\tprivate set_material_name() {\n\t\tif (this._material) {\n\t\t\tthis._material.name = this.fullPath();\n\t\t}\n\t}\n\n\tabstract createMaterial(): M;\n\tget material() {\n\t\treturn (this._material = this._material || this.createMaterial());\n\t}\n\t//\n\n\tset_material(material: Material) {\n\t\tthis.setContainer(material);\n\t}\n\n\t// add_update_method(method, arg?: any) {\n\t// \tthis._update_methods.push([method.bind(this), arg]);\n\t// }\n\n\t//run_update_methods: ->\n\n\t// add_render_hook(object: Object3D) {}\n}\n//delete object.onBeforeRender\n\nexport type BaseMatNodeType = TypedMatNode<Material, any>;\nexport class BaseMatNodeClass extends TypedMatNode<Material, any> {\n\tcreateMaterial() {\n\t\treturn new Material();\n\t}\n}\n","import {Object3D} from 'three/src/core/Object3D';\nimport {TypedNode, BaseNodeType} from '../_Base';\nimport {NodeContext} from '../../poly/NodeContext';\nimport {NodeParamsConfig} from '../utils/params/ParamsConfig';\nimport {Group} from 'three/src/objects/Group';\nimport {ChildrenDisplayController} from './utils/ChildrenDisplayController';\nimport {TransformController} from './utils/TransformController';\nimport {HierarchyController} from './utils/HierarchyController';\n\nconst INPUT_OBJECT_NAME = 'parent object';\nconst DEFAULT_INPUT_NAMES = [INPUT_OBJECT_NAME, INPUT_OBJECT_NAME, INPUT_OBJECT_NAME, INPUT_OBJECT_NAME];\n\ninterface Object3DWithNode extends Object3D {\n\tnode: BaseNodeType;\n}\n\nexport enum ObjNodeRenderOrder {\n\tMANAGER = 0,\n\tCAMERA = 2,\n\tLIGHT = 3,\n}\n\nexport class TypedObjNode<O extends Object3D, K extends NodeParamsConfig> extends TypedNode<NodeContext.OBJ, K> {\n\tstatic nodeContext(): NodeContext {\n\t\treturn NodeContext.OBJ;\n\t}\n\tstatic displayedInputNames(): string[] {\n\t\treturn DEFAULT_INPUT_NAMES;\n\t}\n\tpublic readonly renderOrder: number = ObjNodeRenderOrder.MANAGER;\n\treadonly transformController: TransformController | undefined;\n\treadonly hierarchyController: HierarchyController | undefined;\n\n\tprotected _children_group = this._create_children_group();\n\tprotected _object!: O;\n\n\tprivate _create_children_group() {\n\t\tconst group = new Group();\n\t\tgroup.matrixAutoUpdate = false;\n\t\treturn group;\n\t}\n\n\tprotected _attachableToHierarchy: boolean = true;\n\tattachableToHierarchy() {\n\t\treturn this._attachableToHierarchy;\n\t}\n\tprotected _used_in_scene: boolean = true;\n\tusedInScene() {\n\t\treturn this._used_in_scene;\n\t}\n\t// TODO call set_used_in_scene(false) when node is deleted\n\t// set_used_in_scene(state: boolean) {\n\t// \tthis._used_in_scene = state;\n\t// \tif (!this.scene.loading_controller.isLoading()) {\n\t// \t\tconst root = this.parent as ObjectsManagerNode;\n\t// \t\tif (root) {\n\t// \t\t\troot.update_object(this);\n\t// \t\t}\n\t// \t}\n\t// }\n\taddObjectToParent(parent: Object3D) {\n\t\tif (this.attachableToHierarchy()) {\n\t\t\tparent.add(this.object);\n\t\t}\n\t}\n\tremoveObjectFromParent() {\n\t\tif (this.attachableToHierarchy()) {\n\t\t\tconst parent = this.object.parent;\n\t\t\tif (parent) {\n\t\t\t\tparent.remove(this.object);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic readonly childrenDisplayController: ChildrenDisplayController | undefined;\n\n\tinitializeBaseNode() {\n\t\tthis._object = this._create_object_with_attributes();\n\t\tthis.nameController.add_post_set_fullPath_hook(this.set_object_name.bind(this));\n\t\tthis.set_object_name();\n\t}\n\n\tget children_group() {\n\t\treturn this._children_group;\n\t}\n\tget object() {\n\t\treturn this._object;\n\t}\n\n\t_create_object_with_attributes(): O {\n\t\tconst object = this.create_object();\n\t\t(object as Object3DWithNode).node = this;\n\t\tobject.add(this._children_group);\n\t\treturn object as O;\n\t}\n\tprotected set_object_name() {\n\t\tif (this._object) {\n\t\t\tthis._object.name = this.fullPath();\n\t\t\tthis._children_group.name = `${this.fullPath()}:parented_outputs`;\n\t\t}\n\t}\n\n\tcreate_object(): Object3D {\n\t\tconst object = new Object3D();\n\t\tobject.matrixAutoUpdate = false;\n\t\treturn object;\n\t}\n\n\tisDisplayNodeCooking(): boolean {\n\t\tif (this.displayNodeController) {\n\t\t\tconst displayNode = this.displayNodeController.displayNode();\n\t\t\tif (displayNode) {\n\t\t\t\treturn displayNode.cookController.isCooking();\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tisDisplayed(): boolean {\n\t\treturn this.flags?.display?.active() || false;\n\t}\n}\n\nexport type BaseObjNodeType = TypedObjNode<Object3D, any>;\nexport class BaseObjNodeClass extends TypedObjNode<Object3D, any> {}\n","import {Number3} from '../types/GlobalTypes';\nimport {Vector3} from 'three/src/math/Vector3';\nimport {Quaternion} from 'three/src/math/Quaternion';\nimport {Object3D} from 'three/src/core/Object3D';\nimport {Matrix4} from 'three/src/math/Matrix4';\nimport {Euler} from 'three/src/math/Euler';\nimport {BufferGeometry} from 'three/src/core/BufferGeometry';\nimport {MathUtils} from 'three/src/math/MathUtils';\n\nimport {BaseNodeType} from '../engine/nodes/_Base';\n\nexport enum TransformTargetType {\n\tOBJECTS = 'objects',\n\tGEOMETRIES = 'geometries',\n}\nexport const TRANSFORM_TARGET_TYPES: Array<TransformTargetType> = [\n\tTransformTargetType.GEOMETRIES,\n\tTransformTargetType.OBJECTS,\n];\n\nexport enum RotationOrder {\n\tXYZ = 'XYZ',\n\tXZY = 'XZY',\n\tYXZ = 'YXZ',\n\tYZX = 'YZX',\n\tZYX = 'ZYX',\n\tZXY = 'ZXY',\n}\nexport const ROTATION_ORDERS: RotationOrder[] = [\n\tRotationOrder.XYZ,\n\tRotationOrder.XZY,\n\tRotationOrder.YXZ,\n\tRotationOrder.YZX,\n\tRotationOrder.ZXY,\n\tRotationOrder.ZYX,\n];\nexport const DEFAULT_ROTATION_ORDER = RotationOrder.XYZ;\n\nexport interface SetParamsFromMatrixOptions {\n\tscale?: boolean;\n}\n\nexport class CoreTransform {\n\tprivate static set_params_from_matrix_position = new Vector3();\n\tprivate static set_params_from_matrix_quaternion = new Quaternion();\n\tprivate static set_params_from_matrix_scale = new Vector3();\n\tprivate static set_params_from_matrix_euler = new Euler();\n\tprivate static set_params_from_matrix_rotation = new Vector3();\n\tprivate static set_params_from_matrix_t: Number3 = [0, 0, 0];\n\tprivate static set_params_from_matrix_r: Number3 = [0, 0, 0];\n\tprivate static set_params_from_matrix_s: Number3 = [0, 0, 0];\n\tstatic set_params_from_matrix(matrix: Matrix4, node: BaseNodeType, options: SetParamsFromMatrixOptions = {}) {\n\t\tlet update_scale = options['scale'];\n\t\tif (update_scale == null) {\n\t\t\tupdate_scale = true;\n\t\t}\n\n\t\tmatrix.decompose(\n\t\t\tthis.set_params_from_matrix_position,\n\t\t\tthis.set_params_from_matrix_quaternion,\n\t\t\tthis.set_params_from_matrix_scale\n\t\t);\n\n\t\tthis.set_params_from_matrix_euler.setFromQuaternion(this.set_params_from_matrix_quaternion);\n\t\tthis.set_params_from_matrix_euler.toVector3(this.set_params_from_matrix_rotation);\n\t\tthis.set_params_from_matrix_rotation.divideScalar(Math.PI / 180);\n\n\t\tthis.set_params_from_matrix_position.toArray(this.set_params_from_matrix_t);\n\t\tthis.set_params_from_matrix_rotation.toArray(this.set_params_from_matrix_r);\n\t\tthis.set_params_from_matrix_scale.toArray(this.set_params_from_matrix_s);\n\n\t\tnode.scene().batchUpdates(() => {\n\t\t\tnode.params.set_vector3('t', this.set_params_from_matrix_t);\n\t\t\tnode.params.set_vector3('r', this.set_params_from_matrix_r);\n\t\t\tnode.params.set_vector3('s', this.set_params_from_matrix_s);\n\t\t\tif (update_scale) {\n\t\t\t\tnode.params.set_float('scale', 1);\n\t\t\t}\n\t\t});\n\t}\n\n\tstatic set_params_from_object_position_array: Number3 = [0, 0, 0];\n\tstatic set_params_from_object_rotation_deg = new Vector3();\n\tstatic set_params_from_object_rotation_array: Number3 = [0, 0, 0];\n\tstatic set_params_from_object(object: Object3D, node: BaseNodeType) {\n\t\tobject.position.toArray(this.set_params_from_object_position_array);\n\n\t\tobject.rotation.toArray(this.set_params_from_object_rotation_array);\n\t\tthis.set_params_from_object_rotation_deg.fromArray(this.set_params_from_object_rotation_array);\n\t\tthis.set_params_from_object_rotation_deg.multiplyScalar(180 / Math.PI);\n\t\tthis.set_params_from_object_rotation_deg.toArray(this.set_params_from_object_rotation_array);\n\n\t\tnode.scene().batchUpdates(() => {\n\t\t\tnode.params.set_vector3('t', this.set_params_from_object_position_array);\n\t\t\tnode.params.set_vector3('r', this.set_params_from_object_rotation_array);\n\t\t});\n\t}\n\n\tprivate _translation_matrix: Matrix4 = new Matrix4();\n\tprivate _translation_matrix_q = new Quaternion();\n\tprivate _translation_matrix_s = new Vector3(1, 1, 1);\n\ttranslation_matrix(t: Vector3): Matrix4 {\n\t\tthis._translation_matrix.compose(t, this._translation_matrix_q, this._translation_matrix_s);\n\t\treturn this._translation_matrix;\n\t}\n\n\tprivate _matrix = new Matrix4().identity();\n\tprivate _matrix_q = new Quaternion();\n\tprivate _matrix_euler = new Euler();\n\tprivate _matrix_s = new Vector3();\n\tmatrix(t: Vector3, r: Vector3, s: Vector3, scale: number, rotation_order: RotationOrder) {\n\t\tthis._matrix_euler.set(\n\t\t\tMathUtils.degToRad(r.x),\n\t\t\tMathUtils.degToRad(r.y),\n\t\t\tMathUtils.degToRad(r.z),\n\t\t\trotation_order\n\t\t);\n\t\tthis._matrix_q.setFromEuler(this._matrix_euler);\n\n\t\tthis._matrix_s.copy(s).multiplyScalar(scale);\n\n\t\tthis._matrix.compose(t, this._matrix_q, this._matrix_s);\n\t\treturn this._matrix;\n\t}\n\n\tprivate _rotate_geometry_m = new Matrix4();\n\tprivate _rotate_geometry_q = new Quaternion();\n\tprivate _rotate_geometry_vec_dest = new Vector3();\n\trotate_geometry(geometry: BufferGeometry, vec_origin: Vector3, vec_dest: Vector3) {\n\t\tthis._rotate_geometry_vec_dest.copy(vec_dest);\n\t\tthis._rotate_geometry_vec_dest.normalize();\n\t\tthis._rotate_geometry_q.setFromUnitVectors(vec_origin, this._rotate_geometry_vec_dest);\n\t\t// this._rotate_geometry_m.identity(); // not entirely sure this is necessary\n\t\tthis._rotate_geometry_m.makeRotationFromQuaternion(this._rotate_geometry_q);\n\t\tgeometry.applyMatrix4(this._rotate_geometry_m);\n\t}\n\n\tstatic decompose_matrix(object: Object3D) {\n\t\tobject.matrix.decompose(object.position, object.quaternion, object.scale);\n\t}\n}\n","import {BaseMatNodeType} from '../_Base';\n\nexport class BaseController {\n\tconstructor(protected node: BaseMatNodeType) {}\n\tadd_params() {}\n\n\tupdate() {}\n\n\tget material() {\n\t\treturn this.node.material;\n\t}\n}\n","import {Constructor} from '../../../../types/GlobalTypes';\nimport {TypedObjNode} from '../_Base';\nimport {Matrix4} from 'three/src/math/Matrix4';\nimport {CoreTransform, SetParamsFromMatrixOptions, ROTATION_ORDERS, RotationOrder} from '../../../../core/Transform';\nimport {Object3D} from 'three/src/core/Object3D';\n// import {Vector3} from 'three/src/math/Vector3';\n// import {Quaternion} from 'three/src/math/Quaternion';\nimport {NodeParamsConfig, ParamConfig} from '../../utils/params/ParamsConfig';\nimport {BaseNodeType} from '../../_Base';\nimport {isBooleanTrue} from '../../../../core/BooleanValue';\n\ninterface TransformedParamConfigDefaultParams {\n\tmatrixAutoUpdate?: boolean;\n}\n\nexport function TransformedParamConfig<TBase extends Constructor>(\n\tBase: TBase,\n\tdefault_params?: TransformedParamConfigDefaultParams\n) {\n\tconst matrixAutoUpdate = default_params?.matrixAutoUpdate || false;\n\treturn class Mixin extends Base {\n\t\ttransform = ParamConfig.FOLDER();\n\t\t/** @param toggle on to keep world position when adding a parent or removing from one */\n\t\tkeepPosWhenParenting = ParamConfig.BOOLEAN(0);\n\t\t/** @param rotation order */\n\t\trotationOrder = ParamConfig.INTEGER(ROTATION_ORDERS.indexOf(RotationOrder.XYZ), {\n\t\t\tmenu: {\n\t\t\t\tentries: ROTATION_ORDERS.map((order, v) => {\n\t\t\t\t\treturn {name: order, value: v};\n\t\t\t\t}),\n\t\t\t},\n\t\t});\n\t\t/** @param translate */\n\t\tt = ParamConfig.VECTOR3([0, 0, 0]);\n\t\t/** @param rotation */\n\t\tr = ParamConfig.VECTOR3([0, 0, 0]);\n\t\t/** @param scale */\n\t\ts = ParamConfig.VECTOR3([1, 1, 1]);\n\t\t/** @param scale */\n\t\tscale = ParamConfig.FLOAT(1);\n\t\t// pivot = ParamConfig.VECTOR3([0, 0, 0]);\n\t\t/** @param set for the matrix to be updated every frame */\n\t\tmatrixAutoUpdate = ParamConfig.BOOLEAN(matrixAutoUpdate ? 1 : 0);\n\t\tupdateTransformFromObject = ParamConfig.BUTTON(null, {\n\t\t\tcallback: (node: BaseNodeType) => {\n\t\t\t\tTransformController.PARAM_CALLBACK_update_transform_from_object(node as TransformedObjNode);\n\t\t\t},\n\t\t});\n\t\t// tlookAt = ParamConfig.BOOLEAN(0);\n\t\t// lookAtPos = ParamConfig.VECTOR3([0, 0, 0], {\n\t\t// \tvisibleIf: {tlookAt: 1},\n\t\t// });\n\t\t// look_at = ParamConfig.OPERATOR_PATH('', {\n\t\t// \tvisibleIf: {tlookAt: 1},\n\t\t// \tnodeSelection: {context: NodeContext.OBJ},\n\t\t// });\n\t\t// up = ParamConfig.VECTOR3([0, 1, 0], {\n\t\t// \tvisibleIf: {tlookAt: 1},\n\t\t// });\n\t};\n}\nclass TransformedParamsConfig extends TransformedParamConfig(NodeParamsConfig) {}\nexport class TransformedObjNode extends TypedObjNode<Object3D, TransformedParamsConfig> {\n\treadonly transformController: TransformController = new TransformController(this);\n}\n\nconst HOOK_NAME = '_cook_main_without_inputs_when_dirty';\nexport class TransformController {\n\tconstructor(private node: TransformedObjNode) {}\n\n\tinitializeNode() {\n\t\tif (!this.node.dirtyController.has_hook(HOOK_NAME)) {\n\t\t\tthis.node.dirtyController.addPostDirtyHook(HOOK_NAME, this._cook_main_without_inputs_when_dirty_bound);\n\t\t}\n\t}\n\t// TODO: this will have to be checked via the parent, when I will have obj managers at lower levels than root\n\tprivate _cook_main_without_inputs_when_dirty_bound = this._cook_main_without_inputs_when_dirty.bind(this);\n\tprivate async _cook_main_without_inputs_when_dirty() {\n\t\tawait this.node.cookController.cook_main_without_inputs();\n\t}\n\n\tupdate() {\n\t\tthis.update_transform_with_matrix();\n\t\tconst object = this.node.object;\n\t\tobject.matrixAutoUpdate = isBooleanTrue(this.node.pv.matrixAutoUpdate);\n\t}\n\n\tupdate_transform_with_matrix(matrix?: Matrix4) {\n\t\tconst object = this.node.object;\n\t\tif (matrix != null && !matrix.equals(object.matrix)) {\n\t\t\t// do not apply to cameras with control\n\n\t\t\t// object.matrixAutoUpdate = false;\n\t\t\tobject.matrix.copy(matrix);\n\n\t\t\tobject.dispatchEvent({type: 'change'});\n\t\t} else {\n\t\t\tthis._update_matrix_from_params_with_core_transform();\n\t\t\t// this.update_transform_from_params();\n\t\t}\n\t}\n\n\tprivate _core_transform = new CoreTransform();\n\tprivate _update_matrix_from_params_with_core_transform() {\n\t\tconst object = this.node.object;\n\n\t\tlet prev_auto_update = object.matrixAutoUpdate;\n\t\tif (prev_auto_update) {\n\t\t\tobject.matrixAutoUpdate = false;\n\t\t}\n\t\tconst matrix = this._core_transform.matrix(\n\t\t\tthis.node.pv.t,\n\t\t\tthis.node.pv.r,\n\t\t\tthis.node.pv.s,\n\t\t\tthis.node.pv.scale,\n\t\t\tROTATION_ORDERS[this.node.pv.rotationOrder]\n\t\t);\n\t\tobject.matrix.identity();\n\t\tobject.applyMatrix4(matrix);\n\t\tthis._apply_look_at();\n\t\tobject.updateMatrix();\n\n\t\tif (prev_auto_update) {\n\t\t\tobject.matrixAutoUpdate = true;\n\t\t}\n\n\t\tobject.dispatchEvent({type: 'change'});\n\t}\n\n\t// private _look_at_target_t = new Vector3();\n\t// private _look_at_target_q = new Quaternion();\n\t// private _look_at_target_s = new Vector3();\n\tprivate _apply_look_at() {\n\t\t// const pv = this.node.pv;\n\t\t// if (!pv.tlookAt) {\n\t\t// \treturn;\n\t\t// }\n\t\t// this.node.object.up.copy(pv.up);\n\t\t// this.node.object.lookAt(pv.lookAtPos);\n\t\t// const target_node = this.node.p.look_at.found_node_with_context(NodeContext.OBJ);\n\t\t// if (target_node) {\n\t\t// \tconst target_object = target_node.object;\n\t\t// \ttarget_object.ma.decompose(this._look_at_target_t, this._look_at_target_q, this._look_at_target_s);\n\t\t// \tthis.node.object.up.copy(this.node.pv.up);\n\t\t// \tthis.node.object.lookAt(this._look_at_target_t);\n\t\t// \tconsole.log('lookat', this.node.object, target_object, this._look_at_target_t);\n\t\t// }\n\t}\n\n\tset_params_from_matrix(matrix: Matrix4, options: SetParamsFromMatrixOptions = {}) {\n\t\tCoreTransform.set_params_from_matrix(matrix, this.node, options);\n\t}\n\n\t//\n\t//\n\t// KEEP POS WHEN PARENTING\n\t//\n\t//\n\tstatic update_node_transform_params_if_required(node: TransformedObjNode, new_parent_object: Object3D) {\n\t\tnode.transformController.update_node_transform_params_if_required(new_parent_object);\n\t}\n\t// private _keep_pos_when_parenting_t = new Vector3();\n\t// private _keep_pos_when_parenting_q = new Quaternion();\n\t// private _keep_pos_when_parenting_s = new Vector3();\n\tprivate _keep_pos_when_parenting_m_object = new Matrix4();\n\tprivate _keep_pos_when_parenting_m_new_parent_inv = new Matrix4();\n\tupdate_node_transform_params_if_required(new_parent_object: Object3D) {\n\t\tif (!isBooleanTrue(this.node.pv.keepPosWhenParenting)) {\n\t\t\treturn;\n\t\t}\n\t\tif (!this.node.scene().loadingController.loaded()) {\n\t\t\treturn;\n\t\t}\n\t\tif (new_parent_object == this.node.object.parent) {\n\t\t\treturn;\n\t\t}\n\t\tconst object = this.node.object;\n\t\tobject.updateMatrixWorld(true);\n\t\tnew_parent_object.updateMatrixWorld(true);\n\t\t// compute mat\n\t\tthis._keep_pos_when_parenting_m_object.copy(object.matrixWorld);\n\t\tthis._keep_pos_when_parenting_m_new_parent_inv.copy(new_parent_object.matrixWorld);\n\t\tthis._keep_pos_when_parenting_m_new_parent_inv.invert();\n\t\tthis._keep_pos_when_parenting_m_object.premultiply(this._keep_pos_when_parenting_m_new_parent_inv);\n\t\t// apply mat\n\t\tCoreTransform.set_params_from_matrix(this._keep_pos_when_parenting_m_object, this.node, {scale: true});\n\t}\n\tupdate_node_transform_params_from_object(update_matrix = false) {\n\t\tconst object = this.node.object;\n\t\tif (update_matrix) {\n\t\t\tobject.updateMatrix();\n\t\t}\n\t\tCoreTransform.set_params_from_matrix(object.matrix, this.node, {scale: true});\n\t}\n\n\t//\n\t//\n\t// CALLBACK\n\t//\n\t//\n\tstatic PARAM_CALLBACK_update_transform_from_object(node: TransformedObjNode) {\n\t\tnode.transformController.update_node_transform_params_from_object();\n\t}\n}\n","import {NodeParamsConfig} from '../../utils/params/ParamsConfig';\nimport {TypedObjNode, BaseObjNodeType} from '../_Base';\nimport {Object3D} from 'three/src/core/Object3D';\nimport {TransformController, TransformedObjNode} from './TransformController';\n\nclass HierarchyParamsConfig extends NodeParamsConfig {}\nexport class HierarchyObjNode extends TypedObjNode<Object3D, HierarchyParamsConfig> {\n\treadonly hierarchyController: HierarchyController = new HierarchyController(this);\n}\n\nexport class HierarchyController {\n\tconstructor(private node: HierarchyObjNode) {}\n\n\tinitializeNode() {\n\t\tthis.node.io.inputs.setCount(0, 1);\n\t\tthis.node.io.inputs.set_depends_on_inputs(false);\n\t\tthis.node.io.outputs.set_has_one_output();\n\t\tthis.node.io.inputs.add_on_set_input_hook('on_input_updated:update_parent', () => {\n\t\t\tthis.on_input_updated();\n\t\t});\n\t}\n\n\tstatic on_input_updated(node: BaseObjNodeType) {\n\t\tconst parent_object = node.root().getParentForNode(node);\n\t\tif (node.transformController && parent_object) {\n\t\t\tTransformController.update_node_transform_params_if_required(node as TransformedObjNode, parent_object);\n\t\t}\n\n\t\tif (node.io.inputs.input(0) != null) {\n\t\t\tnode.root().addToParentTransform(node as HierarchyObjNode);\n\t\t} else {\n\t\t\tnode.root().removeFromParentTransform(node as HierarchyObjNode);\n\t\t}\n\t}\n\ton_input_updated() {\n\t\tHierarchyController.on_input_updated(this.node);\n\t}\n}\n","import {NumericAttribValue, PolyDictionary} from '../../types/GlobalTypes';\nimport {Vector3} from 'three/src/math/Vector3';\nimport {Points} from 'three/src/objects/Points';\nimport {Object3D} from 'three/src/core/Object3D';\nimport {Mesh} from 'three/src/objects/Mesh';\nimport {LineSegments} from 'three/src/objects/LineSegments';\nimport {Group} from 'three/src/objects/Group';\nimport {BufferGeometry} from 'three/src/core/BufferGeometry';\nimport {Box3} from 'three/src/math/Box3';\nimport {CoreObject} from './Object';\nimport {CoreGeometry} from './Geometry';\nimport {CoreAttribute} from './Attribute';\nimport {CoreString} from '../String';\nimport {CoreConstant, AttribClass, AttribSize, ObjectData, objectTypeFromConstructor} from './Constant';\nimport {CoreType} from '../Type';\nimport {ArrayUtils} from '../ArrayUtils';\nimport {CoreFace} from './Face';\nexport type GroupString = string;\n\nexport interface Object3DWithGeometry extends Object3D {\n\tgeometry: BufferGeometry;\n}\n\nexport class CoreGroup {\n\t// _group: Group\n\tprivate _timestamp: number | undefined;\n\t// _core_objects:\n\tprivate _objects: Object3D[] = [];\n\tprivate _objects_with_geo: Object3DWithGeometry[] = [];\n\tprivate _core_objects: CoreObject[] | undefined;\n\n\t// _geometries: BufferGeometry[];\n\tprivate _core_geometries: CoreGeometry[] | undefined;\n\n\tprivate _bounding_box: Box3 | undefined;\n\t// private _bounding_sphere: Sphere | undefined;\n\n\tconstructor() {\n\t\t//_group: Group){\n\t\t// this._group = _group;\n\t\tthis.touch();\n\t}\n\n\t//\n\t//\n\t// TIMESTAMP\n\t//\n\t//\n\ttimestamp() {\n\t\treturn this._timestamp;\n\t}\n\ttouch() {\n\t\tthis._timestamp = performance.now();\n\t\tthis.reset();\n\t}\n\treset() {\n\t\tthis._bounding_box = undefined;\n\t\t// this._bounding_sphere = undefined;\n\t\tthis._core_geometries = undefined;\n\t\tthis._core_objects = undefined;\n\t}\n\n\t//\n\t//\n\t// CLONE\n\t//\n\t//\n\tclone() {\n\t\tconst core_group = new CoreGroup();\n\t\tif (this._objects) {\n\t\t\tconst objects = [];\n\t\t\tfor (let object of this._objects) {\n\t\t\t\tobjects.push(CoreObject.clone(object));\n\t\t\t}\n\t\t\tcore_group.setObjects(objects);\n\t\t}\n\t\treturn core_group;\n\t}\n\t//\n\t//\n\t// OBJECTS\n\t//\n\t//\n\tsetObjects(objects: Object3D[]) {\n\t\tthis._objects = objects;\n\t\tthis._objects_with_geo = objects.filter((obj) => (obj as Mesh).geometry != null) as Object3DWithGeometry[];\n\t\tthis.touch();\n\t}\n\tobjects() {\n\t\treturn this._objects;\n\t}\n\tobjectsWithGeo() {\n\t\treturn this._objects_with_geo;\n\t}\n\tcoreObjects() {\n\t\treturn (this._core_objects = this._core_objects || this._create_core_objects());\n\t}\n\tprivate _create_core_objects(): CoreObject[] {\n\t\t// const list: CoreObject[] = [];\n\t\t// if (this._objects) {\n\t\t// \tfor (let i = 0; i < this._objects.length; i++) {\n\t\t// \t\tthis._objects[i].traverse((object) => {\n\t\t// \t\t\tconst core_object = new CoreObject(object, i);\n\t\t// \t\t\tlist.push(core_object);\n\t\t// \t\t});\n\t\t// \t}\n\t\t// }\n\t\tif (this._objects) {\n\t\t\treturn this._objects.map((object, i) => new CoreObject(object, i));\n\t\t}\n\t\treturn [];\n\t\t// return list;\n\t}\n\tobjectsData(): ObjectData[] {\n\t\tif (this._objects) {\n\t\t\treturn this._objects.map((object) => this._objectData(object));\n\t\t}\n\t\treturn [];\n\t}\n\tprivate _objectData(object: Object3D): ObjectData {\n\t\tlet points_count = 0;\n\t\tif ((object as Mesh).geometry) {\n\t\t\tpoints_count = CoreGeometry.pointsCount((object as Mesh).geometry as BufferGeometry);\n\t\t}\n\t\treturn {\n\t\t\ttype: objectTypeFromConstructor(object.constructor),\n\t\t\tname: object.name,\n\t\t\tchildren_count: object.children.length,\n\t\t\tpoints_count: points_count,\n\t\t};\n\t}\n\n\t// group() {\n\t// \treturn this._group;\n\t// }\n\t// uuid() {\n\t// \treturn this._group.uuid;\n\t// }\n\n\tgeometries(): BufferGeometry[] {\n\t\t// this._geometries = [];\n\t\t// for (let object of this._objects) {\n\t\t// \tobject.traverse((object) => this.__geometry_from_object.bind(this)(this._geometries, object));\n\t\t// \t// \tconst geometry = this.geometry_from_object(object)\n\t\t// \t// \tif (geometry != null) {\n\t\t// \t// \t\treturn list.push(new CoreGeometry(geometry));\n\t\t// \t// \t}\n\t\t// \t// });\n\t\t// }\n\t\t// return this._geometries;\n\t\tconst list: BufferGeometry[] = [];\n\t\tfor (let core_object of this.coreObjects()) {\n\t\t\tconst geometry = (core_object.object() as Mesh).geometry as BufferGeometry;\n\t\t\tif (geometry) {\n\t\t\t\tlist.push(geometry);\n\t\t\t}\n\t\t}\n\t\treturn list;\n\t}\n\tcoreGeometries(): CoreGeometry[] {\n\t\treturn (this._core_geometries = this._core_geometries || this._createCoreGeometries());\n\t}\n\tprivate _createCoreGeometries() {\n\t\tconst list: CoreGeometry[] = [];\n\t\tfor (let geometry of this.geometries()) {\n\t\t\tlist.push(new CoreGeometry(geometry));\n\t\t\t// object.traverse(object=> this.__core_geometry_from_object.bind(this)(this._core_geometries, object))\n\t\t\t// \tconst geometry = this.geometry_from_object(object)\n\t\t\t// \tif (geometry != null) {\n\t\t\t// \t\treturn list.push(new CoreGeometry(geometry));\n\t\t\t// \t}\n\t\t\t// });\n\t\t}\n\t\treturn list;\n\t}\n\t// __geometry_from_object(list: BufferGeometry[], object: Mesh) {\n\t// \tif (object.geometry) {\n\t// \t\treturn list.push(object.geometry as BufferGeometry);\n\t// \t}\n\t// }\n\t// __core_geometry_from_object(list, object){\n\t// \tconst geometry = CoreGroup.geometry_from_object(object)\n\t// \tif (geometry != null) {\n\t// \t\treturn list.push(new CoreGeometry(geometry));\n\t// \t}\n\t// }\n\tstatic geometryFromObject(object: Object3D): BufferGeometry | null {\n\t\tif ((object as Mesh).isMesh || (object as LineSegments).isLine || (object as Points).isPoints) {\n\t\t\treturn (object as Mesh).geometry as BufferGeometry;\n\t\t}\n\t\treturn null;\n\t}\n\tfaces() {\n\t\tconst faces: CoreFace[] = [];\n\t\tfor (let object of this.objectsWithGeo()) {\n\t\t\tif (object.geometry) {\n\t\t\t\tconst coreGeo = new CoreGeometry(object.geometry);\n\t\t\t\tconst geoFaces = coreGeo.faces();\n\t\t\t\tfor (let geoFace of geoFaces) {\n\t\t\t\t\tgeoFace.applyMatrix4(object.matrix);\n\t\t\t\t\tfaces.push(geoFace);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn faces;\n\t}\n\tpoints() {\n\t\treturn this.coreGeometries()\n\t\t\t.map((g) => g.points())\n\t\t\t.flat();\n\t}\n\tpointsCount() {\n\t\treturn ArrayUtils.sum(this.coreGeometries().map((g) => g.pointsCount()));\n\t}\n\ttotalPointsCount() {\n\t\tif (this._objects) {\n\t\t\tlet sum = 0;\n\t\t\tfor (let object of this._objects) {\n\t\t\t\tobject.traverse((object) => {\n\t\t\t\t\tconst geometry = (object as Mesh).geometry as BufferGeometry;\n\t\t\t\t\tif (geometry) {\n\t\t\t\t\t\tsum += CoreGeometry.pointsCount(geometry);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t\treturn sum;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\tpointsFromGroup(group: GroupString) {\n\t\tif (group) {\n\t\t\tconst indices = CoreString.indices(group);\n\t\t\tconst points = this.points();\n\t\t\treturn ArrayUtils.compact(indices.map((i) => points[i]));\n\t\t} else {\n\t\t\treturn this.points();\n\t\t}\n\t}\n\n\tstatic _fromObjects(objects: Object3D[]): CoreGroup {\n\t\tconst core_group = new CoreGroup();\n\t\tcore_group.setObjects(objects);\n\t\treturn core_group;\n\t}\n\n\tobjectsFromGroup(group_name: string): Object3D[] {\n\t\treturn this.coreObjectsFromGroup(group_name).map((co) => co.object());\n\t}\n\tcoreObjectsFromGroup(group_name: string): CoreObject[] {\n\t\tgroup_name = group_name.trim();\n\n\t\tif (group_name !== '') {\n\t\t\tconst index = parseInt(group_name);\n\t\t\tif (!CoreType.isNaN(index)) {\n\t\t\t\treturn ArrayUtils.compact([this.coreObjects()[index]]);\n\t\t\t} else {\n\t\t\t\treturn this.coreObjects().filter((core_object) => {\n\t\t\t\t\treturn CoreString.matchMask(group_name, core_object.name());\n\t\t\t\t});\n\t\t\t}\n\t\t} else {\n\t\t\treturn this.coreObjects();\n\t\t}\n\t}\n\n\tboundingBox(): Box3 {\n\t\treturn (this._bounding_box = this._bounding_box || this._compute_bounding_box());\n\t}\n\t// bounding_sphere(): Sphere {\n\t// \treturn (this._bounding_sphere = this._bounding_sphere || this._compute_bounding_sphere());\n\t// }\n\tcenter(): Vector3 {\n\t\tconst center = new Vector3();\n\t\tthis.boundingBox().getCenter(center);\n\t\treturn center;\n\t}\n\tsize(): Vector3 {\n\t\tconst size = new Vector3();\n\t\tthis.boundingBox().getSize(size);\n\t\treturn size;\n\t}\n\n\tprivate _compute_bounding_box() {\n\t\tlet bbox: Box3 | undefined; // = new Box3();\n\t\tif (this._objects) {\n\t\t\tfor (let object of this._objects) {\n\t\t\t\tconst geometry = (object as Object3DWithGeometry).geometry;\n\t\t\t\tif (geometry) {\n\t\t\t\t\tgeometry.computeBoundingBox();\n\t\t\t\t\tif (bbox) {\n\t\t\t\t\t\tbbox.expandByObject(object);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (geometry.boundingBox) {\n\t\t\t\t\t\t\tbbox = geometry.boundingBox.clone();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbbox = bbox || new Box3(new Vector3(-1, -1, -1), new Vector3(+1, +1, +1));\n\t\treturn bbox;\n\t}\n\t// private _compute_bounding_sphere() {\n\t// \tlet sphere: Sphere | undefined; // = new Box3();\n\t// \tif (this._objects) {\n\t// \t\tfor (let object of this._objects) {\n\t// \t\t\tconst geometry = (object as Object3DWithGeometry).geometry;\n\t// \t\t\tgeometry.computeBoundingSphere();\n\t// \t\t\tif (sphere) {\n\t// \t\t\t\tsphere.expandByObject(object);\n\t// \t\t\t} else {\n\t// \t\t\t\tsphere = geometry.boundingBox.clone();\n\t// \t\t\t}\n\t// \t\t}\n\t// \t}\n\t// \tsphere = sphere || new Sphere(new Vector3(0, 0, 0), 1);\n\t// \treturn sphere;\n\t// }\n\tcomputeVertexNormals() {\n\t\tfor (let object of this.coreObjects()) {\n\t\t\tobject.computeVertexNormals();\n\t\t}\n\t}\n\n\thasAttrib(name: string) {\n\t\tlet first_geometry;\n\t\tif ((first_geometry = this.coreGeometries()[0]) != null) {\n\t\t\treturn first_geometry.hasAttrib(name);\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\tattribType(name: string) {\n\t\tconst first_core_geometry = this.coreGeometries()[0];\n\t\tif (first_core_geometry != null) {\n\t\t\treturn first_core_geometry.attribType(name);\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\tobjectAttribType(name: string) {\n\t\tconst first_core_object = this.coreObjects()[0];\n\t\tif (first_core_object != null) {\n\t\t\treturn first_core_object.attribType(name);\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\trenameAttrib(old_name: string, new_name: string, attrib_class: AttribClass) {\n\t\tswitch (attrib_class) {\n\t\t\tcase CoreConstant.ATTRIB_CLASS.VERTEX:\n\t\t\t\tif (this.hasAttrib(old_name)) {\n\t\t\t\t\tif (this._objects) {\n\t\t\t\t\t\tfor (let object of this._objects) {\n\t\t\t\t\t\t\tobject.traverse((child) => {\n\t\t\t\t\t\t\t\tconst geometry = CoreGroup.geometryFromObject(child);\n\t\t\t\t\t\t\t\tif (geometry) {\n\t\t\t\t\t\t\t\t\tconst core_geometry = new CoreGeometry(geometry);\n\t\t\t\t\t\t\t\t\tcore_geometry.renameAttrib(old_name, new_name);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase CoreConstant.ATTRIB_CLASS.OBJECT:\n\t\t\t\tif (this.hasAttrib(old_name)) {\n\t\t\t\t\tif (this._objects) {\n\t\t\t\t\t\tfor (let object of this._objects) {\n\t\t\t\t\t\t\tobject.traverse((child) => {\n\t\t\t\t\t\t\t\tconst core_object = new CoreObject(child, 0);\n\t\t\t\t\t\t\t\tcore_object.renameAttrib(old_name, new_name);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tattribNames() {\n\t\tlet first_geometry;\n\t\tif ((first_geometry = this.coreGeometries()[0]) != null) {\n\t\t\treturn first_geometry.attribNames();\n\t\t} else {\n\t\t\treturn [];\n\t\t}\n\t}\n\tobjectAttribNames() {\n\t\tlet first_object;\n\t\tif ((first_object = this.coreObjects()[0]) != null) {\n\t\t\treturn first_object.attribNames();\n\t\t} else {\n\t\t\treturn [];\n\t\t}\n\t}\n\n\tattribNamesMatchingMask(masks_string: GroupString) {\n\t\tconst masks = CoreString.attribNames(masks_string);\n\n\t\tconst matching_attrib_names: string[] = [];\n\t\tfor (let attrib_name of this.attribNames()) {\n\t\t\tfor (let mask of masks) {\n\t\t\t\tif (CoreString.matchMask(attrib_name, mask)) {\n\t\t\t\t\tmatching_attrib_names.push(attrib_name);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn ArrayUtils.uniq(matching_attrib_names);\n\t}\n\n\tattribSizes() {\n\t\tlet first_geometry;\n\t\tif ((first_geometry = this.coreGeometries()[0]) != null) {\n\t\t\treturn first_geometry.attribSizes();\n\t\t} else {\n\t\t\treturn {};\n\t\t}\n\t}\n\tobjectAttribSizes(): PolyDictionary<AttribSize> {\n\t\tlet first_object;\n\t\tif ((first_object = this.coreObjects()[0]) != null) {\n\t\t\treturn first_object.attribSizes();\n\t\t} else {\n\t\t\treturn {};\n\t\t}\n\t}\n\tattribSize(attrib_name: string) {\n\t\tlet first_geometry;\n\t\tif ((first_geometry = this.coreGeometries()[0]) != null) {\n\t\t\treturn first_geometry.attribSize(attrib_name);\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\taddNumericVertexAttrib(name: string, size: number, default_value: NumericAttribValue) {\n\t\tif (default_value == null) {\n\t\t\tdefault_value = CoreAttribute.default_value(size);\n\t\t}\n\n\t\tfor (let core_geometry of this.coreGeometries()) {\n\t\t\tcore_geometry.addNumericAttrib(name, size, default_value);\n\t\t}\n\t}\n\n\t// add_numeric_object_attrib(name: string, size: number, default_value: NumericAttribValue) {\n\t// \tif (default_value == null) {\n\t// \t\tdefault_value = CoreAttribute.default_value(size);\n\t// \t}\n\n\t// \tfor (let core_object of this.coreObjects()) {\n\t// \t\tcore_object.addNumericAttrib(name, default_value);\n\t// \t}\n\t// }\n\n\tstatic clone(src_group: Group) {\n\t\tconst new_group = new Group();\n\n\t\tsrc_group.children.forEach((src_object) => {\n\t\t\tconst new_object = CoreObject.clone(src_object);\n\t\t\tnew_group.add(new_object);\n\t\t});\n\n\t\treturn new_group;\n\t}\n}\n","import {Constructor} from '../../../../types/GlobalTypes';\nimport {BaseController} from './_BaseController';\nimport {FrontSide} from 'three/src/constants';\nimport {DoubleSide} from 'three/src/constants';\nimport {BackSide} from 'three/src/constants';\nimport {Material} from 'three/src/materials/Material';\nimport {TypedMatNode} from '../_Base';\n\nimport {NodeParamsConfig, ParamConfig} from '../../utils/params/ParamsConfig';\nimport {isBooleanTrue} from '../../../../core/BooleanValue';\nexport function SideParamConfig<TBase extends Constructor>(Base: TBase) {\n\treturn class Mixin extends Base {\n\t\t/** @param defines if the material is double sided or not */\n\t\tdoubleSided = ParamConfig.BOOLEAN(0);\n\t\t/** @param if the material is not double sided, it can be front sided, or back sided */\n\t\tfront = ParamConfig.BOOLEAN(1, {visibleIf: {doubleSided: false}});\n\t};\n}\n\nclass SidedMaterial extends Material {\n\tside!: number;\n}\nclass SideParamsConfig extends SideParamConfig(NodeParamsConfig) {}\nclass SideMatNode extends TypedMatNode<SidedMaterial, SideParamsConfig> {\n\tcreateMaterial() {\n\t\treturn new SidedMaterial();\n\t}\n}\n\nexport class SideController extends BaseController {\n\tconstructor(protected node: SideMatNode) {\n\t\tsuper(node);\n\t}\n\tstatic update(node: SideMatNode) {\n\t\tconst single_side = isBooleanTrue(node.pv.front) ? FrontSide : BackSide;\n\t\tconst new_side = isBooleanTrue(node.pv.doubleSided) ? DoubleSide : single_side;\n\t\tconst mat = node.material;\n\t\tif (new_side != mat.side) {\n\t\t\tmat.side = new_side;\n\t\t\tmat.needsUpdate = true;\n\t\t}\n\t}\n}\n","import {Constructor} from '../../../../types/GlobalTypes';\nimport {Material} from 'three/src/materials/Material';\nimport {TypedMatNode} from '../_Base';\nimport {BaseController} from './_BaseController';\nimport {NodeParamsConfig, ParamConfig} from '../../utils/params/ParamsConfig';\nimport {BaseNodeType} from '../../_Base';\nimport {BaseParamType} from '../../../params/_Base';\nexport function DepthParamConfig<TBase extends Constructor>(Base: TBase) {\n\treturn class Mixin extends Base {\n\t\t/** @param defines if the objects using this material will be rendered in the depth buffer. This can often help transparent objects */\n\t\tdepthWrite = ParamConfig.BOOLEAN(1, {\n\t\t\tcook: false,\n\t\t\tcallback: (node: BaseNodeType, param: BaseParamType) => {\n\t\t\t\tDepthController.update(node as DepthMapMatNode);\n\t\t\t},\n\t\t});\n\t\t/** @param toggle depth test */\n\t\tdepthTest = ParamConfig.BOOLEAN(1, {\n\t\t\tcook: false,\n\t\t\tcallback: (node: BaseNodeType, param: BaseParamType) => {\n\t\t\t\tDepthController.update(node as DepthMapMatNode);\n\t\t\t},\n\t\t});\n\t};\n}\n\nclass DepthParamsConfig extends DepthParamConfig(NodeParamsConfig) {}\n\nabstract class DepthMapMatNode extends TypedMatNode<Material, DepthParamsConfig> {\n\tdepth_controller!: DepthController;\n\tabstract createMaterial(): Material;\n}\n\nexport class DepthController extends BaseController {\n\tconstructor(protected node: DepthMapMatNode) {\n\t\tsuper(node);\n\t}\n\n\tasync update() {\n\t\tthis.node.material.depthWrite = this.node.pv.depthWrite;\n\t\tthis.node.material.depthTest = this.node.pv.depthTest;\n\t}\n\tstatic async update(node: DepthMapMatNode) {\n\t\tnode.depth_controller.update();\n\t}\n}\n","import {Constructor} from '../../../../types/GlobalTypes';\nimport {BaseController} from './_BaseController';\nimport {Material} from 'three/src/materials/Material';\nimport {NodeParamsConfig, ParamConfig} from '../../utils/params/ParamsConfig';\nimport {TypedMatNode} from '../_Base';\nimport {isBooleanTrue} from '../../../../core/BooleanValue';\nexport function SkinningParamConfig<TBase extends Constructor>(Base: TBase) {\n\treturn class Mixin extends Base {\n\t\t/** @param activates skinning for objects animated via a skeleton */\n\t\tskinning = ParamConfig.BOOLEAN(0);\n\t};\n}\n\nclass SkinnedMaterial extends Material {\n\tskinning!: boolean;\n}\nclass SkinningParamsConfig extends SkinningParamConfig(NodeParamsConfig) {}\nclass SkinningMatNode extends TypedMatNode<SkinnedMaterial, SkinningParamsConfig> {\n\tcreateMaterial() {\n\t\treturn new SkinnedMaterial();\n\t}\n}\n\nexport class SkinningController extends BaseController {\n\tconstructor(protected node: SkinningMatNode) {\n\t\tsuper(node);\n\t}\n\tstatic update(node: SkinningMatNode) {\n\t\tconst new_skinning = isBooleanTrue(node.pv.skinning);\n\t\tif (new_skinning != node.material.skinning) {\n\t\t\tnode.material.skinning = new_skinning;\n\t\t\tnode.material.needsUpdate = true;\n\t\t}\n\t}\n}\n","import {Constructor} from '../../../../types/GlobalTypes';\nimport {Material} from 'three/src/materials/Material';\nimport {Texture} from 'three/src/textures/Texture';\nimport {TypedMatNode} from '../_Base';\nimport {\n\tBaseTextureMapController,\n\tBooleanParamOptions,\n\tOperatorPathOptions,\n\tUpdateOptions,\n} from './_BaseTextureController';\nimport {ShaderMaterial} from 'three/src/materials/ShaderMaterial';\n\nimport {NodeParamsConfig, ParamConfig} from '../../utils/params/ParamsConfig';\nimport {NODE_PATH_DEFAULT} from '../../../../core/Walker';\nexport function TextureMapParamConfig<TBase extends Constructor>(Base: TBase) {\n\treturn class Mixin extends Base {\n\t\t/** @param toggle on to use a map affecting color */\n\t\tuseMap = ParamConfig.BOOLEAN(0, BooleanParamOptions(TextureMapController));\n\t\t/** @param texture map affecting color */\n\t\tmap = ParamConfig.OPERATOR_PATH(NODE_PATH_DEFAULT.NODE.UV, OperatorPathOptions(TextureMapController, 'useMap'));\n\t};\n}\nclass TextureMapMaterial extends Material {\n\tmap!: Texture | null;\n}\ntype CurrentMaterial = TextureMapMaterial | ShaderMaterial;\nclass TextureMapParamsConfig extends TextureMapParamConfig(NodeParamsConfig) {}\nabstract class TextureMapMatNode extends TypedMatNode<CurrentMaterial, TextureMapParamsConfig> {\n\ttexture_map_controller!: TextureMapController;\n\tabstract createMaterial(): CurrentMaterial;\n}\n\nexport class TextureMapController extends BaseTextureMapController {\n\tconstructor(protected node: TextureMapMatNode, _update_options: UpdateOptions) {\n\t\tsuper(node, _update_options);\n\t}\n\tinitializeNode() {\n\t\tthis.add_hooks(this.node.p.useMap, this.node.p.map);\n\t}\n\tasync update() {\n\t\tthis._update(this.node.material, 'map', this.node.p.useMap, this.node.p.map);\n\t}\n\tstatic async update(node: TextureMapMatNode) {\n\t\tnode.texture_map_controller.update();\n\t}\n}\n","import {Constructor} from '../../../../types/GlobalTypes';\nimport {Material} from 'three/src/materials/Material';\nimport {Texture} from 'three/src/textures/Texture';\nimport {TypedMatNode} from '../_Base';\nimport {\n\tBaseTextureMapController,\n\tBooleanParamOptions,\n\tOperatorPathOptions,\n\tUpdateOptions,\n} from './_BaseTextureController';\nimport {ShaderMaterial} from 'three/src/materials/ShaderMaterial';\nimport {NodeParamsConfig, ParamConfig} from '../../utils/params/ParamsConfig';\nimport {NODE_PATH_DEFAULT} from '../../../../core/Walker';\nexport function TextureAlphaMapParamConfig<TBase extends Constructor>(Base: TBase) {\n\treturn class Mixin extends Base {\n\t\t/** @param toggle if you want to use an alpha map */\n\t\tuseAlphaMap = ParamConfig.BOOLEAN(0, BooleanParamOptions(TextureAlphaMapController));\n\t\t/** @param specify the alpha map COP node */\n\t\talphaMap = ParamConfig.OPERATOR_PATH(\n\t\t\tNODE_PATH_DEFAULT.NODE.UV,\n\t\t\tOperatorPathOptions(TextureAlphaMapController, 'useAlphaMap')\n\t\t);\n\t};\n}\nclass TextureAlphaMaterial extends Material {\n\talphaMap!: Texture | null;\n}\ntype CurrentMaterial = TextureAlphaMaterial | ShaderMaterial;\nclass TextureAlphaMapParamsConfig extends TextureAlphaMapParamConfig(NodeParamsConfig) {}\nabstract class TextureAlphaMapMatNode extends TypedMatNode<CurrentMaterial, TextureAlphaMapParamsConfig> {\n\ttexture_alpha_map_controller!: TextureAlphaMapController;\n\tabstract createMaterial(): CurrentMaterial;\n}\n\nexport class TextureAlphaMapController extends BaseTextureMapController {\n\tconstructor(protected node: TextureAlphaMapMatNode, _update_options: UpdateOptions) {\n\t\tsuper(node, _update_options);\n\t}\n\tinitializeNode() {\n\t\tthis.add_hooks(this.node.p.useAlphaMap, this.node.p.alphaMap);\n\t}\n\tasync update() {\n\t\tthis._update(this.node.material, 'alphaMap', this.node.p.useAlphaMap, this.node.p.alphaMap);\n\t}\n\tstatic async update(node: TextureAlphaMapMatNode) {\n\t\tnode.texture_alpha_map_controller.update();\n\t}\n}\n","import {BaseNodeClassWithDisplayFlag, BaseNodeType} from '../_Base';\nimport {CoreGraphNode} from '../../../core/graph/CoreGraphNode';\n\ntype DisplayControllerCallback = () => void;\nexport interface DisplayNodeControllerCallbacks {\n\tonDisplayNodeRemove: DisplayControllerCallback;\n\tonDisplayNodeSet: DisplayControllerCallback;\n\tonDisplayNodeUpdate: DisplayControllerCallback;\n}\n\n/*\nhandles callbacks when the children's display flag is updated\n*/\nexport class DisplayNodeController {\n\tprivate _initialized: boolean = false;\n\tprivate _graph_node: CoreGraphNode;\n\tprivate _display_node: BaseNodeClassWithDisplayFlag | undefined = undefined;\n\tprivate _on_display_node_remove_callback: DisplayControllerCallback | undefined;\n\tprivate _on_display_node_set_callback: DisplayControllerCallback | undefined;\n\tprivate _on_display_node_update_callback: DisplayControllerCallback | undefined;\n\n\t// TODO: the node could be a different than BaseNodeType\n\t// at least there should be a way to infer that it is a node\n\t// with children that have a display flag. This would avoid all the flags?.display?... below\n\tconstructor(protected node: BaseNodeType, callbacks: DisplayNodeControllerCallbacks) {\n\t\tthis._graph_node = new CoreGraphNode(node.scene(), 'DisplayNodeController');\n\t\t(this._graph_node as any).node = node;\n\t\tthis._on_display_node_remove_callback = callbacks.onDisplayNodeRemove;\n\t\tthis._on_display_node_set_callback = callbacks.onDisplayNodeSet;\n\t\tthis._on_display_node_update_callback = callbacks.onDisplayNodeUpdate;\n\t}\n\n\tdispose() {\n\t\tthis._graph_node.dispose();\n\t}\n\n\tdisplayNode() {\n\t\treturn this._display_node;\n\t}\n\n\tinitializeNode() {\n\t\tif (this._initialized) {\n\t\t\tconsole.error('display node controller already initialed', this.node);\n\t\t\treturn;\n\t\t}\n\t\tthis._initialized = true;\n\n\t\tthis.node.lifecycle.add_on_child_add_hook((child_node) => {\n\t\t\tif (!this._display_node) {\n\t\t\t\tchild_node.flags?.display?.set(true);\n\t\t\t}\n\t\t});\n\t\tthis.node.lifecycle.add_on_child_remove_hook((child_node) => {\n\t\t\tif (child_node.graphNodeId() == this._display_node?.graphNodeId()) {\n\t\t\t\tconst children = this.node.children();\n\t\t\t\tconst last_child = children[children.length - 1];\n\t\t\t\tif (last_child) {\n\t\t\t\t\tlast_child.flags?.display?.set(true);\n\t\t\t\t} else {\n\t\t\t\t\tthis.setDisplayNode(undefined);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\tthis._graph_node.dirtyController.addPostDirtyHook('_request_display_node_container', () => {\n\t\t\tif (this._on_display_node_update_callback) {\n\t\t\t\tthis._on_display_node_update_callback();\n\t\t\t}\n\t\t});\n\t}\n\n\tasync setDisplayNode(new_display_node: BaseNodeClassWithDisplayFlag | undefined) {\n\t\tif (!this._initialized) {\n\t\t\tconsole.error('display node controller not initialized', this.node);\n\t\t}\n\n\t\tif (this._display_node != new_display_node) {\n\t\t\tconst old_display_node = this._display_node;\n\t\t\tif (old_display_node) {\n\t\t\t\told_display_node.flags.display.set(false);\n\t\t\t\tthis._graph_node.removeGraphInput(old_display_node);\n\t\t\t\tif (this._on_display_node_remove_callback) {\n\t\t\t\t\tthis._on_display_node_remove_callback();\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._display_node = new_display_node;\n\t\t\tif (this._display_node) {\n\t\t\t\tthis._graph_node.addGraphInput(this._display_node);\n\t\t\t\tif (this._on_display_node_set_callback) {\n\t\t\t\t\tthis._on_display_node_set_callback();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n","/**\n * Creates a WebGLRenderer\n *\n * @param\n * By default, a camera will create its own renderer, with sensible defaults. But there may be cases where you want to override those defaults. In those situation, simply create this node, and set the camera renderer param to it.\n *\n */\nimport {TypedRopNode} from './_Base';\nimport {Mesh} from 'three/src/objects/Mesh';\nimport {RopType} from '../../poly/registers/nodes/Rop';\nimport {WebGLRenderer, WebGLRendererParameters} from 'three/src/renderers/WebGLRenderer';\nimport {\n\t// encoding\n\tLinearEncoding,\n\tsRGBEncoding,\n\tGammaEncoding,\n\tRGBEEncoding,\n\tLogLuvEncoding,\n\tRGBM7Encoding,\n\tRGBM16Encoding,\n\tRGBDEncoding,\n\t// BasicDepthPacking,\n\t// RGBADepthPacking,\n\t// tone mapping\n\tNoToneMapping,\n\tLinearToneMapping,\n\tReinhardToneMapping,\n\tCineonToneMapping,\n\tACESFilmicToneMapping,\n\t// shadow map\n\tBasicShadowMap,\n\tPCFShadowMap,\n\tPCFSoftShadowMap,\n\tVSMShadowMap,\n} from 'three/src/constants';\n\nenum RendererPrecision {\n\tlowp = 'lowp',\n\tmediump = 'mediump',\n\thighp = 'highp',\n}\n\nenum PowerPreference {\n\tHIGH = 'high-performance',\n\tLOW = 'low-power',\n\tDEFAULT = 'default',\n}\n\nenum EncodingName {\n\tLinear = 'Linear',\n\tsRGB = 'sRGB',\n\tGamma = 'Gamma',\n\tRGBE = 'RGBE',\n\tLogLuv = 'LogLuv',\n\tRGBM7 = 'RGBM7',\n\tRGBM16 = 'RGBM16',\n\tRGBD = 'RGBD',\n\t// BasicDepth = 'BasicDepth',\n\t// RGBADepth = 'RGBADepth',\n}\nenum EncodingValue {\n\tLinear = LinearEncoding as number,\n\tsRGB = sRGBEncoding as number,\n\tGamma = GammaEncoding as number,\n\tRGBE = RGBEEncoding as number,\n\tLogLuv = LogLuvEncoding as number,\n\tRGBM7 = RGBM7Encoding as number,\n\tRGBM16 = RGBM16Encoding as number,\n\tRGBD = RGBDEncoding as number,\n\t// BasicDepth = BasicDepthPacking as number,\n\t// RGBADepth = RGBADepthPacking as number,\n}\nconst ENCODING_NAMES: EncodingName[] = [\n\tEncodingName.Linear,\n\tEncodingName.sRGB,\n\tEncodingName.Gamma,\n\tEncodingName.RGBE,\n\tEncodingName.LogLuv,\n\tEncodingName.RGBM7,\n\tEncodingName.RGBM16,\n\tEncodingName.RGBD,\n\t// EncodingName.BasicDepth,\n\t// EncodingName.RGBADepth,\n];\nconst ENCODING_VALUES: EncodingValue[] = [\n\tEncodingValue.Linear,\n\tEncodingValue.sRGB,\n\tEncodingValue.Gamma,\n\tEncodingValue.RGBE,\n\tEncodingValue.LogLuv,\n\tEncodingValue.RGBM7,\n\tEncodingValue.RGBM16,\n\tEncodingValue.RGBD,\n\t// EncodingValue.BasicDepth,\n\t// EncodingValue.RGBADepth,\n];\nexport const DEFAULT_OUTPUT_ENCODING = EncodingValue.sRGB as number;\n\nenum ToneMappingName {\n\tNo = 'No',\n\tLinear = 'Linear',\n\tReinhard = 'Reinhard',\n\tCineon = 'Cineon',\n\tACESFilmic = 'ACESFilmic',\n}\nenum ToneMappingValue {\n\tNo = NoToneMapping as number,\n\tLinear = LinearToneMapping as number,\n\tReinhard = ReinhardToneMapping as number,\n\tCineon = CineonToneMapping as number,\n\tACESFilmic = ACESFilmicToneMapping as number,\n}\nconst TONE_MAPPING_NAMES: ToneMappingName[] = [\n\tToneMappingName.No,\n\tToneMappingName.Linear,\n\tToneMappingName.Reinhard,\n\tToneMappingName.Cineon,\n\tToneMappingName.ACESFilmic,\n];\nconst TONE_MAPPING_VALUES: ToneMappingValue[] = [\n\tToneMappingValue.No,\n\tToneMappingValue.Linear,\n\tToneMappingValue.Reinhard,\n\tToneMappingValue.Cineon,\n\tToneMappingValue.ACESFilmic,\n];\nexport const DEFAULT_TONE_MAPPING = ToneMappingValue.ACESFilmic as number;\nconst TONE_MAPPING_MENU_ENTRIES = TONE_MAPPING_NAMES.map((name, i) => {\n\treturn {\n\t\tname: name,\n\t\tvalue: TONE_MAPPING_VALUES[i],\n\t};\n});\n\nenum ShadowMapTypeName {\n\tBasic = 'Basic',\n\tPCF = 'PCF',\n\tPCFSoft = 'PCFSoft',\n\tVSM = 'VSM',\n}\nenum ShadowMapTypeValue {\n\tBasic = BasicShadowMap as number,\n\tPCF = PCFShadowMap as number,\n\tPCFSoft = PCFSoftShadowMap as number,\n\tVSM = VSMShadowMap as number,\n}\nconst SHADOW_MAP_TYPE_NAMES: ShadowMapTypeName[] = [\n\tShadowMapTypeName.Basic,\n\tShadowMapTypeName.PCF,\n\tShadowMapTypeName.PCFSoft,\n\tShadowMapTypeName.VSM,\n];\nconst SHADOW_MAP_TYPE_VALUES: ShadowMapTypeValue[] = [\n\tShadowMapTypeValue.Basic,\n\tShadowMapTypeValue.PCF,\n\tShadowMapTypeValue.PCFSoft,\n\tShadowMapTypeValue.VSM,\n];\nexport const SHADOW_MAP_TYPES = [BasicShadowMap, PCFShadowMap, PCFSoftShadowMap, VSMShadowMap];\nexport const DEFAULT_SHADOW_MAP_TYPE = ShadowMapTypeValue.PCFSoft as number;\n\n// TODO: set debug.checkShaderErrors to false in prod\nconst DEFAULT_PARAMS: WebGLRendererParameters = {\n\talpha: true,\n\tprecision: RendererPrecision.highp,\n\tpremultipliedAlpha: true,\n\tantialias: true,\n\tstencil: true,\n\tpreserveDrawingBuffer: false,\n\tpowerPreference: PowerPreference.DEFAULT,\n\tdepth: true,\n\tlogarithmicDepthBuffer: false,\n};\n\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {CoreType} from '../../../core/Type';\nimport {PolyDictionary} from '../../../types/GlobalTypes';\nimport {RenderController} from '../obj/utils/cameras/RenderController';\nimport {Poly} from '../../Poly';\nclass WebGLRendererRopParamsConfig extends NodeParamsConfig {\n\t/** @param toggle on to have alpha on (change requires page reload) */\n\talpha = ParamConfig.BOOLEAN(1);\n\t/** @param toggle on to have antialias on (change requires page reload) */\n\tantialias = ParamConfig.BOOLEAN(1);\n\t/** @param tone mapping */\n\ttoneMapping = ParamConfig.INTEGER(DEFAULT_TONE_MAPPING, {\n\t\tmenu: {\n\t\t\tentries: TONE_MAPPING_MENU_ENTRIES,\n\t\t},\n\t});\n\t/** @param tone mapping exposure */\n\ttoneMappingExposure = ParamConfig.FLOAT(1, {\n\t\trange: [0, 2],\n\t});\n\t/** @param output encoding */\n\toutputEncoding = ParamConfig.INTEGER(DEFAULT_OUTPUT_ENCODING, {\n\t\tmenu: {\n\t\t\tentries: ENCODING_NAMES.map((name, i) => {\n\t\t\t\treturn {\n\t\t\t\t\tname: name,\n\t\t\t\t\tvalue: ENCODING_VALUES[i],\n\t\t\t\t};\n\t\t\t}),\n\t\t},\n\t});\n\t/** @param physically correct lights */\n\tphysicallyCorrectLights = ParamConfig.BOOLEAN(1);\n\t/** @param sort objects, which can be necessary when rendering transparent objects */\n\tsortObjects = ParamConfig.BOOLEAN(1);\n\t/** @param toggle to override the default pixel ratio, which is 1 for mobile devices, and Math.max(2, window.devicePixelRatio) for other devices */\n\ttpixelRatio = ParamConfig.BOOLEAN(0);\n\t/** @param higher pixelRatio improves render sharpness but reduces performance */\n\tpixelRatio = ParamConfig.INTEGER(2, {\n\t\tvisibleIf: {tpixelRatio: true},\n\t\trange: [1, 4],\n\t\trangeLocked: [true, false],\n\t});\n\t/** @param toggle on to have shadow maps */\n\ttshadowMap = ParamConfig.BOOLEAN(1);\n\t/** @param toggle on to recompute the shadow maps on every frame. If all objects are static, you may want to turn this off */\n\tshadowMapAutoUpdate = ParamConfig.BOOLEAN(1, {visibleIf: {tshadowMap: 1}});\n\t/** @param toggle on to trigger shadows update */\n\tshadowMapNeedsUpdate = ParamConfig.BOOLEAN(0, {visibleIf: {tshadowMap: 1}});\n\t/** @param shadows type */\n\tshadowMapType = ParamConfig.INTEGER(DEFAULT_SHADOW_MAP_TYPE, {\n\t\tvisibleIf: {tshadowMap: 1},\n\t\tmenu: {\n\t\t\tentries: SHADOW_MAP_TYPE_NAMES.map((name, i) => {\n\t\t\t\treturn {\n\t\t\t\t\tname: name,\n\t\t\t\t\tvalue: SHADOW_MAP_TYPE_VALUES[i],\n\t\t\t\t};\n\t\t\t}),\n\t\t},\n\t});\n\n\t// preserve_drawing_buffer = ParamConfig.BOOLEAN(0);\n}\nconst ParamsConfig = new WebGLRendererRopParamsConfig();\n\nexport class WebGLRendererRopNode extends TypedRopNode<WebGLRendererRopParamsConfig> {\n\tparams_config = ParamsConfig;\n\tstatic type(): Readonly<RopType.WEBGL> {\n\t\treturn RopType.WEBGL;\n\t}\n\n\tprivate _renderers_by_canvas_id: PolyDictionary<WebGLRenderer> = {};\n\tcreate_renderer(canvas: HTMLCanvasElement, gl: WebGLRenderingContext): WebGLRenderer {\n\t\tconst params: WebGLRendererParameters = {};\n\t\tconst keys: Array<keyof WebGLRendererParameters> = Object.keys(DEFAULT_PARAMS) as Array<\n\t\t\tkeyof WebGLRendererParameters\n\t\t>;\n\t\tlet k: keyof WebGLRendererParameters;\n\t\tfor (k of keys) {\n\t\t\t(params[k] as any) = DEFAULT_PARAMS[k];\n\t\t}\n\t\tparams.antialias = this.pv.antialias;\n\t\tparams.alpha = this.pv.alpha;\n\t\tparams.canvas = canvas;\n\t\tparams.context = gl;\n\t\t// (params as WebGLRendererParameters).preserveDrawingBuffer = this.pv.preserve_drawing_buffer;\n\t\tconst renderer = new WebGLRenderer(params);\n\n\t\tif (Poly.renderersController.printDebug()) {\n\t\t\tPoly.renderersController.printDebugMessage(`create renderer from node '${this.fullPath()}'`);\n\t\t\tPoly.renderersController.printDebugMessage({\n\t\t\t\tparams: params,\n\t\t\t});\n\t\t}\n\n\t\tthis._update_renderer(renderer);\n\n\t\tthis._renderers_by_canvas_id[canvas.id] = renderer;\n\t\treturn renderer;\n\t}\n\n\tcook() {\n\t\tconst ids = Object.keys(this._renderers_by_canvas_id);\n\t\tfor (let id of ids) {\n\t\t\tconst renderer = this._renderers_by_canvas_id[id];\n\t\t\tthis._update_renderer(renderer);\n\t\t}\n\n\t\tthis._traverse_scene_and_update_materials();\n\n\t\tthis.cookController.end_cook();\n\t}\n\t_update_renderer(renderer: WebGLRenderer) {\n\t\t// this._renderer.setClearAlpha(this.pv.alpha);\n\t\trenderer.physicallyCorrectLights = this.pv.physicallyCorrectLights;\n\t\trenderer.outputEncoding = this.pv.outputEncoding;\n\t\trenderer.toneMapping = this.pv.toneMapping;\n\t\trenderer.toneMappingExposure = this.pv.toneMappingExposure;\n\n\t\t// shadows\n\t\trenderer.shadowMap.enabled = this.pv.tshadowMap;\n\t\trenderer.shadowMap.autoUpdate = this.pv.shadowMapAutoUpdate;\n\t\trenderer.shadowMap.needsUpdate = this.pv.shadowMapNeedsUpdate;\n\t\trenderer.shadowMap.type = this.pv.shadowMapType;\n\n\t\trenderer.sortObjects = this.pv.sortObjects;\n\n\t\tconst pixelRatio = this.pv.tpixelRatio ? this.pv.pixelRatio : RenderController.defaultPixelRatio();\n\n\t\tif (Poly.renderersController.printDebug()) {\n\t\t\tPoly.renderersController.printDebugMessage(`set renderer pixelRatio from '${this.fullPath()}'`);\n\t\t\tPoly.renderersController.printDebugMessage({\n\t\t\t\tpixelRatio: pixelRatio,\n\t\t\t});\n\t\t}\n\n\t\trenderer.setPixelRatio(pixelRatio);\n\t}\n\n\tprivate _traverse_scene_and_update_materials() {\n\t\tthis.scene()\n\t\t\t.threejsScene()\n\t\t\t.traverse((object) => {\n\t\t\t\tconst material = (object as Mesh).material;\n\t\t\t\tif (material) {\n\t\t\t\t\tif (CoreType.isArray(material)) {\n\t\t\t\t\t\tfor (let mat of material) {\n\t\t\t\t\t\t\tmat.needsUpdate = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmaterial.needsUpdate = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t}\n}\n","import {NodeContext} from '../../poly/NodeContext';\nimport {NodeParamsConfig} from '../utils/params/ParamsConfig';\nimport {TypedNode} from '../_Base';\n\nclass ParamLessNetworkRopParamsConfig extends NodeParamsConfig {}\nexport class BaseNetworkRopNode<K extends NodeParamsConfig> extends TypedNode<NodeContext.ROP, K> {\n\tstatic nodeContext(): NodeContext {\n\t\treturn NodeContext.ROP;\n\t}\n\tcook() {\n\t\tthis.cookController.end_cook();\n\t}\n}\nexport class ParamLessBaseNetworkRopNode extends BaseNetworkRopNode<ParamLessNetworkRopParamsConfig> {}\n","import {Mesh} from 'three/src/objects/Mesh';\nimport {OrthographicCamera} from 'three/src/cameras/OrthographicCamera';\nimport {PlaneGeometry} from 'three/src/geometries/PlaneGeometry';\n\nfunction Pass() {\n\n\t// if set to true, the pass is processed by the composer\n\tthis.enabled = true;\n\n\t// if set to true, the pass indicates to swap read and write buffer after rendering\n\tthis.needsSwap = true;\n\n\t// if set to true, the pass clears its buffer before rendering\n\tthis.clear = false;\n\n\t// if set to true, the result of the pass is rendered to screen. This is set automatically by EffectComposer.\n\tthis.renderToScreen = false;\n\n}\n\nObject.assign( Pass.prototype, {\n\n\tsetSize: function ( /* width, height */ ) {},\n\n\trender: function ( /* renderer, writeBuffer, readBuffer, deltaTime, maskActive */ ) {\n\n\t\tconsole.error( 'THREE.Pass: .render() must be implemented in derived pass.' );\n\n\t}\n\n} );\n\n// Helper for passes that need to fill the viewport with a single quad.\n\n// Important: It's actually a hack to put FullScreenQuad into the Pass namespace. This is only\n// done to make examples/js code work. Normally, FullScreenQuad should be exported\n// from this module like Pass.\n\nPass.FullScreenQuad = ( function () {\n\n\tvar camera = new OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );\n\tvar geometry = new PlaneGeometry( 2, 2 );\n\n\tvar FullScreenQuad = function ( material ) {\n\n\t\tthis._mesh = new Mesh( geometry, material );\n\n\t};\n\n\tObject.defineProperty( FullScreenQuad.prototype, 'material', {\n\n\t\tget: function () {\n\n\t\t\treturn this._mesh.material;\n\n\t\t},\n\n\t\tset: function ( value ) {\n\n\t\t\tthis._mesh.material = value;\n\n\t\t}\n\n\t} );\n\n\tObject.assign( FullScreenQuad.prototype, {\n\n\t\tdispose: function () {\n\n\t\t\tthis._mesh.geometry.dispose();\n\n\t\t},\n\n\t\trender: function ( renderer ) {\n\n\t\t\trenderer.render( this._mesh, camera );\n\n\t\t}\n\n\t} );\n\n\treturn FullScreenQuad;\n\n} )();\n\nexport { Pass };\n","/**\n * Full-screen textured quad shader\n */\n\nvar CopyShader = {\n\n\tuniforms: {\n\n\t\t'tDiffuse': { value: null },\n\t\t'opacity': { value: 1.0 }\n\n\t},\n\n\tvertexShader: [\n\n\t\t'varying vec2 vUv;',\n\n\t\t'void main() {',\n\n\t\t'\tvUv = uv;',\n\t\t'\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',\n\n\t\t'}'\n\n\t].join( '\\n' ),\n\n\tfragmentShader: [\n\n\t\t'uniform float opacity;',\n\n\t\t'uniform sampler2D tDiffuse;',\n\n\t\t'varying vec2 vUv;',\n\n\t\t'void main() {',\n\n\t\t'\tvec4 texel = texture2D( tDiffuse, vUv );',\n\t\t'\tgl_FragColor = opacity * texel;',\n\n\t\t'}'\n\n\t].join( '\\n' )\n\n};\n\nexport { CopyShader };\n","import {ShaderMaterial} from 'three/src/materials/ShaderMaterial';\nimport {UniformsUtils} from 'three/src/renderers/shaders/UniformsUtils';\nimport { Pass } from '../postprocessing/Pass.js';\n\nvar ShaderPass = function ( shader, textureID ) {\n\n\tPass.call( this );\n\n\tthis.textureID = ( textureID !== undefined ) ? textureID : 'tDiffuse';\n\n\tif ( shader instanceof ShaderMaterial ) {\n\n\t\tthis.uniforms = shader.uniforms;\n\n\t\tthis.material = shader;\n\n\t} else if ( shader ) {\n\n\t\tthis.uniforms = UniformsUtils.clone( shader.uniforms );\n\n\t\tthis.material = new ShaderMaterial( {\n\n\t\t\tdefines: Object.assign( {}, shader.defines ),\n\t\t\tuniforms: this.uniforms,\n\t\t\tvertexShader: shader.vertexShader,\n\t\t\tfragmentShader: shader.fragmentShader\n\n\t\t} );\n\n\t}\n\n\tthis.fsQuad = new Pass.FullScreenQuad( this.material );\n\n};\n\nShaderPass.prototype = Object.assign( Object.create( Pass.prototype ), {\n\n\tconstructor: ShaderPass,\n\n\trender: function ( renderer, writeBuffer, readBuffer /*, deltaTime, maskActive */ ) {\n\n\t\tif ( this.uniforms[ this.textureID ] ) {\n\n\t\t\tthis.uniforms[ this.textureID ].value = readBuffer.texture;\n\n\t\t}\n\n\t\tthis.fsQuad.material = this.material;\n\n\t\tif ( this.renderToScreen ) {\n\n\t\t\trenderer.setRenderTarget( null );\n\t\t\tthis.fsQuad.render( renderer );\n\n\t\t} else {\n\n\t\t\trenderer.setRenderTarget( writeBuffer );\n\t\t\t// TODO: Avoid using autoClear properties, see https://github.com/mrdoob/three.js/pull/15571#issuecomment-465669600\n\t\t\tif ( this.clear ) renderer.clear( renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil );\n\t\t\tthis.fsQuad.render( renderer );\n\n\t\t}\n\n\t}\n\n} );\n\nexport { ShaderPass };\n","import { Pass } from '../postprocessing/Pass.js';\n\nvar MaskPass = function ( scene, camera ) {\n\n\tPass.call( this );\n\n\tthis.scene = scene;\n\tthis.camera = camera;\n\n\tthis.clear = true;\n\tthis.needsSwap = false;\n\n\tthis.inverse = false;\n\n};\n\nMaskPass.prototype = Object.assign( Object.create( Pass.prototype ), {\n\n\tconstructor: MaskPass,\n\n\trender: function ( renderer, writeBuffer, readBuffer /*, deltaTime, maskActive */ ) {\n\n\t\tvar context = renderer.getContext();\n\t\tvar state = renderer.state;\n\n\t\t// don't update color or depth\n\n\t\tstate.buffers.color.setMask( false );\n\t\tstate.buffers.depth.setMask( false );\n\n\t\t// lock buffers\n\n\t\tstate.buffers.color.setLocked( true );\n\t\tstate.buffers.depth.setLocked( true );\n\n\t\t// set up stencil\n\n\t\tvar writeValue, clearValue;\n\n\t\tif ( this.inverse ) {\n\n\t\t\twriteValue = 0;\n\t\t\tclearValue = 1;\n\n\t\t} else {\n\n\t\t\twriteValue = 1;\n\t\t\tclearValue = 0;\n\n\t\t}\n\n\t\tstate.buffers.stencil.setTest( true );\n\t\tstate.buffers.stencil.setOp( context.REPLACE, context.REPLACE, context.REPLACE );\n\t\tstate.buffers.stencil.setFunc( context.ALWAYS, writeValue, 0xffffffff );\n\t\tstate.buffers.stencil.setClear( clearValue );\n\t\tstate.buffers.stencil.setLocked( true );\n\n\t\t// draw into the stencil buffer\n\n\t\trenderer.setRenderTarget( readBuffer );\n\t\tif ( this.clear ) renderer.clear();\n\t\trenderer.render( this.scene, this.camera );\n\n\t\trenderer.setRenderTarget( writeBuffer );\n\t\tif ( this.clear ) renderer.clear();\n\t\trenderer.render( this.scene, this.camera );\n\n\t\t// unlock color and depth buffer for subsequent rendering\n\n\t\tstate.buffers.color.setLocked( false );\n\t\tstate.buffers.depth.setLocked( false );\n\n\t\t// only render where stencil is set to 1\n\n\t\tstate.buffers.stencil.setLocked( false );\n\t\tstate.buffers.stencil.setFunc( context.EQUAL, 1, 0xffffffff ); // draw if == 1\n\t\tstate.buffers.stencil.setOp( context.KEEP, context.KEEP, context.KEEP );\n\t\tstate.buffers.stencil.setLocked( true );\n\n\t}\n\n} );\n\n\nvar ClearMaskPass = function () {\n\n\tPass.call( this );\n\n\tthis.needsSwap = false;\n\n};\n\nClearMaskPass.prototype = Object.create( Pass.prototype );\n\nObject.assign( ClearMaskPass.prototype, {\n\n\trender: function ( renderer /*, writeBuffer, readBuffer, deltaTime, maskActive */ ) {\n\n\t\trenderer.state.buffers.stencil.setLocked( false );\n\t\trenderer.state.buffers.stencil.setTest( false );\n\n\t}\n\n} );\n\nexport { MaskPass, ClearMaskPass };\n","import {Clock} from 'three/src/core/Clock';\nimport {LinearFilter} from 'three/src/constants';\nimport {Mesh} from 'three/src/objects/Mesh';\nimport {OrthographicCamera} from 'three/src/cameras/OrthographicCamera';\nimport {PlaneGeometry} from 'three/src/geometries/PlaneGeometry';\nimport {RGBAFormat} from 'three/src/constants';\nimport {Vector2} from 'three/src/math/Vector2';\nimport {WebGLRenderTarget} from 'three/src/renderers/WebGLRenderTarget';\nimport { CopyShader } from '../shaders/CopyShader.js';\nimport { ShaderPass } from '../postprocessing/ShaderPass.js';\nimport { MaskPass } from '../postprocessing/MaskPass.js';\nimport { ClearMaskPass } from '../postprocessing/MaskPass.js';\n\nvar EffectComposer = function ( renderer, renderTarget ) {\n\n\tthis.renderer = renderer;\n\n\tif ( renderTarget === undefined ) {\n\n\t\tvar parameters = {\n\t\t\tminFilter: LinearFilter,\n\t\t\tmagFilter: LinearFilter,\n\t\t\tformat: RGBAFormat\n\t\t};\n\n\t\tvar size = renderer.getSize( new Vector2() );\n\t\tthis._pixelRatio = renderer.getPixelRatio();\n\t\tthis._width = size.width;\n\t\tthis._height = size.height;\n\n\t\trenderTarget = new WebGLRenderTarget( this._width * this._pixelRatio, this._height * this._pixelRatio, parameters );\n\t\trenderTarget.texture.name = 'EffectComposer.rt1';\n\n\t} else {\n\n\t\tthis._pixelRatio = 1;\n\t\tthis._width = renderTarget.width;\n\t\tthis._height = renderTarget.height;\n\n\t}\n\n\tthis.renderTarget1 = renderTarget;\n\tthis.renderTarget2 = renderTarget.clone();\n\tthis.renderTarget2.texture.name = 'EffectComposer.rt2';\n\n\tthis.writeBuffer = this.renderTarget1;\n\tthis.readBuffer = this.renderTarget2;\n\n\tthis.renderToScreen = true;\n\n\tthis.passes = [];\n\n\t// dependencies\n\n\tif ( CopyShader === undefined ) {\n\n\t\tconsole.error( 'THREE.EffectComposer relies on CopyShader' );\n\n\t}\n\n\tif ( ShaderPass === undefined ) {\n\n\t\tconsole.error( 'THREE.EffectComposer relies on ShaderPass' );\n\n\t}\n\n\tthis.copyPass = new ShaderPass( CopyShader );\n\n\tthis.clock = new Clock();\n\n};\n\nObject.assign( EffectComposer.prototype, {\n\n\tswapBuffers: function () {\n\n\t\tvar tmp = this.readBuffer;\n\t\tthis.readBuffer = this.writeBuffer;\n\t\tthis.writeBuffer = tmp;\n\n\t},\n\n\taddPass: function ( pass ) {\n\n\t\tthis.passes.push( pass );\n\t\tpass.setSize( this._width * this._pixelRatio, this._height * this._pixelRatio );\n\n\t},\n\n\tinsertPass: function ( pass, index ) {\n\n\t\tthis.passes.splice( index, 0, pass );\n\t\tpass.setSize( this._width * this._pixelRatio, this._height * this._pixelRatio );\n\n\t},\n\n\tremovePass: function ( pass ) {\n\n\t\tconst index = this.passes.indexOf( pass );\n\n\t\tif ( index !== - 1 ) {\n\n\t\t\tthis.passes.splice( index, 1 );\n\n\t\t}\n\n\t},\n\n\tisLastEnabledPass: function ( passIndex ) {\n\n\t\tfor ( var i = passIndex + 1; i < this.passes.length; i ++ ) {\n\n\t\t\tif ( this.passes[ i ].enabled ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn true;\n\n\t},\n\n\trender: function ( deltaTime ) {\n\n\t\t// deltaTime value is in seconds\n\n\t\tif ( deltaTime === undefined ) {\n\n\t\t\tdeltaTime = this.clock.getDelta();\n\n\t\t}\n\n\t\tvar currentRenderTarget = this.renderer.getRenderTarget();\n\n\t\tvar maskActive = false;\n\n\t\tvar pass, i, il = this.passes.length;\n\n\t\tfor ( i = 0; i < il; i ++ ) {\n\n\t\t\tpass = this.passes[ i ];\n\n\t\t\tif ( pass.enabled === false ) continue;\n\n\t\t\tpass.renderToScreen = ( this.renderToScreen && this.isLastEnabledPass( i ) );\n\t\t\tpass.render( this.renderer, this.writeBuffer, this.readBuffer, deltaTime, maskActive );\n\n\t\t\tif ( pass.needsSwap ) {\n\n\t\t\t\tif ( maskActive ) {\n\n\t\t\t\t\tvar context = this.renderer.getContext();\n\t\t\t\t\tvar stencil = this.renderer.state.buffers.stencil;\n\n\t\t\t\t\t//context.stencilFunc( context.NOTEQUAL, 1, 0xffffffff );\n\t\t\t\t\tstencil.setFunc( context.NOTEQUAL, 1, 0xffffffff );\n\n\t\t\t\t\tthis.copyPass.render( this.renderer, this.writeBuffer, this.readBuffer, deltaTime );\n\n\t\t\t\t\t//context.stencilFunc( context.EQUAL, 1, 0xffffffff );\n\t\t\t\t\tstencil.setFunc( context.EQUAL, 1, 0xffffffff );\n\n\t\t\t\t}\n\n\t\t\t\tthis.swapBuffers();\n\n\t\t\t}\n\n\t\t\tif ( MaskPass !== undefined ) {\n\n\t\t\t\tif ( pass instanceof MaskPass ) {\n\n\t\t\t\t\tmaskActive = true;\n\n\t\t\t\t} else if ( pass instanceof ClearMaskPass ) {\n\n\t\t\t\t\tmaskActive = false;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.renderer.setRenderTarget( currentRenderTarget );\n\n\t},\n\n\treset: function ( renderTarget ) {\n\n\t\tif ( renderTarget === undefined ) {\n\n\t\t\tvar size = this.renderer.getSize( new Vector2() );\n\t\t\tthis._pixelRatio = this.renderer.getPixelRatio();\n\t\t\tthis._width = size.width;\n\t\t\tthis._height = size.height;\n\n\t\t\trenderTarget = this.renderTarget1.clone();\n\t\t\trenderTarget.setSize( this._width * this._pixelRatio, this._height * this._pixelRatio );\n\n\t\t}\n\n\t\tthis.renderTarget1.dispose();\n\t\tthis.renderTarget2.dispose();\n\t\tthis.renderTarget1 = renderTarget;\n\t\tthis.renderTarget2 = renderTarget.clone();\n\n\t\tthis.writeBuffer = this.renderTarget1;\n\t\tthis.readBuffer = this.renderTarget2;\n\n\t},\n\n\tsetSize: function ( width, height ) {\n\n\t\tthis._width = width;\n\t\tthis._height = height;\n\n\t\tvar effectiveWidth = this._width * this._pixelRatio;\n\t\tvar effectiveHeight = this._height * this._pixelRatio;\n\n\t\tthis.renderTarget1.setSize( effectiveWidth, effectiveHeight );\n\t\tthis.renderTarget2.setSize( effectiveWidth, effectiveHeight );\n\n\t\tfor ( var i = 0; i < this.passes.length; i ++ ) {\n\n\t\t\tthis.passes[ i ].setSize( effectiveWidth, effectiveHeight );\n\n\t\t}\n\n\t},\n\n\tsetPixelRatio: function ( pixelRatio ) {\n\n\t\tthis._pixelRatio = pixelRatio;\n\n\t\tthis.setSize( this._width, this._height );\n\n\t}\n\n} );\n\n\nvar Pass = function () {\n\n\t// if set to true, the pass is processed by the composer\n\tthis.enabled = true;\n\n\t// if set to true, the pass indicates to swap read and write buffer after rendering\n\tthis.needsSwap = true;\n\n\t// if set to true, the pass clears its buffer before rendering\n\tthis.clear = false;\n\n\t// if set to true, the result of the pass is rendered to screen. This is set automatically by EffectComposer.\n\tthis.renderToScreen = false;\n\n};\n\nObject.assign( Pass.prototype, {\n\n\tsetSize: function ( /* width, height */ ) {},\n\n\trender: function ( /* renderer, writeBuffer, readBuffer, deltaTime, maskActive */ ) {\n\n\t\tconsole.error( 'THREE.Pass: .render() must be implemented in derived pass.' );\n\n\t}\n\n} );\n\n// Helper for passes that need to fill the viewport with a single quad.\nPass.FullScreenQuad = ( function () {\n\n\tvar camera = new OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );\n\tvar geometry = new PlaneGeometry( 2, 2 );\n\n\tvar FullScreenQuad = function ( material ) {\n\n\t\tthis._mesh = new Mesh( geometry, material );\n\n\t};\n\n\tObject.defineProperty( FullScreenQuad.prototype, 'material', {\n\n\t\tget: function () {\n\n\t\t\treturn this._mesh.material;\n\n\t\t},\n\n\t\tset: function ( value ) {\n\n\t\t\tthis._mesh.material = value;\n\n\t\t}\n\n\t} );\n\n\tObject.assign( FullScreenQuad.prototype, {\n\n\t\tdispose: function () {\n\n\t\t\tthis._mesh.geometry.dispose();\n\n\t\t},\n\n\t\trender: function ( renderer ) {\n\n\t\t\trenderer.render( this._mesh, camera );\n\n\t\t}\n\n\t} );\n\n\treturn FullScreenQuad;\n\n} )();\n\nexport { EffectComposer, Pass };\n","import {Color} from 'three/src/math/Color';\nimport { Pass } from '../postprocessing/Pass.js';\n\nvar RenderPass = function ( scene, camera, overrideMaterial, clearColor, clearAlpha ) {\n\n\tPass.call( this );\n\n\tthis.scene = scene;\n\tthis.camera = camera;\n\n\tthis.overrideMaterial = overrideMaterial;\n\n\tthis.clearColor = clearColor;\n\tthis.clearAlpha = ( clearAlpha !== undefined ) ? clearAlpha : 0;\n\n\tthis.clear = true;\n\tthis.clearDepth = false;\n\tthis.needsSwap = false;\n\tthis._oldClearColor = new Color();\n\n};\n\nRenderPass.prototype = Object.assign( Object.create( Pass.prototype ), {\n\n\tconstructor: RenderPass,\n\n\trender: function ( renderer, writeBuffer, readBuffer /*, deltaTime, maskActive */ ) {\n\n\t\tvar oldAutoClear = renderer.autoClear;\n\t\trenderer.autoClear = false;\n\n\t\tvar oldClearAlpha, oldOverrideMaterial;\n\n\t\tif ( this.overrideMaterial !== undefined ) {\n\n\t\t\toldOverrideMaterial = this.scene.overrideMaterial;\n\n\t\t\tthis.scene.overrideMaterial = this.overrideMaterial;\n\n\t\t}\n\n\t\tif ( this.clearColor ) {\n\n\t\t\trenderer.getClearColor( this._oldClearColor );\n\t\t\toldClearAlpha = renderer.getClearAlpha();\n\n\t\t\trenderer.setClearColor( this.clearColor, this.clearAlpha );\n\n\t\t}\n\n\t\tif ( this.clearDepth ) {\n\n\t\t\trenderer.clearDepth();\n\n\t\t}\n\n\t\trenderer.setRenderTarget( this.renderToScreen ? null : readBuffer );\n\n\t\t// TODO: Avoid using autoClear properties, see https://github.com/mrdoob/three.js/pull/15571#issuecomment-465669600\n\t\tif ( this.clear ) renderer.clear( renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil );\n\t\trenderer.render( this.scene, this.camera );\n\n\t\tif ( this.clearColor ) {\n\n\t\t\trenderer.setClearColor( this._oldClearColor, oldClearAlpha );\n\n\t\t}\n\n\t\tif ( this.overrideMaterial !== undefined ) {\n\n\t\t\tthis.scene.overrideMaterial = oldOverrideMaterial;\n\n\t\t}\n\n\t\trenderer.autoClear = oldAutoClear;\n\n\t}\n\n} );\n\nexport { RenderPass };\n","import {Constructor, valueof} from '../../../../types/GlobalTypes';\nimport {WebGLRenderer} from 'three/src/renderers/WebGLRenderer';\nimport {WebGLRenderTarget, WebGLRenderTargetOptions} from 'three/src/renderers/WebGLRenderTarget';\nimport {EffectComposer} from '../../../../modules/three/examples/jsm/postprocessing/EffectComposer';\nimport {RenderPass} from '../../../../modules/three/examples/jsm/postprocessing/RenderPass';\nimport {DisplayNodeController, DisplayNodeControllerCallbacks} from '../../utils/DisplayNodeController';\nimport {PostNodeChildrenMap} from '../../../poly/registers/nodes/Post';\nimport {TypedNode, BaseNodeType} from '../../_Base';\nimport {BasePostProcessNodeType} from '../_Base';\nimport {Scene} from 'three/src/scenes/Scene';\nimport {Camera} from 'three/src/cameras/Camera';\nimport {Vector2} from 'three/src/math/Vector2';\nimport {BaseCameraObjNodeType} from '../../obj/_BaseCamera';\nimport {NodeParamsConfig, ParamConfig} from '../../utils/params/ParamsConfig';\nimport {RGBFormat} from 'three/src/constants';\nimport {Poly} from '../../../Poly';\n\nimport {\n\tMAG_FILTER_DEFAULT_VALUE,\n\tMAG_FILTER_MENU_ENTRIES,\n\tMIN_FILTER_DEFAULT_VALUE,\n\tMIN_FILTER_MENU_ENTRIES,\n} from '../../../../core/cop/ConstantFilter';\nimport {isBooleanTrue} from '../../../../core/BooleanValue';\nexport class PostProcessNetworkParamsConfig extends NodeParamsConfig {\n\tprependRenderPass = ParamConfig.BOOLEAN(1);\n\tuseRenderTarget = ParamConfig.BOOLEAN(1);\n\ttmagFilter = ParamConfig.BOOLEAN(0, {\n\t\tvisibleIf: {useRenderTarget: 1},\n\t});\n\tmagFilter = ParamConfig.INTEGER(MAG_FILTER_DEFAULT_VALUE, {\n\t\tvisibleIf: {useRenderTarget: 1, tmagFilter: 1},\n\t\tmenu: {\n\t\t\tentries: MAG_FILTER_MENU_ENTRIES,\n\t\t},\n\t});\n\ttminFilter = ParamConfig.BOOLEAN(0, {\n\t\tvisibleIf: {useRenderTarget: 1},\n\t});\n\tminFilter = ParamConfig.INTEGER(MIN_FILTER_DEFAULT_VALUE, {\n\t\tvisibleIf: {useRenderTarget: 1, tminFilter: 1},\n\t\tmenu: {\n\t\t\tentries: MIN_FILTER_MENU_ENTRIES,\n\t\t},\n\t});\n\tstencilBuffer = ParamConfig.BOOLEAN(0, {\n\t\tvisibleIf: {useRenderTarget: 1},\n\t});\n\tsampling = ParamConfig.INTEGER(1, {\n\t\trange: [1, 4],\n\t\trangeLocked: [true, false],\n\t});\n}\nexport interface BaseNetworkPostProcessNodeType extends TypedNode<any, PostProcessNetworkParamsConfig> {\n\treadonly displayNodeController: DisplayNodeController;\n\tcreateNode<S extends keyof PostNodeChildrenMap>(node_class: S): PostNodeChildrenMap[S];\n\tcreateNode<K extends valueof<PostNodeChildrenMap>>(node_class: Constructor<K>): K;\n\tchildren(): BasePostProcessNodeType[];\n\tnodesByType<K extends keyof PostNodeChildrenMap>(type: K): PostNodeChildrenMap[K][];\n\n\treadonly effectsComposerController: EffectsComposerController;\n}\n\ninterface CreateEffectsComposerOptions {\n\trenderer: WebGLRenderer;\n\tscene: Scene;\n\tcamera: Camera;\n\tresolution: Vector2;\n\t// render_target?: WebGLRenderTarget;\n\trequester: BaseNodeType;\n\tcamera_node?: BaseCameraObjNodeType;\n\t// useRenderTarget?: boolean;\n\t// prepend_render_pass?: boolean;\n}\n\nexport class EffectsComposerController {\n\tconstructor(private node: BaseNetworkPostProcessNodeType) {}\n\n\tdisplayNodeControllerCallbacks(): DisplayNodeControllerCallbacks {\n\t\treturn {\n\t\t\tonDisplayNodeRemove: () => {},\n\t\t\tonDisplayNodeSet: () => {\n\t\t\t\tthis.node.setDirty();\n\t\t\t},\n\t\t\tonDisplayNodeUpdate: () => {\n\t\t\t\tthis.node.setDirty();\n\t\t\t},\n\t\t};\n\t}\n\n\tcreateEffectsComposer(options: CreateEffectsComposerOptions) {\n\t\tconst renderer = options.renderer;\n\n\t\tlet composer: EffectComposer;\n\t\tif (isBooleanTrue(this.node.pv.useRenderTarget)) {\n\t\t\tconst render_target = this._create_render_target(renderer);\n\t\t\tcomposer = new EffectComposer(renderer, render_target);\n\t\t} else {\n\t\t\tcomposer = new EffectComposer(renderer);\n\t\t}\n\n\t\t// to achieve better antialiasing\n\t\t// while using post:\n\t\tcomposer.setPixelRatio(window.devicePixelRatio * this.node.pv.sampling);\n\t\t// be careful, as this messes up with the renderer\n\t\t// and when using in cop/post has the output texture be 2x as large\n\t\t// composer.setPixelRatio(window.devicePixelRatio * 1);\n\n\t\tthis._build_passes(composer, options);\n\n\t\treturn composer;\n\t}\n\n\tprivate _renderer_size = new Vector2();\n\tprivate _create_render_target(renderer: WebGLRenderer) {\n\t\tlet render_target: WebGLRenderTarget | undefined;\n\t\trenderer.autoClear = false;\n\t\tconst parameters: WebGLRenderTargetOptions = {\n\t\t\t// format: RGBFormat,\n\t\t\tformat: RGBFormat,\n\t\t\tstencilBuffer: isBooleanTrue(this.node.pv.stencilBuffer),\n\t\t};\n\t\tif (isBooleanTrue(this.node.pv.tminFilter)) {\n\t\t\tparameters.minFilter = this.node.pv.minFilter;\n\t\t}\n\t\tif (isBooleanTrue(this.node.pv.tmagFilter)) {\n\t\t\tparameters.magFilter = this.node.pv.magFilter;\n\t\t}\n\n\t\trenderer.getDrawingBufferSize(this._renderer_size);\n\t\trender_target = Poly.renderersController.renderTarget(this._renderer_size.x, this._renderer_size.y, parameters);\n\t\treturn render_target;\n\t}\n\n\tprivate _build_passes(composer: EffectComposer, options: CreateEffectsComposerOptions) {\n\t\tif (isBooleanTrue(this.node.pv.prependRenderPass)) {\n\t\t\tconst render_pass = new RenderPass(options.scene, options.camera);\n\t\t\tcomposer.addPass(render_pass);\n\t\t}\n\n\t\tconst post_node = this.node.displayNodeController.displayNode() as BasePostProcessNodeType;\n\t\tif (post_node) {\n\t\t\tpost_node.setup_composer({\n\t\t\t\tcomposer: composer,\n\t\t\t\tcamera: options.camera,\n\t\t\t\tresolution: options.resolution,\n\t\t\t\tcamera_node: options.camera_node,\n\t\t\t\tscene: options.scene,\n\t\t\t\trequester: options.requester,\n\t\t\t});\n\t\t}\n\t}\n}\n","import {CATEGORY_ROP} from './Category';\n\nimport {AnimationsRopNode} from '../../../nodes/rop/Animations';\nimport {CopRopNode} from '../../../nodes/rop/Cop';\nimport {CSS2DRendererRopNode} from '../../../nodes/rop/CSS2DRenderer';\nimport {Css3DRendererRopNode} from '../../../nodes/rop/CSS3DRenderer';\nimport {EventsRopNode} from '../../../nodes/rop/Events';\nimport {MaterialsRopNode} from '../../../nodes/rop/Materials';\nimport {PostProcessRopNode} from '../../../nodes/rop/PostProcess';\nimport {RenderersRopNode} from '../../../nodes/rop/Renderers';\nimport {WebGLRendererRopNode} from '../../../nodes/rop/WebGLRenderer';\n\nexport enum RopType {\n\tCSS2D = 'CSS2DRenderer',\n\tCSS3D = 'CSS3DRenderer',\n\tWEBGL = 'WebGLRenderer',\n}\n\nexport interface RopNodeChildrenMap {\n\tCSS2DRenderer: CSS2DRendererRopNode;\n\tCSS3DRenderer: Css3DRendererRopNode;\n\tWebGLRenderer: WebGLRendererRopNode;\n\t// networks\n\tanimations: AnimationsRopNode;\n\tcop: CopRopNode;\n\tevents: EventsRopNode;\n\tmaterials: MaterialsRopNode;\n\tpostProcess: PostProcessRopNode;\n\trenderers: RenderersRopNode;\n}\n\nimport {PolyEngine} from '../../../Poly';\nexport class RopRegister {\n\tstatic run(poly: PolyEngine) {\n\t\tpoly.registerNode(CSS2DRendererRopNode, CATEGORY_ROP.CSS);\n\t\t// poly.registerNode(Css3DRendererRopNode, CATEGORY_ROP.CSS); // not registering, since sop/css3d_object is not yet working\n\t\tpoly.registerNode(WebGLRendererRopNode, CATEGORY_ROP.WEBGL);\n\t\t// networks\n\t\tpoly.registerNode(AnimationsRopNode, CATEGORY_ROP.NETWORK);\n\t\tpoly.registerNode(CopRopNode, CATEGORY_ROP.NETWORK);\n\t\tpoly.registerNode(EventsRopNode, CATEGORY_ROP.NETWORK);\n\t\tpoly.registerNode(MaterialsRopNode, CATEGORY_ROP.NETWORK);\n\t\tpoly.registerNode(PostProcessRopNode, CATEGORY_ROP.NETWORK);\n\t\tpoly.registerNode(RenderersRopNode, CATEGORY_ROP.NETWORK);\n\t}\n}\n","/**\n * Creates a THREE.Scene.\n *\n * @remarks\n * By default, all objects created will be added under the same master scene. This is enough in most cases, but there might be times where you want to use a custom one. For instance:\n *\n * - you would like to change the background color or the environment.\n * - you would like to have a fog.\n * - You may also use multiple scenes, if you want to switch from one to the other.\n *\n * For those situtation, you can parent the objects under a scene node, and set your camera scene parameter to point to it. The camera will then render this scene instead of the master one.\n *\n *\n */\nimport {TypedObjNode} from './_Base';\nimport {Scene} from 'three/src/scenes/Scene';\nimport {Fog} from 'three/src/scenes/Fog';\nimport {FogExp2} from 'three/src/scenes/FogExp2';\nimport {NodeContext} from '../../poly/NodeContext';\nimport {BaseCopNodeType} from '../cop/_Base';\nimport {BaseMatNodeType} from '../mat/_Base';\nimport {HierarchyController} from './utils/HierarchyController';\n\nenum BackgroundMode {\n\tNONE = 'none',\n\tCOLOR = 'color',\n\tTEXTURE = 'texture',\n}\nconst BACKGROUND_MODES: BackgroundMode[] = [BackgroundMode.NONE, BackgroundMode.COLOR, BackgroundMode.TEXTURE];\n\nenum FogType {\n\tLINEAR = 'linear',\n\tEXPONENTIAL = 'exponential',\n}\nconst FOG_TYPES: FogType[] = [FogType.LINEAR, FogType.EXPONENTIAL];\n\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {isBooleanTrue} from '../../../core/BooleanValue';\nclass SceneObjParamConfig extends NodeParamsConfig {\n\t/** @param autoUpdate */\n\tautoUpdate = ParamConfig.BOOLEAN(1);\n\n\t// background\n\t/** @param set background mode (none, color or texture) */\n\tbackgroundMode = ParamConfig.INTEGER(BACKGROUND_MODES.indexOf(BackgroundMode.NONE), {\n\t\tmenu: {\n\t\t\tentries: BACKGROUND_MODES.map((mode, i) => {\n\t\t\t\treturn {name: mode, value: i};\n\t\t\t}),\n\t\t},\n\t});\n\t/** @param background color */\n\tbgColor = ParamConfig.COLOR([0, 0, 0], {\n\t\tvisibleIf: {backgroundMode: BACKGROUND_MODES.indexOf(BackgroundMode.COLOR)},\n\t});\n\t/** @param background texture */\n\tbgTexture = ParamConfig.OPERATOR_PATH('', {\n\t\tvisibleIf: {backgroundMode: BACKGROUND_MODES.indexOf(BackgroundMode.TEXTURE)},\n\t\tnodeSelection: {\n\t\t\tcontext: NodeContext.COP,\n\t\t},\n\t\tdependentOnFoundNode: false,\n\t});\n\n\t// environment\n\t/** @param toggle on to use an environment map */\n\tuseEnvironment = ParamConfig.BOOLEAN(0);\n\t/** @param environment map */\n\tenvironment = ParamConfig.OPERATOR_PATH('', {\n\t\tvisibleIf: {useEnvironment: 1},\n\t\tnodeSelection: {\n\t\t\tcontext: NodeContext.COP,\n\t\t},\n\t\tdependentOnFoundNode: false,\n\t});\n\n\t// fog\n\t/** @param toggle on to use fog */\n\tuseFog = ParamConfig.BOOLEAN(0);\n\t/** @param fog type */\n\tfogType = ParamConfig.INTEGER(FOG_TYPES.indexOf(FogType.EXPONENTIAL), {\n\t\tvisibleIf: {useFog: 1},\n\t\tmenu: {\n\t\t\tentries: FOG_TYPES.map((mode, i) => {\n\t\t\t\treturn {name: mode, value: i};\n\t\t\t}),\n\t\t},\n\t});\n\t/** @param fog color */\n\tfogColor = ParamConfig.COLOR([1, 1, 1], {visibleIf: {useFog: 1}});\n\t/** @param fog near */\n\tfogNear = ParamConfig.FLOAT(1, {\n\t\trange: [0, 100],\n\t\trangeLocked: [true, false],\n\t\tvisibleIf: {useFog: 1, fogType: FOG_TYPES.indexOf(FogType.LINEAR)},\n\t});\n\t/** @param fog far */\n\tfogFar = ParamConfig.FLOAT(100, {\n\t\trange: [0, 100],\n\t\trangeLocked: [true, false],\n\t\tvisibleIf: {useFog: 1, fogType: FOG_TYPES.indexOf(FogType.LINEAR)},\n\t});\n\t/** @param fog density */\n\tfogDensity = ParamConfig.FLOAT(0.00025, {\n\t\tvisibleIf: {useFog: 1, fogType: FOG_TYPES.indexOf(FogType.EXPONENTIAL)},\n\t});\n\n\t// override material\n\t/** @param toggle on to override all materials */\n\tuseOverrideMaterial = ParamConfig.BOOLEAN(0);\n\t/** @param material */\n\toverrideMaterial = ParamConfig.OPERATOR_PATH('/MAT/mesh_standard1', {\n\t\tvisibleIf: {useOverrideMaterial: 1},\n\t\tnodeSelection: {\n\t\t\tcontext: NodeContext.MAT,\n\t\t},\n\t\tdependentOnFoundNode: false,\n\t});\n}\nconst ParamsConfig = new SceneObjParamConfig();\n\nexport class SceneObjNode extends TypedObjNode<Scene, SceneObjParamConfig> {\n\tparams_config = ParamsConfig;\n\tstatic type(): Readonly<'scene'> {\n\t\treturn 'scene';\n\t}\n\treadonly hierarchyController: HierarchyController = new HierarchyController(this);\n\n\tprivate _fog: Fog | undefined;\n\tprivate _fogExp2: FogExp2 | undefined;\n\n\tcreate_object() {\n\t\tconst scene = new Scene();\n\t\tscene.matrixAutoUpdate = false;\n\t\treturn scene;\n\t}\n\n\tinitializeNode() {\n\t\t// this.dirtyController.addPostDirtyHook(\n\t\t// \t'_cook_main_without_inputs_when_dirty',\n\t\t// \tthis._cook_main_without_inputs_when_dirty_bound\n\t\t// );\n\n\t\t// super.initializeNode();\n\t\tthis.hierarchyController.initializeNode();\n\t\t// this.io.outputs.set_has_one_output();\n\t}\n\t// TODO: I may be able to swap those methods to param callbacks for most params\n\t// private _cook_main_without_inputs_when_dirty_bound = this._cook_main_without_inputs_when_dirty.bind(this);\n\t// private async _cook_main_without_inputs_when_dirty() {\n\t// \t// if (this.used_in_scene) {\n\t// \tawait this.cookController.cook_main_without_inputs();\n\t// \t// }\n\t// }\n\n\tcook() {\n\t\tif (isBooleanTrue(this.pv.autoUpdate) != this.object.autoUpdate) {\n\t\t\tthis.object.autoUpdate = isBooleanTrue(this.pv.autoUpdate);\n\t\t}\n\n\t\tthis._update_background();\n\t\tthis._update_fog();\n\t\tthis._update_enviromment();\n\t\tthis._update_material_override();\n\n\t\tthis.cookController.end_cook();\n\t}\n\n\t//\n\t//\n\t// BACKGROUND\n\t//\n\t//\n\tprivate _update_background() {\n\t\tif (this.pv.backgroundMode == BACKGROUND_MODES.indexOf(BackgroundMode.NONE)) {\n\t\t\tthis.object.background = null;\n\t\t} else {\n\t\t\tif (this.pv.backgroundMode == BACKGROUND_MODES.indexOf(BackgroundMode.COLOR)) {\n\t\t\t\tthis.object.background = this.pv.bgColor;\n\t\t\t} else {\n\t\t\t\tconst node = this.p.bgTexture.found_node();\n\t\t\t\tif (node) {\n\t\t\t\t\tif (node.nodeContext() == NodeContext.COP) {\n\t\t\t\t\t\t(node as BaseCopNodeType).requestContainer().then((container) => {\n\t\t\t\t\t\t\tthis.object.background = container.texture();\n\t\t\t\t\t\t});\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.states.error.set('bgTexture node is not a texture');\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tthis.states.error.set('bgTexture node not found');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t//\n\t//\n\t// FOG\n\t//\n\t//\n\tprivate _update_fog() {\n\t\tif (isBooleanTrue(this.pv.useFog)) {\n\t\t\tif (this.pv.fogType == FOG_TYPES.indexOf(FogType.LINEAR)) {\n\t\t\t\tconst fog = this.fog2();\n\t\t\t\tthis.object.fog = fog;\n\t\t\t\tfog.color = this.pv.fogColor;\n\t\t\t\tfog.near = this.pv.fogNear;\n\t\t\t\tfog.far = this.pv.fogFar;\n\t\t\t} else {\n\t\t\t\tconst fogExp2 = this.fogExp2();\n\t\t\t\tthis.object.fog = this.fogExp2();\n\t\t\t\tfogExp2.color = this.pv.fogColor;\n\t\t\t\tfogExp2.density = this.pv.fogDensity;\n\t\t\t}\n\t\t} else {\n\t\t\tconst current_fog = this.object.fog;\n\t\t\tif (current_fog) {\n\t\t\t\tthis.object.fog = null;\n\t\t\t}\n\t\t}\n\t}\n\tfog2() {\n\t\treturn (this._fog = this._fog || new Fog(0xffffff, this.pv.fogNear, this.pv.fogFar));\n\t}\n\tfogExp2() {\n\t\treturn (this._fogExp2 = this._fogExp2 || new FogExp2(0xffffff, this.pv.fogDensity));\n\t}\n\n\t//\n\t//\n\t// ENVIRONMENT\n\t//\n\t//\n\tprivate _update_enviromment() {\n\t\tif (isBooleanTrue(this.pv.useEnvironment)) {\n\t\t\tconst node = this.p.environment.found_node();\n\t\t\tif (node) {\n\t\t\t\tif (node.nodeContext() == NodeContext.COP) {\n\t\t\t\t\t(node as BaseCopNodeType).requestContainer().then((container) => {\n\t\t\t\t\t\tthis.object.environment = container.texture();\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tthis.states.error.set('bgTexture node is not a texture');\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.states.error.set('bgTexture node not found');\n\t\t\t}\n\t\t} else {\n\t\t\tthis.object.environment = null;\n\t\t}\n\t}\n\n\t//\n\t//\n\t// MATERIAL OVERRIDE\n\t//\n\t//\n\tprivate _update_material_override() {\n\t\tif (isBooleanTrue(this.pv.useOverrideMaterial)) {\n\t\t\tconst node = this.p.overrideMaterial.found_node();\n\t\t\tif (node) {\n\t\t\t\tif (node.nodeContext() == NodeContext.MAT) {\n\t\t\t\t\t(node as BaseMatNodeType).requestContainer().then((container) => {\n\t\t\t\t\t\tthis.object.overrideMaterial = container.material();\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tthis.states.error.set('bgTexture node is not a material');\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.states.error.set('bgTexture node not found');\n\t\t\t}\n\t\t} else {\n\t\t\tthis.object.overrideMaterial = null;\n\t\t}\n\t}\n}\n","import {Constructor, PolyDictionary} from '../../../../../types/GlobalTypes';\nimport {WebGLRenderer, WebGLRendererParameters} from 'three/src/renderers/WebGLRenderer';\nimport {Vector2} from 'three/src/math/Vector2';\nimport {Scene} from 'three/src/scenes/Scene';\nimport {NodeContext} from '../../../../poly/NodeContext';\nimport {SceneObjNode} from '../../Scene';\nimport {BaseThreejsCameraObjNodeType} from '../../_BaseCamera';\nimport {Poly} from '../../../../Poly';\nimport {\n\tWebGLRendererRopNode,\n\tDEFAULT_SHADOW_MAP_TYPE,\n\tDEFAULT_OUTPUT_ENCODING,\n\tDEFAULT_TONE_MAPPING,\n} from '../../../rop/WebGLRenderer';\nimport {CSS2DRendererRopNode} from '../../../rop/CSS2DRenderer';\nimport {Css3DRendererRopNode} from '../../../rop/CSS3DRenderer';\nimport {RopType} from '../../../../poly/registers/nodes/Rop';\n\nimport {ParamConfig} from '../../../utils/params/ParamsConfig';\nimport {CoreUserAgent} from '../../../../../core/UserAgent';\nimport {isBooleanTrue} from '../../../../../core/BooleanValue';\nexport function CameraRenderParamConfig<TBase extends Constructor>(Base: TBase) {\n\treturn class Mixin extends Base {\n\t\trender = ParamConfig.FOLDER();\n\n\t\t/** @param toggle on to override rendered scene */\n\t\tsetScene = ParamConfig.BOOLEAN(0);\n\t\t/** @param override rendered scene */\n\t\tscene = ParamConfig.OPERATOR_PATH('/scene1', {\n\t\t\tvisibleIf: {setScene: 1},\n\t\t\tnodeSelection: {\n\t\t\t\tcontext: NodeContext.OBJ,\n\t\t\t\ttypes: [SceneObjNode.type()],\n\t\t\t},\n\t\t});\n\n\t\t/** @param toggle on to override the renderer */\n\t\tsetRenderer = ParamConfig.BOOLEAN(0);\n\t\t/** @param override renderer used */\n\t\trenderer = ParamConfig.OPERATOR_PATH('./renderers1/webGLRenderer1', {\n\t\t\tvisibleIf: {setRenderer: 1},\n\t\t\tnodeSelection: {\n\t\t\t\tcontext: NodeContext.ROP,\n\t\t\t\ttypes: [WebGLRendererRopNode.type()],\n\t\t\t},\n\t\t});\n\n\t\t/** @param toggle on to add a CSSRenderer to have html elements on top of the 3D objects */\n\t\tsetCSSRenderer = ParamConfig.BOOLEAN(0);\n\t\t/** @param add a css renderer */\n\t\tCSSRenderer = ParamConfig.OPERATOR_PATH('./renderers1/CSS2DRenderer1', {\n\t\t\tvisibleIf: {setCSSRenderer: 1},\n\t\t\tnodeSelection: {\n\t\t\t\tcontext: NodeContext.ROP,\n\t\t\t\ttypes: [RopType.CSS2D, RopType.CSS3D],\n\t\t\t},\n\t\t});\n\t};\n}\n\nexport class RenderController {\n\tprivate _renderers_by_canvas_id: PolyDictionary<WebGLRenderer> = {};\n\tprivate _resolution_by_canvas_id: PolyDictionary<Vector2> = {};\n\tprivate _resolved_scene: Scene | undefined;\n\tprivate _resolved_renderer_rop: WebGLRendererRopNode | undefined;\n\tprivate _resolved_cssRenderer_rop: CSS2DRendererRopNode | Css3DRendererRopNode | undefined;\n\n\tconstructor(private node: BaseThreejsCameraObjNodeType) {}\n\n\t//\n\t//\n\t// render methods\n\t//\n\t//\n\trender(canvas: HTMLCanvasElement, size?: Vector2, aspect?: number) {\n\t\tif (isBooleanTrue(this.node.pv.doPostProcess)) {\n\t\t\tthis.node.postProcessController.render(canvas, size);\n\t\t} else {\n\t\t\tthis.render_with_renderer(canvas);\n\t\t}\n\n\t\tif (this._resolved_cssRenderer_rop && this._resolved_scene && isBooleanTrue(this.node.pv.setCSSRenderer)) {\n\t\t\tconst cssRenderer = this.cssRenderer(canvas);\n\t\t\tif (cssRenderer) {\n\t\t\t\tcssRenderer.render(this._resolved_scene, this.node.object);\n\t\t\t}\n\t\t}\n\t}\n\trender_with_renderer(canvas: HTMLCanvasElement) {\n\t\tconst renderer = this.renderer(canvas);\n\t\tif (renderer) {\n\t\t\t// renderer.autoClear = false;\n\t\t\tif (this._resolved_scene) {\n\t\t\t\trenderer.render(this._resolved_scene, this.node.object);\n\t\t\t}\n\t\t}\n\t}\n\n\tasync update() {\n\t\tthis.update_scene();\n\t\tthis.update_renderer();\n\t\tthis.update_cssRenderer();\n\t}\n\n\t//\n\t//\n\t// SCENE\n\t//\n\t//\n\tget resolved_scene() {\n\t\treturn this._resolved_scene;\n\t}\n\tprivate update_scene() {\n\t\tif (isBooleanTrue(this.node.pv.setScene)) {\n\t\t\tconst param = this.node.p.scene;\n\t\t\tif (param.isDirty()) {\n\t\t\t\tparam.find_target();\n\t\t\t}\n\t\t\tconst node = param.found_node_with_context_and_type(NodeContext.OBJ, SceneObjNode.type());\n\t\t\tif (node) {\n\t\t\t\t// it's probably weird to cook the node here, but that works for now\n\t\t\t\tif (node.isDirty()) {\n\t\t\t\t\tnode.cookController.cook_main_without_inputs();\n\t\t\t\t}\n\t\t\t\tthis._resolved_scene = node.object;\n\t\t\t}\n\t\t} else {\n\t\t\tthis._resolved_scene = this.node.scene().threejsScene();\n\t\t}\n\t}\n\n\t//\n\t//\n\t// RENDERER\n\t//\n\t//\n\tprivate update_renderer() {\n\t\tif (isBooleanTrue(this.node.pv.setRenderer)) {\n\t\t\tconst param = this.node.p.renderer;\n\t\t\tif (param.isDirty()) {\n\t\t\t\tparam.find_target();\n\t\t\t}\n\t\t\tthis._resolved_renderer_rop = param.found_node_with_context_and_type(NodeContext.ROP, RopType.WEBGL);\n\t\t} else {\n\t\t\tthis._resolved_renderer_rop = undefined;\n\t\t}\n\t}\n\tprivate update_cssRenderer() {\n\t\tif (isBooleanTrue(this.node.pv.setCSSRenderer)) {\n\t\t\tconst param = this.node.p.CSSRenderer;\n\t\t\tif (param.isDirty()) {\n\t\t\t\tparam.find_target();\n\t\t\t}\n\t\t\tthis._resolved_cssRenderer_rop = param.found_node_with_context_and_type(NodeContext.ROP, [\n\t\t\t\tRopType.CSS2D,\n\t\t\t\tRopType.CSS3D,\n\t\t\t]);\n\t\t} else {\n\t\t\tif (this._resolved_cssRenderer_rop) {\n\t\t\t\t// TODO: not yet sure how to remove it so that it can be easily added again\n\t\t\t\t// const renderer = this.cssRenderer()\n\t\t\t\t// const dom\n\t\t\t\t// this._resolved_cssRenderer_rop.remove_renderer_element(canvas);\n\t\t\t}\n\t\t\tthis._resolved_cssRenderer_rop = undefined;\n\t\t}\n\t}\n\n\trenderer(canvas: HTMLCanvasElement) {\n\t\treturn this._renderers_by_canvas_id[canvas.id];\n\t}\n\tcssRenderer(canvas: HTMLCanvasElement) {\n\t\tif (this._resolved_cssRenderer_rop && isBooleanTrue(this.node.pv.setCSSRenderer)) {\n\t\t\treturn this._resolved_cssRenderer_rop.renderer(canvas);\n\t\t}\n\t}\n\n\tprivate _super_sampling_size = new Vector2();\n\tcreateRenderer(canvas: HTMLCanvasElement, size: Vector2): WebGLRenderer | undefined {\n\t\tconst gl = Poly.renderersController.renderingContext(canvas);\n\t\tif (!gl) {\n\t\t\tconsole.error('failed to create webgl context');\n\t\t\treturn;\n\t\t}\n\n\t\tlet renderer: WebGLRenderer | undefined;\n\t\tif (isBooleanTrue(this.node.pv.setRenderer)) {\n\t\t\tthis.update_renderer();\n\t\t\tif (this._resolved_renderer_rop) {\n\t\t\t\trenderer = this._resolved_renderer_rop.create_renderer(canvas, gl);\n\t\t\t}\n\t\t}\n\t\tif (!renderer) {\n\t\t\trenderer = RenderController._createDefaultRenderer(canvas, gl);\n\t\t}\n\n\t\t// https://github.com/mrdoob/js/issues/15493\n\t\t// This below is an attempt to fix env map not being loaded in firefox, but that doesn't work.\n\t\t// Since the threejs example (https://threejs.org/examples/?q=exr#webgl_materials_envmaps_exr) also only works in chrome, not in firefox, I assume this is a firefox+linux bug\n\t\t// console.log(renderer.extensions)\n\t\t// renderer.extensions.get( 'EXT_color_buffer_float' );\n\n\t\t// attempt to have particle systems work in firefox on mobile\n\t\t// (current solution is to have the node SOP/particlesSystemGPU force webgl2 to be used)\n\t\t// renderer.extensions.get( 'WEBGL_color_buffer_float' );\n\t\t// renderer.extensions.get( 'WEBGL_draw_buffers' );\n\n\t\tPoly.renderersController.registerRenderer(renderer);\n\t\tthis._renderers_by_canvas_id[canvas.id] = renderer;\n\t\tthis._super_sampling_size.copy(size);\n\t\tthis.set_renderer_size(canvas, this._super_sampling_size);\n\t\t// remove devicePixelRatio for now, as this seems to double the size\n\t\t// of the canvas on high dpi screens\n\t\t// or if this is used, make sure to have the canvas at 100% width and height\n\t\t// renderer.setPixelRatio(window.devicePixelRatio);\n\t\t// UPDATE: favor using devicePixelRatio\n\t\t// to have nice subsampling feel, without needing antialias\n\n\t\treturn renderer;\n\t}\n\tstatic defaultPixelRatio() {\n\t\treturn CoreUserAgent.isMobile() ? 1 : Math.max(2, window.devicePixelRatio);\n\t}\n\tprivate static _createDefaultRenderer(canvas: HTMLCanvasElement, gl: WebGLRenderingContext) {\n\t\tconst params: WebGLRendererParameters = {\n\t\t\tcanvas: canvas,\n\t\t\tantialias: false, // no anti alias with a pixel ratio of 2 is more performant\n\t\t\talpha: true,\n\t\t\tcontext: gl,\n\t\t};\n\t\tconst renderer = new WebGLRenderer(params);\n\t\tconst pixelRatio = this.defaultPixelRatio();\n\t\trenderer.setPixelRatio(pixelRatio);\n\n\t\trenderer.shadowMap.enabled = true;\n\t\trenderer.shadowMap.type = DEFAULT_SHADOW_MAP_TYPE;\n\n\t\trenderer.physicallyCorrectLights = true;\n\n\t\t// // TODO: find a way to have those accessible via params\n\t\trenderer.toneMapping = DEFAULT_TONE_MAPPING;\n\t\trenderer.toneMappingExposure = 1;\n\t\trenderer.outputEncoding = DEFAULT_OUTPUT_ENCODING;\n\n\t\tif (Poly.renderersController.printDebug()) {\n\t\t\tPoly.renderersController.printDebugMessage('create default renderer');\n\t\t\tPoly.renderersController.printDebugMessage({\n\t\t\t\tparams: params,\n\t\t\t\tpixelRatio: pixelRatio,\n\t\t\t});\n\t\t}\n\n\t\treturn renderer;\n\t}\n\n\tdelete_renderer(canvas: HTMLCanvasElement) {\n\t\tconst renderer = this.renderer(canvas);\n\t\tif (renderer) {\n\t\t\tPoly.renderersController.deregisterRenderer(renderer);\n\t\t}\n\t}\n\tcanvas_resolution(canvas: HTMLCanvasElement) {\n\t\treturn this._resolution_by_canvas_id[canvas.id];\n\t}\n\tset_renderer_size(canvas: HTMLCanvasElement, size: Vector2) {\n\t\tthis._resolution_by_canvas_id[canvas.id] = this._resolution_by_canvas_id[canvas.id] || new Vector2();\n\t\tthis._resolution_by_canvas_id[canvas.id].copy(size);\n\n\t\tconst renderer = this.renderer(canvas);\n\t\tif (renderer) {\n\t\t\tconst update_style = false;\n\t\t\trenderer.setSize(size.x, size.y, update_style);\n\t\t}\n\n\t\tif (this._resolved_cssRenderer_rop) {\n\t\t\tconst cssRenderer = this.cssRenderer(canvas);\n\t\t\tif (cssRenderer) {\n\t\t\t\tcssRenderer.setSize(size.x, size.y);\n\t\t\t}\n\t\t}\n\t}\n}\n","import {Vector3} from 'three/src/math/Vector3';\nimport {Vector2} from 'three/src/math/Vector2';\nimport {Quaternion} from 'three/src/math/Quaternion';\nimport {Matrix4} from 'three/src/math/Matrix4';\nimport {InstancedBufferGeometry} from 'three/src/core/InstancedBufferGeometry';\nimport {InstancedBufferAttribute} from 'three/src/core/InstancedBufferAttribute';\nimport {CorePoint} from './Point';\nimport {CoreGroup} from './Group';\nimport {CoreGeometry} from './Geometry';\nimport {BufferGeometry} from 'three/src/core/BufferGeometry';\nimport {CoreType} from '../Type';\nimport {PolyDictionary} from '../../types/GlobalTypes';\n\nconst DEFAULT = {\n\tSCALE: new Vector3(1, 1, 1),\n\tPSCALE: 1,\n\tEYE: new Vector3(0, 0, 0),\n\tUP: new Vector3(0, 1, 0),\n};\nconst SCALE_ATTRIB_NAME = 'scale';\nconst PSCALE_ATTRIB_NAME = 'pscale';\nconst NORMAL_ATTRIB_NAME = 'normal';\nconst UP_ATTRIB_NAME = 'up';\nconst MATRIX_T = 'translate';\nconst MATRIX_R = 'rotate';\nconst MATRIX_S = 'scale';\n\nconst DEFAULT_COLOR = new Vector3(1, 1, 1);\nconst DEFAULT_UV = new Vector2(0, 0);\nconst ATTRIB_NAME_UV = 'uv';\nconst ATTRIB_NAME_COLOR = 'color';\n\nexport class CoreInstancer {\n\tprivate _is_pscale_present: boolean;\n\tprivate _is_scale_present: boolean;\n\tprivate _is_normal_present: boolean;\n\tprivate _is_up_present: boolean;\n\tprivate _do_rotate_matrices: boolean;\n\tprivate _matrices: PolyDictionary<Matrix4> = {};\n\n\tconstructor(private _group_wrapper: CoreGroup) {\n\t\tthis._is_pscale_present = this._group_wrapper.hasAttrib('pscale');\n\t\tthis._is_scale_present = this._group_wrapper.hasAttrib('scale');\n\n\t\tthis._is_normal_present = this._group_wrapper.hasAttrib('normal');\n\t\tthis._is_up_present = this._group_wrapper.hasAttrib('up');\n\n\t\tthis._do_rotate_matrices = this._is_normal_present; //&& this._is_up_present;\n\t}\n\n\tmatrices() {\n\t\tthis._matrices = {};\n\t\tthis._matrices[MATRIX_T] = new Matrix4();\n\t\tthis._matrices[MATRIX_R] = new Matrix4();\n\t\tthis._matrices[MATRIX_S] = new Matrix4();\n\n\t\treturn this._group_wrapper.points().map((point) => {\n\t\t\tconst matrix = new Matrix4();\n\t\t\tthis._matrix_from_point(point, matrix);\n\t\t\treturn matrix;\n\t\t});\n\t}\n\n\tprivate _point_scale = new Vector3();\n\tprivate _point_normal = new Vector3();\n\tprivate _point_up = new Vector3();\n\t// private _point_m = new Matrix4()\n\t_matrix_from_point(point: CorePoint, matrix: Matrix4) {\n\t\tconst t = point.position();\n\t\t//r = new Vector3(0,0,0)\n\t\tif (this._is_scale_present) {\n\t\t\tpoint.attribValue(SCALE_ATTRIB_NAME, this._point_scale);\n\t\t} else {\n\t\t\tthis._point_scale.copy(DEFAULT.SCALE);\n\t\t}\n\t\tconst pscale: number = this._is_pscale_present\n\t\t\t? (point.attribValue(PSCALE_ATTRIB_NAME) as number)\n\t\t\t: DEFAULT.PSCALE;\n\t\tthis._point_scale.multiplyScalar(pscale);\n\n\t\t//matrix = #Core.Transform.matrix(t, r, s, scale)\n\t\t// matrix.identity();\n\n\t\tconst scale_matrix = this._matrices[MATRIX_S];\n\t\tscale_matrix.makeScale(this._point_scale.x, this._point_scale.y, this._point_scale.z);\n\n\t\tconst translate_matrix = this._matrices[MATRIX_T];\n\t\ttranslate_matrix.makeTranslation(t.x, t.y, t.z);\n\n\t\tmatrix.multiply(translate_matrix);\n\n\t\tif (this._do_rotate_matrices) {\n\t\t\tconst rotate_matrix = this._matrices[MATRIX_R];\n\t\t\tconst eye = DEFAULT.EYE;\n\t\t\tpoint.attribValue(NORMAL_ATTRIB_NAME, this._point_normal);\n\t\t\tthis._point_normal.multiplyScalar(-1);\n\t\t\tif (this._is_up_present) {\n\t\t\t\tpoint.attribValue(UP_ATTRIB_NAME, this._point_up);\n\t\t\t} else {\n\t\t\t\tthis._point_up.copy(DEFAULT.UP);\n\t\t\t}\n\t\t\tthis._point_up.normalize();\n\t\t\trotate_matrix.lookAt(eye, this._point_normal, this._point_up);\n\n\t\t\tmatrix.multiply(rotate_matrix);\n\t\t}\n\n\t\tmatrix.multiply(scale_matrix);\n\t}\n\n\tprivate static _point_color = new Vector3();\n\tprivate static _point_uv = new Vector2();\n\tstatic create_instance_buffer_geo(\n\t\tgeometry_to_instance: BufferGeometry,\n\t\ttemplate_core_group: CoreGroup,\n\t\tattributes_to_copy: string\n\t) {\n\t\tconst instance_pts = template_core_group.points();\n\t\t// geometry_to_instance = new BoxBufferGeometry( 2, 2, 2 )\n\t\t// geometry = new InstancedBufferGeometry()\n\t\t// geometry.index = geometry_to_instance.index\n\t\t// geometry.attributes.position = geometry_to_instance.attributes.position\n\t\t// geometry.attributes.uv = geometry_to_instance.attributes.uv\n\n\t\tconst geometry = new InstancedBufferGeometry();\n\t\tgeometry.copy(geometry_to_instance);\n\t\tgeometry.instanceCount = Infinity;\n\n\t\tconst instances_count = instance_pts.length;\n\t\tconst positions = new Float32Array(instances_count * 3);\n\t\tconst colors = new Float32Array(instances_count * 3);\n\t\tconst scales = new Float32Array(instances_count * 3);\n\t\tconst orients = new Float32Array(instances_count * 4);\n\n\t\tconst has_color = template_core_group.hasAttrib(ATTRIB_NAME_COLOR);\n\n\t\tconst position = new Vector3(0, 0, 0);\n\t\tconst quaternion = new Quaternion();\n\t\tconst scale = new Vector3(1, 1, 1);\n\n\t\tconst instancer = new CoreInstancer(template_core_group);\n\t\tconst instance_matrices = instancer.matrices();\n\n\t\tinstance_pts.forEach((instance_pt, i) => {\n\t\t\tconst index3 = i * 3;\n\t\t\tconst index4 = i * 4;\n\n\t\t\tconst matrix = instance_matrices[i];\n\t\t\tmatrix.decompose(position, quaternion, scale);\n\n\t\t\tposition.toArray(positions, index3);\n\t\t\tquaternion.toArray(orients, index4);\n\t\t\tscale.toArray(scales, index3);\n\n\t\t\tconst color = has_color\n\t\t\t\t? (instance_pt.attribValue(ATTRIB_NAME_COLOR, this._point_color) as Vector3)\n\t\t\t\t: DEFAULT_COLOR;\n\t\t\tcolor.toArray(colors, index3);\n\t\t});\n\n\t\t// if(this._param_add_uv_offset){\n\t\tconst has_uv = template_core_group.hasAttrib(ATTRIB_NAME_UV);\n\t\tif (has_uv) {\n\t\t\tconst uvs = new Float32Array(instances_count * 2);\n\t\t\tinstance_pts.forEach((instance_pt, i) => {\n\t\t\t\tconst index2 = i * 2;\n\t\t\t\tconst uv = has_uv ? (instance_pt.attribValue(ATTRIB_NAME_UV, this._point_uv) as Vector2) : DEFAULT_UV;\n\t\t\t\tuv.toArray(uvs, index2);\n\t\t\t});\n\t\t\tgeometry.setAttribute('instanceUv', new InstancedBufferAttribute(uvs, 2));\n\t\t}\n\t\t// }\n\n\t\tgeometry.setAttribute('instancePosition', new InstancedBufferAttribute(positions, 3));\n\t\tgeometry.setAttribute('instanceScale', new InstancedBufferAttribute(scales, 3));\n\t\tgeometry.setAttribute('instanceOrientation', new InstancedBufferAttribute(orients, 4));\n\t\tgeometry.setAttribute('instanceColor', new InstancedBufferAttribute(colors, 3));\n\n\t\tconst attrib_names = template_core_group.attribNamesMatchingMask(attributes_to_copy);\n\n\t\tattrib_names.forEach((attrib_name) => {\n\t\t\tconst attrib_size = template_core_group.attribSize(attrib_name);\n\t\t\tconst values = new Float32Array(instances_count * attrib_size);\n\t\t\tinstance_pts.forEach((pt, i) => {\n\t\t\t\tconst value = pt.attribValue(attrib_name);\n\t\t\t\tif (CoreType.isNumber(value)) {\n\t\t\t\t\tvalues[i] = value;\n\t\t\t\t} else {\n\t\t\t\t\t(value as Vector3).toArray(values, i * attrib_size);\n\t\t\t\t}\n\t\t\t});\n\t\t\tgeometry.setAttribute(attrib_name, new InstancedBufferAttribute(values, attrib_size));\n\t\t});\n\n\t\tconst core_geometry = new CoreGeometry(geometry);\n\t\tcore_geometry.markAsInstance();\n\n\t\treturn geometry;\n\t}\n}\n","export class CoreUserAgent {\n\t// user agent on linux with chrome\n\t// \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.88 Safari/537.36\"\n\t// user agent on linux with firefox\n\t// \"Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:83.0) Gecko/20100101 Firefox/83.0\"\n\tstatic isChrome(): boolean {\n\t\treturn navigator.userAgent.indexOf('Chrome') != -1;\n\t}\n\tstatic isMobile(): boolean {\n\t\treturn /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);\n\t}\n}\n","import {\n\tLinearFilter,\n\tNearestFilter,\n\tNearestMipMapNearestFilter,\n\tNearestMipMapLinearFilter,\n\tLinearMipMapNearestFilter,\n\tLinearMipMapLinearFilter,\n} from 'three/src/constants';\nimport {PolyDictionary} from '../../types/GlobalTypes';\n\nexport const MAG_FILTERS: PolyDictionary<number>[] = [{LinearFilter}, {NearestFilter}];\nexport const MIN_FILTERS: PolyDictionary<number>[] = [\n\t{NearestFilter},\n\t{NearestMipMapNearestFilter},\n\t{NearestMipMapLinearFilter},\n\t{LinearFilter},\n\t{LinearMipMapNearestFilter},\n\t{LinearMipMapLinearFilter},\n];\nexport const MAG_FILTER_DEFAULT_VALUE = Object.values(MAG_FILTERS[0])[0];\nexport const MIN_FILTER_DEFAULT_VALUE = Object.values(MIN_FILTERS[5])[0];\nexport const MAG_FILTER_MENU_ENTRIES = MAG_FILTERS.map((m) => {\n\treturn {\n\t\tname: Object.keys(m)[0],\n\t\tvalue: Object.values(m)[0] as number,\n\t};\n});\nexport const MIN_FILTER_MENU_ENTRIES = MIN_FILTERS.map((m) => {\n\treturn {\n\t\tname: Object.keys(m)[0],\n\t\tvalue: Object.values(m)[0] as number,\n\t};\n});\n","import {Constructor} from '../../../../types/GlobalTypes';\nimport {BaseController} from './_BaseController';\nimport {TypedMatNode} from '../_Base';\nimport {Material} from 'three/src/materials/Material';\nimport {Color} from 'three/src/math/Color';\n\nimport {NodeParamsConfig, ParamConfig} from '../../utils/params/ParamsConfig';\nimport {isBooleanTrue} from '../../../../core/BooleanValue';\n\nexport function ColorParamConfig<TBase extends Constructor>(Base: TBase) {\n\treturn class Mixin extends Base {\n\t\t/** @param material color */\n\t\tcolor = ParamConfig.COLOR([1, 1, 1]);\n\t\t/** @param defines if the color attribute on the geometry is used */\n\t\tuseVertexColors = ParamConfig.BOOLEAN(0);\n\t\t/** @param sets the material to transparent */\n\t\ttransparent = ParamConfig.BOOLEAN(0);\n\t\t/** @param sets the material opacity */\n\t\topacity = ParamConfig.FLOAT(1);\n\t\t/** @param sets the min alpha below which the material is invisible */\n\t\talphaTest = ParamConfig.FLOAT(0);\n\t\t/** @param toggle on if you have a fog in the scene and the material should be affected by it */\n\t\tuseFog = ParamConfig.BOOLEAN(0);\n\t};\n}\n\nclass ColoredMaterial extends Material {\n\tpublic color!: Color;\n\tvertexColors!: boolean;\n\ttransparent!: boolean;\n\tdepthTest!: boolean;\n\talphaTest!: number;\n\tfog!: boolean;\n}\nclass ColorParamsConfig extends ColorParamConfig(NodeParamsConfig) {}\nclass ColoredMatNode extends TypedMatNode<ColoredMaterial, ColorParamsConfig> {\n\tcreateMaterial() {\n\t\treturn new ColoredMaterial();\n\t}\n}\n\nexport class ColorsController extends BaseController {\n\tconstructor(protected node: ColoredMatNode) {\n\t\tsuper(node);\n\t}\n\tstatic update(node: ColoredMatNode) {\n\t\tconst material = node.material;\n\t\tconst pv = node.pv;\n\n\t\tmaterial.color.copy(pv.color);\n\t\tconst newVertexColor = isBooleanTrue(pv.useVertexColors); // ? VertexColors : NoColors;\n\t\tif (newVertexColor != material.vertexColors) {\n\t\t\tmaterial.vertexColors = newVertexColor;\n\t\t\tmaterial.needsUpdate = true;\n\t\t}\n\n\t\tmaterial.opacity = pv.opacity;\n\t\tmaterial.transparent = isBooleanTrue(pv.transparent) || pv.opacity < 1;\n\t\tmaterial.depthTest = true;\n\t\tmaterial.alphaTest = pv.alphaTest;\n\t\tmaterial.fog = isBooleanTrue(pv.useFog);\n\t}\n}\n","import {Constructor} from '../../../../types/GlobalTypes';\nimport {BaseController} from './_BaseController';\nimport {Material} from 'three/src/materials/Material';\nimport {Texture} from 'three/src/textures/Texture';\nimport {BaseMatNodeType} from '../_Base';\nimport {ParamConfig} from '../../utils/params/ParamsConfig';\nimport {NodeContext} from '../../../poly/NodeContext';\nimport {BaseCopNodeType} from '../../cop/_Base';\nimport {OperatorPathParam} from '../../../params/OperatorPath';\nimport {BooleanParam} from '../../../params/Boolean';\nimport {BaseNodeType} from '../../_Base';\nimport {BaseParamType} from '../../../params/_Base';\nimport {ShaderMaterial} from 'three/src/materials/ShaderMaterial';\nimport {IUniform} from 'three/src/renderers/shaders/UniformsLib';\nimport {IUniforms} from '../../../../core/geometry/Material';\nimport {NODE_PATH_DEFAULT} from '../../../../core/Walker';\n\nexport function TextureMapParamConfig<TBase extends Constructor>(Base: TBase) {\n\treturn class Mixin extends Base {\n\t\tuseMap = ParamConfig.BOOLEAN(0);\n\t\tmap = ParamConfig.OPERATOR_PATH(NODE_PATH_DEFAULT.NODE.UV, {visibleIf: {useMap: 1}});\n\t};\n}\n// class TextureMapMaterial<T extends string> extends Material {\n// \t[T]!: Texture | null;\n// }\n// class TextureMapParamsConfig extends TextureMapParamConfig(NodeParamsConfig) {}\n// class TextureMapMatNode extends TypedMatNode<TextureMapMaterial, TextureMapParamsConfig> {\n// \tcreateMaterial() {\n// \t\treturn new TextureMapMaterial();\n// \t}\n// }\n\ntype FilterFlags<Base, Condition> = {\n\t[Key in keyof Base]: Base[Key] extends Condition ? Key : never;\n};\ntype AllowedNames<Base, Condition> = FilterFlags<Base, Condition>[keyof Base];\ntype SubType<Base, Condition> = Pick<Base, AllowedNames<Base, Condition>>;\n\n// type test = FilterFlags<MeshLambertMaterial, Texture|null>\n// type test2 = AllowedNames<MeshLambertMaterial, Texture|null>\n// type test3 = SubType<MeshLambertMaterial, Texture|null>\n\nexport function BooleanParamOptions(controller_class: typeof BaseTextureMapController) {\n\treturn {\n\t\tcook: false,\n\t\tcallback: (node: BaseNodeType, param: BaseParamType) => {\n\t\t\tcontroller_class.update(node as BaseMatNodeType);\n\t\t},\n\t};\n}\nexport function OperatorPathOptions(controller: typeof BaseTextureMapController, use_map_name: string) {\n\treturn {\n\t\tvisibleIf: {[use_map_name]: 1},\n\t\tnodeSelection: {context: NodeContext.COP},\n\t\tcook: false,\n\t\tcallback: (node: BaseNodeType, param: BaseParamType) => {\n\t\t\tcontroller.update(node as BaseMatNodeType);\n\t\t},\n\t};\n}\n\ntype TextureUpdateCallback<O extends Object> = (\n\tmaterial: Material,\n\tobject: O,\n\tmat_attrib_name: keyof SubType<O, Texture | null>,\n\ttexture: Texture\n) => void;\ntype TextureRemoveCallback<O extends Object> = (\n\tmaterial: Material,\n\tobject: O,\n\tmat_attrib_name: keyof SubType<O, Texture | null>\n) => void;\n\ntype CurrentMaterial = Material | ShaderMaterial;\n\nexport interface UpdateOptions {\n\tdirect_params?: boolean;\n\tuniforms?: boolean;\n\t// define?: boolean;\n\t// define_uv?: boolean;\n}\nexport class BaseTextureMapController extends BaseController {\n\tconstructor(protected node: BaseMatNodeType, protected _update_options: UpdateOptions) {\n\t\tsuper(node);\n\t\t// if (this._update_options.define == null) {\n\t\t// \tthis._update_options.define = true;\n\t\t// }\n\t\t// if (this._update_options.define_uv == null) {\n\t\t// \tthis._update_options.define_uv = true;\n\t\t// }\n\t}\n\n\tprotected add_hooks(use_map_param: BooleanParam, path_param: OperatorPathParam) {\n\t\tuse_map_param.addPostDirtyHook('TextureController', () => {\n\t\t\tthis.update();\n\t\t});\n\t\tpath_param.addPostDirtyHook('TextureController', () => {\n\t\t\tthis.update();\n\t\t});\n\t}\n\tstatic update(node: BaseNodeType) {}\n\n\tasync _update<M extends CurrentMaterial>(\n\t\tmaterial: M,\n\t\tmat_attrib_name: string,\n\t\tuse_map_param: BooleanParam,\n\t\tpath_param: OperatorPathParam\n\t) {\n\t\tif (this._update_options.uniforms) {\n\t\t\tconst shader_material = material as ShaderMaterial;\n\t\t\tconst attr_name = mat_attrib_name as keyof SubType<IUniforms, Texture | null>;\n\t\t\tawait this._update_texture_on_uniforms(shader_material, attr_name, use_map_param, path_param);\n\t\t}\n\t\tif (this._update_options.direct_params) {\n\t\t\tconst mat = material as Material;\n\t\t\tconst attr_name = mat_attrib_name as keyof SubType<Material, Texture | null>;\n\t\t\tawait this._update_texture_on_material(mat, attr_name, use_map_param, path_param);\n\t\t}\n\t}\n\n\t//\n\t//\n\t// FOR CASES WHERE THE TEXTURE IS ON THE UNIFORMS\n\t//\n\t//\n\tasync _update_texture_on_uniforms<O extends IUniform>(\n\t\tmaterial: ShaderMaterial,\n\t\tmat_attrib_name: keyof SubType<O, Texture | null>,\n\t\tuse_map_param: BooleanParam,\n\t\tpath_param: OperatorPathParam\n\t) {\n\t\tthis._update_required_attribute(\n\t\t\tmaterial,\n\t\t\tmaterial.uniforms,\n\t\t\tmat_attrib_name as never,\n\t\t\tuse_map_param,\n\t\t\tpath_param,\n\t\t\tthis._apply_texture_on_uniforms.bind(this),\n\t\t\tthis._remove_texture_from_uniforms.bind(this)\n\t\t);\n\t}\n\tprivate _apply_texture_on_uniforms<O extends IUniforms>(\n\t\tmaterial: Material,\n\t\tuniforms: O,\n\t\tmat_attrib_name: keyof SubType<O, Texture | null>,\n\t\ttexture: Texture\n\t) {\n\t\tconst has_texture = uniforms[mat_attrib_name] != null && uniforms[mat_attrib_name].value != null;\n\t\tlet new_texture_is_different = false;\n\t\tif (has_texture) {\n\t\t\tconst current_texture: Texture = (<unknown>uniforms[mat_attrib_name].value) as Texture;\n\t\t\tif (current_texture.uuid != texture.uuid) {\n\t\t\t\tnew_texture_is_different = true;\n\t\t\t}\n\t\t}\n\t\tif (!has_texture || new_texture_is_different) {\n\t\t\tuniforms[mat_attrib_name].value = texture as any;\n\t\t\t// currently removing the settings of defines USE_MAP or USE_UV\n\t\t\t// as this seems to conflict with setting .map on the material itself.\n\t\t\t// ideally I should test if .alphaMap and .envMap still work\n\t\t\t// if (this._do_update_define()) {\n\t\t\t// \tif (material.defines) {\n\t\t\t// \t\tconst define_name = this._define_name(`${mat_attrib_name}`);\n\t\t\t// \t\tmaterial.defines[define_name] = 3;\n\t\t\t// \t}\n\t\t\t// }\n\t\t\t// if (this._update_options.define_uv) {\n\t\t\t// \tif (material.defines) {\n\t\t\t// \t\tmaterial.defines['USE_UV'] = 5;\n\t\t\t// \t}\n\t\t\t// }\n\t\t\tthis._apply_texture_on_material(material, material, mat_attrib_name as any, texture);\n\t\t\tmaterial.needsUpdate = true;\n\t\t}\n\t}\n\tprivate _remove_texture_from_uniforms<U extends IUniforms>(\n\t\tmaterial: Material,\n\t\tuniforms: U,\n\t\tmat_attrib_name: keyof SubType<U, Texture | null>\n\t) {\n\t\tif (uniforms[mat_attrib_name].value) {\n\t\t\tuniforms[mat_attrib_name].value = null;\n\t\t\t// if (this._do_update_define()) {\n\t\t\t// \tif (material.defines) {\n\t\t\t// \t\t// const define_name = this._define_name(`${mat_attrib_name}`);\n\t\t\t// \t\t// delete material.defines[define_name];\n\t\t\t// \t}\n\t\t\t// }\n\t\t\tthis._remove_texture_from_material(material, material, mat_attrib_name as any);\n\t\t\tmaterial.needsUpdate = true;\n\t\t}\n\t}\n\t// private _define_name(mat_attrib_name: string): string {\n\t// \treturn 'USE_' + mat_attrib_name.replace('_', '').toUpperCase();\n\t// }\n\n\t//\n\t//\n\t// FOR CASES WHERE THE TEXTURE IS ON THE MATERIAL\n\t//\n\t//\n\tasync _update_texture_on_material<M extends Material>(\n\t\tmaterial: M,\n\t\tmat_attrib_name: keyof SubType<M, Texture | null>,\n\t\tuse_map_param: BooleanParam,\n\t\tpath_param: OperatorPathParam\n\t) {\n\t\tthis._update_required_attribute(\n\t\t\tmaterial,\n\t\t\tmaterial,\n\t\t\tmat_attrib_name,\n\t\t\tuse_map_param,\n\t\t\tpath_param,\n\t\t\tthis._apply_texture_on_material.bind(this),\n\t\t\tthis._remove_texture_from_material.bind(this)\n\t\t);\n\t}\n\tprivate _apply_texture_on_material<M extends Material>(\n\t\tmaterial: Material,\n\t\ttexture_owner: M,\n\t\tmat_attrib_name: keyof SubType<M, Texture | null>,\n\t\ttexture: Texture\n\t) {\n\t\tconst has_texture = texture_owner[mat_attrib_name] != null;\n\t\tlet new_texture_is_different = false;\n\t\tif (has_texture) {\n\t\t\tconst current_texture: Texture = (<unknown>texture_owner[mat_attrib_name]) as Texture;\n\t\t\tif (current_texture.uuid != texture.uuid) {\n\t\t\t\tnew_texture_is_different = true;\n\t\t\t}\n\t\t}\n\t\tif (!has_texture || new_texture_is_different) {\n\t\t\ttexture_owner[mat_attrib_name] = texture as any;\n\t\t\tmaterial.needsUpdate = true;\n\t\t}\n\t}\n\tprivate _remove_texture_from_material<M extends Material>(\n\t\tmaterial: Material,\n\t\ttexture_owner: M,\n\t\tmat_attrib_name: keyof SubType<M, Texture | null>\n\t) {\n\t\tif (texture_owner[mat_attrib_name]) {\n\t\t\ttexture_owner[mat_attrib_name] = null as any;\n\t\t\tmaterial.needsUpdate = true;\n\t\t}\n\t}\n\n\t//\n\t//\n\t// MAIN ALGO to decide if texture should be updated\n\t//\n\t//\n\tprivate async _update_required_attribute<O extends Object>(\n\t\tmaterial: Material,\n\t\ttexture_owner: O,\n\t\tmat_attrib_name: keyof SubType<O, Texture | null>,\n\t\tuse_map_param: BooleanParam,\n\t\tpath_param: OperatorPathParam,\n\t\tupdate_callback: TextureUpdateCallback<O>,\n\t\tremove_callback: TextureRemoveCallback<O>\n\t) {\n\t\tif (use_map_param.isDirty()) {\n\t\t\tawait use_map_param.compute();\n\t\t}\n\t\tconst use_map: boolean = use_map_param.value;\n\n\t\tif (use_map) {\n\t\t\tif (path_param.isDirty()) {\n\t\t\t\tawait path_param.compute();\n\t\t\t}\n\n\t\t\tconst found_node = path_param.found_node();\n\t\t\tif (found_node) {\n\t\t\t\tif (found_node.nodeContext() == NodeContext.COP) {\n\t\t\t\t\tconst texture_node = found_node as BaseCopNodeType;\n\n\t\t\t\t\tconst container = await texture_node.requestContainer();\n\t\t\t\t\tconst texture = container.texture();\n\n\t\t\t\t\tif (texture) {\n\t\t\t\t\t\tupdate_callback(material, texture_owner, mat_attrib_name, texture);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.node.states.error.set(`found node has no texture`);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tthis.node.states.error.set(`found map node is not a COP node`);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.node.states.error.set(\n\t\t\t\t\t`could not find map node ${path_param.name()} with path ${path_param.value}`\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\t// this is not wrapped in an else clause after the \"if (use_map) {\"\n\t\t// as we should come here after any of the errors above, if any is triggered\n\t\tremove_callback(material, texture_owner, mat_attrib_name);\n\t}\n\n\t// private _do_update_define(): boolean {\n\t// \tif (this._update_options.define == null) {\n\t// \t\treturn true;\n\t// \t}\n\t// \treturn this._update_options.define;\n\t// }\n}\n","import {TypedObjNode} from './_Base';\nimport {Group} from 'three/src/objects/Group';\n\nimport {NodeParamsConfig} from '../utils/params/ParamsConfig';\nexport class BaseManagerObjNode<K extends NodeParamsConfig> extends TypedObjNode<Group, K> {\n\tprotected _attachableToHierarchy: boolean = false;\n\n\tcreate_object() {\n\t\tconst group = new Group();\n\t\tgroup.matrixAutoUpdate = false;\n\t\treturn group;\n\t}\n\n\tcook() {\n\t\tthis.cookController.end_cook();\n\t}\n}\n\nclass ParamLessObjParamsConfig extends NodeParamsConfig {}\nexport class ParamLessBaseManagerObjNode extends BaseManagerObjNode<ParamLessObjParamsConfig> {}\n","import {BaseObjNodeClass} from '../_Base';\nimport {Object3D} from 'three/src/core/Object3D';\nimport {DisplayNodeController, DisplayNodeControllerCallbacks} from '../../utils/DisplayNodeController';\nimport {Group} from 'three/src/objects/Group';\nimport {PolyDictionary} from '../../../../types/GlobalTypes';\nimport {BaseSopNodeType} from '../../sop/_Base';\n\nconst DISPLAY_PARAM_NAME = 'display';\n\ninterface BaseObjNodeClassWithDisplayNode extends BaseObjNodeClass {\n\tdisplayNodeController: DisplayNodeController;\n}\n\nexport class ChildrenDisplayController {\n\t_children_uuids_dict: PolyDictionary<boolean> = {};\n\t_children_length: number = 0;\n\tprivate _sop_group = this._create_sop_group();\n\n\tconstructor(private node: BaseObjNodeClassWithDisplayNode) {}\n\n\tprivate _create_sop_group() {\n\t\t// This may need to be a Mesh for the rivet to update correctly\n\t\t// But when it is not used for a rivet, there is a place where a MeshBasicMaterial\n\t\t// is added to it, making it an additional webgl program for the renderer.\n\t\t// const mesh = new Mesh();\n\t\tconst group = new Group();\n\t\tgroup.matrixAutoUpdate = false;\n\t\treturn group;\n\t}\n\tsopGroup() {\n\t\treturn this._sop_group;\n\t}\n\tset_sop_group_name() {\n\t\tthis._sop_group.name = `${this.node.name()}:sop_group`;\n\t}\n\n\tdisplayNodeControllerCallbacks(): DisplayNodeControllerCallbacks {\n\t\treturn {\n\t\t\tonDisplayNodeRemove: () => {\n\t\t\t\tthis.remove_children();\n\t\t\t},\n\t\t\tonDisplayNodeSet: () => {\n\t\t\t\t// use a timeout here, so that the node isn't cooked too early when being copy/pasted, if it had the display flag on.\n\t\t\t\t// This would make nodes error\n\t\t\t\tsetTimeout(() => {\n\t\t\t\t\tthis.request_display_node_container();\n\t\t\t\t}, 0);\n\t\t\t},\n\t\t\tonDisplayNodeUpdate: () => {\n\t\t\t\tthis.request_display_node_container();\n\t\t\t},\n\t\t};\n\t}\n\n\tinitializeNode() {\n\t\tthis.node.object.add(this.sopGroup());\n\t\tthis.node.nameController.add_post_set_fullPath_hook(this.set_sop_group_name.bind(this));\n\t\tthis._create_sop_group();\n\n\t\tconst display_flag = this.node.flags?.display;\n\t\tif (display_flag) {\n\t\t\tdisplay_flag.onUpdate(() => {\n\t\t\t\tthis._updateSopGroupHierarchy();\n\t\t\t\tif (display_flag.active()) {\n\t\t\t\t\tthis.request_display_node_container();\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\tprivate _updateSopGroupHierarchy() {\n\t\tconst display_flag = this.node.flags?.display;\n\t\tif (display_flag) {\n\t\t\tconst sopGroup = this.sopGroup();\n\t\t\tif (this.usedInScene()) {\n\t\t\t\tsopGroup.visible = true;\n\t\t\t\tthis.node.object.add(sopGroup);\n\t\t\t} else {\n\t\t\t\tsopGroup.visible = false;\n\t\t\t\tthis.node.object.remove(sopGroup);\n\t\t\t}\n\t\t}\n\t}\n\n\tusedInScene(): boolean {\n\t\tconst has_active_param = this.node.params.has(DISPLAY_PARAM_NAME);\n\t\tconst is_active_param_on = this.node.params.boolean(DISPLAY_PARAM_NAME);\n\n\t\tconst used_in_scene = this.node.usedInScene();\n\t\tconst display_flag_on = this.node.flags?.display?.active() || false;\n\t\tconst param_active_on = !has_active_param || is_active_param_on;\n\n\t\treturn used_in_scene && display_flag_on && param_active_on;\n\t}\n\n\tasync request_display_node_container() {\n\t\tif (!this.node.scene().loadingController.loaded()) {\n\t\t\treturn;\n\t\t}\n\t\tif (this.usedInScene()) {\n\t\t\tawait this._set_content_under_sop_group();\n\t\t}\n\t}\n\n\tremove_children() {\n\t\tif (this._sop_group.children.length == 0) {\n\t\t\treturn;\n\t\t}\n\t\tlet child: Object3D | undefined;\n\t\twhile ((child = this._sop_group.children[0])) {\n\t\t\tthis._sop_group.remove(child);\n\t\t}\n\t\tthis._children_uuids_dict = {};\n\t\tthis._children_length = 0;\n\t}\n\n\tasync _set_content_under_sop_group() {\n\t\t// we also check that the parent are the same, in case the node has been deleted\n\t\t// TODO: there should be a wider refactor where deleted node cannot raise callbacks such as flags update\n\t\tconst display_node = this.node.displayNodeController.displayNode() as BaseSopNodeType;\n\t\tif (display_node && display_node.parent()?.graphNodeId() == this.node.graphNodeId()) {\n\t\t\tconst container = await display_node.requestContainer();\n\t\t\tconst core_group = container.coreContent();\n\t\t\tif (core_group) {\n\t\t\t\t// check if the new objects are different\n\t\t\t\tconst new_objects = core_group.objects();\n\t\t\t\tlet new_objects_are_different = new_objects.length != this._children_length;\n\t\t\t\tif (!new_objects_are_different) {\n\t\t\t\t\tfor (let object of new_objects) {\n\t\t\t\t\t\tif (!(object.uuid in this._children_uuids_dict)) {\n\t\t\t\t\t\t\tnew_objects_are_different = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// update hierarchy if different\n\t\t\t\tif (new_objects_are_different) {\n\t\t\t\t\tthis.remove_children();\n\t\t\t\t\tfor (let object of new_objects) {\n\t\t\t\t\t\tthis._sop_group.add(object);\n\t\t\t\t\t\t// ensure the matrix of the parent is used\n\t\t\t\t\t\tobject.updateMatrix();\n\t\t\t\t\t\tthis._children_uuids_dict[object.uuid] = true;\n\t\t\t\t\t}\n\t\t\t\t\tthis._children_length = new_objects.length;\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tthis.remove_children();\n\t}\n}\n","import {Constructor} from '../../../../../types/GlobalTypes';\nimport {MeshBasicMaterial} from 'three/src/materials/MeshBasicMaterial';\nimport {NodeParamsConfig, ParamConfig} from '../../../utils/params/ParamsConfig';\nimport {TypedObjNode} from '../../_Base';\nimport {Group} from 'three/src/objects/Group';\nimport {Light} from 'three/src/lights/Light';\nimport {Object3D} from 'three/src/core/Object3D';\nimport {FlagsControllerD} from '../../../utils/FlagsController';\nexport function BaseLightHelperParamConfig<TBase extends Constructor>(Base: TBase) {\n\treturn class Mixin extends Base {\n\t\tshowHelper = ParamConfig.BOOLEAN(0);\n\t};\n}\nclass BaseLightHelperParamsConfig extends BaseLightHelperParamConfig(NodeParamsConfig) {}\nexport abstract class BaseLightHelperObjNode<L extends Light> extends TypedObjNode<Group, BaseLightHelperParamsConfig> {\n\tpublic readonly flags: FlagsControllerD = new FlagsControllerD(this);\n\n\t// public readonly helper: BaseLightHelper<L> | undefined;\n\tabstract get light(): L;\n}\n\nexport abstract class BaseLightHelper<O extends Object3D, L extends Light, N extends BaseLightHelperObjNode<L>> {\n\tprotected _object: O = this.createObject();\n\tprotected _material = new MeshBasicMaterial({wireframe: true, fog: false});\n\tconstructor(protected node: N, private _name: string) {}\n\n\tbuild() {\n\t\tthis._object.matrixAutoUpdate = false;\n\t\tthis._object.name = this._name;\n\t\tthis.buildHelper();\n\t}\n\n\tprotected abstract createObject(): O;\n\tprotected abstract buildHelper(): void;\n\tget object() {\n\t\treturn this._object;\n\t}\n\n\tabstract update(): void;\n}\n","import {TypedObjNode, ObjNodeRenderOrder} from './_Base';\nimport {Light} from 'three/src/lights/Light';\nimport {Color} from 'three/src/math/Color';\nimport {NodeParamsConfig} from '../utils/params/ParamsConfig';\nimport {FlagsControllerD} from '../utils/FlagsController';\nimport {Group} from 'three/src/objects/Group';\n\nexport abstract class TypedLightObjNode<L extends Light, K extends NodeParamsConfig> extends TypedObjNode<Group, K> {\n\tpublic readonly flags: FlagsControllerD = new FlagsControllerD(this);\n\tpublic readonly renderOrder: number = ObjNodeRenderOrder.LIGHT;\n\tprotected _color_with_intensity = new Color(0x00000);\n\tprotected _light!: L;\n\tget light() {\n\t\treturn this._light;\n\t}\n\tprotected abstract create_light(): L;\n\tprotected _used_in_scene: boolean = true;\n\tinitializeBaseNode() {\n\t\tsuper.initializeBaseNode();\n\n\t\tthis._light = this.create_light();\n\t\tthis.object.add(this._light);\n\t\tthis.flags.display.onUpdate(() => {\n\t\t\tthis.update_light_attachment();\n\t\t});\n\t\tthis.dirtyController.addPostDirtyHook(\n\t\t\t'_cook_main_without_inputs_when_dirty',\n\t\t\tthis._cook_main_without_inputs_when_dirty_bound\n\t\t);\n\t}\n\t// TODO: I may be able to swap those methods to param callbacks for most params\n\tprivate _cook_main_without_inputs_when_dirty_bound = this._cook_main_without_inputs_when_dirty.bind(this);\n\tprivate async _cook_main_without_inputs_when_dirty() {\n\t\t// if (this.used_in_scene) {\n\t\tawait this.cookController.cook_main_without_inputs();\n\t\t// }\n\t}\n\n\tprotected set_object_name() {\n\t\tsuper.set_object_name();\n\t\tif (this._light) {\n\t\t\tthis._light.name = `${this.fullPath()}:light`;\n\t\t}\n\t}\n\n\tprivate update_light_attachment() {\n\t\tif (this.flags.display.active()) {\n\t\t\tthis.object.add(this.light);\n\t\t\tthis._cook_main_without_inputs_when_dirty();\n\t\t} else {\n\t\t\tthis.object.remove(this.light);\n\t\t}\n\t}\n\n\t// create_params() {\n\t// \t// this.create_light_params();\n\t// \t// this.create_shadow_params_main();\n\t// }\n\n\tcreate_shadow_params_main() {\n\t\tif (this._light.shadow != null) {\n\t\t\treturn this.create_shadow_params();\n\t\t}\n\t}\n\n\tprotected create_light_params(): void {}\n\tprotected update_light_params(): void {}\n\n\tprotected create_shadow_params() {\n\t\treturn;\n\t\t// this.add_param('toggle', 'cast_shadows', 1);\n\t\t// shadow_options = {visibleIf: {cast_shadows: 1}}\n\t\t// this.add_param( 'vector2', 'shadow_res', [1024, 1024], shadow_options );\n\t\t// this.add_param( 'float', 'shadow_near', 0.1, shadow_options );\n\t\t// this.add_param( 'float', 'shadow_far', 100, shadow_options );\n\t\t// // this.add_param( 'float', 'shadow_far', 500 ) # same as param distance\n\t\t// this.add_param( 'float', 'shadow_bias', -0.0001, shadow_options );\n\t\t// this.add_param( 'float', 'shadow_blur', 1, shadow_options );\n\t}\n\n\t// as_code_set_up_custom: ->\n\t// \tlines = []\n\t// \tlines.push \"#{this.code_var_name()}.set_display_flag(#{this.display_flag_state()})\"\n\t// \tlines\n\n\tcook() {\n\t\tthis.update_light_params();\n\t\tthis.update_shadow_params();\n\t\tthis.cookController.end_cook();\n\t}\n\n\tupdate_shadow_params() {\n\t\t// let object;\n\t\t// return;\n\t\t// if (((object = this.object()) != null) && (object.shadow != null)) {\n\t\t// \tobject.castShadow = this._param_cast_shadow;\n\t\t// \tobject.shadow.mapSize.width = this._param_shadow_res.x;\n\t\t// \tobject.shadow.mapSize.height = this._param_shadow_res.y;\n\t\t// \tobject.shadow.camera.near = this._param_shadow_near;\n\t\t// \tobject.shadow.camera.far = this._param_shadow_far;\n\t\t// \treturn object.shadow.bias = this._param_shadow_bias;\n\t\t// }\n\t}\n\n\tget color_with_intensity() {\n\t\tconst color = this.params.color('color');\n\t\tconst intensity = this.params.float('intensity');\n\t\tthis._color_with_intensity.copy(color).multiplyScalar(intensity);\n\t\treturn this._color_with_intensity;\n\t}\n\tget active(): boolean {\n\t\treturn this.flags.display.active();\n\t}\n}\n\nexport type BaseLightObjNodeType = TypedLightObjNode<Light, NodeParamsConfig>;\n// export class BaseLightObjNodeClass extends TypedLightObjNode<Light, NodeParamsConfig> {}\n","import {Light} from 'three/src/lights/Light';\nimport {Object3D} from 'three/src/core/Object3D';\nimport {BaseLightHelper, BaseLightHelperObjNode} from './helpers/_BaseLightHelper';\n\n// interface Helper<L extends Light> extends BaseLightHelper<L> {\n// \tdispose: () => void;\n// \tupdate: () => void;\n// }\nexport interface HelperConstructor<O extends Object3D, L extends Light> {\n\tnew (node: BaseLightHelperObjNode<L>, name: string): BaseLightHelper<O, L, BaseLightHelperObjNode<L>>;\n}\n\nexport class HelperController<O extends Object3D, L extends Light> {\n\tprivate _helper: BaseLightHelper<O, L, BaseLightHelperObjNode<L>> | undefined;\n\tconstructor(\n\t\tprivate node: BaseLightHelperObjNode<L>,\n\t\tprivate _helper_constructor: HelperConstructor<O, L>,\n\t\tprivate _name: string\n\t) {}\n\n\tinitializeNode() {\n\t\tthis.node.flags.display.onUpdate(() => {\n\t\t\tthis.update();\n\t\t});\n\t}\n\n\tget helper() {\n\t\tif (this.node.flags.display.active()) {\n\t\t\treturn (this._helper = this._helper || this._create_helper());\n\t\t}\n\t}\n\tget visible() {\n\t\treturn this.node.flags.display.active() && this.node.pv.showHelper;\n\t}\n\n\tprivate _create_helper(): BaseLightHelper<O, L, BaseLightHelperObjNode<L>> {\n\t\tconst helper = new this._helper_constructor(this.node, this._name);\n\t\thelper.build();\n\t\treturn helper;\n\t}\n\n\tupdate() {\n\t\tif (this.visible) {\n\t\t\tif (!this._helper) {\n\t\t\t\tthis._helper = this._create_helper();\n\t\t\t}\n\t\t\tif (this._helper) {\n\t\t\t\tthis.node.light.add(this._helper.object);\n\t\t\t\tthis._helper.update();\n\t\t\t}\n\t\t} else {\n\t\t\tif (this._helper) {\n\t\t\t\tthis.node.light.remove(this._helper.object);\n\t\t\t}\n\t\t}\n\t}\n}\n","import {TypedNode} from '../_Base';\nimport {NodeContext} from '../../poly/NodeContext';\nimport {NodeParamsConfig} from '../utils/params/ParamsConfig';\nimport {FlagsController} from '../utils/FlagsController';\n\nexport class TypedRopNode<K extends NodeParamsConfig> extends TypedNode<NodeContext.ROP, K> {\n\tstatic nodeContext(): NodeContext {\n\t\treturn NodeContext.ROP;\n\t}\n\n\tpublic readonly flags: FlagsController = new FlagsController(this);\n\t// protected _renderer: R = this._create_renderer();\n\n\tinitializeBaseNode() {\n\t\tthis.dirtyController.addPostDirtyHook('cook_immediately', () => {\n\t\t\tthis.cookController.cook_main_without_inputs();\n\t\t});\n\t}\n\n\t// protected abstract _create_renderer(): R;\n\t// renderer() {\n\t// \treturn this._renderer;\n\t// }\n\n\tcook() {\n\t\tthis.cookController.end_cook();\n\t}\n}\n\nexport type BaseRopNodeType = TypedRopNode<NodeParamsConfig>;\nexport class BaseRopNodeClass extends TypedRopNode<NodeParamsConfig> {\n\t// protected _create_renderer() {\n\t// \treturn {};\n\t// }\n}\n","import {Object3D} from 'three/src/core/Object3D';\n\nexport class CSS2DObject extends Object3D {\n\tconstructor(protected _element: HTMLElement) {\n\t\tsuper();\n\n\t\tthis._element.style.position = 'absolute';\n\n\t\tthis.addEventListener('removed', this._on_removed.bind(this));\n\t}\n\n\tprivate _on_removed() {\n\t\tthis.traverse(function (object) {\n\t\t\tif (object instanceof CSS2DObject) {\n\t\t\t\tif (object.element instanceof Element && object.element.parentNode !== null) {\n\t\t\t\t\tobject.element.parentNode.removeChild(object.element);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\tget element() {\n\t\treturn this._element;\n\t}\n\n\tcopy(source: CSS2DObject, recursive: boolean) {\n\t\tObject3D.prototype.copy.call(this, source, recursive);\n\n\t\tthis._element = source.element.cloneNode(true) as HTMLElement;\n\t\tthis.matrixAutoUpdate = source.matrixAutoUpdate;\n\n\t\treturn this;\n\t}\n}\n","import {BaseSopOperation} from './_Base';\nimport {DefaultOperationParams} from '../_Base';\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {Vector2} from 'three/src/math/Vector2';\nimport {Vector3} from 'three/src/math/Vector3';\nimport {Vector4} from 'three/src/math/Vector4';\nimport {ATTRIBUTE_CLASSES, AttribClass, AttribType, ATTRIBUTE_TYPES} from '../../../core/geometry/Constant';\nimport {InputCloneMode} from '../../../engine/poly/InputCloneMode';\nimport {TypeAssert} from '../../../engine/poly/Assert';\nimport {CoreObject} from '../../../core/geometry/Object';\nimport {CoreAttribute} from '../../../core/geometry/Attribute';\n\ninterface AttribCreateSopParams extends DefaultOperationParams {\n\tgroup: string;\n\tclass: number;\n\ttype: number;\n\tname: string;\n\tsize: number;\n\tvalue1: number;\n\tvalue2: Vector2;\n\tvalue3: Vector3;\n\tvalue4: Vector4;\n\tstring: string;\n}\n\nexport class AttribCreateSopOperation extends BaseSopOperation {\n\tstatic readonly DEFAULT_PARAMS: AttribCreateSopParams = {\n\t\tgroup: '',\n\t\tclass: ATTRIBUTE_CLASSES.indexOf(AttribClass.VERTEX),\n\t\ttype: ATTRIBUTE_TYPES.indexOf(AttribType.NUMERIC),\n\t\tname: 'new_attrib',\n\t\tsize: 1,\n\t\tvalue1: 0,\n\t\tvalue2: new Vector2(0, 0),\n\t\tvalue3: new Vector3(0, 0, 0),\n\t\tvalue4: new Vector4(0, 0, 0, 0),\n\t\tstring: '',\n\t};\n\tstatic readonly INPUT_CLONED_STATE = InputCloneMode.FROM_NODE;\n\tstatic type(): Readonly<'attribCreate'> {\n\t\treturn 'attribCreate';\n\t}\n\n\tcook(input_contents: CoreGroup[], params: AttribCreateSopParams) {\n\t\tconst core_group = input_contents[0];\n\t\tif (params.name && params.name.trim() != '') {\n\t\t\tthis._add_attribute(ATTRIBUTE_CLASSES[params.class], core_group, params);\n\t\t} else {\n\t\t\tthis.states?.error.set('attribute name is not valid');\n\t\t}\n\t\treturn core_group;\n\t}\n\tprivate async _add_attribute(attrib_class: AttribClass, core_group: CoreGroup, params: AttribCreateSopParams) {\n\t\tconst attrib_type = ATTRIBUTE_TYPES[params.type];\n\t\tswitch (attrib_class) {\n\t\t\tcase AttribClass.VERTEX:\n\t\t\t\tawait this.add_point_attribute(attrib_type, core_group, params);\n\t\t\t\treturn;\n\t\t\tcase AttribClass.OBJECT:\n\t\t\t\tawait this.add_object_attribute(attrib_type, core_group, params);\n\t\t\t\treturn;\n\t\t}\n\t\tTypeAssert.unreachable(attrib_class);\n\t}\n\n\tasync add_point_attribute(attrib_type: AttribType, core_group: CoreGroup, params: AttribCreateSopParams) {\n\t\tconst core_objects = core_group.coreObjects();\n\t\tswitch (attrib_type) {\n\t\t\tcase AttribType.NUMERIC: {\n\t\t\t\tfor (let i = 0; i < core_objects.length; i++) {\n\t\t\t\t\tawait this.add_numeric_attribute_to_points(core_objects[i], params);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tcase AttribType.STRING: {\n\t\t\t\tfor (let i = 0; i < core_objects.length; i++) {\n\t\t\t\t\tawait this.add_string_attribute_to_points(core_objects[i], params);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tTypeAssert.unreachable(attrib_type);\n\t}\n\tasync add_object_attribute(attrib_type: AttribType, core_group: CoreGroup, params: AttribCreateSopParams) {\n\t\tconst core_objects = core_group.coreObjectsFromGroup(params.group);\n\t\tswitch (attrib_type) {\n\t\t\tcase AttribType.NUMERIC:\n\t\t\t\tawait this.add_numeric_attribute_to_object(core_objects, params);\n\t\t\t\treturn;\n\t\t\tcase AttribType.STRING:\n\t\t\t\tawait this.add_string_attribute_to_object(core_objects, params);\n\t\t\t\treturn;\n\t\t}\n\t\tTypeAssert.unreachable(attrib_type);\n\t}\n\n\tasync add_numeric_attribute_to_points(core_object: CoreObject, params: AttribCreateSopParams) {\n\t\tconst core_geometry = core_object.coreGeometry();\n\t\tif (!core_geometry) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst value = [params.value1, params.value2, params.value3, params.value4][params.size - 1];\n\t\tcore_object.addNumericVertexAttrib(params.name, params.size, value);\n\t}\n\n\tasync add_numeric_attribute_to_object(core_objects: CoreObject[], params: AttribCreateSopParams) {\n\t\tconst value = [params.value1, params.value2, params.value3, params.value4][params.size - 1];\n\t\tfor (let core_object of core_objects) {\n\t\t\tcore_object.setAttribValue(params.name, value);\n\t\t}\n\t}\n\n\tasync add_string_attribute_to_points(core_object: CoreObject, params: AttribCreateSopParams) {\n\t\tconst points = core_object.pointsFromGroup(params.group);\n\t\tconst value = params.string;\n\n\t\tconst string_values: string[] = new Array(points.length);\n\n\t\tfor (let i = 0; i < points.length; i++) {\n\t\t\tstring_values[i] = value;\n\t\t}\n\n\t\tconst index_data = CoreAttribute.array_to_indexed_arrays(string_values);\n\t\tconst geometry = core_object.coreGeometry();\n\t\tif (geometry) {\n\t\t\tgeometry.setIndexedAttribute(params.name, index_data['values'], index_data['indices']);\n\t\t}\n\t}\n\n\tasync add_string_attribute_to_object(core_objects: CoreObject[], params: AttribCreateSopParams) {\n\t\tconst value = params.string;\n\t\tfor (let core_object of core_objects) {\n\t\t\tcore_object.setAttribValue(params.name, value);\n\t\t}\n\t}\n}\n","import {NodeContext} from '../../poly/NodeContext';\nimport {NodeParamsConfig} from '../utils/params/ParamsConfig';\nimport {TypedNode} from '../_Base';\n\nclass ParamLessNetworkSopParamsConfig extends NodeParamsConfig {}\nexport class BaseNetworkSopNode<K extends NodeParamsConfig> extends TypedNode<NodeContext.SOP, K> {\n\tstatic nodeContext(): NodeContext {\n\t\treturn NodeContext.SOP;\n\t}\n\t// initializeBaseNode() {\n\t// \tthis.children_controller?.init({dependent: false});\n\t// }\n\tcook() {\n\t\tthis.cookController.end_cook();\n\t}\n}\nexport class ParamLessBaseNetworkSopNode extends BaseNetworkSopNode<ParamLessNetworkSopParamsConfig> {}\n","import {BaseSopOperation} from './_Base';\nimport {DefaultOperationParams} from '../_Base';\nimport {CoreGroup, Object3DWithGeometry} from '../../../core/geometry/Group';\nimport {ObjectType, objectTypeFromConstructor} from '../../../core/geometry/Constant';\nimport {Material} from 'three/src/materials/Material';\nimport {MapUtils} from '../../../core/MapUtils';\nimport {CoreGeometry} from '../../../core/geometry/Geometry';\nimport {Object3D} from 'three/src/core/Object3D';\nimport {Group} from 'three/src/objects/Group';\nimport {Mesh} from 'three/src/objects/Mesh';\nimport {InputCloneMode} from '../../../engine/poly/InputCloneMode';\nimport {isBooleanTrue} from '../../../core/BooleanValue';\n\ninterface MergeSopParams extends DefaultOperationParams {\n\tcompact: boolean;\n}\n\nexport class MergeSopOperation extends BaseSopOperation {\n\tstatic readonly DEFAULT_PARAMS: MergeSopParams = {\n\t\tcompact: false,\n\t};\n\tstatic readonly INPUT_CLONED_STATE = InputCloneMode.FROM_NODE;\n\tstatic type(): Readonly<'merge'> {\n\t\treturn 'merge';\n\t}\n\n\t// TODO: improvement:\n\t// for compact, I should really keep track of geometry ids,\n\t// to make sure I am not including a geometry twice, if there is a hierarchy\n\tcook(input_contents: CoreGroup[], params: MergeSopParams) {\n\t\tlet all_objects: Object3D[] = [];\n\t\tfor (let input_core_group of input_contents) {\n\t\t\tif (input_core_group) {\n\t\t\t\tconst objects = input_core_group.objects();\n\t\t\t\tif (isBooleanTrue(params.compact)) {\n\t\t\t\t\tfor (let object of objects) {\n\t\t\t\t\t\tobject.traverse((child) => {\n\t\t\t\t\t\t\tall_objects.push(child as Object3DWithGeometry);\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// if we are not compact,\n\t\t\t\t\t// we only use the current level, not children\n\t\t\t\t\tfor (let object of input_core_group.objects()) {\n\t\t\t\t\t\tall_objects.push(object);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (isBooleanTrue(params.compact)) {\n\t\t\tall_objects = this._make_compact(all_objects);\n\t\t}\n\t\tfor (let object of all_objects) {\n\t\t\tobject.traverse((o) => {\n\t\t\t\to.matrixAutoUpdate = false;\n\t\t\t});\n\t\t}\n\t\treturn this.create_core_group_from_objects(all_objects);\n\t}\n\t_make_compact(all_objects: Object3D[]): Object3DWithGeometry[] {\n\t\tconst materials_by_object_type: Map<ObjectType, Material> = new Map();\n\t\tconst objects_by_type: Map<ObjectType, Object3DWithGeometry[]> = new Map();\n\t\t// objects_by_type.set(ObjectType.MESH, []);\n\t\t// objects_by_type.set(ObjectType.POINTS, []);\n\t\t// objects_by_type.set(ObjectType.LINE_SEGMENTS, []);\n\t\tconst ordered_object_types: ObjectType[] = [];\n\n\t\tfor (let object of all_objects) {\n\t\t\tobject.traverse((object3d: Object3D) => {\n\t\t\t\tif (object3d instanceof Group) {\n\t\t\t\t\t// we do not want groups,\n\t\t\t\t\t// as their children will end up being duplicated\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tconst object = object3d as Object3DWithGeometry;\n\t\t\t\tif (object.geometry) {\n\t\t\t\t\tconst object_type = objectTypeFromConstructor(object.constructor);\n\t\t\t\t\tif (!ordered_object_types.includes(object_type)) {\n\t\t\t\t\t\tordered_object_types.push(object_type);\n\t\t\t\t\t}\n\t\t\t\t\tif (object_type) {\n\t\t\t\t\t\tconst found_mat = materials_by_object_type.get(object_type);\n\t\t\t\t\t\tif (!found_mat) {\n\t\t\t\t\t\t\tmaterials_by_object_type.set(object_type, (object as Mesh).material as Material);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tMapUtils.push_on_array_at_entry(objects_by_type, object_type, object);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\tconst merged_objects: Object3DWithGeometry[] = [];\n\t\tordered_object_types.forEach((object_type) => {\n\t\t\tconst objects = objects_by_type.get(object_type);\n\t\t\tif (objects) {\n\t\t\t\tconst geometries = [];\n\t\t\t\tfor (let object of objects) {\n\t\t\t\t\tconst geometry = object.geometry;\n\t\t\t\t\tgeometry.applyMatrix4(object.matrix);\n\t\t\t\t\tgeometries.push(geometry);\n\t\t\t\t}\n\n\t\t\t\t// TODO: test that this works with geometries with same attributes\n\t\t\t\ttry {\n\t\t\t\t\tconst merged_geometry = CoreGeometry.merge_geometries(geometries);\n\t\t\t\t\tif (merged_geometry) {\n\t\t\t\t\t\tconst material = materials_by_object_type.get(object_type);\n\t\t\t\t\t\tconst object = this.create_object(merged_geometry, object_type, material);\n\t\t\t\t\t\tmerged_objects.push(object as Object3DWithGeometry);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.states?.error.set('merge failed, check that input geometries have the same attributes');\n\t\t\t\t\t}\n\t\t\t\t} catch (e) {\n\t\t\t\t\tthis.states?.error.set(e);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\treturn merged_objects;\n\t}\n}\n","import {BaseSopOperation} from './_Base';\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {DefaultOperationParams} from '../_Base';\nimport {InputCloneMode} from '../../../engine/poly/InputCloneMode';\n\ninterface NullSopParams extends DefaultOperationParams {}\n\nexport class NullSopOperation extends BaseSopOperation {\n\tstatic readonly DEFAULT_PARAMS: NullSopParams = {};\n\tstatic readonly INPUT_CLONED_STATE = InputCloneMode.FROM_NODE;\n\tstatic type(): Readonly<'null'> {\n\t\treturn 'null';\n\t}\n\n\tcook(input_contents: CoreGroup[], params: NullSopParams) {\n\t\tconst core_group = input_contents[0];\n\t\tif (core_group) {\n\t\t\treturn core_group;\n\t\t} else {\n\t\t\treturn this.create_core_group_from_objects([]);\n\t\t}\n\t}\n}\n","import {GlobalsGlNode} from '../../Globals';\nimport {GlConnectionPointType} from '../../../utils/io/connections/Gl';\nimport {BaseGlNodeType} from '../../_Base';\nimport {ShadersCollectionController} from '../utils/ShadersCollectionController';\n\nexport abstract class GlobalsBaseController {\n\tprivate static __next_id: number = 0;\n\tprivate _id: number;\n\n\tconstructor() {\n\t\tthis._id = GlobalsBaseController.__next_id++;\n\t}\n\tid() {\n\t\treturn this._id;\n\t}\n\n\thandle_globals_node(\n\t\tglobals_node: GlobalsGlNode,\n\t\toutput_name: string,\n\t\tshaders_collection_controller: ShadersCollectionController\n\t\t// definitions_by_shader_name: Map<ShaderName, BaseGLDefinition[]>,\n\t\t// body_lines_by_shader_name: Map<ShaderName, string[]>,\n\t\t// body_lines: string[],\n\t\t// dependencies: ShaderName[],\n\t\t// shader_name: ShaderName\n\t): void {}\n\n\tabstract read_attribute(\n\t\tnode: BaseGlNodeType,\n\t\tgl_type: GlConnectionPointType,\n\t\tattrib_name: string,\n\t\tshaders_collection_controller: ShadersCollectionController\n\t): string | undefined;\n}\n","import {CoreString} from './String';\nimport {Vector2} from 'three/src/math/Vector2';\nimport {Vector3} from 'three/src/math/Vector3';\nimport {Vector4} from 'three/src/math/Vector4';\nimport {Color} from 'three/src/math/Color';\nimport {CoreType} from './Type';\n\nexport class ThreeToGl {\n\tstatic any(value: any): string {\n\t\tif (CoreType.isString(value)) {\n\t\t\treturn value;\n\t\t}\n\t\tif (CoreType.isBoolean(value)) {\n\t\t\treturn `${value}`;\n\t\t}\n\t\tif (CoreType.isNumber(value)) {\n\t\t\treturn `${CoreString.ensureFloat(value)}`;\n\t\t}\n\t\tif (CoreType.isArray(value)) {\n\t\t\treturn this.numeric_array(value);\n\t\t}\n\t\t// and if it is a vector\n\t\tif (\n\t\t\tvalue instanceof Vector2 ||\n\t\t\tvalue instanceof Vector3 ||\n\t\t\tvalue instanceof Vector4 ||\n\t\t\tvalue instanceof Color\n\t\t) {\n\t\t\treturn this.numeric_array(value.toArray());\n\t\t}\n\t\treturn `ThreeToGl error: unknown value type '${value}'`;\n\t}\n\tstatic numeric_array(values: number[]): string {\n\t\tconst values_str = new Array(values.length);\n\t\tfor (let i = 0; i < values.length; i++) {\n\t\t\tvalues_str[i] = `${CoreString.ensureFloat(values[i])}`;\n\t\t}\n\t\tconst gl_type = `vec${values.length}`;\n\t\treturn `${gl_type}(${values_str.join(', ')})`;\n\t}\n\tstatic vector4(vec: Vector4 | string): string {\n\t\tif (CoreType.isString(vec)) {\n\t\t\treturn vec;\n\t\t}\n\t\tconst values = vec.toArray().map((v) => {\n\t\t\treturn `${CoreString.ensureFloat(v)}`;\n\t\t});\n\t\treturn `vec4(${values.join(', ')})`;\n\t}\n\tstatic vector3(vec: Vector3 | string): string {\n\t\tif (CoreType.isString(vec)) {\n\t\t\treturn vec;\n\t\t}\n\t\tconst values = vec.toArray().map((v) => {\n\t\t\treturn `${CoreString.ensureFloat(v)}`;\n\t\t});\n\t\treturn `vec3(${values.join(', ')})`;\n\t}\n\tstatic vector2(vec: Vector2 | string): string {\n\t\tif (CoreType.isString(vec)) {\n\t\t\treturn vec;\n\t\t}\n\t\tconst values = vec.toArray().map((v) => {\n\t\t\treturn `${CoreString.ensureFloat(v)}`;\n\t\t});\n\t\treturn `vec2(${values.join(', ')})`;\n\t}\n\n\tstatic vector3_float(vec: Vector3 | string, num: number | string): string {\n\t\tif (!CoreType.isString(num)) {\n\t\t\tnum = CoreString.ensureFloat(num);\n\t\t}\n\t\treturn `vec4(${this.vector3(vec)}, ${num})`;\n\t}\n\n\tstatic float4(x: number | string, y: number | string, z: number | string, w: number | string) {\n\t\tif (!CoreType.isString(x)) {\n\t\t\tx = CoreString.ensureFloat(x);\n\t\t}\n\t\tif (!CoreType.isString(y)) {\n\t\t\ty = CoreString.ensureFloat(y);\n\t\t}\n\t\tif (!CoreType.isString(z)) {\n\t\t\tz = CoreString.ensureFloat(z);\n\t\t}\n\t\tif (!CoreType.isString(w)) {\n\t\t\tw = CoreString.ensureFloat(w);\n\t\t}\n\t\treturn `vec4(${x}, ${y}, ${z}, ${w})`;\n\t}\n\tstatic float3(x: number | string, y: number | string, z: number | string) {\n\t\tif (!CoreType.isString(x)) {\n\t\t\tx = CoreString.ensureFloat(x);\n\t\t}\n\t\tif (!CoreType.isString(y)) {\n\t\t\ty = CoreString.ensureFloat(y);\n\t\t}\n\t\tif (!CoreType.isString(z)) {\n\t\t\tz = CoreString.ensureFloat(z);\n\t\t}\n\t\treturn `vec3(${x}, ${y}, ${z})`;\n\t}\n\tstatic float2(x: number | string, y: number | string) {\n\t\tif (!CoreType.isString(x)) {\n\t\t\tx = CoreString.ensureFloat(x);\n\t\t}\n\t\tif (!CoreType.isString(y)) {\n\t\t\ty = CoreString.ensureFloat(y);\n\t\t}\n\t\treturn `vec2(${x}, ${y})`;\n\t}\n\tstatic float(x: number | string) {\n\t\tif (!CoreType.isString(x)) {\n\t\t\tx = CoreString.ensureFloat(x);\n\t\t}\n\t\treturn `${x}`;\n\t}\n\tstatic int(x: number | string) {\n\t\treturn `${x}`;\n\t}\n\tstatic bool(x: number | string) {\n\t\treturn `${x}`;\n\t}\n}\n","import {TypedNode} from '../_Base';\nimport {ThreeToGl} from '../../../core/ThreeToGl';\nimport {BaseGlShaderAssembler} from './code/assemblers/_Base';\nimport {AssemblerControllerNode} from './code/Controller';\nimport {NodeContext} from '../../poly/NodeContext';\nimport {NodeParamsConfig} from '../utils/params/ParamsConfig';\nimport {ParamConfigsController} from '../utils/code/controllers/ParamConfigsController';\nimport {ShadersCollectionController} from './code/utils/ShadersCollectionController';\nimport {ParamInitValueSerialized} from '../../params/types/ParamInitValueSerialized';\nimport {GlParamConfig} from './code/utils/ParamConfig';\nimport {ParamType} from '../../poly/ParamType';\n\nconst REGEX_PATH_SANITIZE = /\\/+/g;\n\nexport class TypedGlNode<K extends NodeParamsConfig> extends TypedNode<NodeContext.GL, K> {\n\tstatic nodeContext(): NodeContext {\n\t\treturn NodeContext.GL;\n\t}\n\n\tprotected _param_configs_controller: ParamConfigsController<GlParamConfig<ParamType>> | undefined;\n\tprotected _assembler: BaseGlShaderAssembler | undefined;\n\n\tinitializeBaseNode() {\n\t\tthis.uiData.setLayoutHorizontal();\n\t\tthis.io.connections.initInputs();\n\n\t\tthis.io.connection_points.spare_params.initializeNode();\n\t}\n\n\tcook() {\n\t\tconsole.warn('gl nodes should never cook');\n\t}\n\n\tprotected _set_mat_to_recompile() {\n\t\tthis.material_node?.assemblerController?.set_compilation_required_and_dirty(this);\n\t}\n\tget material_node(): AssemblerControllerNode | undefined {\n\t\tconst parent = this.parent();\n\t\tif (parent) {\n\t\t\tif (parent.nodeContext() == NodeContext.GL) {\n\t\t\t\treturn (parent as BaseGlNodeType)?.material_node;\n\t\t\t} else {\n\t\t\t\treturn parent as AssemblerControllerNode;\n\t\t\t}\n\t\t}\n\t}\n\n\t//\n\t//\n\t// VARIABLES\n\t//\n\t//\n\tgl_var_name(name: string) {\n\t\tconst path_sanitized = this.fullPath(this.material_node).replace(REGEX_PATH_SANITIZE, '_');\n\t\treturn `v_POLY_${path_sanitized}_${name}`;\n\t}\n\n\tvariable_for_input(name: string): string {\n\t\tconst input_index = this.io.inputs.get_input_index(name);\n\t\tconst connection = this.io.connections.inputConnection(input_index);\n\t\tif (connection) {\n\t\t\tconst input_node = (<unknown>connection.node_src) as BaseGlNodeType;\n\t\t\tconst output_connection_point =\n\t\t\t\tinput_node.io.outputs.named_output_connection_points[connection.output_index];\n\t\t\tif (output_connection_point) {\n\t\t\t\tconst output_name = output_connection_point.name();\n\t\t\t\treturn input_node.gl_var_name(output_name);\n\t\t\t} else {\n\t\t\t\tconsole.warn(`no output called '${name}' for gl node ${input_node.fullPath()}`);\n\t\t\t\tthrow 'variable_for_input ERROR';\n\t\t\t}\n\t\t} else {\n\t\t\tif (this.params.has(name)) {\n\t\t\t\treturn ThreeToGl.any(this.params.get(name)?.value);\n\t\t\t} else {\n\t\t\t\tconst connection_point = this.io.inputs.named_input_connection_points[input_index];\n\t\t\t\treturn ThreeToGl.any(connection_point.init_value);\n\t\t\t}\n\t\t}\n\t}\n\n\t//\n\t//\n\t// ADDED LINES\n\t//\n\t//\n\tset_lines(shaders_collection_controller: ShadersCollectionController) {}\n\n\treset_code() {\n\t\tthis._param_configs_controller?.reset();\n\t\t// this.reset_lines();\n\t}\n\n\t//\n\t//\n\t// PARAM CONFIGS\n\t//\n\t//\n\tpublic set_param_configs() {}\n\tparam_configs() {\n\t\treturn this._param_configs_controller?.list;\n\t}\n\n\t//\n\t//\n\t// INPUT\n\t//\n\t//\n\tparam_default_value(name: string): ParamInitValueSerialized {\n\t\treturn null;\n\t}\n}\n\nexport type BaseGlNodeType = TypedGlNode<NodeParamsConfig>;\nexport class BaseGlNodeClass extends TypedGlNode<NodeParamsConfig> {}\n\nclass ParamlessParamsConfig extends NodeParamsConfig {}\nconst ParamsConfig = new ParamlessParamsConfig();\nexport class ParamlessTypedGlNode extends TypedGlNode<ParamlessParamsConfig> {\n\tparams_config = ParamsConfig;\n}\n","/**\n * Allows to feed a vertex attribute into the shader\n *\n *\n */\nimport {TypedGlNode, BaseGlNodeType} from './_Base';\nimport {GlConnectionPointType, BaseGlConnectionPoint} from '../utils/io/connections/Gl';\nimport {ShadersCollectionController} from './code/utils/ShadersCollectionController';\n\nexport const ATTRIBUTE_NODE_AVAILABLE_GL_TYPES = [\n\tGlConnectionPointType.FLOAT,\n\tGlConnectionPointType.VEC2,\n\tGlConnectionPointType.VEC3,\n\tGlConnectionPointType.VEC4,\n];\n\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {GlNodeType} from '../../poly/NodeContext';\nclass AttributeGlParamsConfig extends NodeParamsConfig {\n\t/** @param attribute name */\n\tname = ParamConfig.STRING('');\n\t/** @param attribute type (float, vec2, vec3, vec4) */\n\ttype = ParamConfig.INTEGER(0, {\n\t\tmenu: {\n\t\t\tentries: ATTRIBUTE_NODE_AVAILABLE_GL_TYPES.map((name, i) => {\n\t\t\t\treturn {name: name, value: i};\n\t\t\t}),\n\t\t},\n\t});\n\t/** @param allows to export the attribute to a material (when used inside a particles system) */\n\ttexport_when_connected = ParamConfig.BOOLEAN(0, {hidden: true});\n\t/** @param allows to export the attribute to a material (when used inside a particles system) */\n\texport_when_connected = ParamConfig.BOOLEAN(0, {visibleIf: {texport_when_connected: 1}});\n}\nconst ParamsConfig = new AttributeGlParamsConfig();\n\nexport class AttributeGlNode extends TypedGlNode<AttributeGlParamsConfig> {\n\tparams_config = ParamsConfig;\n\tstatic type(): Readonly<GlNodeType.ATTRIBUTE> {\n\t\treturn GlNodeType.ATTRIBUTE;\n\t}\n\tstatic readonly INPUT_NAME = 'in';\n\tstatic readonly OUTPUT_NAME = 'val';\n\n\tprivate _on_create_set_name_if_none_bound = this._on_create_set_name_if_none.bind(this);\n\t// private _update_signature_if_required_bound = this._update_signature_if_required.bind(this);\n\t// public readonly gl_connections_controller: GlConnectionsController = new GlConnectionsController(this);\n\tinitializeNode() {\n\t\tthis.addPostDirtyHook('_set_mat_to_recompile', this._set_mat_to_recompile_if_is_exporting.bind(this));\n\t\tthis.lifecycle.add_on_create_hook(this._on_create_set_name_if_none_bound);\n\t\tthis.io.connection_points.initializeNode();\n\n\t\tthis.io.connection_points.set_expected_input_types_function(() => {\n\t\t\tif (this.material_node?.assemblerController?.allow_attribute_exports()) {\n\t\t\t\treturn [ATTRIBUTE_NODE_AVAILABLE_GL_TYPES[this.pv.type]];\n\t\t\t} else {\n\t\t\t\treturn [];\n\t\t\t}\n\t\t});\n\t\tthis.io.connection_points.set_input_name_function((index: number) => {\n\t\t\treturn AttributeGlNode.INPUT_NAME;\n\t\t});\n\t\tthis.io.connection_points.set_expected_output_types_function(() => [\n\t\t\tATTRIBUTE_NODE_AVAILABLE_GL_TYPES[this.pv.type],\n\t\t]);\n\t\t// this.params.add_on_scene_load_hook('_update_signature_if_required', this._update_signature_if_required_bound);\n\t\t// this.params.set_post_create_params_hook(this._update_signature_if_required_bound);\n\t\t// this.addPostDirtyHook('_update_signature_if_required', this._update_signature_if_required_bound);\n\t\tthis.scene().dispatchController.onAddListener(() => {\n\t\t\tthis.params.onParamsCreated('params_label', () => {\n\t\t\t\tthis.params.label.init([this.p.name, this.p.export_when_connected], () => {\n\t\t\t\t\treturn this.pv.export_when_connected ? `${this.pv.name} (EXPORTED)` : this.pv.name;\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t\tthis.params.addOnSceneLoadHook('prepare params', () => {\n\t\t\tif (this.material_node?.assemblerController?.allow_attribute_exports()) {\n\t\t\t\tthis.p.texport_when_connected.set(1);\n\t\t\t}\n\t\t});\n\t}\n\t// create_params() {}\n\t// inputless_params_names(): string[] {\n\t// \treturn ['type'];\n\t// }\n\n\tget input_name() {\n\t\treturn AttributeGlNode.INPUT_NAME;\n\t}\n\tget output_name() {\n\t\treturn AttributeGlNode.OUTPUT_NAME;\n\t}\n\n\t// private create_inputs_from_params() {\n\t// \tif (this.material_node.allow_attribute_exports) {\n\t// \t\t// this.set_named_inputs([new TypedConnectionFloat(AttributeGlNode.input_name())]);\n\t// \t\tthis.io.inputs.setNamedInputConnectionPoints([\n\t// \t\t\tnew TypedNamedConnectionPoint(INPUT_NAME, ConnectionPointTypes[this.pv.type]),\n\t// \t\t]);\n\t// \t\t// this._init_graph_node_inputs();\n\t// \t}\n\t// }\n\n\tset_lines(shaders_collection_controller: ShadersCollectionController) {\n\t\tthis.material_node?.assemblerController?.assembler.set_node_lines_attribute(\n\t\t\tthis,\n\t\t\tshaders_collection_controller\n\t\t);\n\t}\n\n\t// update_output_type(constructor) {\n\t// \tconst named_output = new constructor(Attribute.output_name());\n\t// \tthis.set_named_outputs([named_output]);\n\t// }\n\t// update_input_type(constructor) {\n\t// \tconst named_input = new constructor(Attribute.input_name());\n\t// \tthis.set_named_inputs([named_input]);\n\t// \tthis._init_graph_node_inputs();\n\t// }\n\n\tget attribute_name(): string {\n\t\treturn this.pv.name.trim();\n\t}\n\tgl_type(): GlConnectionPointType {\n\t\treturn this.io.outputs.named_output_connection_points[0].type();\n\t}\n\tset_gl_type(type: GlConnectionPointType) {\n\t\tthis.p.type.set(ATTRIBUTE_NODE_AVAILABLE_GL_TYPES.indexOf(type));\n\t}\n\t//\n\t//\n\t// Utility methods for SOP/ParticlesSystemGPU and Assembler/Particles\n\t//\n\t//\n\tconnected_input_node(): BaseGlNodeType | null {\n\t\t// if (this.io.inputs.has_named_inputs) {\n\t\treturn this.io.inputs.named_input(AttributeGlNode.INPUT_NAME);\n\t\t// }\n\t}\n\tconnected_input_connection_point(): BaseGlConnectionPoint | undefined {\n\t\treturn this.io.inputs.named_input_connection_point(AttributeGlNode.INPUT_NAME);\n\t}\n\t// connected_input(): NamedConnection {\n\t// \tconst connection_point = this.connected_input_connection_point();\n\t// \tif (connection_point) {\n\t// \t\treturn this.io.inputs.named_inputs().filter((ni) => ni.name() == Attribute.input_name())[0];\n\t// \t}\n\t// }\n\toutput_connection_point(): BaseGlConnectionPoint | undefined {\n\t\t// if (this.io.inputs.has_named_inputs) {\n\t\treturn this.io.outputs.named_output_connection_points_by_name(this.output_name);\n\t\t// }\n\t}\n\t// connected_output(): NamedConnection {\n\t// \tconst output = this.named_output(0);\n\t// \tif (output) {\n\t// \t\treturn output; //this.named_inputs().filter(ni=>ni.name() == Attribute.input_name())[0]\n\t// \t}\n\t// }\n\tget is_importing(): boolean {\n\t\treturn this.io.outputs.used_output_names().length > 0; // TODO: ensure that we can check that the connected outputs are part of the nodes retrieved by the node traverser\n\t}\n\tget is_exporting(): boolean {\n\t\tif (this.pv.export_when_connected) {\n\t\t\tconst input_node = this.io.inputs.named_input(AttributeGlNode.INPUT_NAME);\n\t\t\treturn input_node != null;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\tprivate _set_mat_to_recompile_if_is_exporting() {\n\t\tif (this.is_exporting) {\n\t\t\tthis._set_mat_to_recompile();\n\t\t}\n\t}\n\t//\n\t//\n\t// HOOKS\n\t//\n\t//\n\tprivate _on_create_set_name_if_none() {\n\t\tif (this.pv.name == '') {\n\t\t\tthis.p.name.set(this.name());\n\t\t}\n\t}\n\n\t//\n\t//\n\t// SIGNATURE\n\t//\n\t//\n\t// private _update_signature_if_required(dirty_trigger?: CoreGraphNode) {\n\t// \tif (!this.lifecycle.creation_completed || dirty_trigger == this.p.type) {\n\t// \t\tthis.update_input_and_output_types();\n\t// \t\tthis.removeDirtyState();\n\t// \t\tthis.make_output_nodes_dirty();\n\t// \t}\n\t// \tthis.material_node?.assembler_controller.set_compilation_required_and_dirty(this);\n\t// }\n\t// private update_input_and_output_types() {\n\t// \tconst set_dirty = false;\n\t// \tthis.io.outputs.setNamedOutputConnectionPoints(\n\t// \t\t[new TypedNamedConnectionPoint(this.output_name, ConnectionPointTypesAvailableForAttribute[this.pv.type])],\n\t// \t\tset_dirty\n\t// \t);\n\t// \tif (this.material_node?.assembler_controller.allow_attribute_exports()) {\n\t// \t\tthis.io.inputs.setNamedInputConnectionPoints([\n\t// \t\t\tnew TypedNamedConnectionPoint(this.input_name, ConnectionPointTypesAvailableForAttribute[this.pv.type]),\n\t// \t\t]);\n\t// \t}\n\t// }\n}\n","import {TypedGLDefinition, GLDefinitionType} from './GLDefinition';\n\nexport class TypedGLDefinitionCollection<T extends GLDefinitionType> {\n\t_errored: boolean = false;\n\t_error_message: string | undefined;\n\n\tconstructor(private _definitions: TypedGLDefinition<T>[] = []) {}\n\n\tget errored() {\n\t\treturn this._errored;\n\t}\n\tget error_message() {\n\t\treturn this._error_message;\n\t}\n\n\tuniq(): TypedGLDefinition<T>[] {\n\t\tconst definitions_by_name: Map<string, TypedGLDefinition<T>> = new Map();\n\t\tconst names: string[] = [];\n\n\t\tfor (let definition of this._definitions) {\n\t\t\tif (!this._errored) {\n\t\t\t\tconst name = definition.name();\n\t\t\t\tconst existing = definitions_by_name.get(name);\n\t\t\t\tif (existing) {\n\t\t\t\t\tif (existing.data_type != definition.data_type) {\n\t\t\t\t\t\tthis._errored = true;\n\t\t\t\t\t\tthis._error_message = `attempt to create '${definition.name()}' with types '${\n\t\t\t\t\t\t\tdefinition.data_type\n\t\t\t\t\t\t}' by node '${definition.node.fullPath()}', when there is already an existing with type ${\n\t\t\t\t\t\t\texisting.data_type\n\t\t\t\t\t\t} from node '${existing.node.fullPath()}'`;\n\t\t\t\t\t\tconsole.warn('emitting error message:', this._error_message);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tdefinitions_by_name.set(name, definition);\n\t\t\t\t\tnames.push(name);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst uniq_definitions: TypedGLDefinition<T>[] = [];\n\t\tfor (let name of names) {\n\t\t\tconst definition = definitions_by_name.get(name);\n\t\t\tif (definition) {\n\t\t\t\tuniq_definitions.push(definition);\n\t\t\t}\n\t\t}\n\t\t// sorting may make dependencies be declared after the function calling them\n\t\t// const sorted_definitions = lodash_sortBy(uniq_definitions, (d)=>d.name())\n\t\treturn uniq_definitions;\n\t}\n}\n","import {BaseGlNodeType} from '../_Base';\nimport {TypedGLDefinitionCollection} from './GLDefinitionCollection';\nimport {GlConnectionPointType} from '../../utils/io/connections/Gl';\n\nexport enum GLDefinitionType {\n\tATTRIBUTE = 'attribute',\n\tFUNCTION = 'function',\n\tUNIFORM = 'uniform',\n\tVARYING = 'varying',\n}\n\nexport abstract class TypedGLDefinition<T extends GLDefinitionType> {\n\t// constructor(protected _node: BaseGlNodeType, protected _name: string) {}\n\tconstructor(\n\t\tprotected _definition_type: T,\n\t\tprotected _data_type: GlConnectionPointType,\n\t\tprotected _node: BaseGlNodeType,\n\t\tprotected _name: string\n\t) {\n\t\t// super(_node, _name);\n\t}\n\n\tget definition_type() {\n\t\treturn this._definition_type;\n\t}\n\tget data_type() {\n\t\treturn this._data_type;\n\t}\n\tget node() {\n\t\treturn this._node;\n\t}\n\tname() {\n\t\treturn this._name;\n\t}\n\t// get id() {\n\t// \treturn this._data_type;\n\t// }\n\n\tabstract get line(): string;\n\tcollection_instance() {\n\t\treturn new TypedGLDefinitionCollection<T>();\n\t}\n}\n\nexport class AttributeGLDefinition extends TypedGLDefinition<GLDefinitionType.ATTRIBUTE> {\n\tconstructor(protected _node: BaseGlNodeType, protected _data_type: GlConnectionPointType, protected _name: string) {\n\t\tsuper(GLDefinitionType.ATTRIBUTE, _data_type, _node, _name);\n\t}\n\tget line() {\n\t\treturn `attribute ${this.data_type} ${this.name()}`;\n\t}\n}\n\nexport class FunctionGLDefinition extends TypedGLDefinition<GLDefinitionType.FUNCTION> {\n\tconstructor(protected _node: BaseGlNodeType, protected _name: string) {\n\t\tsuper(GLDefinitionType.FUNCTION, GlConnectionPointType.FLOAT, _node, _name);\n\t}\n\tget line() {\n\t\treturn this.name();\n\t}\n}\n\nexport class UniformGLDefinition extends TypedGLDefinition<GLDefinitionType.UNIFORM> {\n\tconstructor(protected _node: BaseGlNodeType, protected _data_type: GlConnectionPointType, protected _name: string) {\n\t\tsuper(GLDefinitionType.UNIFORM, _data_type, _node, _name);\n\t}\n\tget line() {\n\t\treturn `uniform ${this.data_type} ${this.name()}`;\n\t}\n}\n\nexport class VaryingGLDefinition extends TypedGLDefinition<GLDefinitionType.VARYING> {\n\tconstructor(protected _node: BaseGlNodeType, protected _data_type: GlConnectionPointType, protected _name: string) {\n\t\tsuper(GLDefinitionType.VARYING, _data_type, _node, _name);\n\t}\n\tget line() {\n\t\treturn `varying ${this.data_type} ${this.name()}`;\n\t}\n}\nexport type BaseGLDefinition = TypedGLDefinition<GLDefinitionType>;\n","export enum ShaderName {\n\tVERTEX = 'vertex',\n\tFRAGMENT = 'fragment',\n\tLEAVES_FROM_NODES_SHADER = 'leaves_from_nodes_shader',\n\tPARTICLES_0 = 'particles_0',\n\tPARTICLES_1 = 'particles_1',\n\tPARTICLES_2 = 'particles_2',\n\tPARTICLES_3 = 'particles_3',\n\tPARTICLES_4 = 'particles_4',\n\tPARTICLES_5 = 'particles_5',\n\tPARTICLES_6 = 'particles_6',\n\tPARTICLES_7 = 'particles_7',\n\tPARTICLES_8 = 'particles_8',\n\tPARTICLES_9 = 'particles_9',\n}\nexport const ParticleShaderNames: Array<ShaderName> = [\n\tShaderName.PARTICLES_0,\n\tShaderName.PARTICLES_1,\n\tShaderName.PARTICLES_2,\n\tShaderName.PARTICLES_3,\n\tShaderName.PARTICLES_4,\n\tShaderName.PARTICLES_5,\n\tShaderName.PARTICLES_6,\n\tShaderName.PARTICLES_7,\n\tShaderName.PARTICLES_8,\n\tShaderName.PARTICLES_9,\n];\n","import {GlobalsBaseController} from './_Base';\nimport {GlobalsGlNode} from '../../Globals';\nimport {AttributeGlNode} from '../../Attribute';\n// import {Definition} from '../../Definition/_Module';\n// import {DefinitionBaseConfig} from '../Config/DefinitionBaseConfig';\n// import {BaseGlNodeType} from '../../_Base';\nimport {VaryingGLDefinition, AttributeGLDefinition} from '../../utils/GLDefinition';\nimport {GlConnectionPointType} from '../../../utils/io/connections/Gl';\n// import {TypeAssert} from '../../../../poly/Assert';\nimport {MapUtils} from '../../../../../core/MapUtils';\nimport {ShaderName} from '../../../utils/shaders/ShaderName';\nimport {BaseGlNodeType} from '../../_Base';\nimport {ShadersCollectionController} from '../utils/ShadersCollectionController';\nimport {PolyDictionary} from '../../../../../types/GlobalTypes';\n\nconst VARIABLE_CONFIG_DEFAULT_BY_NAME: PolyDictionary<string> = {\n\tposition: 'vec3( position )',\n};\n\nexport class GlobalsGeometryHandler extends GlobalsBaseController {\n\tstatic PRE_DEFINED_ATTRIBUTES = [\n\t\t'position',\n\t\t'color',\n\t\t'normal',\n\t\t'uv',\n\t\t'uv2',\n\t\t'morphTarget0',\n\t\t'morphTarget1',\n\t\t'morphTarget2',\n\t\t'morphTarget3',\n\t\t'skinIndex',\n\t\t'skinWeight',\n\t];\n\n\tstatic IF_RULE = {\n\t\tuv:\n\t\t\t'defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )',\n\t};\n\n\thandle_globals_node(\n\t\tglobals_node: GlobalsGlNode,\n\t\toutput_name: string,\n\t\tshaders_collection_controller: ShadersCollectionController\n\t\t// definitions_by_shader_name: Map<ShaderName, BaseGLDefinition[]>,\n\t\t// body_lines_by_shader_name: Map<ShaderName, string[]>,\n\t\t// body_lines: string[],\n\t\t// dependencies: ShaderName[],\n\t\t// shader_name: ShaderName\n\t): void {\n\t\tconst connection_point = globals_node.io.outputs.named_output_connection_points_by_name(output_name);\n\t\tif (!connection_point) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst var_name = globals_node.gl_var_name(output_name);\n\t\tconst gl_type = connection_point.type();\n\t\tconst definition = new VaryingGLDefinition(globals_node, gl_type, var_name);\n\n\t\t// MapUtils.push_on_array_at_entry(definitions_by_shader_name, shader_name, definition);\n\t\tshaders_collection_controller.add_definitions(globals_node, [definition]);\n\t\t// definitions_by_shader_name.get(shader_name)!.push(definition);\n\t\tconst assembler = globals_node.material_node?.assemblerController?.assembler;\n\t\tif (!assembler) {\n\t\t\treturn;\n\t\t}\n\t\tconst shader_config = assembler.shader_config(shaders_collection_controller.current_shader_name);\n\t\tif (!shader_config) {\n\t\t\treturn;\n\t\t}\n\t\tconst dependencies = shader_config.dependencies();\n\n\t\tconst body_line = `${var_name} = ${gl_type}(${output_name})`;\n\t\tfor (let dependency of dependencies) {\n\t\t\t// MapUtils.push_on_array_at_entry(definitions_by_shader_name, dependency, definition);\n\t\t\t// MapUtils.push_on_array_at_entry(body_lines_by_shader_name, dependency, body_line);\n\t\t\tshaders_collection_controller.add_definitions(globals_node, [definition], dependency);\n\t\t\tshaders_collection_controller.add_body_lines(globals_node, [body_line], dependency);\n\t\t}\n\t\tif (dependencies.length == 0) {\n\t\t\t// body_lines.push(body_line);\n\t\t\tshaders_collection_controller.add_body_lines(globals_node, [body_line]);\n\t\t}\n\t}\n\n\tstatic variable_config_default(variable_name: string): string | undefined {\n\t\treturn VARIABLE_CONFIG_DEFAULT_BY_NAME[variable_name];\n\t}\n\tvariable_config_default(variable_name: string): string | undefined {\n\t\treturn GlobalsGeometryHandler.variable_config_default(variable_name);\n\t}\n\t// variable_config_required_definitions(variable_name:string):DefinitionBaseConfig[]{\n\t// \treturn null\n\t// }\n\tread_attribute(\n\t\tnode: BaseGlNodeType,\n\t\tgl_type: GlConnectionPointType,\n\t\tattrib_name: string,\n\t\tshaders_collection_controller: ShadersCollectionController\n\t) {\n\t\treturn GlobalsGeometryHandler.read_attribute(node, gl_type, attrib_name, shaders_collection_controller);\n\t}\n\n\tstatic read_attribute(\n\t\tnode: BaseGlNodeType,\n\t\tgl_type: GlConnectionPointType,\n\t\tattrib_name: string,\n\t\tshaders_collection_controller: ShadersCollectionController\n\t): string | undefined {\n\t\tif (GlobalsGeometryHandler.PRE_DEFINED_ATTRIBUTES.indexOf(attrib_name) < 0) {\n\t\t\tshaders_collection_controller.add_definitions(\n\t\t\t\tnode,\n\t\t\t\t[new AttributeGLDefinition(node, gl_type, attrib_name)],\n\t\t\t\tShaderName.VERTEX\n\t\t\t);\n\t\t} else {\n\t\t\t// const if_rule = GlobalsGeometryHandler.IF_RULE[attrib_name]\n\t\t\t// if(if_rule){\n\t\t\t// \tconst definition = new Definition.Attribute(node, gl_type, attrib_name)\n\t\t\t// \tdefinition.set_if_rule(if_rule)\n\t\t\t// \tnode.add_definitions([definition])\n\t\t\t// }\n\t\t}\n\n\t\t// if (!shader_name) {\n\t\t// \tthrow 'no shader name';\n\t\t// }\n\t\tconst shader_name = shaders_collection_controller.current_shader_name;\n\t\tswitch (shader_name) {\n\t\t\tcase ShaderName.VERTEX: {\n\t\t\t\treturn attrib_name;\n\t\t\t}\n\t\t\tcase ShaderName.FRAGMENT: {\n\t\t\t\t// let's assume it can only be an attribute gl node\n\t\t\t\tif (!(node instanceof AttributeGlNode)) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tconst var_name = 'varying_' + node.gl_var_name(node.output_name);\n\t\t\t\tconst varying_definition = new VaryingGLDefinition(node, gl_type, var_name);\n\n\t\t\t\tconst definitions_by_shader_name: Map<ShaderName, VaryingGLDefinition[]> = new Map();\n\t\t\t\t// definitions_by_shader_name.set(ShaderName.VERTEX, [])\n\t\t\t\tdefinitions_by_shader_name.set(ShaderName.FRAGMENT, []);\n\t\t\t\t// {\n\t\t\t\t// \t[ShaderName.VERTEX]: [],\n\t\t\t\t// \t[ShaderName.FRAGMENT]: [],\n\t\t\t\t// };\n\t\t\t\tconst body_lines_by_shader_name: Map<ShaderName, string[]> = new Map();\n\t\t\t\t// body_lines_by_shader_name.set(ShaderName.VERTEX, [])\n\t\t\t\tbody_lines_by_shader_name.set(ShaderName.FRAGMENT, []);\n\t\t\t\tMapUtils.push_on_array_at_entry(definitions_by_shader_name, shader_name, varying_definition);\n\n\t\t\t\tconst set_varying_body_line = `${var_name} = ${gl_type}(${attrib_name})`;\n\n\t\t\t\tconst shader_config = node.material_node?.assemblerController?.assembler.shader_config(shader_name);\n\t\t\t\tif (shader_config) {\n\t\t\t\t\tconst dependencies = shader_config.dependencies();\n\t\t\t\t\tfor (let dependency of dependencies) {\n\t\t\t\t\t\tMapUtils.push_on_array_at_entry(definitions_by_shader_name, dependency, varying_definition);\n\t\t\t\t\t\tMapUtils.push_on_array_at_entry(body_lines_by_shader_name, dependency, set_varying_body_line);\n\t\t\t\t\t}\n\t\t\t\t\tdefinitions_by_shader_name.forEach((definitions, shader_name) => {\n\t\t\t\t\t\tshaders_collection_controller.add_definitions(node, definitions, shader_name);\n\t\t\t\t\t});\n\t\t\t\t\tbody_lines_by_shader_name.forEach((body_lines, shader_name) => {\n\t\t\t\t\t\tshaders_collection_controller.add_body_lines(node, body_lines, shader_name);\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\treturn var_name;\n\t\t\t}\n\t\t}\n\t\t// TypeAssert.unreachable(shader_name);\n\n\t\t// const shader_name = node._shader_name // TODO: this is hack\n\t\t// const varying_definition = new Definition.Varying(node, gl_type, attrib_name)\n\t\t// const var_name = varying_definition.name()\n\t\t// definitions_by_shader_name[shader_name].push(varying_definition)\n\t\t// const shader_config = node.shader_config(shader_name)\n\t\t// const dependencies = shader_config.dependencies()\n\t\t// const body_line = `${var_name} = ${gl_type}(${attrib_name})`\n\t\t// for(let dependency of dependencies){\n\t\t// \tdefinitions_by_shader_name[dependency].push(varying_definition)\n\t\t// \tbody_lines_by_shader_name[dependency].push(body_line)\n\t\t// }\n\t\t// // if(dependencies.length == 0){\n\t\t// \t// body_lines.push(body_line)\n\t\t// \tnode.add_body_lines([body_line])\n\t\t// // }\n\t\t// for(let shader_name of Object.keys(definitions_by_shader_name)){\n\t\t// \tnode.add_definitions(definitions_by_shader_name[shader_name], shader_name)\n\t\t// }\n\t\t// for(let shader_name of Object.keys(body_lines_by_shader_name)){\n\t\t// \tnode.add_body_lines(body_lines_by_shader_name[shader_name], shader_name)\n\t\t// }\n\t\t// node.add_body_lines(body_lines)\n\t}\n\thandle_attribute_node(\n\t\tnode: AttributeGlNode,\n\t\tgl_type: GlConnectionPointType,\n\t\tattrib_name: string,\n\t\tshaders_collection_controller: ShadersCollectionController\n\t) {\n\t\treturn GlobalsGeometryHandler.read_attribute(node, gl_type, attrib_name, shaders_collection_controller);\n\t}\n}\n","import {AttribValue} from '../../../types/GlobalTypes';\nimport {CoreGraphNode} from '../../../core/graph/CoreGraphNode';\nimport {PolyScene} from '../../scene/PolyScene';\n\nexport class BaseCopyStamp extends CoreGraphNode {\n\tprotected _global_index: number = 0;\n\n\tconstructor(scene: PolyScene) {\n\t\tsuper(scene, 'CopyStamp');\n\t}\n\n\tset_global_index(index: number) {\n\t\tthis._global_index = index;\n\t\tthis.setDirty();\n\t\tthis.removeDirtyState();\n\t}\n\n\tvalue(attrib_name?: string): AttribValue {\n\t\treturn this._global_index;\n\t}\n}\n","import {BaseCopyStamp} from '../../utils/CopyStamp';\nimport {CorePoint} from '../../../../core/geometry/Point';\n\nexport class CopyStamp extends BaseCopyStamp {\n\tprotected _point: CorePoint | undefined;\n\n\tset_point(point: CorePoint) {\n\t\tthis._point = point;\n\t\tthis.setDirty();\n\t\tthis.removeDirtyState();\n\t}\n\n\tvalue(attrib_name?: string) {\n\t\tif (this._point) {\n\t\t\tif (attrib_name) {\n\t\t\t\treturn this._point.attribValue(attrib_name);\n\t\t\t} else {\n\t\t\t\treturn this._point.index();\n\t\t\t}\n\t\t} else {\n\t\t\treturn this._global_index;\n\t\t}\n\t}\n}\n","/**\n * Copies a geometry onto every point from the right input.\n *\n * @remarks\n * This is different than the instance SOP, as the operation here is more expensive, but allows for more flexibility.\n *\n *\n */\n\nimport {TypedSopNode} from './_Base';\nimport {CoreGroup, Object3DWithGeometry} from '../../../core/geometry/Group';\nimport {CoreObject} from '../../../core/geometry/Object';\nimport {CoreInstancer} from '../../../core/geometry/Instancer';\nimport {CoreString} from '../../../core/String';\nimport {CopyStamp} from './utils/CopyStamp';\nimport {Matrix4} from 'three/src/math/Matrix4';\nimport {CorePoint} from '../../../core/geometry/Point';\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {InputCloneMode} from '../../poly/InputCloneMode';\nimport {Object3D} from 'three/src/core/Object3D';\nimport {Vector3} from 'three/src/math/Vector3';\nimport {Quaternion} from 'three/src/math/Quaternion';\nimport {ArrayUtils} from '../../../core/ArrayUtils';\nimport {TypeAssert} from '../../poly/Assert';\nimport {isBooleanTrue} from '../../../core/BooleanValue';\n\nenum TransformMode {\n\tOBJECT = 0,\n\tGEOMETRY = 1,\n}\nconst TRANSFORM_MODES: TransformMode[] = [TransformMode.OBJECT, TransformMode.GEOMETRY];\nconst TransformModeMenuEntries = [\n\t{name: 'object', value: TransformMode.OBJECT},\n\t{name: 'geometry', value: TransformMode.GEOMETRY},\n];\nclass CopySopParamsConfig extends NodeParamsConfig {\n\t/** @param copies count, used when the second input is not given */\n\tcount = ParamConfig.INTEGER(1, {\n\t\trange: [1, 20],\n\t\trangeLocked: [true, false],\n\t});\n\t/** @param transforms every input object each on a single input point */\n\ttransformOnly = ParamConfig.BOOLEAN(0);\n\t/** @param defines if the objects or the geometries are transformed */\n\ttransformMode = ParamConfig.INTEGER(0, {\n\t\tmenu: {\n\t\t\tentries: TransformModeMenuEntries,\n\t\t},\n\t});\n\t/** @param toggles on to copy attributes from the input points to the created objects. Note that the vertex attributes from the points become object attributes */\n\tcopyAttributes = ParamConfig.BOOLEAN(0);\n\t/** @param names of attributes to copy */\n\tattributesToCopy = ParamConfig.STRING('', {\n\t\tvisibleIf: {copyAttributes: true},\n\t});\n\t/** @param toggle on to use the `copy` expression, which allows to change how the left input is evaluated for each point */\n\tuseCopyExpr = ParamConfig.BOOLEAN(0);\n}\nconst ParamsConfig = new CopySopParamsConfig();\n\nexport class CopySopNode extends TypedSopNode<CopySopParamsConfig> {\n\tparams_config = ParamsConfig;\n\tstatic type() {\n\t\treturn 'copy';\n\t}\n\n\tprivate _attribute_names_to_copy: string[] = [];\n\tprivate _objects: Object3D[] = [];\n\tprivate _stamp_node!: CopyStamp;\n\n\tstatic displayedInputNames(): string[] {\n\t\treturn ['geometry to be copied', 'points to copy to'];\n\t}\n\n\tinitializeNode() {\n\t\tthis.io.inputs.setCount(1, 2);\n\t\tthis.io.inputs.initInputsClonedState([InputCloneMode.ALWAYS, InputCloneMode.NEVER]);\n\t}\n\n\tasync cook(input_contents: CoreGroup[]) {\n\t\tconst core_group0 = input_contents[0];\n\t\tif (!this.io.inputs.has_input(1)) {\n\t\t\tawait this.cook_without_template(core_group0);\n\t\t\treturn;\n\t\t}\n\n\t\tconst core_group1 = input_contents[1];\n\t\tif (!core_group1) {\n\t\t\tthis.states.error.set('second input invalid');\n\t\t\treturn;\n\t\t}\n\t\tawait this.cook_with_template(core_group0, core_group1);\n\t}\n\n\tprivate async cook_with_template(instance_core_group: CoreGroup, template_core_group: CoreGroup) {\n\t\tthis._objects = [];\n\n\t\tconst template_points = template_core_group.points();\n\n\t\tconst instancer = new CoreInstancer(template_core_group);\n\t\tlet instance_matrices = instancer.matrices();\n\t\tconst t = new Vector3();\n\t\tconst q = new Quaternion();\n\t\tconst s = new Vector3();\n\t\tinstance_matrices[0].decompose(t, q, s);\n\n\t\tthis._attribute_names_to_copy = CoreString.attribNames(this.pv.attributesToCopy).filter((attrib_name) =>\n\t\t\ttemplate_core_group.hasAttrib(attrib_name)\n\t\t);\n\t\tawait this._copy_moved_objects_on_template_points(instance_core_group, instance_matrices, template_points);\n\t\tthis.setObjects(this._objects);\n\t}\n\n\t// https://stackoverflow.com/questions/24586110/resolve-promises-one-after-another-i-e-in-sequence\n\tprivate async _copy_moved_objects_on_template_points(\n\t\tinstance_core_group: CoreGroup,\n\t\tinstance_matrices: Matrix4[],\n\t\ttemplate_points: CorePoint[]\n\t) {\n\t\tfor (let point_index = 0; point_index < template_points.length; point_index++) {\n\t\t\tawait this._copy_moved_object_on_template_point(\n\t\t\t\tinstance_core_group,\n\t\t\t\tinstance_matrices,\n\t\t\t\ttemplate_points,\n\t\t\t\tpoint_index\n\t\t\t);\n\t\t}\n\t}\n\n\tprivate async _copy_moved_object_on_template_point(\n\t\tinstance_core_group: CoreGroup,\n\t\tinstance_matrices: Matrix4[],\n\t\ttemplate_points: CorePoint[],\n\t\tpoint_index: number\n\t) {\n\t\tconst matrix = instance_matrices[point_index];\n\t\tconst template_point = template_points[point_index];\n\t\tthis.stamp_node.set_point(template_point);\n\n\t\tconst moved_objects = await this._get_moved_objects_for_template_point(instance_core_group, point_index);\n\n\t\tfor (let moved_object of moved_objects) {\n\t\t\tif (isBooleanTrue(this.pv.copyAttributes)) {\n\t\t\t\tthis._copyAttributes_from_template(moved_object, template_point);\n\t\t\t}\n\n\t\t\t// TODO: that node is getting inconsistent...\n\t\t\t// should I always only move the object?\n\t\t\t// and have a toggle to bake back to the geo?\n\t\t\t// or just enfore the use of a merge?\n\t\t\tif (isBooleanTrue(this.pv.transformOnly)) {\n\t\t\t\tmoved_object.applyMatrix4(matrix);\n\t\t\t} else {\n\t\t\t\tthis._apply_matrix_to_object_or_geometry(moved_object, matrix);\n\t\t\t}\n\n\t\t\tthis._objects.push(moved_object);\n\t\t}\n\t}\n\n\tprivate _apply_matrix_to_object_or_geometry(object: Object3D, matrix: Matrix4) {\n\t\tconst transformMode = TRANSFORM_MODES[this.pv.transformMode];\n\t\tswitch (transformMode) {\n\t\t\tcase TransformMode.OBJECT: {\n\t\t\t\tthis._apply_matrix_to_object(object, matrix);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tcase TransformMode.GEOMETRY: {\n\t\t\t\tconst geometry = (object as Object3DWithGeometry).geometry;\n\t\t\t\tif (geometry) {\n\t\t\t\t\tgeometry.applyMatrix4(matrix);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tTypeAssert.unreachable(transformMode);\n\t}\n\n\tprivate _object_position = new Vector3();\n\tprivate _apply_matrix_to_object(object: Object3D, matrix: Matrix4) {\n\t\t// center to origin\n\t\tthis._object_position.copy(object.position);\n\t\tobject.position.multiplyScalar(0);\n\t\tobject.updateMatrix();\n\t\t// apply matrix\n\t\tobject.applyMatrix4(matrix);\n\t\t// revert to position\n\t\tobject.position.add(this._object_position);\n\t\tobject.updateMatrix();\n\t}\n\n\tprivate async _get_moved_objects_for_template_point(\n\t\tinstance_core_group: CoreGroup,\n\t\tpoint_index: number\n\t): Promise<Object3D[]> {\n\t\tconst stamped_instance_core_group = await this._stamp_instance_group_if_required(instance_core_group);\n\t\tif (stamped_instance_core_group) {\n\t\t\t// duplicate or select from instance children\n\t\t\tconst moved_objects = isBooleanTrue(this.pv.transformOnly)\n\t\t\t\t? // TODO: why is doing a transform slower than cloning the input??\n\t\t\t\t  ArrayUtils.compact([stamped_instance_core_group.objects()[point_index]])\n\t\t\t\t: stamped_instance_core_group.clone().objects();\n\n\t\t\treturn moved_objects;\n\t\t} else {\n\t\t\treturn [];\n\t\t}\n\t}\n\n\tprivate async _stamp_instance_group_if_required(instance_core_group: CoreGroup): Promise<CoreGroup | undefined> {\n\t\tif (isBooleanTrue(this.pv.useCopyExpr)) {\n\t\t\tconst container0 = await this.containerController.requestInputContainer(0);\n\t\t\tif (container0) {\n\t\t\t\tconst core_group0 = container0.coreContent();\n\t\t\t\tif (core_group0) {\n\t\t\t\t\treturn core_group0;\n\t\t\t\t} else {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.states.error.set(`input failed for index ${this.stamp_value()}`);\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else {\n\t\t\treturn instance_core_group;\n\t\t}\n\t}\n\n\tprivate async _copy_moved_objects_for_each_instance(instance_core_group: CoreGroup) {\n\t\tfor (let i = 0; i < this.pv.count; i++) {\n\t\t\tawait this._copy_moved_objects_for_instance(instance_core_group, i);\n\t\t}\n\t}\n\n\tprivate async _copy_moved_objects_for_instance(instance_core_group: CoreGroup, i: number) {\n\t\tthis.stamp_node.set_global_index(i);\n\n\t\tconst stamped_instance_core_group = await this._stamp_instance_group_if_required(instance_core_group);\n\t\tif (stamped_instance_core_group) {\n\t\t\tstamped_instance_core_group.objects().forEach((object) => {\n\t\t\t\t// TODO: I should use the Core Group, to ensure that material.linewidth is properly cloned\n\t\t\t\tconst new_object = CoreObject.clone(object);\n\t\t\t\tthis._objects.push(new_object);\n\t\t\t});\n\t\t}\n\t}\n\n\t// TODO: what if I combine both param_count and stamping?!\n\tprivate async cook_without_template(instance_core_group: CoreGroup) {\n\t\tthis._objects = [];\n\t\tawait this._copy_moved_objects_for_each_instance(instance_core_group);\n\n\t\tthis.setObjects(this._objects);\n\t}\n\n\tprivate _copyAttributes_from_template(object: Object3D, template_point: CorePoint) {\n\t\tthis._attribute_names_to_copy.forEach((attrib_name, i) => {\n\t\t\tconst attrib_value = template_point.attribValue(attrib_name);\n\t\t\tconst object_wrapper = new CoreObject(object, i);\n\t\t\tobject_wrapper.addAttribute(attrib_name, attrib_value);\n\t\t});\n\t}\n\n\t//\n\t//\n\t// STAMP\n\t//\n\t//\n\tstamp_value(attrib_name?: string) {\n\t\treturn this.stamp_node.value(attrib_name);\n\t}\n\tget stamp_node() {\n\t\treturn (this._stamp_node = this._stamp_node || this.create_stamp_node());\n\t}\n\tprivate create_stamp_node() {\n\t\tconst stamp_node = new CopyStamp(this.scene());\n\t\tthis.dirtyController.set_forbidden_trigger_nodes([stamp_node]);\n\t\treturn stamp_node;\n\t}\n\tdispose() {\n\t\tsuper.dispose();\n\t\tif (this._stamp_node) {\n\t\t\tthis._stamp_node.dispose();\n\t\t}\n\t}\n\n\t// private set_dirty_allowed(original_trigger_graph_node: CoreGraphNode): boolean {\n\t// \treturn original_trigger_graph_node.graphNodeId() !== this.stamp_node.graphNodeId();\n\t// }\n}\n","import {Matrix4} from 'three/src/math/Matrix4';\nimport {Object3D} from 'three/src/core/Object3D';\nimport {Vector3} from 'three/src/math/Vector3';\n\nimport {CSS2DObject} from '../objects/CSS2DObject';\nimport {Scene} from 'three/src/scenes/Scene';\nimport {Camera} from 'three/src/cameras/Camera';\nimport {CoreMath} from '../../../core/math/_Module';\n\n// converted from threejs CSS2Drenderer https://github.com/mrdoob/three.js/blob/dev/examples/jsm/renderers/CSS2DRenderer.js\n// original @author mrdoob / http://mrdoob.com/\nexport class CSS2DRenderer {\n\tprivate _width: number = 0;\n\tprivate _height: number = 0;\n\tprivate _widthHalf: number = 0;\n\tprivate _heightHalf: number = 0;\n\n\tprivate vector = new Vector3();\n\tprivate viewMatrix = new Matrix4();\n\tprivate viewProjectionMatrix = new Matrix4();\n\tprivate cache_distanceToCameraSquared: WeakMap<Object3D, number> = new WeakMap();\n\tpublic readonly domElement = document.createElement('div');\n\tprivate _sort_objects: boolean = false;\n\n\t// fog\n\tprivate _use_fog = false;\n\tprivate _fog_near = 1;\n\tprivate _fog_far = 100;\n\n\tconstructor() {\n\t\tthis.domElement.classList.add('polygonjs-CSS2DRenderer');\n\t}\n\n\tgetSize() {\n\t\treturn {\n\t\t\twidth: this._width,\n\t\t\theight: this._height,\n\t\t};\n\t}\n\tsetSize(width: number, height: number) {\n\t\tthis._width = width;\n\t\tthis._height = height;\n\n\t\tthis._widthHalf = this._width / 2;\n\t\tthis._heightHalf = this._height / 2;\n\n\t\tthis.domElement.style.width = width + 'px';\n\t\tthis.domElement.style.height = height + 'px';\n\t}\n\n\trenderObject(object: Object3D, scene: Scene, camera: Camera) {\n\t\tif (object instanceof CSS2DObject) {\n\t\t\t// object.onBeforeRender(this, scene, camera);\n\n\t\t\tthis.vector.setFromMatrixPosition(object.matrixWorld);\n\t\t\tthis.vector.applyMatrix4(this.viewProjectionMatrix);\n\n\t\t\tvar element = object.element;\n\t\t\tvar style =\n\t\t\t\t'translate(-50%,-50%) translate(' +\n\t\t\t\t(this.vector.x * this._widthHalf + this._widthHalf) +\n\t\t\t\t'px,' +\n\t\t\t\t(-this.vector.y * this._heightHalf + this._heightHalf) +\n\t\t\t\t'px)';\n\n\t\t\telement.style.webkitTransform = style;\n\t\t\t// element.style.MozTransform = style;\n\t\t\t// element.style.Transform = style;\n\t\t\telement.style.transform = style;\n\n\t\t\telement.style.display = object.visible && this.vector.z >= -1 && this.vector.z <= 1 ? '' : 'none';\n\t\t\t// opacity was previously set here in case the _use_fog was changed from true to false and opacity had to be reset. But that causes problems for cases where css is app specific and is set in integrations in an app. So for now, for opacity to be updated correctly, a page reload will be needed. (an alternative could be to have a this._use_fog_updated and have an else clause below, but that could have an unwanted performance cost)\n\t\t\t// element.style.opacity = `1`;\n\n\t\t\tif (this._sort_objects || this._use_fog) {\n\t\t\t\tconst dist_to_squared = this.getDistanceToSquared(camera, object);\n\t\t\t\tif (this._use_fog) {\n\t\t\t\t\tconst dist = Math.sqrt(dist_to_squared);\n\t\t\t\t\tconst dist_remapped = CoreMath.fit(dist, this._fog_near, this._fog_far, 0, 1);\n\t\t\t\t\tconst opacity = CoreMath.clamp(1 - dist_remapped, 0, 1);\n\t\t\t\t\telement.style.opacity = `${opacity}`;\n\t\t\t\t\tif (opacity == 0) {\n\t\t\t\t\t\telement.style.display = 'none';\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tthis.cache_distanceToCameraSquared.set(object, dist_to_squared);\n\t\t\t}\n\t\t\tif (element.parentNode !== this.domElement) {\n\t\t\t\tthis.domElement.appendChild(element);\n\t\t\t}\n\n\t\t\t// object.onAfterRender(_this, scene, camera);\n\t\t}\n\n\t\tfor (var i = 0, l = object.children.length; i < l; i++) {\n\t\t\tthis.renderObject(object.children[i], scene, camera);\n\t\t}\n\t}\n\n\tprivate a = new Vector3();\n\tprivate b = new Vector3();\n\tgetDistanceToSquared(object1: Object3D, object2: Object3D) {\n\t\tthis.a.setFromMatrixPosition(object1.matrixWorld);\n\t\tthis.b.setFromMatrixPosition(object2.matrixWorld);\n\n\t\treturn this.a.distanceToSquared(this.b);\n\t}\n\n\tfilterAndFlatten(scene: Scene) {\n\t\tconst result: CSS2DObject[] = [];\n\n\t\tscene.traverse(function (object) {\n\t\t\tif (object instanceof CSS2DObject) result.push(object);\n\t\t});\n\n\t\treturn result;\n\t}\n\n\trender(scene: Scene, camera: Camera) {\n\t\tif (scene.autoUpdate === true) scene.updateMatrixWorld();\n\t\tif (camera.parent === null) camera.updateMatrixWorld();\n\n\t\tthis.viewMatrix.copy(camera.matrixWorldInverse);\n\t\tthis.viewProjectionMatrix.multiplyMatrices(camera.projectionMatrix, this.viewMatrix);\n\n\t\tthis.renderObject(scene, scene, camera);\n\t\tif (this._sort_objects) {\n\t\t\tthis.zOrder(scene);\n\t\t}\n\t}\n\n\t//\n\t//\n\t// SORTING\n\t//\n\t//\n\tset_sorting(state: boolean) {\n\t\tthis._sort_objects = state;\n\t}\n\tzOrder(scene: Scene) {\n\t\tconst sorted = this.filterAndFlatten(scene).sort((a, b) => {\n\t\t\tconst distanceA = this.cache_distanceToCameraSquared.get(a);\n\t\t\tconst distanceB = this.cache_distanceToCameraSquared.get(b);\n\t\t\tif (distanceA != null && distanceB != null) {\n\t\t\t\treturn distanceA - distanceB;\n\t\t\t} else {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t});\n\n\t\tconst zMax = sorted.length;\n\n\t\tfor (let i = 0, l = sorted.length; i < l; i++) {\n\t\t\tsorted[i].element.style.zIndex = `${zMax - i}`;\n\t\t}\n\t}\n\n\t//\n\t//\n\t// FOG\n\t//\n\t//\n\tset_use_fog(state: boolean) {\n\t\tthis._use_fog = state;\n\t}\n\tset_fog_range(near: number, far: number) {\n\t\tthis._fog_near = near;\n\t\tthis._fog_far = far;\n\t}\n}\n","/**\n * Creates a CSS2DRenderer\n *\n * @param\n * If you want to display HTML elements that follow the 3D objects, you will need to create this node, and set the camera css renderer to it. If you can CSSObjects in your scene, they will then be displayed.\n *\n * Note that the CSS2DRenderer currently requires the WebGLRenderer to have a pixelRatio of 1. Since the default is 2 for desktop, you would need to assign your own WebGLRenderer node to the camera and set its pixelRatio to 1.\n *\n */\nimport {TypedRopNode} from './_Base';\nimport {CSS2DRenderer} from '../../../modules/core/renderers/CSS2DRenderer';\nimport {RopType} from '../../poly/registers/nodes/Rop';\n\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nclass CSS2DRendererRopParamsConfig extends NodeParamsConfig {\n\t/** @param css rules to be added in the html document */\n\tcss = ParamConfig.STRING('', {\n\t\tmultiline: true,\n\t});\n\t/** @param toggle on to ensure objects z-index is set based on camera depth */\n\tsortObjects = ParamConfig.BOOLEAN(0);\n\t/** @param toggle on to have css opacity be set from camera depth */\n\tuseFog = ParamConfig.BOOLEAN(0);\n\t/** @param fog near */\n\tfogNear = ParamConfig.FLOAT(1, {\n\t\trange: [0, 100],\n\t\trangeLocked: [true, false],\n\t\tvisibleIf: {useFog: 1},\n\t});\n\t/** @param fog far */\n\tfogFar = ParamConfig.FLOAT(100, {\n\t\trange: [0, 100],\n\t\trangeLocked: [true, false],\n\t\tvisibleIf: {useFog: 1},\n\t});\n}\nconst ParamsConfig = new CSS2DRendererRopParamsConfig();\n\nexport class CSS2DRendererRopNode extends TypedRopNode<CSS2DRendererRopParamsConfig> {\n\tparams_config = ParamsConfig;\n\tstatic type(): Readonly<RopType.CSS2D> {\n\t\treturn RopType.CSS2D;\n\t}\n\n\tprivate _renderers_by_canvas_id: Map<string, CSS2DRenderer> = new Map();\n\tcreate_renderer(canvas: HTMLCanvasElement) {\n\t\tconst renderer = new CSS2DRenderer();\n\t\tthis._renderers_by_canvas_id.set(canvas.id, renderer);\n\t\tconst parent = canvas.parentElement;\n\t\tif (parent) {\n\t\t\tparent.prepend(renderer.domElement);\n\t\t\tparent.style.position = 'relative';\n\t\t}\n\t\trenderer.domElement.style.position = 'absolute';\n\t\trenderer.domElement.style.top = '0px';\n\t\trenderer.domElement.style.left = '0px';\n\t\trenderer.domElement.style.pointerEvents = 'none';\n\t\trenderer.setSize(canvas.width / window.devicePixelRatio, canvas.height / window.devicePixelRatio);\n\t\tthis._update_renderer(renderer);\n\t\treturn renderer;\n\t}\n\trenderer(canvas: HTMLCanvasElement) {\n\t\treturn this._renderers_by_canvas_id.get(canvas.id) || this.create_renderer(canvas);\n\t}\n\t// remove_renderer_element(canvas: HTMLCanvasElement) {\n\t// \t// not ideal, because I could not re-add it back\n\t// \tconst renderer = this.renderer(canvas);\n\t// \tif (renderer) {\n\t// \t\tconst parent = canvas.parentElement;\n\t// \t\tif (parent) {\n\t// \t\t\tparent.removeChild(renderer.domElement);\n\t// \t\t}\n\t// \t}\n\t// }\n\n\tcook() {\n\t\tthis._update_css();\n\n\t\tthis._renderers_by_canvas_id.forEach((renderer) => {\n\t\t\tthis._update_renderer(renderer);\n\t\t});\n\n\t\tthis.cookController.end_cook();\n\t}\n\n\tprivate _update_renderer(renderer: CSS2DRenderer) {\n\t\trenderer.set_sorting(this.pv.sortObjects);\n\t\trenderer.set_use_fog(this.pv.useFog);\n\t\trenderer.set_fog_range(this.pv.fogNear, this.pv.fogFar);\n\t}\n\n\tprivate _update_css() {\n\t\tconst element = this.css_element();\n\t\t// console.log(element);\n\t\t// if (element.rules.length > 0) {\n\t\t// \telement.deleteRule(0);\n\t\t// }\n\t\t// element.insertRule(this.pv.css);\n\t\t// console.log('rule inserted', this.pv.css);\n\t\telement.innerHTML = this.pv.css;\n\t}\n\n\tprivate _css_element: HTMLElement | undefined; // = new CSSStyleSheet();\n\tprivate css_element() {\n\t\treturn (this._css_element = this._css_element || this._find_element() || this._create_element());\n\t}\n\tprivate _find_element() {\n\t\treturn document.getElementById(this._css_element_id());\n\t}\n\tprivate _create_element() {\n\t\tconst style = document.createElement('style');\n\t\t// document.body.append(element);\n\t\t// https://davidwalsh.name/add-rules-stylesheets\n\t\t// WebKit hack :(\n\t\tstyle.appendChild(document.createTextNode(''));\n\t\tdocument.head.appendChild(style);\n\n\t\tstyle.id = this._css_element_id();\n\t\treturn style;\n\t}\n\tprivate _css_element_id() {\n\t\treturn `css_2d_renderer-${this.graphNodeId()}`;\n\t}\n}\n","/**\n * Creates a Mesh Lambert Material\n *\n * @remarks\n * This material needs lights to be visible. While not as photorealistic as the MeshStandardMaterial, it is very cheap to process.\n *\n */\n\nimport {MeshLambertMaterial} from 'three/src/materials/MeshLambertMaterial';\nimport {FrontSide} from 'three/src/constants';\nimport {TypedMatNode} from './_Base';\n\nimport {NodeParamsConfig} from '../utils/params/ParamsConfig';\nimport {ColorsController, ColorParamConfig} from './utils/ColorsController';\nimport {SideController, SideParamConfig} from './utils/SideController';\nimport {DepthController, DepthParamConfig} from './utils/DepthController';\nimport {SkinningController, SkinningParamConfig} from './utils/SkinningController';\nimport {TextureMapController, TextureMapParamConfig} from './utils/TextureMapController';\nimport {TextureAlphaMapController, TextureAlphaMapParamConfig} from './utils/TextureAlphaMapController';\nclass MeshLambertMatParamsConfig extends TextureAlphaMapParamConfig(\n\tTextureMapParamConfig(SkinningParamConfig(DepthParamConfig(SideParamConfig(ColorParamConfig(NodeParamsConfig)))))\n) {}\nconst ParamsConfig = new MeshLambertMatParamsConfig();\n\nexport class MeshLambertMatNode extends TypedMatNode<MeshLambertMaterial, MeshLambertMatParamsConfig> {\n\tparams_config = ParamsConfig;\n\tstatic type() {\n\t\treturn 'meshLambert';\n\t}\n\n\tcreateMaterial() {\n\t\treturn new MeshLambertMaterial({\n\t\t\tvertexColors: false,\n\t\t\tside: FrontSide,\n\t\t\tcolor: 0xffffff,\n\t\t\topacity: 1,\n\t\t});\n\t}\n\treadonly texture_map_controller: TextureMapController = new TextureMapController(this, {direct_params: true});\n\treadonly texture_alpha_map_controller: TextureAlphaMapController = new TextureAlphaMapController(this, {\n\t\tdirect_params: true,\n\t});\n\treadonly depth_controller: DepthController = new DepthController(this);\n\tinitializeNode() {\n\t\tthis.params.onParamsCreated('init controllers', () => {\n\t\t\tthis.texture_map_controller.initializeNode();\n\t\t\tthis.texture_alpha_map_controller.initializeNode();\n\t\t});\n\t}\n\tasync cook() {\n\t\tColorsController.update(this);\n\t\tSideController.update(this);\n\t\tSkinningController.update(this);\n\t\tthis.texture_map_controller.update();\n\t\tthis.texture_alpha_map_controller.update();\n\t\tthis.depth_controller.update();\n\n\t\tthis.set_material(this.material);\n\t}\n}\n","/**\n * Parent for COP nodes\n *\n *\n */\nimport {ParamLessBaseManagerObjNode} from './_BaseManager';\nimport {NodeContext, NetworkNodeType} from '../../poly/NodeContext';\nimport {CopNodeChildrenMap} from '../../poly/registers/nodes/Cop';\nimport {BaseCopNodeType} from '../cop/_Base';\nimport {ParamsInitData} from '../utils/io/IOController';\nimport {Constructor, valueof} from '../../../types/GlobalTypes';\n\nexport class CopObjNode extends ParamLessBaseManagerObjNode {\n\tstatic type() {\n\t\treturn NetworkNodeType.COP;\n\t}\n\tprotected _children_controller_context = NodeContext.COP;\n\n\tcreateNode<S extends keyof CopNodeChildrenMap>(\n\t\tnode_class: S,\n\t\tparams_init_value_overrides?: ParamsInitData\n\t): CopNodeChildrenMap[S];\n\tcreateNode<K extends valueof<CopNodeChildrenMap>>(\n\t\tnode_class: Constructor<K>,\n\t\tparams_init_value_overrides?: ParamsInitData\n\t): K;\n\tcreateNode<K extends valueof<CopNodeChildrenMap>>(\n\t\tnode_class: Constructor<K>,\n\t\tparams_init_value_overrides?: ParamsInitData\n\t): K {\n\t\treturn super.createNode(node_class, params_init_value_overrides) as K;\n\t}\n\tchildren() {\n\t\treturn super.children() as BaseCopNodeType[];\n\t}\n\tnodesByType<K extends keyof CopNodeChildrenMap>(type: K): CopNodeChildrenMap[K][] {\n\t\treturn super.nodesByType(type) as CopNodeChildrenMap[K][];\n\t}\n}\n","/**\n * Parent for SOP nodes\n *\n * @remarks\n * This node also has its own transforms. And if it is set as input of other nodes, their objects will be added as children to the object of this node.\n *\n */\nimport {TypedObjNode} from './_Base';\nimport {Group} from 'three/src/objects/Group';\nimport {BaseNodeType} from '../_Base';\nimport {DisplayNodeController} from '../utils/DisplayNodeController';\nimport {NodeContext} from '../../poly/NodeContext';\nimport {BaseSopNodeType} from '../sop/_Base';\nimport {TransformedParamConfig, TransformController} from './utils/TransformController';\nimport {GeoNodeChildrenMap} from '../../poly/registers/nodes/Sop';\nimport {FlagsControllerD} from '../utils/FlagsController';\nimport {HierarchyController} from './utils/HierarchyController';\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {ChildrenDisplayController} from './utils/ChildrenDisplayController';\nimport {ParamsInitData} from '../utils/io/IOController';\nimport {Constructor, valueof} from '../../../types/GlobalTypes';\nimport {isBooleanTrue} from '../../../core/BooleanValue';\nclass GeoObjParamConfig extends TransformedParamConfig(NodeParamsConfig) {\n\t/** @param toggle off to hide */\n\tdisplay = ParamConfig.BOOLEAN(1);\n\t/** @param set render order */\n\trenderOrder = ParamConfig.INTEGER(0, {\n\t\trange: [0, 10],\n\t\trangeLocked: [true, false],\n\t});\n}\nconst ParamsConfig = new GeoObjParamConfig();\n\nexport class GeoObjNode extends TypedObjNode<Group, GeoObjParamConfig> {\n\tparams_config = ParamsConfig;\n\tstatic type() {\n\t\treturn 'geo';\n\t}\n\treadonly hierarchyController: HierarchyController = new HierarchyController(this);\n\treadonly transformController: TransformController = new TransformController(this);\n\tpublic readonly flags: FlagsControllerD = new FlagsControllerD(this);\n\tcreate_object() {\n\t\tconst group = new Group();\n\t\tgroup.matrixAutoUpdate = false;\n\t\treturn group;\n\t}\n\n\t// display_node and children_display controllers\n\tpublic readonly childrenDisplayController: ChildrenDisplayController = new ChildrenDisplayController(this);\n\tpublic readonly displayNodeController: DisplayNodeController = new DisplayNodeController(\n\t\tthis,\n\t\tthis.childrenDisplayController.displayNodeControllerCallbacks()\n\t);\n\t//\n\n\tprotected _children_controller_context = NodeContext.SOP;\n\n\tprivate _on_child_add_bound = this._on_child_add.bind(this);\n\tinitializeNode() {\n\t\t// this.lifecycle.add_on_create_hook(this._on_create_bound);\n\t\tthis.lifecycle.add_on_child_add_hook(this._on_child_add_bound);\n\n\t\tthis.hierarchyController.initializeNode();\n\t\tthis.transformController.initializeNode();\n\n\t\tthis.childrenDisplayController.initializeNode();\n\t}\n\n\tisDisplayNodeCooking(): boolean {\n\t\tif (this.flags.display.active()) {\n\t\t\tconst display_node = this.displayNodeController.displayNode();\n\t\t\treturn display_node ? display_node.isDirty() : false;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tcreateNode<S extends keyof GeoNodeChildrenMap>(\n\t\tnode_class: S,\n\t\tparams_init_value_overrides?: ParamsInitData\n\t): GeoNodeChildrenMap[S];\n\tcreateNode<K extends valueof<GeoNodeChildrenMap>>(\n\t\tnode_class: Constructor<K>,\n\t\tparams_init_value_overrides?: ParamsInitData\n\t): K;\n\tcreateNode<K extends valueof<GeoNodeChildrenMap>>(\n\t\tnode_class: Constructor<K>,\n\t\tparams_init_value_overrides?: ParamsInitData\n\t): K {\n\t\treturn super.createNode(node_class, params_init_value_overrides) as K;\n\t}\n\tchildren() {\n\t\treturn super.children() as BaseSopNodeType[];\n\t}\n\tnodesByType<K extends keyof GeoNodeChildrenMap>(type: K): GeoNodeChildrenMap[K][] {\n\t\treturn super.nodesByType(type) as GeoNodeChildrenMap[K][];\n\t}\n\n\t//\n\t//\n\t// HOOK\n\t//\n\t//\n\n\t_on_child_add(node: BaseNodeType) {\n\t\tif (this.scene().loadingController.loaded()) {\n\t\t\tif (this.children().length == 1) {\n\t\t\t\tnode.flags?.display?.set(true);\n\t\t\t}\n\t\t}\n\t}\n\n\t//\n\t//\n\t// COOK\n\t//\n\t//\n\tcook() {\n\t\tthis.transformController.update();\n\t\tthis.object.visible = isBooleanTrue(this.pv.display);\n\t\tthis.object.renderOrder = this.pv.renderOrder;\n\t\tthis.cookController.end_cook();\n\t}\n}\n","/**\n * Parent for Material nodes\n *\n *\n */\nimport {Constructor, valueof} from '../../../types/GlobalTypes';\nimport {ParamLessBaseManagerObjNode} from './_BaseManager';\nimport {NodeContext, NetworkNodeType} from '../../poly/NodeContext';\nimport {ObjNodeRenderOrder} from './_Base';\nimport {MatNodeChildrenMap} from '../../poly/registers/nodes/Mat';\nimport {BaseMatNodeType} from '../mat/_Base';\nimport {ParamsInitData} from '../utils/io/IOController';\n\nexport class MaterialsObjNode extends ParamLessBaseManagerObjNode {\n\tpublic readonly renderOrder: number = ObjNodeRenderOrder.MANAGER;\n\tstatic type(): Readonly<NetworkNodeType.MAT> {\n\t\treturn NetworkNodeType.MAT;\n\t}\n\n\tprotected _children_controller_context = NodeContext.MAT;\n\n\tcreateNode<S extends keyof MatNodeChildrenMap>(\n\t\tnode_class: S,\n\t\tparams_init_value_overrides?: ParamsInitData\n\t): MatNodeChildrenMap[S];\n\tcreateNode<K extends valueof<MatNodeChildrenMap>>(\n\t\tnode_class: Constructor<K>,\n\t\tparams_init_value_overrides?: ParamsInitData\n\t): K;\n\tcreateNode<K extends valueof<MatNodeChildrenMap>>(\n\t\tnode_class: Constructor<K>,\n\t\tparams_init_value_overrides?: ParamsInitData\n\t): K {\n\t\treturn super.createNode(node_class, params_init_value_overrides) as K;\n\t}\n\tchildren() {\n\t\treturn super.children() as BaseMatNodeType[];\n\t}\n\tnodesByType<K extends keyof MatNodeChildrenMap>(type: K): MatNodeChildrenMap[K][] {\n\t\treturn super.nodesByType(type) as MatNodeChildrenMap[K][];\n\t}\n}\n","/**\n * Creates an empty group.\n *\n * @remarks\n * This node also has its own transforms. And if it is set as input of other nodes, their objects will be added as children to the object of this node.\n *\n */\nimport {TypedObjNode} from './_Base';\nimport {Group} from 'three/src/objects/Group';\nimport {TransformedParamConfig, TransformController} from './utils/TransformController';\nimport {FlagsControllerD} from '../utils/FlagsController';\nimport {AxesHelper} from 'three/src/helpers/AxesHelper';\nimport {NodeParamsConfig} from '../utils/params/ParamsConfig';\nimport {HierarchyController} from './utils/HierarchyController';\nclass NullObjParamConfig extends TransformedParamConfig(NodeParamsConfig) {}\nconst ParamsConfig = new NullObjParamConfig();\n\nexport class NullObjNode extends TypedObjNode<Group, NullObjParamConfig> {\n\tparams_config = ParamsConfig;\n\tstatic type() {\n\t\treturn 'null';\n\t}\n\treadonly hierarchyController: HierarchyController = new HierarchyController(this);\n\treadonly transformController: TransformController = new TransformController(this);\n\tpublic readonly flags: FlagsControllerD = new FlagsControllerD(this);\n\tprivate _helper = new AxesHelper(1);\n\n\tcreate_object() {\n\t\tconst group = new Group();\n\t\tgroup.matrixAutoUpdate = false;\n\t\treturn group;\n\t}\n\tinitializeNode() {\n\t\tthis.hierarchyController.initializeNode();\n\t\tthis.transformController.initializeNode();\n\t\tthis._updateHelperHierarchy();\n\t\tthis._helper.matrixAutoUpdate = false;\n\t\tthis.flags.display.onUpdate(() => {\n\t\t\tthis._updateHelperHierarchy();\n\t\t});\n\t}\n\tprivate _updateHelperHierarchy() {\n\t\tif (this.flags.display.active()) {\n\t\t\tthis.object.add(this._helper);\n\t\t} else {\n\t\t\tthis.object.remove(this._helper);\n\t\t}\n\t}\n\n\tcook() {\n\t\tthis.transformController.update();\n\t\tthis.cookController.end_cook();\n\t}\n}\n","/**\n * Creates an attribute on the geometry or object.\n *\n * @remarks\n * This allows you to create an attribute and define the following:\n * - the group this applies to\n * - the name\n * - the type (numeric or string)\n * - the size (float, vector2, vector3 or vector4)\n * - the class (geometry or object attribute)\n * - the value\n *\n * Note that you can also given an expression to set the value of the attribute, such as `sin(2*@P.z)`\n *\n */\nimport {TypedSopNode} from './_Base';\nimport {\n\tAttribClassMenuEntries,\n\tAttribTypeMenuEntries,\n\tAttribClass,\n\tAttribType,\n\tATTRIBUTE_CLASSES,\n\tATTRIBUTE_TYPES,\n} from '../../../core/geometry/Constant';\nimport {CoreAttribute} from '../../../core/geometry/Attribute';\nimport {CoreObject} from '../../../core/geometry/Object';\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {TypeAssert} from '../../poly/Assert';\nimport {BufferGeometry} from 'three/src/core/BufferGeometry';\nimport {PolyDictionary} from '../../../types/GlobalTypes';\nimport {Vector2} from 'three/src/math/Vector2';\nimport {Vector3} from 'three/src/math/Vector3';\nimport {Vector4} from 'three/src/math/Vector4';\n\ntype VectorComponent = 'x' | 'y' | 'z' | 'w';\nconst COMPONENT_NAMES: Array<VectorComponent> = ['x', 'y', 'z', 'w'];\n\ntype ValueArrayByName = PolyDictionary<number[]>;\n\nimport {AttribCreateSopOperation} from '../../operations/sop/AttribCreate';\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nconst DEFAULT = AttribCreateSopOperation.DEFAULT_PARAMS;\nclass AttribCreateSopParamsConfig extends NodeParamsConfig {\n\t/** @param the group this applies to */\n\tgroup = ParamConfig.STRING(DEFAULT.group);\n\t/** @param the attribute class (geometry or object) */\n\tclass = ParamConfig.INTEGER(DEFAULT.class, {\n\t\tmenu: {\n\t\t\tentries: AttribClassMenuEntries,\n\t\t},\n\t});\n\t/** @param the attribute type (numeric or string) */\n\ttype = ParamConfig.INTEGER(DEFAULT.type, {\n\t\tmenu: {\n\t\t\tentries: AttribTypeMenuEntries,\n\t\t},\n\t});\n\t/** @param the attribute name */\n\tname = ParamConfig.STRING(DEFAULT.name);\n\t/** @param the attribute size (1 for float, 2 for vector2, 3 for vector3, 4 for vector4) */\n\tsize = ParamConfig.INTEGER(DEFAULT.size, {\n\t\trange: [1, 4],\n\t\trangeLocked: [true, true],\n\t\tvisibleIf: {type: AttribType.NUMERIC},\n\t});\n\t/** @param the value for a float attribute */\n\tvalue1 = ParamConfig.FLOAT(DEFAULT.value1, {\n\t\tvisibleIf: {type: AttribType.NUMERIC, size: 1},\n\t\texpression: {forEntities: true},\n\t});\n\t/** @param the value for a vector2 */\n\tvalue2 = ParamConfig.VECTOR2(DEFAULT.value2, {\n\t\tvisibleIf: {type: AttribType.NUMERIC, size: 2},\n\t\texpression: {forEntities: true},\n\t});\n\t/** @param the value for a vector3 */\n\tvalue3 = ParamConfig.VECTOR3(DEFAULT.value3, {\n\t\tvisibleIf: {type: AttribType.NUMERIC, size: 3},\n\t\texpression: {forEntities: true},\n\t});\n\t/** @param the value for a vector4 */\n\tvalue4 = ParamConfig.VECTOR4(DEFAULT.value4, {\n\t\tvisibleIf: {type: AttribType.NUMERIC, size: 4},\n\t\texpression: {forEntities: true},\n\t});\n\t/** @param the value for a string attribute */\n\tstring = ParamConfig.STRING(DEFAULT.string, {\n\t\tvisibleIf: {type: AttribType.STRING},\n\t\texpression: {forEntities: true},\n\t});\n}\nconst ParamsConfig = new AttribCreateSopParamsConfig();\nexport class AttribCreateSopNode extends TypedSopNode<AttribCreateSopParamsConfig> {\n\tparams_config = ParamsConfig;\n\tstatic type() {\n\t\treturn 'attribCreate';\n\t}\n\n\tprivate _x_arrays_by_geometry_uuid: ValueArrayByName = {};\n\tprivate _y_arrays_by_geometry_uuid: ValueArrayByName = {};\n\tprivate _z_arrays_by_geometry_uuid: ValueArrayByName = {};\n\tprivate _w_arrays_by_geometry_uuid: ValueArrayByName = {};\n\n\tinitializeNode() {\n\t\tthis.io.inputs.setCount(1);\n\t\tthis.io.inputs.initInputsClonedState(AttribCreateSopOperation.INPUT_CLONED_STATE);\n\n\t\tthis.scene().dispatchController.onAddListener(() => {\n\t\t\tthis.params.onParamsCreated('params_label', () => {\n\t\t\t\tthis.params.label.init([this.p.name]);\n\t\t\t});\n\t\t});\n\t}\n\n\tprivate _operation: AttribCreateSopOperation | undefined;\n\tcook(input_contents: CoreGroup[]) {\n\t\t// cannot yet convert to an operation, as expressions may be used in this node\n\t\t// but we can still use one when no expression is required\n\n\t\tif (this._is_using_expression()) {\n\t\t\tif (this.pv.name && this.pv.name.trim() != '') {\n\t\t\t\tthis._add_attribute(ATTRIBUTE_CLASSES[this.pv.class], input_contents[0]);\n\t\t\t} else {\n\t\t\t\tthis.states.error.set('attribute name is not valid');\n\t\t\t}\n\t\t} else {\n\t\t\tthis._operation = this._operation || new AttribCreateSopOperation(this.scene(), this.states);\n\t\t\tconst core_group = this._operation.cook(input_contents, this.pv);\n\t\t\tthis.setCoreGroup(core_group);\n\t\t}\n\t}\n\tprivate async _add_attribute(attrib_class: AttribClass, core_group: CoreGroup) {\n\t\tconst attrib_type = ATTRIBUTE_TYPES[this.pv.type];\n\t\tswitch (attrib_class) {\n\t\t\tcase AttribClass.VERTEX:\n\t\t\t\tawait this.add_point_attribute(attrib_type, core_group);\n\t\t\t\treturn this.setCoreGroup(core_group);\n\t\t\tcase AttribClass.OBJECT:\n\t\t\t\tawait this.add_object_attribute(attrib_type, core_group);\n\t\t\t\treturn this.setCoreGroup(core_group);\n\t\t}\n\t\tTypeAssert.unreachable(attrib_class);\n\t}\n\n\tasync add_point_attribute(attrib_type: AttribType, core_group: CoreGroup) {\n\t\tconst core_objects = core_group.coreObjects();\n\t\tswitch (attrib_type) {\n\t\t\tcase AttribType.NUMERIC: {\n\t\t\t\tfor (let i = 0; i < core_objects.length; i++) {\n\t\t\t\t\tawait this.add_numeric_attribute_to_points(core_objects[i]);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tcase AttribType.STRING: {\n\t\t\t\tfor (let i = 0; i < core_objects.length; i++) {\n\t\t\t\t\tawait this.add_string_attribute_to_points(core_objects[i]);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tTypeAssert.unreachable(attrib_type);\n\t}\n\tasync add_object_attribute(attrib_type: AttribType, core_group: CoreGroup) {\n\t\tconst core_objects = core_group.coreObjectsFromGroup(this.pv.group);\n\t\tswitch (attrib_type) {\n\t\t\tcase AttribType.NUMERIC:\n\t\t\t\tawait this.add_numeric_attribute_to_object(core_objects);\n\t\t\t\treturn;\n\t\t\tcase AttribType.STRING:\n\t\t\t\tawait this.add_string_attribute_to_object(core_objects);\n\t\t\t\treturn;\n\t\t}\n\t\tTypeAssert.unreachable(attrib_type);\n\t}\n\n\tasync add_numeric_attribute_to_points(core_object: CoreObject) {\n\t\tconst core_geometry = core_object.coreGeometry();\n\t\tif (!core_geometry) {\n\t\t\treturn;\n\t\t}\n\t\tconst points = core_object.pointsFromGroup(this.pv.group);\n\n\t\tconst param = [this.p.value1, this.p.value2, this.p.value3, this.p.value4][this.pv.size - 1];\n\n\t\tif (param.hasExpression()) {\n\t\t\tif (!core_geometry.hasAttrib(this.pv.name)) {\n\t\t\t\tcore_geometry.addNumericAttrib(this.pv.name, this.pv.size, param.value);\n\t\t\t}\n\n\t\t\tconst geometry = core_geometry.geometry();\n\t\t\tconst array = geometry.getAttribute(this.pv.name).array as number[];\n\t\t\tif (this.pv.size == 1) {\n\t\t\t\tif (this.p.value1.expressionController) {\n\t\t\t\t\tawait this.p.value1.expressionController.compute_expression_for_points(points, (point, value) => {\n\t\t\t\t\t\tarray[point.index() * this.pv.size + 0] = value;\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst vparam = [this.p.value2, this.p.value3, this.p.value4][this.pv.size - 2];\n\t\t\t\tlet params = vparam.components;\n\t\t\t\tconst tmp_arrays = new Array(params.length);\n\t\t\t\tlet component_param;\n\n\t\t\t\tconst arrays_by_geometry_uuid = [\n\t\t\t\t\tthis._x_arrays_by_geometry_uuid,\n\t\t\t\t\tthis._y_arrays_by_geometry_uuid,\n\t\t\t\t\tthis._z_arrays_by_geometry_uuid,\n\t\t\t\t\tthis._w_arrays_by_geometry_uuid,\n\t\t\t\t];\n\n\t\t\t\tfor (let i = 0; i < params.length; i++) {\n\t\t\t\t\tcomponent_param = params[i];\n\t\t\t\t\tif (component_param.hasExpression() && component_param.expressionController) {\n\t\t\t\t\t\ttmp_arrays[i] = this._init_array_if_required(\n\t\t\t\t\t\t\tgeometry,\n\t\t\t\t\t\t\tarrays_by_geometry_uuid[i],\n\t\t\t\t\t\t\tpoints.length\n\t\t\t\t\t\t);\n\t\t\t\t\t\tawait component_param.expressionController.compute_expression_for_points(\n\t\t\t\t\t\t\tpoints,\n\t\t\t\t\t\t\t(point, value) => {\n\t\t\t\t\t\t\t\t// array[point.index()*this.pv.size+i] = value\n\t\t\t\t\t\t\t\ttmp_arrays[i][point.index()] = value;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst value = component_param.value;\n\t\t\t\t\t\tfor (let point of points) {\n\t\t\t\t\t\t\tarray[point.index() * this.pv.size + i] = value;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// commit the tmp values\n\t\t\t\tfor (let j = 0; j < tmp_arrays.length; j++) {\n\t\t\t\t\tconst tmp_array = tmp_arrays[j];\n\t\t\t\t\tif (tmp_array) {\n\t\t\t\t\t\tfor (let i = 0; i < tmp_array.length; i++) {\n\t\t\t\t\t\t\tarray[i * this.pv.size + j] = tmp_array[i];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t// no need to do work here, as this will be done in the operation\n\t\t}\n\t}\n\n\tasync add_numeric_attribute_to_object(core_objects: CoreObject[]) {\n\t\tconst param = [this.p.value1, this.p.value2, this.p.value3, this.p.value4][this.pv.size - 1];\n\t\tif (param.hasExpression()) {\n\t\t\tif (this.pv.size == 1) {\n\t\t\t\tif (this.p.value1.expressionController) {\n\t\t\t\t\tawait this.p.value1.expressionController.compute_expression_for_objects(\n\t\t\t\t\t\tcore_objects,\n\t\t\t\t\t\t(core_object, value) => {\n\t\t\t\t\t\t\tcore_object.setAttribValue(this.pv.name, value);\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst vparam = [this.p.value2, this.p.value3, this.p.value4][this.pv.size - 2];\n\t\t\t\tlet params = vparam.components;\n\t\t\t\tlet values_by_core_object_index: PolyDictionary<Vector2 | Vector3 | Vector4> = {};\n\t\t\t\t// for (let component_param of params) {\n\t\t\t\t// \tvalues.push(component_param.value);\n\t\t\t\t// }\n\t\t\t\tconst init_vector = this._vector_by_attrib_size(this.pv.size);\n\t\t\t\tif (init_vector) {\n\t\t\t\t\tfor (let core_object of core_objects) {\n\t\t\t\t\t\tvalues_by_core_object_index[core_object.index()] = init_vector;\n\t\t\t\t\t}\n\t\t\t\t\tfor (let component_index = 0; component_index < params.length; component_index++) {\n\t\t\t\t\t\tconst component_param = params[component_index];\n\t\t\t\t\t\tconst component_name = COMPONENT_NAMES[component_index];\n\t\t\t\t\t\tif (component_param.hasExpression() && component_param.expressionController) {\n\t\t\t\t\t\t\tawait component_param.expressionController.compute_expression_for_objects(\n\t\t\t\t\t\t\t\tcore_objects,\n\t\t\t\t\t\t\t\t(core_object, value) => {\n\t\t\t\t\t\t\t\t\tconst vector = values_by_core_object_index[core_object.index()] as Vector4;\n\t\t\t\t\t\t\t\t\tvector[component_name] = value;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tfor (let core_object of core_objects) {\n\t\t\t\t\t\t\t\tconst vector = values_by_core_object_index[core_object.index()] as Vector4;\n\t\t\t\t\t\t\t\tvector[component_name] = component_param.value;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor (let i = 0; i < core_objects.length; i++) {\n\t\t\t\t\t\tconst core_object = core_objects[i];\n\t\t\t\t\t\tconst value = values_by_core_object_index[core_object.index()];\n\t\t\t\t\t\tcore_object.setAttribValue(this.pv.name, value);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t// no need to do work here, as this will be done in the operation\n\t\t}\n\t}\n\tprivate _vector_by_attrib_size(size: number) {\n\t\tswitch (size) {\n\t\t\tcase 2:\n\t\t\t\treturn new Vector2(0, 0);\n\t\t\tcase 3:\n\t\t\t\treturn new Vector3(0, 0, 0);\n\t\t\tcase 4:\n\t\t\t\treturn new Vector4(0, 0, 0, 0);\n\t\t}\n\t}\n\n\t// private _convert_object_numeric_value(value: Vector4) {\n\t// \tlet converted_value;\n\t// \tswitch (this.pv.size) {\n\t// \t\tcase 1: {\n\t// \t\t\tconverted_value = value.x;\n\t// \t\t\tbreak;\n\t// \t\t}\n\t// \t\tcase 2: {\n\t// \t\t\tconverted_value = new Vector2(value.x, value.y);\n\t// \t\t\tbreak;\n\t// \t\t}\n\t// \t\tcase 3: {\n\t// \t\t\tconverted_value = new Vector3(value.x, value.y, value.z);\n\t// \t\t\tbreak;\n\t// \t\t}\n\t// \t\tcase 4: {\n\t// \t\t\tconverted_value = new Vector4(value.x, value.y, value.z, value.w);\n\t// \t\t\tbreak;\n\t// \t\t}\n\t// \t}\n\t// \treturn converted_value;\n\t// }\n\n\tasync add_string_attribute_to_points(core_object: CoreObject) {\n\t\tconst points = core_object.pointsFromGroup(this.pv.group);\n\t\tconst param = this.p.string;\n\n\t\tconst string_values: string[] = new Array(points.length);\n\t\tif (param.hasExpression() && param.expressionController) {\n\t\t\tawait param.expressionController.compute_expression_for_points(points, (point, value) => {\n\t\t\t\tstring_values[point.index()] = value;\n\t\t\t});\n\t\t} else {\n\t\t\t// no need to do work here, as this will be done in the operation\n\t\t}\n\n\t\tconst index_data = CoreAttribute.array_to_indexed_arrays(string_values);\n\t\tconst geometry = core_object.coreGeometry();\n\t\tif (geometry) {\n\t\t\tgeometry.setIndexedAttribute(this.pv.name, index_data['values'], index_data['indices']);\n\t\t}\n\t}\n\n\tasync add_string_attribute_to_object(core_objects: CoreObject[]) {\n\t\tconst param = this.p.string;\n\t\tif (param.hasExpression() && param.expressionController) {\n\t\t\tawait param.expressionController.compute_expression_for_objects(core_objects, (core_object, value) => {\n\t\t\t\tcore_object.setAttribValue(this.pv.name, value);\n\t\t\t});\n\t\t} else {\n\t\t\t// no need to do work here, as this will be done in the operation\n\t\t}\n\t\t// this.context().set_entity(object);\n\n\t\t// const core_object = new CoreObject(object);\n\n\t\t// this.param('string').eval(val => {\n\t\t// \tcore_object.addAttribute(this.pv.name, val);\n\t\t// });\n\t}\n\n\tprivate _init_array_if_required(\n\t\tgeometry: BufferGeometry,\n\t\tarrays_by_geometry_uuid: ValueArrayByName,\n\t\tpoints_count: number\n\t) {\n\t\tconst uuid = geometry.uuid;\n\t\tconst current_array = arrays_by_geometry_uuid[uuid];\n\t\tif (current_array) {\n\t\t\t// only create new array if we need more point, or as soon as the length is different?\n\t\t\tif (current_array.length < points_count) {\n\t\t\t\tarrays_by_geometry_uuid[uuid] = new Array(points_count);\n\t\t\t}\n\t\t} else {\n\t\t\tarrays_by_geometry_uuid[uuid] = new Array(points_count);\n\t\t}\n\t\treturn arrays_by_geometry_uuid[uuid];\n\t}\n\n\t//\n\t//\n\t// CHECK IF EXPRESSION IS BEING USED, TO ALLOW EASY SWITCH TO OPERATION\n\t//\n\t//\n\tprivate _is_using_expression(): boolean {\n\t\tconst attrib_type = ATTRIBUTE_TYPES[this.pv.type];\n\t\tswitch (attrib_type) {\n\t\t\tcase AttribType.NUMERIC:\n\t\t\t\tconst param = [this.p.value1, this.p.value2, this.p.value3, this.p.value4][this.pv.size - 1];\n\t\t\t\treturn param.hasExpression();\n\t\t\tcase AttribType.STRING:\n\t\t\t\treturn this.p.string.hasExpression();\n\t\t}\n\t}\n}\n","/**\n * A subnet to create EVENT nodes\n *\n */\nimport {ParamLessBaseNetworkSopNode} from './_BaseManager';\nimport {NodeContext, NetworkNodeType} from '../../poly/NodeContext';\nimport {EventNodeChildrenMap} from '../../poly/registers/nodes/Event';\nimport {BaseEventNodeType} from '../event/_Base';\nimport {ParamsInitData} from '../utils/io/IOController';\nimport {Constructor, valueof} from '../../../types/GlobalTypes';\n\nexport class EventsSopNode extends ParamLessBaseNetworkSopNode {\n\tstatic type() {\n\t\treturn NetworkNodeType.EVENT;\n\t}\n\n\tprotected _children_controller_context = NodeContext.EVENT;\n\n\tcreateNode<S extends keyof EventNodeChildrenMap>(\n\t\tnode_class: S,\n\t\tparams_init_value_overrides?: ParamsInitData\n\t): EventNodeChildrenMap[S];\n\tcreateNode<K extends valueof<EventNodeChildrenMap>>(\n\t\tnode_class: Constructor<K>,\n\t\tparams_init_value_overrides?: ParamsInitData\n\t): K;\n\tcreateNode<K extends valueof<EventNodeChildrenMap>>(\n\t\tnode_class: Constructor<K>,\n\t\tparams_init_value_overrides?: ParamsInitData\n\t): K {\n\t\treturn super.createNode(node_class, params_init_value_overrides) as K;\n\t}\n\tchildren() {\n\t\treturn super.children() as BaseEventNodeType[];\n\t}\n\tnodesByType<K extends keyof EventNodeChildrenMap>(type: K): EventNodeChildrenMap[K][] {\n\t\treturn super.nodesByType(type) as EventNodeChildrenMap[K][];\n\t}\n}\n","/**\n * Merge input geometries\n *\n * @remarks\n * This node can take up to 4 inputs. It can operate within 1 of 2 modes:\n *\n * - compact ON: all objects will be merged in as few objects as possible. So all meshes will be merged into one, all point objects into one, and all line objects into one. This requires the objects to have the same attributes.\n * - compact OFF: all objects are simply put under a common parent, but remain distinct objects.\n\n */\nimport {TypedSopNode} from './_Base';\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {MergeSopOperation} from '../../operations/sop/Merge';\n\nconst INPUT_NAME = 'geometry to merge';\n\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {BaseNodeType} from '../_Base';\nimport {NodeEvent} from '../../poly/NodeEvent';\nconst DEFAULT = MergeSopOperation.DEFAULT_PARAMS;\nconst DEFAULT_INPUTS_COUNT = 4;\nclass MergeSopParamsConfig extends NodeParamsConfig {\n\t/** @param When off, input objects remain separate. When on, they are merged together by type (mesh, points and lines). In order to merge them correctly, you'll have to make sure they have the same attributes */\n\tcompact = ParamConfig.BOOLEAN(DEFAULT.compact);\n\tinputsCount = ParamConfig.INTEGER(DEFAULT_INPUTS_COUNT, {\n\t\trange: [1, 32],\n\t\trangeLocked: [true, false],\n\t\tcallback: (node: BaseNodeType) => {\n\t\t\tMergeSopNode.PARAM_CALLBACK_setInputsCount(node as MergeSopNode);\n\t\t},\n\t});\n}\nconst ParamsConfig = new MergeSopParamsConfig();\n\nexport class MergeSopNode extends TypedSopNode<MergeSopParamsConfig> {\n\tparams_config = ParamsConfig;\n\tstatic type() {\n\t\treturn 'merge';\n\t}\n\n\tstatic displayedInputNames(): string[] {\n\t\treturn [INPUT_NAME, INPUT_NAME, INPUT_NAME, INPUT_NAME];\n\t}\n\n\tinitializeNode() {\n\t\tthis.io.inputs.setCount(1, DEFAULT_INPUTS_COUNT);\n\t\tthis.io.inputs.initInputsClonedState(MergeSopOperation.INPUT_CLONED_STATE);\n\n\t\t// this.uiData.set_icon('compress-arrows-alt');\n\t\tthis.scene().dispatchController.onAddListener(() => {\n\t\t\tthis.params.onParamsCreated('params_label', () => {\n\t\t\t\tthis.params.label.init([this.p.compact], () => {\n\t\t\t\t\treturn this.pv.compact ? 'compact' : 'separate objects';\n\t\t\t\t});\n\t\t\t});\n\t\t\tthis.params.addOnSceneLoadHook('update inputs', () => {\n\t\t\t\tthis._callbackUpdateInputsCount();\n\t\t\t});\n\t\t});\n\t}\n\n\tprivate _operation: MergeSopOperation | undefined;\n\tcook(input_contents: CoreGroup[]) {\n\t\tthis._operation = this._operation || new MergeSopOperation(this.scene(), this.states);\n\t\tconst core_group = this._operation.cook(input_contents, this.pv);\n\t\tthis.setCoreGroup(core_group);\n\t}\n\n\tprivate _callbackUpdateInputsCount() {\n\t\tthis.io.inputs.setCount(1, this.pv.inputsCount);\n\t\tthis.emit(NodeEvent.INPUTS_UPDATED);\n\t}\n\tstatic PARAM_CALLBACK_setInputsCount(node: MergeSopNode) {\n\t\tnode._callbackUpdateInputsCount();\n\t}\n}\n","/**\n * Updates the normals of the geometry\n *\n * @remarks\n * Just like the Point and Color SOPs, this can take expressions\n *\n */\nimport {TypedSopNode} from './_Base';\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {InputCloneMode} from '../../poly/InputCloneMode';\nimport {CoreObject} from '../../../core/geometry/Object';\nimport {Attribute} from '../../../core/geometry/Attribute';\nimport {Mesh} from 'three/src/objects/Mesh';\nimport {BufferGeometry} from 'three/src/core/BufferGeometry';\nimport {CoreGeometry} from '../../../core/geometry/Geometry';\n\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {isBooleanTrue} from '../../../core/BooleanValue';\nclass NormalsSopParamsConfig extends NodeParamsConfig {\n\t/** @param toggle on if normals can be updated via expressions */\n\tedit = ParamConfig.BOOLEAN(0);\n\t/** @param toggle on to update the x component */\n\tupdateX = ParamConfig.BOOLEAN(0, {\n\t\tvisibleIf: {edit: 1},\n\t});\n\t/** @param expression or value for the x component */\n\tx = ParamConfig.FLOAT('@N.x', {\n\t\tvisibleIf: {updateX: 1, edit: 1},\n\t\texpression: {forEntities: true},\n\t});\n\t/** @param toggle on to update the y component */\n\tupdateY = ParamConfig.BOOLEAN(0, {\n\t\tvisibleIf: {edit: 1},\n\t});\n\t/** @param expression or value for the y component */\n\ty = ParamConfig.FLOAT('@N.y', {\n\t\tvisibleIf: {updateY: 1, edit: 1},\n\t\texpression: {forEntities: true},\n\t});\n\t/** @param toggle on to update the z component */\n\tupdateZ = ParamConfig.BOOLEAN(0, {\n\t\tvisibleIf: {edit: 1},\n\t});\n\t/** @param expression or value for the z component */\n\tz = ParamConfig.FLOAT('@N.z', {\n\t\tvisibleIf: {updateZ: 1, edit: 1},\n\t\texpression: {forEntities: true},\n\t});\n\n\t/** @param recompute the normals based on the position */\n\trecompute = ParamConfig.BOOLEAN(1, {\n\t\tvisibleIf: {edit: 0},\n\t});\n\t/** @param invert normals */\n\tinvert = ParamConfig.BOOLEAN(0);\n}\nconst ParamsConfig = new NormalsSopParamsConfig();\n\nexport class NormalsSopNode extends TypedSopNode<NormalsSopParamsConfig> {\n\tparams_config = ParamsConfig;\n\tstatic type() {\n\t\treturn 'normals';\n\t}\n\n\tstatic displayedInputNames(): string[] {\n\t\treturn ['geometry to update normals of'];\n\t}\n\tinitializeNode() {\n\t\tthis.io.inputs.setCount(1);\n\t\tthis.io.inputs.initInputsClonedState(InputCloneMode.FROM_NODE);\n\t}\n\n\tasync cook(input_contents: CoreGroup[]) {\n\t\tconst core_group = input_contents[0];\n\n\t\tif (isBooleanTrue(this.pv.edit)) {\n\t\t\tawait this._eval_expressions_for_core_group(core_group);\n\t\t} else {\n\t\t\tif (this.pv.recompute) {\n\t\t\t\tcore_group.computeVertexNormals();\n\t\t\t}\n\t\t}\n\t\tif (isBooleanTrue(this.pv.invert)) {\n\t\t\tthis._invert_normals(core_group);\n\t\t}\n\n\t\tthis.setCoreGroup(core_group);\n\t}\n\n\tprivate async _eval_expressions_for_core_group(core_group: CoreGroup) {\n\t\tconst core_objects = core_group.coreObjects();\n\t\tfor (let i = 0; i < core_objects.length; i++) {\n\t\t\tawait this._eval_expressions_for_core_object(core_objects[i]);\n\t\t}\n\t}\n\tprivate async _eval_expressions_for_core_object(core_object: CoreObject) {\n\t\tconst object = core_object.object();\n\t\tconst geometry = (object as Mesh).geometry as BufferGeometry;\n\t\tconst points = core_object.points();\n\n\t\tlet attrib = geometry.getAttribute(Attribute.NORMAL);\n\t\tif (!attrib) {\n\t\t\tconst core_geometry = new CoreGeometry(geometry);\n\t\t\tcore_geometry.addNumericAttrib(Attribute.NORMAL, 3, 0);\n\t\t\tattrib = geometry.getAttribute(Attribute.NORMAL);\n\t\t}\n\t\tconst array = attrib.array as number[];\n\n\t\t// x\n\t\tif (isBooleanTrue(this.pv.updateX)) {\n\t\t\tif (this.p.x.hasExpression() && this.p.x.expressionController) {\n\t\t\t\tawait this.p.x.expressionController.compute_expression_for_points(points, (point, value) => {\n\t\t\t\t\tarray[point.index() * 3 + 0] = value;\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tlet point;\n\t\t\t\tfor (let i = 0; i < points.length; i++) {\n\t\t\t\t\tpoint = points[i];\n\t\t\t\t\tarray[point.index() * 3 + 0] = this.pv.x;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// y\n\t\tif (isBooleanTrue(this.pv.updateY)) {\n\t\t\tif (this.p.y.hasExpression() && this.p.y.expressionController) {\n\t\t\t\tawait this.p.y.expressionController.compute_expression_for_points(points, (point, value) => {\n\t\t\t\t\tarray[point.index() * 3 + 1] = value;\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tlet point;\n\t\t\t\tfor (let i = 0; i < points.length; i++) {\n\t\t\t\t\tpoint = points[i];\n\t\t\t\t\tarray[point.index() * 3 + 1] = this.pv.y;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// z\n\t\tif (isBooleanTrue(this.pv.updateZ)) {\n\t\t\tif (this.p.z.hasExpression() && this.p.z.expressionController) {\n\t\t\t\tawait this.p.z.expressionController.compute_expression_for_points(points, (point, value) => {\n\t\t\t\t\tarray[point.index() * 3 + 2] = value;\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tlet point;\n\t\t\t\tfor (let i = 0; i < points.length; i++) {\n\t\t\t\t\tpoint = points[i];\n\t\t\t\t\tarray[point.index() * 3 + 2] = this.pv.z;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate _invert_normals(core_group: CoreGroup) {\n\t\tfor (let core_object of core_group.coreObjects()) {\n\t\t\tconst geometry = core_object.coreGeometry()?.geometry();\n\t\t\tif (geometry) {\n\t\t\t\tconst normal_attrib = geometry.attributes[Attribute.NORMAL];\n\t\t\t\tif (normal_attrib) {\n\t\t\t\t\tconst array = normal_attrib.array as number[];\n\t\t\t\t\tfor (let i = 0; i < array.length; i++) {\n\t\t\t\t\t\tarray[i] *= -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n","/**\n * This node does not change the input geometry.\n *\n * @remarks\n * It can still be used to keep a copy of the input geometry, in case downstream nodes were to process it without cloning.\n *\n */\nimport {TypedSopNode} from './_Base';\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {NullSopOperation} from '../../operations/sop/Null';\n\nimport {NodeParamsConfig} from '../utils/params/ParamsConfig';\nclass NullSopParamsConfig extends NodeParamsConfig {}\nconst ParamsConfig = new NullSopParamsConfig();\n\nexport class NullSopNode extends TypedSopNode<NullSopParamsConfig> {\n\tparams_config = ParamsConfig;\n\tstatic type() {\n\t\treturn 'null';\n\t}\n\n\tinitializeNode() {\n\t\tthis.io.inputs.setCount(0, 1);\n\t\tthis.io.inputs.initInputsClonedState(NullSopOperation.INPUT_CLONED_STATE);\n\t\t// this.uiData.set_border_radius(1000);\n\t}\n\n\tprivate _operation: NullSopOperation | undefined;\n\tcook(input_contents: CoreGroup[]) {\n\t\tthis._operation = this._operation || new NullSopOperation(this.scene(), this.states);\n\t\tconst core_group = this._operation.cook(input_contents, this.pv);\n\t\tthis.setCoreGroup(core_group);\n\t}\n}\n","/**\n * Imports an object from another geometry OBJ node.\n *\n * @remarks\n * It can still be used to keep a copy of the input geometry, in case downstream nodes were to process it without cloning.\n *\n */\nimport {TypedSopNode, BaseSopNodeType} from './_Base';\nimport {NodeContext} from '../../poly/NodeContext';\n// import {CoreWalker} from '../../../Core/Walker';\n\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {GeometryContainer} from '../../containers/Geometry';\nclass ObjectMergeSopParamsConfig extends NodeParamsConfig {\n\t/** @param which SOP node to import from */\n\tgeometry = ParamConfig.OPERATOR_PATH('', {\n\t\tnodeSelection: {\n\t\t\tcontext: NodeContext.SOP,\n\t\t},\n\t});\n}\nconst ParamsConfig = new ObjectMergeSopParamsConfig();\n\nexport class ObjectMergeSopNode extends TypedSopNode<ObjectMergeSopParamsConfig> {\n\tparams_config = ParamsConfig;\n\tstatic type() {\n\t\treturn 'objectMerge';\n\t}\n\n\t// _param_apply_parent_transform: boolean\n\tinitializeNode() {}\n\n\tasync cook(input_containers: CoreGroup[]) {\n\t\tconst geometry_node = this.p.geometry.found_node();\n\t\tif (geometry_node) {\n\t\t\tif (geometry_node.nodeContext() == NodeContext.SOP) {\n\t\t\t\tconst container = await geometry_node.requestContainer();\n\t\t\t\tthis.import_input(geometry_node as BaseSopNodeType, container);\n\t\t\t} else {\n\t\t\t\tthis.states.error.set('found node is not a geometry');\n\t\t\t}\n\t\t} else {\n\t\t\tthis.states.error.set(`node not found at path '${this.pv.geometry}'`);\n\t\t}\n\t}\n\n\timport_input(geometry_node: BaseSopNodeType, container: GeometryContainer) {\n\t\tlet core_group;\n\t\t// I unfortunately need to do a clone here,\n\t\t// because if 2 objectmerge nodes import the same geometry,\n\t\t// they would try to place it under 2 different geo nodes\n\t\t// which is not possible\n\t\tif ((core_group = container.coreContentCloned()) != null) {\n\t\t\t// cannot do that until i know how to make it recook\n\t\t\t// when the obj changes\n\t\t\t// if (this._param_apply_parent_transform){\n\t\t\t// \tconst matrix = geometry_node.parent().object().matrixWorld\n\t\t\t// \tgroup.children.forEach(child=>{\n\t\t\t// \t\tconsole.log(child)\n\t\t\t// \t\tconst geometry = child.geometry\n\t\t\t// \t\tif(geometry){\n\t\t\t// \t\t\tgeometry.applyMatrix(matrix)\n\t\t\t// \t\t}\n\t\t\t// \t})\n\t\t\t// }\n\n\t\t\tthis.setCoreGroup(core_group);\n\t\t} else {\n\t\t\tthis.states.error.set('invalid target');\n\t\t}\n\t}\n\n\t// geometry_node() {\n\t// \tif ((this._param_geometry != null) && (this._param_geometry !== '')) {\n\t// \t\tCoreWalker.find_node(this, this._param_geometry);\n\t// \t}\n\t// }\n}\n","import {TypedSopNode} from './_Base';\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {SopOperationContainer, OperationInputsMap} from '../../operations/container/sop';\nimport {OPERATIONS_COMPOSER_NODE_TYPE} from '../../operations/_Base';\nimport {BaseOperationContainer} from '../../operations/container/_Base';\n\nimport {InputCloneMode} from '../../poly/InputCloneMode';\n\nimport {NodeParamsConfig} from '../utils/params/ParamsConfig';\nclass OperationsComposerSopParamConfig extends NodeParamsConfig {}\nconst ParamsConfig = new OperationsComposerSopParamConfig();\n\nexport interface OperationContainerInputConfig {\n\toperation_input_index: number;\n\tnode_input_index: number;\n}\n\nexport class OperationsComposerSopNode extends TypedSopNode<OperationsComposerSopParamConfig> {\n\tparams_config = ParamsConfig;\n\tstatic type() {\n\t\treturn OPERATIONS_COMPOSER_NODE_TYPE;\n\t}\n\n\tinitializeNode() {\n\t\t// the number of inputs will be set from the JsonImporter, when the node is created\n\t\t// since this is when we can know the number of inputs\n\t\t// and creating a large number of max inputs in advance\n\t\t// will result is creating many CoreGraphNodes\n\t\t// this.io.inputs.setCount(0, 2);\n\t\tthis.io.inputs.initInputsClonedState(InputCloneMode.FROM_NODE);\n\t}\n\n\tprivate _output_operation_container: SopOperationContainer | undefined;\n\tprivate _input_configs_by_operation_container: OperationInputsMap = new WeakMap();\n\n\tset_output_operation_container(operation_container: SopOperationContainer) {\n\t\tthis._output_operation_container = operation_container;\n\t}\n\toutput_operation_container() {\n\t\treturn this._output_operation_container;\n\t}\n\tadd_input_config(operation: SopOperationContainer, input_config: OperationContainerInputConfig) {\n\t\tlet existing_map = this._input_configs_by_operation_container.get(operation);\n\t\tif (!existing_map) {\n\t\t\texisting_map = new Map();\n\t\t\tthis._input_configs_by_operation_container.set(operation, existing_map);\n\t\t}\n\t\texisting_map.set(input_config.operation_input_index, input_config.node_input_index);\n\t}\n\n\tprivate _operation_containers_requiring_resolve: BaseOperationContainer[] | undefined;\n\tadd_operation_container_with_path_param_resolve_required(operation_container: BaseOperationContainer) {\n\t\tif (!this._operation_containers_requiring_resolve) {\n\t\t\tthis._operation_containers_requiring_resolve = [];\n\t\t}\n\t\tthis._operation_containers_requiring_resolve.push(operation_container);\n\t}\n\tresolve_operation_containers_path_params() {\n\t\tif (!this._operation_containers_requiring_resolve) {\n\t\t\treturn;\n\t\t}\n\t\tfor (let operation_container of this._operation_containers_requiring_resolve) {\n\t\t\toperation_container.resolve_path_params(this);\n\t\t}\n\t}\n\n\tasync cook(input_contents: CoreGroup[]) {\n\t\tif (this._output_operation_container) {\n\t\t\tthis._output_operation_container.setDirty();\n\n\t\t\tconst core_group = await this._output_operation_container.compute(\n\t\t\t\tinput_contents,\n\t\t\t\tthis._input_configs_by_operation_container\n\t\t\t);\n\t\t\tif (core_group) {\n\t\t\t\tthis.setCoreGroup(core_group);\n\t\t\t}\n\t\t}\n\t}\n}\n","/**\n * Creates a plane.\n *\n * @remarks\n * This node is similar to the Color and Normal SOPs, and can update the vertex positions with expressions\n *\n */\nimport {BufferGeometry} from 'three/src/core/BufferGeometry';\nimport {TypedSopNode} from './_Base';\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {CoreObject} from '../../../core/geometry/Object';\nimport {CorePoint} from '../../../core/geometry/Point';\nimport {InputCloneMode} from '../../poly/InputCloneMode';\nimport {BufferAttribute} from 'three/src/core/BufferAttribute';\nimport {Mesh} from 'three/src/objects/Mesh';\nimport {BooleanParam} from '../../params/Boolean';\nimport {FloatParam} from '../../params/Float';\n\nconst POSITION_ATTRIB_NAME = 'position';\n\ntype ValueArrayByName = Map<string, number[]>;\ntype ComponentOffset = 0 | 1 | 2;\n\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {isBooleanTrue} from '../../../core/BooleanValue';\nclass PointSopParamsConfig extends NodeParamsConfig {\n\t/** @param toggle on to update the x component */\n\tupdateX = ParamConfig.BOOLEAN(0);\n\t/** @param expression the x component */\n\tx = ParamConfig.FLOAT('@P.x', {\n\t\tvisibleIf: {updateX: 1},\n\t\texpression: {forEntities: true},\n\t});\n\t/** @param toggle on to update the y component */\n\tupdateY = ParamConfig.BOOLEAN(0);\n\t/** @param expression the y component */\n\ty = ParamConfig.FLOAT('@P.y', {\n\t\tvisibleIf: {updateY: 1},\n\t\texpression: {forEntities: true},\n\t});\n\t/** @param toggle on to update the z component */\n\tupdateZ = ParamConfig.BOOLEAN(0);\n\t/** @param expression the z component */\n\tz = ParamConfig.FLOAT('@P.z', {\n\t\tvisibleIf: {updateZ: 1},\n\t\texpression: {forEntities: true},\n\t});\n\t/** @param toggle on to update the normals */\n\tupdateNormals = ParamConfig.BOOLEAN(1);\n}\nconst ParamsConfig = new PointSopParamsConfig();\n\nexport class PointSopNode extends TypedSopNode<PointSopParamsConfig> {\n\tparams_config = ParamsConfig;\n\tstatic type() {\n\t\treturn 'point';\n\t}\n\n\tprivate _x_arrays_by_geometry_uuid: ValueArrayByName = new Map();\n\tprivate _y_arrays_by_geometry_uuid: ValueArrayByName = new Map();\n\tprivate _z_arrays_by_geometry_uuid: ValueArrayByName = new Map();\n\n\tstatic displayedInputNames(): string[] {\n\t\treturn ['points to move'];\n\t}\n\n\tinitializeNode() {\n\t\tthis.io.inputs.setCount(1);\n\t\tthis.io.inputs.initInputsClonedState(InputCloneMode.FROM_NODE);\n\t\t// this.uiData.set_icon('dot-circle');\n\t}\n\n\tasync cook(input_contents: CoreGroup[]) {\n\t\tconst core_group = input_contents[0];\n\t\tawait this._eval_expressions_for_core_group(core_group);\n\t}\n\n\t// group.traverse (object)=>\n\t// \tif (geometry = object.geometry)?\n\t// \t\tthis._eval_expressions(geometry)\n\t// \t\tgeometry.computeVertexNormals()\n\n\tasync _eval_expressions_for_core_group(core_group: CoreGroup) {\n\t\tconst core_objects = core_group.coreObjects();\n\t\t// this._allocate_arrays(core_objects)\n\n\t\tfor (let i = 0; i < core_objects.length; i++) {\n\t\t\tawait this._eval_expressions_for_core_object(core_objects[i]);\n\t\t}\n\n\t\tif (isBooleanTrue(this.pv.updateNormals)) {\n\t\t\tcore_group.computeVertexNormals();\n\t\t}\n\n\t\tconst geometries = core_group.geometries();\n\t\tfor (let geometry of geometries) {\n\t\t\tgeometry.computeBoundingBox();\n\t\t}\n\n\t\t// needs update required for when no cloning\n\t\tif (!this.io.inputs.cloneRequired(0)) {\n\t\t\tconst geometries = core_group.geometries();\n\t\t\tfor (let geometry of geometries) {\n\t\t\t\tconst attrib = geometry.getAttribute(POSITION_ATTRIB_NAME) as BufferAttribute;\n\t\t\t\tattrib.needsUpdate = true;\n\t\t\t}\n\t\t}\n\n\t\tthis.setCoreGroup(core_group);\n\t}\n\tasync _eval_expressions_for_core_object(core_object: CoreObject) {\n\t\tconst object = core_object.object();\n\t\tconst geometry = (object as Mesh).geometry as BufferGeometry;\n\t\tconst points = core_object.points();\n\n\t\tconst array = geometry.getAttribute(POSITION_ATTRIB_NAME).array as number[];\n\n\t\tconst tmp_array_x = await this._update_from_param(\n\t\t\tgeometry,\n\t\t\tarray,\n\t\t\tpoints,\n\t\t\tthis.p.updateX,\n\t\t\tthis.p.x,\n\t\t\tthis.pv.x,\n\t\t\tthis._x_arrays_by_geometry_uuid,\n\t\t\t0\n\t\t);\n\t\tconst tmp_array_y = await this._update_from_param(\n\t\t\tgeometry,\n\t\t\tarray,\n\t\t\tpoints,\n\t\t\tthis.p.updateY,\n\t\t\tthis.p.y,\n\t\t\tthis.pv.y,\n\t\t\tthis._y_arrays_by_geometry_uuid,\n\t\t\t1\n\t\t);\n\t\tconst tmp_array_z = await this._update_from_param(\n\t\t\tgeometry,\n\t\t\tarray,\n\t\t\tpoints,\n\t\t\tthis.p.updateZ,\n\t\t\tthis.p.z,\n\t\t\tthis.pv.z,\n\t\t\tthis._z_arrays_by_geometry_uuid,\n\t\t\t2\n\t\t);\n\n\t\tif (tmp_array_x) {\n\t\t\tthis._commit_tmp_values(tmp_array_x, array, 0);\n\t\t}\n\t\tif (tmp_array_y) {\n\t\t\tthis._commit_tmp_values(tmp_array_y, array, 1);\n\t\t}\n\t\tif (tmp_array_z) {\n\t\t\tthis._commit_tmp_values(tmp_array_z, array, 2);\n\t\t}\n\t}\n\n\tprivate async _update_from_param(\n\t\tgeometry: BufferGeometry,\n\t\tarray: number[],\n\t\tpoints: CorePoint[],\n\t\tdo_update_param: BooleanParam,\n\t\tvalue_param: FloatParam,\n\t\tparam_value: number,\n\t\tarrays_by_geometry_uuid: ValueArrayByName,\n\t\toffset: ComponentOffset\n\t) {\n\t\tconst do_update = do_update_param;\n\t\tconst param = value_param;\n\n\t\tlet tmp_array = this._init_array_if_required(geometry, arrays_by_geometry_uuid, points.length, offset);\n\t\tif (do_update.value) {\n\t\t\tif (param.hasExpression() && param.expressionController) {\n\t\t\t\tawait param.expressionController.compute_expression_for_points(points, (point, value) => {\n\t\t\t\t\ttmp_array[point.index()] = value;\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tlet point;\n\t\t\t\tfor (let i = 0; i < points.length; i++) {\n\t\t\t\t\tpoint = points[i];\n\t\t\t\t\ttmp_array[point.index()] = param_value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn tmp_array;\n\t}\n\n\tprivate _init_array_if_required(\n\t\tgeometry: BufferGeometry,\n\t\tarrays_by_geometry_uuid: ValueArrayByName,\n\t\tpoints_count: number,\n\t\toffset: ComponentOffset\n\t) {\n\t\tconst uuid = geometry.uuid;\n\t\tconst current_array = arrays_by_geometry_uuid.get(uuid);\n\t\tif (current_array) {\n\t\t\t// only create new array if we need more point, or as soon as the length is different?\n\t\t\tif (current_array.length < points_count) {\n\t\t\t\tconst new_array = this._array_for_component(geometry, points_count, offset);\n\t\t\t\tarrays_by_geometry_uuid.set(uuid, new_array);\n\t\t\t\treturn new_array;\n\t\t\t} else {\n\t\t\t\treturn current_array;\n\t\t\t}\n\t\t} else {\n\t\t\tconst new_array = this._array_for_component(geometry, points_count, offset);\n\t\t\tarrays_by_geometry_uuid.set(uuid, new_array);\n\t\t\treturn new_array;\n\t\t}\n\t}\n\n\tprivate _array_for_component(geometry: BufferGeometry, points_count: number, offset: ComponentOffset) {\n\t\tconst new_array = new Array<number>(points_count);\n\t\tconst src_array = geometry.getAttribute(POSITION_ATTRIB_NAME).array;\n\t\tfor (let i = 0; i < new_array.length; i++) {\n\t\t\tnew_array[i] = src_array[i * 3 + offset];\n\t\t}\n\t\treturn new_array;\n\t}\n\n\tprivate _commit_tmp_values(tmp_array: number[], target_array: number[], offset: number) {\n\t\tfor (let i = 0; i < tmp_array.length; i++) {\n\t\t\ttarget_array[i * 3 + offset] = tmp_array[i];\n\t\t}\n\t}\n}\n","/**\n * A subnet to create ROP nodes\n *\n */\nimport {Constructor, valueof} from '../../../types/GlobalTypes';\nimport {ParamLessBaseNetworkSopNode} from './_BaseManager';\nimport {NodeContext, NetworkNodeType} from '../../poly/NodeContext';\nimport {RopNodeChildrenMap} from '../../poly/registers/nodes/Rop';\nimport {BaseRopNodeType} from '../rop/_Base';\nimport {ParamsInitData} from '../utils/io/IOController';\n\nexport class RenderersSopNode extends ParamLessBaseNetworkSopNode {\n\tstatic type() {\n\t\treturn NetworkNodeType.ROP;\n\t}\n\n\tprotected _children_controller_context = NodeContext.ROP;\n\n\tcreateNode<S extends keyof RopNodeChildrenMap>(\n\t\tnode_class: S,\n\t\tparams_init_value_overrides?: ParamsInitData\n\t): RopNodeChildrenMap[S];\n\tcreateNode<K extends valueof<RopNodeChildrenMap>>(\n\t\tnode_class: Constructor<K>,\n\t\tparams_init_value_overrides?: ParamsInitData\n\t): K;\n\tcreateNode<K extends valueof<RopNodeChildrenMap>>(\n\t\tnode_class: Constructor<K>,\n\t\tparams_init_value_overrides?: ParamsInitData\n\t): K {\n\t\treturn super.createNode(node_class, params_init_value_overrides) as K;\n\t}\n\tchildren() {\n\t\treturn super.children() as BaseRopNodeType[];\n\t}\n\tnodesByType<K extends keyof RopNodeChildrenMap>(type: K): RopNodeChildrenMap[K][] {\n\t\treturn super.nodesByType(type) as RopNodeChildrenMap[K][];\n\t}\n}\n","import {BaseSopOperation} from './_Base';\nimport {DefaultOperationParams} from '../_Base';\nimport {InputCloneMode} from '../../poly/InputCloneMode';\nimport {CSS2DObject} from '../../../modules/core/objects/CSS2DObject';\nimport {CoreString} from '../../../core/String';\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {CoreType} from '../../../core/Type';\nimport {isBooleanTrue} from '../../../core/BooleanValue';\n\ninterface CSS2DObjectParams {\n\tid: string;\n\tclassName: string;\n\thtml: string;\n}\nconst ATTRIBUTE_NAME = {\n\tid: 'id',\n\tclassName: 'class',\n\thtml: 'html',\n};\n\ninterface CSS2DObjectSopParams extends DefaultOperationParams {\n\tuseIdAttrib: boolean;\n\tid: string;\n\tuseClassAttrib: boolean;\n\tclassName: string;\n\tuseHtmlAttrib: boolean;\n\thtml: string;\n\tcopyAttributes: boolean;\n\tattributesToCopy: string;\n}\n\nexport class CSS2DObjectSopOperation extends BaseSopOperation {\n\tstatic readonly DEFAULT_PARAMS: CSS2DObjectSopParams = {\n\t\tuseIdAttrib: false,\n\t\tid: 'my_css_object',\n\t\tuseClassAttrib: false,\n\t\tclassName: 'CSS2DObject',\n\t\tuseHtmlAttrib: false,\n\t\thtml: '<div>default html</div>',\n\t\tcopyAttributes: false,\n\t\tattributesToCopy: '',\n\t};\n\tstatic readonly INPUT_CLONED_STATE = InputCloneMode.FROM_NODE;\n\tstatic type(): Readonly<'CSS2DObject'> {\n\t\treturn 'CSS2DObject';\n\t}\n\n\tcook(input_contents: CoreGroup[], params: CSS2DObjectSopParams) {\n\t\tconst core_group = input_contents[0];\n\t\tif (core_group) {\n\t\t\tconst objects = this._create_objects_from_input_points(core_group, params);\n\t\t\treturn this.create_core_group_from_objects(objects);\n\t\t} else {\n\t\t\tconst object = this._create_object_from_scratch(params);\n\t\t\treturn this.create_core_group_from_objects([object]);\n\t\t}\n\t}\n\tprivate _create_objects_from_input_points(core_group: CoreGroup, params: CSS2DObjectSopParams) {\n\t\tconst points = core_group.points();\n\t\tconst objects: CSS2DObject[] = [];\n\t\tfor (let point of points) {\n\t\t\tconst id = isBooleanTrue(params.useIdAttrib)\n\t\t\t\t? (point.attribValue(ATTRIBUTE_NAME.id) as string)\n\t\t\t\t: params.className;\n\t\t\tconst className = isBooleanTrue(params.useClassAttrib)\n\t\t\t\t? (point.attribValue(ATTRIBUTE_NAME.className) as string)\n\t\t\t\t: params.className;\n\t\t\tconst html = isBooleanTrue(params.useHtmlAttrib)\n\t\t\t\t? (point.attribValue(ATTRIBUTE_NAME.html) as string)\n\t\t\t\t: params.html;\n\n\t\t\tconst object = CSS2DObjectSopOperation.create_css_object({\n\t\t\t\tid,\n\t\t\t\tclassName,\n\t\t\t\thtml,\n\t\t\t});\n\t\t\tconst element = object.element;\n\t\t\tif (isBooleanTrue(params.copyAttributes)) {\n\t\t\t\tconst attrib_names = CoreString.attribNames(params.attributesToCopy);\n\t\t\t\tfor (let attrib_name of attrib_names) {\n\t\t\t\t\tconst attrib_value = point.attribValue(attrib_name);\n\t\t\t\t\tif (CoreType.isString(attrib_value)) {\n\t\t\t\t\t\telement.setAttribute(attrib_name, attrib_value);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (CoreType.isNumber(attrib_value)) {\n\t\t\t\t\t\t\telement.setAttribute(attrib_name, `${attrib_value}`);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tobject.position.copy(point.position());\n\t\t\tobject.updateMatrix();\n\n\t\t\tobjects.push(object);\n\t\t}\n\t\treturn objects;\n\t}\n\n\tprivate _create_object_from_scratch(params: CSS2DObjectSopParams) {\n\t\tconst object = CSS2DObjectSopOperation.create_css_object({\n\t\t\tid: params.id,\n\t\t\tclassName: params.className,\n\t\t\thtml: params.html,\n\t\t});\n\n\t\treturn object;\n\t}\n\n\tprivate static create_css_object(params: CSS2DObjectParams) {\n\t\tconst element = document.createElement('div');\n\t\telement.id = params.id;\n\t\telement.className = params.className;\n\t\telement.innerHTML = params.html;\n\n\t\tconst object = new CSS2DObject(element);\n\n\t\tobject.matrixAutoUpdate = false;\n\n\t\treturn object;\n\t}\n}\n","import {BaseSopOperation} from './_Base';\nimport {DefaultOperationParams} from '../_Base';\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {Vector3} from 'three/src/math/Vector3';\nimport {ObjectType} from '../../../core/geometry/Constant';\nimport {Object3D} from 'three/src/core/Object3D';\nimport {BufferGeometry} from 'three/src/core/BufferGeometry';\nimport {BufferAttribute, Float32BufferAttribute} from 'three/src/core/BufferAttribute';\nimport {CorePoint} from '../../../core/geometry/Point';\nimport {isBooleanTrue} from '../../../core/BooleanValue';\ninterface AddSopParams extends DefaultOperationParams {\n\t// create point\n\tcreatePoint: boolean;\n\tpointsCount: number;\n\tposition: Vector3;\n\t// connect input points\n\tconnectInputPoints: boolean;\n\t// open: boolean; // creating a polygon when this is closed still needs work\n\tconnectToLastPoint: boolean;\n}\n\nexport class AddSopOperation extends BaseSopOperation {\n\tstatic readonly DEFAULT_PARAMS: AddSopParams = {\n\t\tcreatePoint: true,\n\t\tpointsCount: 1,\n\t\tposition: new Vector3(0, 0, 0),\n\t\tconnectInputPoints: false,\n\t\tconnectToLastPoint: false,\n\t};\n\tstatic type(): Readonly<'add'> {\n\t\treturn 'add';\n\t}\n\n\tcook(input_contents: CoreGroup[], params: AddSopParams) {\n\t\tconst objects: Object3D[] = [];\n\t\tthis._create_point(objects, params);\n\t\tthis._create_polygon(input_contents[0], objects, params);\n\n\t\treturn this.create_core_group_from_objects(objects);\n\t}\n\tprivate _create_point(objects: Object3D[], params: AddSopParams) {\n\t\tif (!isBooleanTrue(params.createPoint)) {\n\t\t\treturn;\n\t\t}\n\t\tconst geometry = new BufferGeometry();\n\t\tconst positions: number[] = [];\n\t\tfor (let i = 0; i < params.pointsCount; i++) {\n\t\t\tparams.position.toArray(positions, i * 3);\n\t\t}\n\t\tgeometry.setAttribute('position', new BufferAttribute(new Float32Array(positions), 3));\n\t\tconst object = this.create_object(geometry, ObjectType.POINTS);\n\n\t\tif (objects) {\n\t\t\tobjects.push(object);\n\t\t}\n\t}\n\n\tprivate _create_polygon(core_group: CoreGroup, objects: Object3D[], params: AddSopParams) {\n\t\tif (!isBooleanTrue(params.connectInputPoints)) {\n\t\t\treturn;\n\t\t}\n\t\tconst points = core_group.points();\n\t\tif (points.length > 0) {\n\t\t\t// const is_polygon_closed = !params.open && points.length >= 3;\n\t\t\t// if (is_polygon_closed) {\n\t\t\t// \tthis._create_polygon_closed(core_group, objects);\n\t\t\t// } else {\n\t\t\tthis._create_polygon_open(core_group, objects, params);\n\t\t\t// }\n\t\t}\n\t}\n\n\t// private _create_polygon_closed(core_group: CoreGroup, objects: Object3D[]) {\n\t// \tconst points = core_group.points();\n\n\t// \tconst geometry = CoreGeometryUtilShape.geometryFromPoints(points.map((p) => p.position()));\n\t// \tconst object = this.create_object(geometry, ObjectType.MESH);\n\t// \tobjects.push(object);\n\t// }\n\n\tprivate _create_polygon_open(core_group: CoreGroup, objects: Object3D[], params: AddSopParams) {\n\t\tconst points = core_group.points();\n\n\t\tlet positions: number[] = [];\n\t\tconst indices: number[] = [];\n\t\tlet point: CorePoint;\n\t\tfor (let i = 0; i < points.length; i++) {\n\t\t\tpoint = points[i];\n\t\t\tpoint.position().toArray(positions, i * 3);\n\t\t\t// positions.push(point.position().toArray());\n\n\t\t\tif (i > 0) {\n\t\t\t\tindices.push(i - 1);\n\t\t\t\tindices.push(i);\n\t\t\t}\n\t\t}\n\n\t\tif (points.length > 2 && params.connectToLastPoint) {\n\t\t\tpoints[0].position().toArray(positions, positions.length);\n\t\t\tconst last_index = indices[indices.length - 1];\n\t\t\tindices.push(last_index);\n\t\t\tindices.push(0);\n\t\t}\n\t\tconst geometry = new BufferGeometry();\n\t\tgeometry.setAttribute('position', new Float32BufferAttribute(positions, 3));\n\t\tgeometry.setIndex(indices);\n\t\tconst object = this.create_object(geometry, ObjectType.LINE_SEGMENTS);\n\t\tobjects.push(object);\n\t}\n}\n","import {BaseSopOperation} from './_Base';\nimport {DefaultOperationParams} from '../_Base';\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {InputCloneMode} from '../../../engine/poly/InputCloneMode';\nimport {BufferAttribute} from 'three/src/core/BufferAttribute';\nimport {BufferGeometry} from 'three/src/core/BufferGeometry';\ninterface AttribAddMultSopParams extends DefaultOperationParams {\n\tname: string;\n\tpreAdd: number;\n\tmult: number;\n\tpostAdd: number;\n}\n\nexport class AttribAddMultSopOperation extends BaseSopOperation {\n\tstatic readonly DEFAULT_PARAMS: AttribAddMultSopParams = {\n\t\tname: '',\n\t\tpreAdd: 0,\n\t\tmult: 1,\n\t\tpostAdd: 0,\n\t};\n\tstatic readonly INPUT_CLONED_STATE = InputCloneMode.FROM_NODE;\n\tstatic type(): Readonly<'attribAddMult'> {\n\t\treturn 'attribAddMult';\n\t}\n\n\tcook(input_contents: CoreGroup[], params: AttribAddMultSopParams) {\n\t\tconst core_group = input_contents[0];\n\t\tconst attrib_names = core_group.attribNamesMatchingMask(params.name);\n\n\t\tfor (let attrib_name of attrib_names) {\n\t\t\tconst geometries = core_group.geometries();\n\t\t\tfor (let geometry of geometries) {\n\t\t\t\tthis._update_attrib(attrib_name, geometry, params);\n\t\t\t}\n\t\t}\n\n\t\treturn core_group;\n\t}\n\tprivate _update_attrib(attrib_name: string, geometry: BufferGeometry, params: AttribAddMultSopParams) {\n\t\tconst attribute = geometry.getAttribute(attrib_name) as BufferAttribute;\n\t\tif (attribute) {\n\t\t\tconst values = attribute.array as number[];\n\n\t\t\tconst preAdd = params.preAdd;\n\t\t\tconst mult = params.mult;\n\t\t\tconst postAdd = params.postAdd;\n\t\t\tfor (let i = 0; i < values.length; i++) {\n\t\t\t\tconst value = values[i];\n\t\t\t\tvalues[i] = (value + preAdd) * mult + postAdd;\n\t\t\t}\n\t\t\t// if (!this.io.inputs.clone_required(0)) {\n\t\t\tattribute.needsUpdate = true;\n\t\t\t// }\n\t\t}\n\t}\n}\n","import {BaseSopOperation} from './_Base';\nimport {DefaultOperationParams} from '../_Base';\nimport {CoreGroup} from '../../../core/geometry/Group';\n\nimport {BufferGeometry} from 'three/src/core/BufferGeometry';\nimport {BufferAttribute, Float32BufferAttribute} from 'three/src/core/BufferAttribute';\nimport {InputCloneMode} from '../../../engine/poly/InputCloneMode';\nimport {isBooleanTrue} from '../../../core/BooleanValue';\ninterface AttribCopySopParams extends DefaultOperationParams {\n\tname: string;\n\ttnewName: boolean;\n\tnewName: string;\n\tsrcOffset: number;\n\tdestOffset: number;\n}\n\nexport class AttribCopySopOperation extends BaseSopOperation {\n\tstatic readonly DEFAULT_PARAMS: AttribCopySopParams = {\n\t\tname: '',\n\t\ttnewName: false,\n\t\tnewName: '',\n\t\tsrcOffset: 0,\n\t\tdestOffset: 0,\n\t};\n\tstatic readonly INPUT_CLONED_STATE = [InputCloneMode.FROM_NODE, InputCloneMode.NEVER];\n\tstatic type(): Readonly<'attribCopy'> {\n\t\treturn 'attribCopy';\n\t}\n\n\tcook(input_contents: CoreGroup[], params: AttribCopySopParams) {\n\t\tconst core_group_dest = input_contents[0];\n\t\tconst core_group_src = input_contents[1] || core_group_dest;\n\n\t\tconst attrib_names = core_group_src.attribNamesMatchingMask(params.name);\n\t\tfor (let attrib_name of attrib_names) {\n\t\t\tthis.copy_vertex_attribute_between_core_groups(core_group_dest, core_group_src, attrib_name, params);\n\t\t}\n\n\t\treturn core_group_dest;\n\t}\n\n\tprivate copy_vertex_attribute_between_core_groups(\n\t\tcore_group_dest: CoreGroup,\n\t\tcore_group_src: CoreGroup,\n\t\tattrib_name: string,\n\t\tparams: AttribCopySopParams\n\t) {\n\t\tconst src_objects = core_group_src.objectsWithGeo();\n\t\tconst dest_objects = core_group_dest.objectsWithGeo();\n\n\t\tif (dest_objects.length > src_objects.length) {\n\t\t\tthis.states?.error.set('second input does not have enough objects to copy attributes from');\n\t\t} else {\n\t\t\tfor (let i = 0; i < dest_objects.length; i++) {\n\t\t\t\tconst dest_geometry = dest_objects[i].geometry;\n\t\t\t\tconst src_geometry = dest_objects[i].geometry;\n\t\t\t\tthis.copy_vertex_attribute_between_geometries(dest_geometry, src_geometry, attrib_name, params);\n\t\t\t}\n\t\t}\n\t}\n\tprivate copy_vertex_attribute_between_geometries(\n\t\tdest_geometry: BufferGeometry,\n\t\tsrc_geometry: BufferGeometry,\n\t\tattrib_name: string,\n\t\tparams: AttribCopySopParams\n\t) {\n\t\tconst src_attrib = src_geometry.getAttribute(attrib_name);\n\t\tif (src_attrib) {\n\t\t\tconst size = src_attrib.itemSize;\n\t\t\tconst src_points_count = src_geometry.getAttribute('position').array.length / 3;\n\t\t\tconst dest_points_count = dest_geometry.getAttribute('position').array.length / 3;\n\t\t\tif (dest_points_count > src_points_count) {\n\t\t\t\tthis.states?.error.set('not enough points in second input');\n\t\t\t}\n\n\t\t\tconst dest_name = isBooleanTrue(params.tnewName) ? params.newName : attrib_name;\n\t\t\tlet dest_attribute = dest_geometry.getAttribute(dest_name);\n\t\t\tif (dest_attribute) {\n\t\t\t\tthis._fill_dest_array(dest_attribute as BufferAttribute, src_attrib as BufferAttribute, params);\n\t\t\t\t(dest_attribute as BufferAttribute).needsUpdate = true;\n\t\t\t} else {\n\t\t\t\tconst src_array = src_attrib.array as number[];\n\t\t\t\tconst dest_array = src_array.slice(0, dest_points_count * size);\n\t\t\t\tdest_geometry.setAttribute(dest_name, new Float32BufferAttribute(dest_array, size));\n\t\t\t}\n\t\t} else {\n\t\t\tthis.states?.error.set(`attribute '${attrib_name}' does not exist on second input`);\n\t\t}\n\t}\n\n\tprivate _fill_dest_array(\n\t\tdest_attribute: BufferAttribute,\n\t\tsrc_attribute: BufferAttribute,\n\t\tparams: AttribCopySopParams\n\t) {\n\t\tconst dest_array = dest_attribute.array as number[];\n\t\tconst src_array = src_attribute.array as number[];\n\t\tconst dest_array_size = dest_array.length;\n\t\tconst dest_item_size = dest_attribute.itemSize;\n\t\tconst src_item_size = src_attribute.itemSize;\n\t\tconst srcOffset = params.srcOffset;\n\t\tconst destOffset = params.destOffset;\n\t\t// if same itemSize, we copy item by item\n\t\tif (dest_attribute.itemSize == src_attribute.itemSize) {\n\t\t\tdest_attribute.copyArray(src_attribute.array);\n\t\t\tfor (let i = 0; i < dest_array_size; i++) {\n\t\t\t\tdest_array[i] = src_array[i];\n\t\t\t}\n\t\t} else {\n\t\t\tconst points_count = dest_array.length / dest_item_size;\n\t\t\tif (dest_item_size < src_item_size) {\n\t\t\t\t// if dest attrib is smaller than src attrib (ie: vector -> to float)\n\t\t\t\t// we copy only the selected items from src\n\t\t\t\tfor (let i = 0; i < points_count; i++) {\n\t\t\t\t\tfor (let j = 0; j < dest_item_size; j++) {\n\t\t\t\t\t\tdest_array[i * dest_item_size + j + destOffset] = src_array[i * src_item_size + j + srcOffset];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// if dest attrib is larger than src attrib (ie: float -> vector )\n\t\t\t\tfor (let i = 0; i < points_count; i++) {\n\t\t\t\t\tfor (let j = 0; j < src_item_size; j++) {\n\t\t\t\t\t\tdest_array[i * dest_item_size + j + destOffset] = src_array[i * src_item_size + j + srcOffset];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n","import {BaseSopOperation} from './_Base';\nimport {DefaultOperationParams} from '../_Base';\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {BufferAttribute} from 'three/src/core/BufferAttribute';\nimport {InputCloneMode} from '../../../engine/poly/InputCloneMode';\nimport {Vector3} from 'three/src/math/Vector3';\nimport {CoreString} from '../../../core/String';\nimport {isBooleanTrue} from '../../../core/BooleanValue';\ninterface AttribNormalizeSopParams extends DefaultOperationParams {\n\tmode: number;\n\tname: string;\n\tchangeName: boolean;\n\tnewName: string;\n}\n\nexport enum NormalizeMode {\n\tMIN_MAX_TO_01 = 'min/max to 0/1',\n\tVECTOR_TO_LENGTH_1 = 'vectors to length 1',\n}\nexport const NORMALIZE_MODES: NormalizeMode[] = [NormalizeMode.MIN_MAX_TO_01, NormalizeMode.VECTOR_TO_LENGTH_1];\n\nexport class AttribNormalizeSopOperation extends BaseSopOperation {\n\tstatic readonly DEFAULT_PARAMS: AttribNormalizeSopParams = {\n\t\tmode: 0,\n\t\tname: 'position',\n\t\tchangeName: false,\n\t\tnewName: '',\n\t};\n\tstatic readonly INPUT_CLONED_STATE = InputCloneMode.FROM_NODE;\n\tstatic type(): Readonly<'attribNormalize'> {\n\t\treturn 'attribNormalize';\n\t}\n\n\tcook(input_contents: CoreGroup[], params: AttribNormalizeSopParams) {\n\t\tconst core_group = input_contents[0];\n\t\tconst objects = input_contents[0].objectsWithGeo();\n\t\tconst attrib_names = CoreString.attribNames(params.name);\n\t\tfor (let object of objects) {\n\t\t\tconst geometry = object.geometry;\n\t\t\tfor (let attrib_name of attrib_names) {\n\t\t\t\tconst src_attrib = geometry.getAttribute(attrib_name) as BufferAttribute;\n\t\t\t\tif (src_attrib) {\n\t\t\t\t\tlet dest_attrib: BufferAttribute | undefined = src_attrib;\n\t\t\t\t\tif (isBooleanTrue(params.changeName) && params.newName != '') {\n\t\t\t\t\t\tdest_attrib = geometry.getAttribute(params.newName) as BufferAttribute;\n\t\t\t\t\t\tif (dest_attrib) {\n\t\t\t\t\t\t\tdest_attrib.needsUpdate = true;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tdest_attrib = dest_attrib || src_attrib.clone();\n\t\t\t\t\t}\n\t\t\t\t\tthis._normalize_attribute(src_attrib, dest_attrib, params);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn core_group;\n\t}\n\tprivate _normalize_attribute(\n\t\tsrc_attrib: BufferAttribute,\n\t\tdest_attrib: BufferAttribute,\n\t\tparams: AttribNormalizeSopParams\n\t) {\n\t\tconst mode = NORMALIZE_MODES[params.mode];\n\t\tswitch (mode) {\n\t\t\tcase NormalizeMode.MIN_MAX_TO_01:\n\t\t\t\treturn this._normalize_from_min_max_to_01(src_attrib, dest_attrib);\n\t\t\tcase NormalizeMode.VECTOR_TO_LENGTH_1:\n\t\t\t\treturn this._normalize_vectors(src_attrib, dest_attrib);\n\t\t}\n\t}\n\n\tprivate min3: Vector3 = new Vector3();\n\tprivate max3: Vector3 = new Vector3();\n\tprivate _normalize_from_min_max_to_01(src_attrib: BufferAttribute, dest_attrib: BufferAttribute) {\n\t\tconst attrib_size = src_attrib.itemSize;\n\t\tconst src_array = src_attrib.array as number[];\n\t\tconst dest_array = dest_attrib.array as number[];\n\t\t// const values = points.map((point) => point.attribValue(params.name));\n\t\tswitch (attrib_size) {\n\t\t\tcase 1: {\n\t\t\t\tconst minf = Math.min(...src_array);\n\t\t\t\tconst maxf = Math.max(...src_array);\n\t\t\t\tfor (let i = 0; i < dest_array.length; i++) {\n\t\t\t\t\tdest_array[i] = (src_array[i] - minf) / (maxf - minf);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tcase 3: {\n\t\t\t\tconst points_count = src_array.length / attrib_size;\n\t\t\t\tconst xs = new Array(points_count);\n\t\t\t\tconst ys = new Array(points_count);\n\t\t\t\tconst zs = new Array(points_count);\n\t\t\t\tlet j = 0;\n\t\t\t\tfor (let i = 0; i < points_count; i++) {\n\t\t\t\t\tj = i * attrib_size;\n\t\t\t\t\txs[i] = src_array[j + 0];\n\t\t\t\t\tys[i] = src_array[j + 1];\n\t\t\t\t\tzs[i] = src_array[j + 2];\n\t\t\t\t}\n\t\t\t\tthis.min3.set(Math.min(...xs), Math.min(...ys), Math.min(...zs));\n\t\t\t\tthis.max3.set(Math.max(...xs), Math.max(...ys), Math.max(...zs));\n\t\t\t\tfor (let i = 0; i < points_count; i++) {\n\t\t\t\t\tj = i * attrib_size;\n\t\t\t\t\tdest_array[j + 0] = (xs[i] - this.min3.x) / (this.max3.x - this.min3.x);\n\t\t\t\t\tdest_array[j + 1] = (ys[i] - this.min3.y) / (this.max3.y - this.min3.y);\n\t\t\t\t\tdest_array[j + 2] = (zs[i] - this.min3.z) / (this.max3.z - this.min3.z);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t// let target_name = params.name;\n\t\t// if (params.changeName) {\n\t\t// \ttarget_name = params.newName;\n\t\t// \tif (!core_group.hasAttrib(target_name)) {\n\t\t// \t\tcore_group.addNumericVertexAttrib(target_name, attrib_size, 0);\n\t\t// \t}\n\t\t// }\n\n\t\t// normalized_values.forEach((normalized_value, i) => {\n\t\t// \tconst point = points[i];\n\t\t// \tpoint.setAttribValue(target_name, normalized_value);\n\t\t// });\n\t}\n\n\tprivate _vec: Vector3 = new Vector3();\n\tprivate _normalize_vectors(src_attrib: BufferAttribute, dest_attrib: BufferAttribute) {\n\t\tconst src_array = src_attrib.array;\n\t\tconst dest_array = dest_attrib.array;\n\n\t\tconst elements_count = src_array.length;\n\t\tif (src_attrib.itemSize == 3) {\n\t\t\tfor (let i = 0; i < elements_count; i += 3) {\n\t\t\t\tthis._vec.fromArray(src_array, i);\n\t\t\t\tthis._vec.normalize();\n\t\t\t\tthis._vec.toArray(dest_array, i);\n\t\t\t}\n\t\t}\n\t}\n}\n","import {BaseSopOperation} from './_Base';\nimport {DefaultOperationParams} from '../_Base';\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {InputCloneMode} from '../../../engine/poly/InputCloneMode';\nimport {AttribClass} from '../../../core/geometry/Constant';\nimport {CoreObject} from '../../../core/geometry/Object';\nimport {CorePoint} from '../../../core/geometry/Point';\nimport {CoreString} from '../../../core/String';\nimport {ArrayUtils} from '../../../core/ArrayUtils';\nimport {NumericAttribValue, PolyDictionary} from '../../../types/GlobalTypes';\nimport {CoreAttribute} from '../../../core/geometry/Attribute';\ninterface AttribPromoteSopParams extends DefaultOperationParams {\n\tclassFrom: number;\n\tclassTo: number;\n\tmode: number;\n\tname: string;\n}\n\nexport enum AttribPromoteMode {\n\tMIN = 0,\n\tMAX = 1,\n\tFIRST_FOUND = 2,\n}\n\nexport class AttribPromoteSopOperation extends BaseSopOperation {\n\tstatic readonly DEFAULT_PARAMS: AttribPromoteSopParams = {\n\t\tclassFrom: AttribClass.VERTEX,\n\t\tclassTo: AttribClass.OBJECT,\n\t\tmode: AttribPromoteMode.FIRST_FOUND,\n\t\tname: '',\n\t};\n\tstatic readonly INPUT_CLONED_STATE = InputCloneMode.FROM_NODE;\n\tstatic type(): Readonly<'attribPromote'> {\n\t\treturn 'attribPromote';\n\t}\n\n\tprivate _core_group: CoreGroup | undefined;\n\tprivate _core_object: CoreObject | undefined;\n\tprivate _values_per_attrib_name: PolyDictionary<NumericAttribValue[]> = {};\n\tprivate _filtered_values_per_attrib_name: PolyDictionary<NumericAttribValue | undefined> = {};\n\tcook(input_contents: CoreGroup[], params: AttribPromoteSopParams) {\n\t\tthis._core_group = input_contents[0];\n\n\t\tthis._values_per_attrib_name = {};\n\t\tthis._filtered_values_per_attrib_name = {};\n\n\t\tfor (let core_object of this._core_group.coreObjects()) {\n\t\t\tthis._core_object = core_object;\n\t\t\tthis.find_values(params);\n\t\t\tthis.filter_values(params);\n\t\t\tthis.set_values(params);\n\t\t}\n\n\t\treturn this._core_group;\n\t}\n\tprivate find_values(params: AttribPromoteSopParams) {\n\t\tconst attrib_names = CoreString.attribNames(params.name);\n\t\tfor (let attrib_name of attrib_names) {\n\t\t\tthis._find_values_for_attrib_name(attrib_name, params);\n\t\t}\n\t}\n\tprivate _find_values_for_attrib_name(attrib_name: string, params: AttribPromoteSopParams) {\n\t\tswitch (params.classFrom) {\n\t\t\tcase AttribClass.VERTEX:\n\t\t\t\treturn this.find_values_from_points(attrib_name, params);\n\t\t\tcase AttribClass.OBJECT:\n\t\t\t\treturn this.find_values_from_object(attrib_name, params);\n\t\t}\n\t}\n\n\tprivate find_values_from_points(attrib_name: string, params: AttribPromoteSopParams) {\n\t\tif (this._core_object) {\n\t\t\tconst points = this._core_object.points();\n\t\t\tconst first_point = points[0];\n\t\t\tif (first_point) {\n\t\t\t\tif (!first_point.isAttribIndexed(attrib_name)) {\n\t\t\t\t\tconst values: NumericAttribValue[] = new Array(points.length);\n\t\t\t\t\tlet point: CorePoint;\n\t\t\t\t\tfor (let i = 0; i < points.length; i++) {\n\t\t\t\t\t\tpoint = points[i];\n\t\t\t\t\t\tvalues[i] = point.attribValue(attrib_name) as NumericAttribValue;\n\t\t\t\t\t}\n\t\t\t\t\tthis._values_per_attrib_name[attrib_name] = values;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate find_values_from_object(attrib_name: string, params: AttribPromoteSopParams) {\n\t\tthis._values_per_attrib_name[attrib_name] = [];\n\t\tif (this._core_object) {\n\t\t\tthis._values_per_attrib_name[attrib_name].push(this._core_object.attribValue(attrib_name) as number);\n\t\t}\n\t}\n\n\tprivate filter_values(params: AttribPromoteSopParams) {\n\t\tconst attrib_names = Object.keys(this._values_per_attrib_name);\n\t\tfor (let attrib_name of attrib_names) {\n\t\t\tconst values = this._values_per_attrib_name[attrib_name];\n\t\t\tswitch (params.mode) {\n\t\t\t\tcase AttribPromoteMode.MIN:\n\t\t\t\t\tthis._filtered_values_per_attrib_name[attrib_name] = ArrayUtils.min(values);\n\t\t\t\t\tbreak;\n\t\t\t\tcase AttribPromoteMode.MAX:\n\t\t\t\t\tthis._filtered_values_per_attrib_name[attrib_name] = ArrayUtils.max(values);\n\t\t\t\t\tbreak;\n\t\t\t\tcase AttribPromoteMode.FIRST_FOUND:\n\t\t\t\t\tthis._filtered_values_per_attrib_name[attrib_name] = values[0];\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate set_values(params: AttribPromoteSopParams) {\n\t\tconst attrib_names = Object.keys(this._filtered_values_per_attrib_name);\n\t\tfor (let attrib_name of attrib_names) {\n\t\t\tconst new_value = this._filtered_values_per_attrib_name[attrib_name];\n\t\t\tif (new_value != null) {\n\t\t\t\tswitch (params.classTo) {\n\t\t\t\t\tcase AttribClass.VERTEX:\n\t\t\t\t\t\tthis.set_values_to_points(attrib_name, new_value, params);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase AttribClass.OBJECT:\n\t\t\t\t\t\tthis.set_values_to_object(attrib_name, new_value, params);\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate set_values_to_points(attrib_name: string, new_value: NumericAttribValue, params: AttribPromoteSopParams) {\n\t\tif (this._core_group && this._core_object) {\n\t\t\tconst attribute_exists = this._core_group.hasAttrib(attrib_name);\n\t\t\tif (!attribute_exists) {\n\t\t\t\tconst attribSize = CoreAttribute.attribSizeFromValue(new_value);\n\t\t\t\tif (attribSize) {\n\t\t\t\t\tthis._core_group.addNumericVertexAttrib(attrib_name, attribSize, new_value);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst points = this._core_object.points();\n\t\t\tfor (let point of points) {\n\t\t\t\tpoint.setAttribValue(attrib_name, new_value);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate set_values_to_object(attrib_name: string, new_value: NumericAttribValue, params: AttribPromoteSopParams) {\n\t\tthis._core_object?.setAttribValue(attrib_name, new_value);\n\t}\n}\n","import {BaseSopOperation} from './_Base';\nimport {DefaultOperationParams} from '../_Base';\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {Vector3} from 'three/src/math/Vector3';\nimport {ObjectType} from '../../../core/geometry/Constant';\nimport {InputCloneMode} from '../../../engine/poly/InputCloneMode';\nimport {BufferAttribute} from 'three/src/core/BufferAttribute';\nimport {BufferGeometry} from 'three/src/core/BufferGeometry';\n\ninterface CenterSopParams extends DefaultOperationParams {}\n\nexport class CenterSopOperation extends BaseSopOperation {\n\tstatic readonly DEFAULT_PARAMS: CenterSopParams = {};\n\tstatic readonly INPUT_CLONED_STATE = InputCloneMode.FROM_NODE;\n\tstatic type(): Readonly<'center'> {\n\t\treturn 'center';\n\t}\n\n\tprivate _geo_center: Vector3 = new Vector3();\n\tcook(input_contents: CoreGroup[], params: CenterSopParams) {\n\t\tconst core_group = input_contents[0];\n\t\tconst src_objects = core_group.objectsWithGeo();\n\n\t\tconst positions = new Array(src_objects.length * 3);\n\t\tpositions.fill(0);\n\t\tfor (let i = 0; i < src_objects.length; i++) {\n\t\t\tconst src_object = src_objects[i];\n\t\t\tconst src_geometry = src_object.geometry;\n\t\t\tsrc_geometry.computeBoundingBox();\n\t\t\tif (src_geometry.boundingBox) {\n\t\t\t\tsrc_geometry.boundingBox?.getCenter(this._geo_center);\n\t\t\t\tsrc_object.updateMatrixWorld();\n\t\t\t\tthis._geo_center.applyMatrix4(src_object.matrixWorld);\n\t\t\t\tthis._geo_center.toArray(positions, i * 3);\n\t\t\t}\n\t\t}\n\t\tconst geometry = new BufferGeometry();\n\t\tgeometry.setAttribute('position', new BufferAttribute(new Float32Array(positions), 3));\n\t\tconst object = this.create_object(geometry, ObjectType.POINTS);\n\t\treturn this.create_core_group_from_objects([object]);\n\t}\n}\n","import {BaseSopOperation} from './_Base';\nimport {DefaultOperationParams} from '../_Base';\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {TypedNodePathParamValue} from '../../../core/Walker';\nimport {GlobalsGeometryHandler} from '../../../engine/nodes/gl/code/globals/Geometry';\nimport {BufferGeometry} from 'three/src/core/BufferGeometry';\nimport {ObjectTypeByObject} from '../../../core/geometry/Constant';\nimport {CoreMaterial} from '../../../core/geometry/Material';\nimport {NodeContext} from '../../../engine/poly/NodeContext';\nimport {CoreInstancer} from '../../../core/geometry/Instancer';\nimport {BaseBuilderMatNodeType} from '../../../engine/nodes/mat/_BaseBuilder';\nimport {Mesh} from 'three/src/objects/Mesh';\nimport {Material} from 'three/src/materials/Material';\nimport {InputCloneMode} from '../../../engine/poly/InputCloneMode';\nimport {isBooleanTrue} from '../../../core/BooleanValue';\n\ninterface InstanceSopParams extends DefaultOperationParams {\n\tattributesToCopy: string;\n\tapplyMaterial: boolean;\n\tmaterial: TypedNodePathParamValue;\n}\n\nexport class InstanceSopOperation extends BaseSopOperation {\n\tstatic readonly DEFAULT_PARAMS: InstanceSopParams = {\n\t\tattributesToCopy: 'instance*',\n\t\tapplyMaterial: true,\n\t\tmaterial: new TypedNodePathParamValue(''),\n\t};\n\tstatic readonly INPUT_CLONED_STATE = [InputCloneMode.ALWAYS, InputCloneMode.NEVER];\n\tstatic type(): Readonly<'instance'> {\n\t\treturn 'instance';\n\t}\n\n\tprivate _globals_handler: GlobalsGeometryHandler | undefined;\n\tprivate _geometry: BufferGeometry | undefined;\n\n\tasync cook(input_contents: CoreGroup[], params: InstanceSopParams) {\n\t\tconst core_group_to_instance = input_contents[0];\n\t\tthis._geometry = undefined;\n\n\t\tconst object_to_instance = core_group_to_instance.objectsWithGeo()[0];\n\t\tif (object_to_instance) {\n\t\t\tconst geometry_to_instance = object_to_instance.geometry;\n\t\t\tif (geometry_to_instance) {\n\t\t\t\tconst core_group = input_contents[1];\n\t\t\t\tthis._create_instance(geometry_to_instance, core_group, params);\n\t\t\t}\n\t\t}\n\n\t\tif (this._geometry) {\n\t\t\tconst type = ObjectTypeByObject(object_to_instance);\n\t\t\tif (type) {\n\t\t\t\tconst object = this.create_object(this._geometry, type);\n\n\t\t\t\tif (isBooleanTrue(params.applyMaterial)) {\n\t\t\t\t\tconst material = await this._get_material(params);\n\t\t\t\t\tif (material) {\n\t\t\t\t\t\tawait this._applyMaterial(object as Mesh, material);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn this.create_core_group_from_objects([object]);\n\t\t\t}\n\t\t}\n\t\treturn this.create_core_group_from_objects([]);\n\t}\n\n\tprivate async _get_material(params: InstanceSopParams) {\n\t\tif (isBooleanTrue(params.applyMaterial)) {\n\t\t\tconst material_node = params.material.ensure_node_context(NodeContext.MAT, this.states?.error);\n\t\t\tif (material_node) {\n\t\t\t\tthis._globals_handler = this._globals_handler || new GlobalsGeometryHandler();\n\t\t\t\tconst mat_builder_node = material_node as BaseBuilderMatNodeType;\n\t\t\t\tconst matNodeAssemblerController = mat_builder_node.assemblerController;\n\t\t\t\tif (matNodeAssemblerController) {\n\t\t\t\t\tmatNodeAssemblerController.set_assembler_globals_handler(this._globals_handler);\n\t\t\t\t}\n\n\t\t\t\tconst container = await material_node.requestContainer();\n\t\t\t\tconst material = container.material();\n\t\t\t\treturn material;\n\t\t\t}\n\t\t}\n\t}\n\n\tasync _applyMaterial(object: Mesh, material: Material) {\n\t\tobject.material = material;\n\t\tCoreMaterial.apply_custom_materials(object, material);\n\t}\n\n\tprivate _create_instance(\n\t\tgeometry_to_instance: BufferGeometry,\n\t\ttemplate_core_group: CoreGroup,\n\t\tparams: InstanceSopParams\n\t) {\n\t\tthis._geometry = CoreInstancer.create_instance_buffer_geo(\n\t\t\tgeometry_to_instance,\n\t\t\ttemplate_core_group,\n\t\t\tparams.attributesToCopy\n\t\t);\n\t}\n}\n","import {BaseSopOperation} from './_Base';\nimport {DefaultOperationParams} from '../_Base';\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {TypedNodePathParamValue} from '../../../core/Walker';\nimport {NodeContext} from '../../../engine/poly/NodeContext';\nimport {BaseBuilderMatNodeType} from '../../../engine/nodes/mat/_BaseBuilder';\nimport {CoreMaterial} from '../../../core/geometry/Material';\nimport {Object3D} from 'three/src/core/Object3D';\nimport {Material} from 'three/src/materials/Material';\nimport {Mesh} from 'three/src/objects/Mesh';\nimport {Texture} from 'three/src/textures/Texture';\nimport {GlobalsGeometryHandler} from '../../../engine/nodes/gl/code/globals/Geometry';\nimport {InputCloneMode} from '../../../engine/poly/InputCloneMode';\nimport {ShaderMaterial} from 'three/src/materials/ShaderMaterial';\nimport {CoreObject} from '../../../core/geometry/Object';\nimport {isBooleanTrue} from '../../../core/BooleanValue';\n\ninterface MaterialSopParams extends DefaultOperationParams {\n\tgroup: string;\n\tassignMat: boolean;\n\tmaterial: TypedNodePathParamValue;\n\tapplyToChildren: boolean;\n\tcloneMat: boolean;\n\tshareUniforms: boolean;\n\tswapCurrentTex: boolean;\n\ttexSrc0: string;\n\ttexDest0: string;\n}\n\nexport class MaterialSopOperation extends BaseSopOperation {\n\tstatic readonly DEFAULT_PARAMS: MaterialSopParams = {\n\t\tgroup: '',\n\t\tassignMat: true,\n\t\tmaterial: new TypedNodePathParamValue('/MAT/mesh_standard1'),\n\t\tapplyToChildren: true,\n\t\tcloneMat: false,\n\t\tshareUniforms: true,\n\t\tswapCurrentTex: false,\n\t\ttexSrc0: 'emissiveMap',\n\t\ttexDest0: 'map',\n\t};\n\tstatic readonly INPUT_CLONED_STATE = InputCloneMode.FROM_NODE;\n\tstatic type(): Readonly<'material'> {\n\t\treturn 'material';\n\t}\n\n\tprivate _globals_handler: GlobalsGeometryHandler = new GlobalsGeometryHandler();\n\n\tasync cook(input_contents: CoreGroup[], params: MaterialSopParams) {\n\t\tconst core_group = input_contents[0];\n\n\t\tthis._old_mat_by_old_new_id.clear();\n\n\t\tawait this._apply_materials(core_group, params);\n\t\tthis._swap_textures(core_group, params);\n\t\treturn core_group;\n\t}\n\n\tprivate async _apply_materials(core_group: CoreGroup, params: MaterialSopParams) {\n\t\tif (!isBooleanTrue(params.assignMat)) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst material_node = params.material.ensure_node_context(NodeContext.MAT, this.states?.error);\n\t\tif (material_node) {\n\t\t\tconst material = material_node.material;\n\t\t\tconst assembler_controller = (material_node as BaseBuilderMatNodeType).assemblerController;\n\t\t\tif (assembler_controller) {\n\t\t\t\tassembler_controller.set_assembler_globals_handler(this._globals_handler);\n\t\t\t}\n\n\t\t\tawait material_node.requestContainer();\n\t\t\tif (material) {\n\t\t\t\tif (isBooleanTrue(params.applyToChildren)) {\n\t\t\t\t\t// if we apply to children, the group will be tested inside _apply_material\n\t\t\t\t\tfor (let object of core_group.objects()) {\n\t\t\t\t\t\tobject.traverse((grand_child) => {\n\t\t\t\t\t\t\tthis._apply_material(grand_child, material, params);\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// if we apply to children, the group is tested here\n\t\t\t\t\tfor (let object of core_group.objectsFromGroup(params.group)) {\n\t\t\t\t\t\tthis._apply_material(object, material, params);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn core_group;\n\t\t\t} else {\n\t\t\t\tthis.states?.error.set(`material invalid. (error: '${material_node.states.error.message()}')`);\n\t\t\t}\n\t\t} else {\n\t\t\tthis.states?.error.set(`no material node found`);\n\t\t}\n\t}\n\n\tprivate _old_mat_by_old_new_id: Map<string, Material> = new Map();\n\tprivate _materials_by_uuid: Map<string, Material> = new Map();\n\tprivate _swap_textures(core_group: CoreGroup, params: MaterialSopParams) {\n\t\tif (!isBooleanTrue(params.swapCurrentTex)) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._materials_by_uuid.clear();\n\n\t\tfor (let object of core_group.objectsFromGroup(params.group)) {\n\t\t\tif (params.applyToChildren) {\n\t\t\t\tobject.traverse((child) => {\n\t\t\t\t\tconst mat = (object as Mesh).material as Material;\n\t\t\t\t\tthis._materials_by_uuid.set(mat.uuid, mat);\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tconst mat = (object as Mesh).material as Material;\n\t\t\t\tthis._materials_by_uuid.set(mat.uuid, mat);\n\t\t\t}\n\t\t}\n\n\t\tthis._materials_by_uuid.forEach((mat, mat_uuid) => {\n\t\t\tthis._swap_texture(mat, params);\n\t\t});\n\t}\n\n\tprivate _apply_material(object: Object3D, src_material: Material, params: MaterialSopParams) {\n\t\tif (params.group) {\n\t\t\tif (!CoreObject.isInGroup(params.group, object)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tconst used_material = isBooleanTrue(params.cloneMat) ? CoreMaterial.clone(src_material) : src_material;\n\n\t\tif (src_material instanceof ShaderMaterial && used_material instanceof ShaderMaterial) {\n\t\t\tfor (let uniform_name in src_material.uniforms) {\n\t\t\t\tused_material.uniforms[uniform_name] = src_material.uniforms[uniform_name];\n\t\t\t}\n\t\t}\n\n\t\tconst object_with_material = object as Mesh;\n\t\t// const current_mat = object_with_material.material as Material | undefined;\n\t\t// if (current_mat && params.swapCurrentTex) {\n\t\t// \tthis._swap_texture(used_material, current_mat, params);\n\t\t// }\n\t\tthis._old_mat_by_old_new_id.set(used_material.uuid, object_with_material.material as Material);\n\t\tobject_with_material.material = used_material;\n\n\t\tCoreMaterial.apply_render_hook(object, used_material);\n\t\tCoreMaterial.apply_custom_materials(object, used_material);\n\t}\n\n\tprivate _swap_texture(target_mat: Material, params: MaterialSopParams) {\n\t\tif (params.texSrc0 == '' || params.texDest0 == '') {\n\t\t\treturn;\n\t\t}\n\t\tlet src_mat = this._old_mat_by_old_new_id.get(target_mat.uuid);\n\t\tsrc_mat = src_mat || target_mat;\n\n\t\tconst src_tex: Texture | null = (src_mat as any)[params.texSrc0];\n\t\tif (src_tex) {\n\t\t\t// swap mat param\n\t\t\t(target_mat as any)[params.texDest0] = src_tex;\n\t\t\t// (src_mat as any)[params.texSrc0] = null;\n\t\t\t// swap uniforms\n\t\t\tconst uniforms = (target_mat as any).uniforms;\n\t\t\tif (uniforms) {\n\t\t\t\tconst uniforms_map = uniforms[params.texDest0];\n\t\t\t\tif (uniforms_map) {\n\t\t\t\t\tuniforms[params.texDest0] = {value: src_tex};\n\t\t\t\t\t// uniforms[params.texSrc0] = {value: null};\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n","import {BaseSopOperation} from './_Base';\nimport {DefaultOperationParams} from '../_Base';\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {Object3D} from 'three/src/core/Object3D';\nimport {InputCloneMode} from '../../../engine/poly/InputCloneMode';\nimport {isBooleanTrue} from '../../../core/BooleanValue';\n\ninterface ObjectPropertiesSopParams extends DefaultOperationParams {\n\tapplyToChildren: boolean;\n\t// name\n\ttname: boolean;\n\tname: string;\n\t// renderOrder\n\ttrenderOrder: boolean;\n\trenderOrder: number;\n\t// frustumCulled\n\ttfrustumCulled: boolean;\n\tfrustumCulled: boolean;\n\t// matrixAutoUpdate\n\ttmatrixAutoUpdate: boolean;\n\tmatrixAutoUpdate: boolean;\n\t// visible\n\ttvisible: boolean;\n\tvisible: boolean;\n\t// castShadow\n\ttcastShadow: boolean;\n\tcastShadow: boolean;\n\t// receiveShadow\n\ttreceiveShadow: boolean;\n\treceiveShadow: boolean;\n}\n\nexport class ObjectPropertiesSopOperation extends BaseSopOperation {\n\tstatic readonly DEFAULT_PARAMS: ObjectPropertiesSopParams = {\n\t\tapplyToChildren: false,\n\t\t// name\n\t\ttname: false,\n\t\tname: '',\n\t\t// renderOrder\n\t\ttrenderOrder: false,\n\t\trenderOrder: 0,\n\t\t// frustrumCulled\n\t\ttfrustumCulled: false,\n\t\tfrustumCulled: true,\n\t\t// matrixAutoUpdate\n\t\ttmatrixAutoUpdate: false,\n\t\tmatrixAutoUpdate: false,\n\t\t// visible\n\t\ttvisible: false,\n\t\tvisible: true,\n\t\t// castShadow\n\t\ttcastShadow: false,\n\t\tcastShadow: true,\n\t\t// receiveShadow\n\t\ttreceiveShadow: false,\n\t\treceiveShadow: true,\n\t};\n\tstatic readonly INPUT_CLONED_STATE = InputCloneMode.FROM_NODE;\n\tstatic type(): Readonly<'objectProperties'> {\n\t\treturn 'objectProperties';\n\t}\n\n\tcook(input_contents: CoreGroup[], params: ObjectPropertiesSopParams) {\n\t\tconst core_group = input_contents[0];\n\n\t\tfor (let object of core_group.objects()) {\n\t\t\tif (params.applyToChildren) {\n\t\t\t\tobject.traverse((child) => {\n\t\t\t\t\tthis._update_object(child, params);\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tthis._update_object(object, params);\n\t\t\t}\n\t\t}\n\n\t\treturn core_group;\n\t}\n\tprivate _update_object(object: Object3D, params: ObjectPropertiesSopParams) {\n\t\tif (isBooleanTrue(params.tname)) {\n\t\t\tobject.name = params.name;\n\t\t}\n\t\tif (isBooleanTrue(params.trenderOrder)) {\n\t\t\tobject.renderOrder = params.renderOrder;\n\t\t}\n\t\tif (isBooleanTrue(params.tfrustumCulled)) {\n\t\t\tobject.frustumCulled = params.frustumCulled;\n\t\t}\n\t\tif (isBooleanTrue(params.tmatrixAutoUpdate)) {\n\t\t\tobject.matrixAutoUpdate = params.matrixAutoUpdate;\n\t\t}\n\t\tif (isBooleanTrue(params.tvisible)) {\n\t\t\tobject.visible = params.visible;\n\t\t}\n\t\tif (isBooleanTrue(params.tcastShadow)) {\n\t\t\tobject.castShadow = params.castShadow;\n\t\t}\n\t\tif (isBooleanTrue(params.treceiveShadow)) {\n\t\t\tobject.receiveShadow = params.receiveShadow;\n\t\t}\n\t}\n}\n","import {BaseSopOperation} from './_Base';\nimport {DefaultOperationParams} from '../_Base';\nimport {Vector2} from 'three/src/math/Vector2';\nimport {Vector3} from 'three/src/math/Vector3';\nimport {PlaneBufferGeometry} from 'three/src/geometries/PlaneGeometry';\nimport {CoreTransform} from '../../../core/Transform';\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {InputCloneMode} from '../../../engine/poly/InputCloneMode';\nimport {isBooleanTrue} from '../../../core/BooleanValue';\n\ninterface PlaneSopParams extends DefaultOperationParams {\n\tsize: Vector2;\n\tuseSegmentsCount: boolean;\n\tstepSize: number;\n\tsegments: Vector2;\n\tdirection: Vector3;\n\tcenter: Vector3;\n}\nconst DEFAULT_UP = new Vector3(0, 0, 1);\nconst ROTATE_START = new Vector3(0, 0, 1);\nconst ROTATE_END = new Vector3(0, 1, 0);\n\nexport class PlaneSopOperation extends BaseSopOperation {\n\tstatic readonly DEFAULT_PARAMS: PlaneSopParams = {\n\t\tsize: new Vector2(1, 1),\n\t\tuseSegmentsCount: false,\n\t\tstepSize: 1,\n\t\tsegments: new Vector2(1, 1),\n\t\tdirection: new Vector3(0, 1, 0),\n\t\tcenter: new Vector3(0, 0, 0),\n\t};\n\tstatic readonly INPUT_CLONED_STATE = InputCloneMode.NEVER;\n\tstatic type(): Readonly<'plane'> {\n\t\treturn 'plane';\n\t}\n\n\tprivate _core_transform = new CoreTransform();\n\n\tcook(input_contents: CoreGroup[], params: PlaneSopParams) {\n\t\tconst core_group = input_contents[0];\n\t\tif (core_group) {\n\t\t\treturn this._cook_with_input(core_group, params);\n\t\t} else {\n\t\t\treturn this._cook_without_input(params);\n\t\t}\n\t}\n\tprivate _cook_without_input(params: PlaneSopParams) {\n\t\tconst geometry = this._create_plane(params.size, params);\n\n\t\t// convert to buffer geo, as some render problems can occur otherwise\n\t\t// geometry = BufferGeometryUtils.mergeBufferGeometries([geometry])\n\t\t// console.log(geometry, geometry.isBufferGeometry)\n\t\tthis._core_transform.rotate_geometry(geometry, DEFAULT_UP, params.direction);\n\n\t\tconst matrix = this._core_transform.translation_matrix(params.center);\n\t\tgeometry.applyMatrix4(matrix);\n\n\t\treturn this.create_core_group_from_geometry(geometry);\n\t}\n\tprivate _cook_with_input(core_group: CoreGroup, params: PlaneSopParams) {\n\t\tconst bbox = core_group.boundingBox();\n\t\tconst size = new Vector3();\n\t\tbbox.getSize(size);\n\t\tconst center = new Vector3();\n\t\tbbox.getCenter(center);\n\n\t\t// TODO: rotate the input geo to get the accurate bbox\n\t\tconst size2d = new Vector2(size.x, size.z);\n\t\tconst geometry = this._create_plane(size2d, params);\n\n\t\tthis._core_transform.rotate_geometry(geometry, ROTATE_START, ROTATE_END);\n\n\t\tconst matrix = this._core_transform.translation_matrix(center);\n\t\tgeometry.applyMatrix4(matrix);\n\n\t\treturn this.create_core_group_from_geometry(geometry);\n\t}\n\n\tprivate _create_plane(size: Vector2, params: PlaneSopParams) {\n\t\tlet segments_count = new Vector2(1, 1);\n\t\tsize = size.clone();\n\t\tif (isBooleanTrue(params.useSegmentsCount)) {\n\t\t\tsegments_count.x = Math.floor(params.segments.x);\n\t\t\tsegments_count.y = Math.floor(params.segments.y);\n\t\t} else {\n\t\t\tif (params.stepSize > 0) {\n\t\t\t\tsegments_count.x = Math.floor(size.x / params.stepSize);\n\t\t\t\tsegments_count.y = Math.floor(size.y / params.stepSize);\n\t\t\t\tsize.x = segments_count.x * params.stepSize;\n\t\t\t\tsize.y = segments_count.y * params.stepSize;\n\t\t\t}\n\t\t}\n\t\treturn new PlaneBufferGeometry(size.x, size.y, segments_count.x, segments_count.y);\n\t}\n}\n","import {BaseSopOperation} from './_Base';\nimport {CoreGroup, Object3DWithGeometry} from '../../../core/geometry/Group';\nimport {Vector3} from 'three/src/math/Vector3';\nimport {Matrix4} from 'three/src/math/Matrix4';\nimport {Object3D} from 'three/src/core/Object3D';\nimport {TypeAssert} from '../../../engine/poly/Assert';\nimport {DefaultOperationParams} from '../_Base';\n\nimport {TransformTargetType, TRANSFORM_TARGET_TYPES} from '../../../core/Transform';\nimport {InputCloneMode} from '../../../engine/poly/InputCloneMode';\nimport {Quaternion} from 'three/src/math/Quaternion';\nimport {MathUtils} from 'three';\n\nconst AXIS_VERTICAL = new Vector3(0, 1, 0);\nconst AXIS_HORIZONTAL = new Vector3(-1, 0, 0);\n\ninterface PolarTransformSopParams extends DefaultOperationParams {\n\tapplyOn: number;\n\tcenter: Vector3;\n\tlongitude: number;\n\tlatitude: number;\n\tdepth: number;\n}\n\nexport class PolarTransformSopOperation extends BaseSopOperation {\n\tstatic readonly DEFAULT_PARAMS: PolarTransformSopParams = {\n\t\tapplyOn: TRANSFORM_TARGET_TYPES.indexOf(TransformTargetType.GEOMETRIES),\n\t\tcenter: new Vector3(0, 0, 0),\n\t\tlongitude: 0,\n\t\tlatitude: 0,\n\t\tdepth: 1,\n\t};\n\tstatic readonly INPUT_CLONED_STATE = InputCloneMode.FROM_NODE;\n\tstatic type(): Readonly<'polarTransform'> {\n\t\treturn 'polarTransform';\n\t}\n\n\tcook(input_contents: CoreGroup[], params: PolarTransformSopParams) {\n\t\tconst objects = input_contents[0].objects();\n\t\tconst matrix = this.matrix(params);\n\n\t\tthis._apply_transform(objects, params, matrix);\n\n\t\treturn input_contents[0];\n\t}\n\tprivate _apply_transform(objects: Object3D[], params: PolarTransformSopParams, matrix: Matrix4) {\n\t\tconst mode = TRANSFORM_TARGET_TYPES[params.applyOn];\n\t\tswitch (mode) {\n\t\t\tcase TransformTargetType.GEOMETRIES: {\n\t\t\t\treturn this._apply_matrix_to_geometries(objects, matrix);\n\t\t\t}\n\t\t\tcase TransformTargetType.OBJECTS: {\n\t\t\t\treturn this._apply_matrix_to_objects(objects, matrix);\n\t\t\t}\n\t\t}\n\t\tTypeAssert.unreachable(mode);\n\t}\n\n\tprivate _apply_matrix_to_geometries(objects: Object3D[], matrix: Matrix4) {\n\t\tfor (let object of objects) {\n\t\t\tconst geometry = (object as Object3DWithGeometry).geometry;\n\t\t\tif (geometry) {\n\t\t\t\tgeometry.applyMatrix4(matrix);\n\t\t\t}\n\t\t}\n\t}\n\tprivate _apply_matrix_to_objects(objects: Object3D[], matrix: Matrix4) {\n\t\tfor (let object of objects) {\n\t\t\tmatrix.decompose(this._decomposed.t, this._decomposed.q, this._decomposed.s);\n\t\t\tobject.position.copy(this._decomposed.t);\n\t\t\tobject.quaternion.copy(this._decomposed.q);\n\t\t\tobject.scale.copy(this._decomposed.s);\n\t\t\tobject.updateMatrix();\n\t\t}\n\t}\n\n\tprivate _centerMatrix = new Matrix4();\n\tprivate _longitudeMatrix = new Matrix4();\n\tprivate _latitudeMatrix = new Matrix4();\n\tprivate _depthMatrix = new Matrix4();\n\tprivate _fullMatrix = new Matrix4();\n\tprivate _decomposed = {\n\t\tt: new Vector3(),\n\t\tq: new Quaternion(),\n\t\ts: new Vector3(),\n\t};\n\tmatrix(params: PolarTransformSopParams) {\n\t\tthis._centerMatrix.identity();\n\t\tthis._longitudeMatrix.identity();\n\t\tthis._latitudeMatrix.identity();\n\t\tthis._depthMatrix.identity();\n\t\tthis._centerMatrix.makeTranslation(params.center.x, params.center.y, params.center.z);\n\t\tthis._longitudeMatrix.makeRotationAxis(AXIS_VERTICAL, MathUtils.degToRad(params.longitude));\n\t\tthis._latitudeMatrix.makeRotationAxis(AXIS_HORIZONTAL, MathUtils.degToRad(params.latitude));\n\t\tthis._depthMatrix.makeTranslation(0, 0, params.depth);\n\t\tthis._fullMatrix\n\t\t\t.copy(this._centerMatrix)\n\t\t\t.multiply(this._longitudeMatrix)\n\t\t\t.multiply(this._latitudeMatrix)\n\t\t\t.multiply(this._depthMatrix);\n\n\t\treturn this._fullMatrix;\n\t}\n}\n","import {BaseSopOperation} from './_Base';\nimport {DefaultOperationParams} from '../_Base';\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {SphereBufferGeometry} from 'three/src/geometries/SphereGeometry';\nimport {IcosahedronBufferGeometry} from 'three/src/geometries/IcosahedronGeometry';\nimport {Vector2} from 'three/src/math/Vector2';\nimport {Vector3} from 'three/src/math/Vector3';\nimport {InputCloneMode} from '../../../engine/poly/InputCloneMode';\nimport {isBooleanTrue} from '../../../core/BooleanValue';\n\ninterface SphereSopParams extends DefaultOperationParams {\n\ttype: number;\n\tradius: number;\n\tresolution: Vector2;\n\topen: boolean;\n\tphiStart: number;\n\tphiLength: number;\n\tthetaStart: number;\n\tthetaLength: number;\n\tdetail: number;\n\tcenter: Vector3;\n}\n\nenum SphereType {\n\tDEFAULT = 'default',\n\tISOCAHEDRON = 'isocahedron',\n}\ntype SphereTypes = {[key in SphereType]: number};\nexport const SPHERE_TYPE: SphereTypes = {\n\tdefault: 0,\n\tisocahedron: 1,\n};\nexport const SPHERE_TYPES: Array<SphereType> = [SphereType.DEFAULT, SphereType.ISOCAHEDRON];\n\nexport class SphereSopOperation extends BaseSopOperation {\n\tstatic readonly DEFAULT_PARAMS: SphereSopParams = {\n\t\ttype: SPHERE_TYPE.default,\n\t\tradius: 1,\n\t\tresolution: new Vector2(30, 30),\n\t\topen: false,\n\t\tphiStart: 0,\n\t\tphiLength: Math.PI * 2,\n\t\tthetaStart: 0,\n\t\tthetaLength: Math.PI,\n\t\tdetail: 1,\n\t\tcenter: new Vector3(0, 0, 0),\n\t};\n\tstatic readonly INPUT_CLONED_STATE = InputCloneMode.FROM_NODE;\n\tstatic type(): Readonly<'sphere'> {\n\t\treturn 'sphere';\n\t}\n\n\tcook(input_contents: CoreGroup[], params: SphereSopParams) {\n\t\tconst core_group = input_contents[0];\n\t\tif (core_group) {\n\t\t\treturn this._cook_with_input(core_group, params);\n\t\t} else {\n\t\t\treturn this._cook_without_input(params);\n\t\t}\n\t}\n\tprivate _cook_without_input(params: SphereSopParams) {\n\t\tconst geometry = this._create_required_geometry(params);\n\t\tgeometry.translate(params.center.x, params.center.y, params.center.z);\n\t\treturn this.create_core_group_from_geometry(geometry);\n\t}\n\tprivate _cook_with_input(core_group: CoreGroup, params: SphereSopParams) {\n\t\tconst bbox = core_group.boundingBox();\n\t\tconst size = bbox.max.clone().sub(bbox.min);\n\t\tconst center = bbox.max.clone().add(bbox.min).multiplyScalar(0.5);\n\n\t\tconst geometry = this._create_required_geometry(params);\n\t\tgeometry.translate(params.center.x, params.center.y, params.center.z);\n\t\tgeometry.translate(center.x, center.y, center.z);\n\t\tgeometry.scale(size.x, size.y, size.z);\n\t\treturn this.create_core_group_from_geometry(geometry);\n\t}\n\n\tprivate _create_required_geometry(params: SphereSopParams) {\n\t\tif (params.type == SPHERE_TYPE.default) {\n\t\t\treturn this._create_default_sphere(params);\n\t\t} else {\n\t\t\treturn this._create_default_isocahedron(params);\n\t\t}\n\t}\n\n\tprivate _create_default_sphere(params: SphereSopParams) {\n\t\tif (isBooleanTrue(params.open)) {\n\t\t\treturn new SphereBufferGeometry(\n\t\t\t\tparams.radius,\n\t\t\t\tparams.resolution.x,\n\t\t\t\tparams.resolution.y,\n\t\t\t\tparams.phiStart,\n\t\t\t\tparams.phiLength,\n\t\t\t\tparams.thetaStart,\n\t\t\t\tparams.thetaLength\n\t\t\t);\n\t\t} else {\n\t\t\treturn new SphereBufferGeometry(params.radius, params.resolution.x, params.resolution.y);\n\t\t}\n\t}\n\t_create_default_isocahedron(params: SphereSopParams) {\n\t\treturn new IcosahedronBufferGeometry(params.radius, params.detail);\n\t}\n}\n","import {BaseSopOperation} from './_Base';\nimport {CoreGroup, Object3DWithGeometry} from '../../../core/geometry/Group';\nimport {Vector3} from 'three/src/math/Vector3';\nimport {Matrix4} from 'three/src/math/Matrix4';\nimport {Object3D} from 'three/src/core/Object3D';\nimport {TypeAssert} from '../../../engine/poly/Assert';\nimport {DefaultOperationParams} from '../_Base';\n\nimport {\n\tCoreTransform,\n\tROTATION_ORDERS,\n\tRotationOrder,\n\tTransformTargetType,\n\tTRANSFORM_TARGET_TYPES,\n} from '../../../core/Transform';\nimport {InputCloneMode} from '../../../engine/poly/InputCloneMode';\n\ninterface TransformSopParams extends DefaultOperationParams {\n\tapplyOn: number;\n\tgroup: string;\n\trotationOrder: number;\n\tt: Vector3;\n\tr: Vector3;\n\ts: Vector3;\n\tscale: number;\n\tpivot: Vector3;\n}\n\nexport class TransformSopOperation extends BaseSopOperation {\n\tstatic readonly DEFAULT_PARAMS: TransformSopParams = {\n\t\tapplyOn: TRANSFORM_TARGET_TYPES.indexOf(TransformTargetType.GEOMETRIES),\n\t\tgroup: '',\n\t\trotationOrder: ROTATION_ORDERS.indexOf(RotationOrder.XYZ),\n\t\tt: new Vector3(0, 0, 0),\n\t\tr: new Vector3(0, 0, 0),\n\t\ts: new Vector3(1, 1, 1),\n\t\tscale: 1,\n\t\tpivot: new Vector3(0, 0, 0),\n\t};\n\tstatic readonly INPUT_CLONED_STATE = InputCloneMode.FROM_NODE;\n\tstatic type(): Readonly<'transform'> {\n\t\treturn 'transform';\n\t}\n\n\tprivate _core_transform = new CoreTransform();\n\tcook(input_contents: CoreGroup[], params: TransformSopParams) {\n\t\tconst objects = input_contents[0].objects();\n\t\tconst matrix = this._core_transform.matrix(\n\t\t\tparams.t,\n\t\t\tparams.r,\n\t\t\tparams.s,\n\t\t\tparams.scale,\n\t\t\tROTATION_ORDERS[params.rotationOrder]\n\t\t);\n\n\t\tthis._apply_transform(objects, params, matrix);\n\n\t\treturn input_contents[0];\n\t}\n\tprivate _apply_transform(objects: Object3D[], params: TransformSopParams, matrix: Matrix4) {\n\t\tconst mode = TRANSFORM_TARGET_TYPES[params.applyOn];\n\t\tswitch (mode) {\n\t\t\tcase TransformTargetType.GEOMETRIES: {\n\t\t\t\treturn this._apply_matrix_to_geometries(objects, params, matrix);\n\t\t\t}\n\t\t\tcase TransformTargetType.OBJECTS: {\n\t\t\t\treturn this._apply_matrix_to_objects(objects, matrix);\n\t\t\t}\n\t\t}\n\t\tTypeAssert.unreachable(mode);\n\t}\n\n\tprivate _point_pos = new Vector3();\n\tprivate _apply_matrix_to_geometries(objects: Object3D[], params: TransformSopParams, matrix: Matrix4) {\n\t\tif (params.group.trim() === '') {\n\t\t\tfor (let object of objects) {\n\t\t\t\tconst geometry = (object as Object3DWithGeometry).geometry;\n\t\t\t\tif (geometry) {\n\t\t\t\t\tgeometry.translate(-params.pivot.x, -params.pivot.y, -params.pivot.z);\n\t\t\t\t\tgeometry.applyMatrix4(matrix);\n\t\t\t\t\tgeometry.translate(params.pivot.x, params.pivot.y, params.pivot.z);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tconst core_group = CoreGroup._fromObjects(objects);\n\t\t\tconst points = core_group.pointsFromGroup(params.group);\n\t\t\tfor (let point of points) {\n\t\t\t\tconst position = point.getPosition(this._point_pos).sub(params.pivot);\n\t\t\t\tposition.applyMatrix4(matrix);\n\t\t\t\tpoint.setPosition(position.add(params.pivot));\n\t\t\t}\n\t\t}\n\t}\n\tprivate _object_position = new Vector3();\n\tprivate _apply_matrix_to_objects(objects: Object3D[], matrix: Matrix4) {\n\t\tfor (let object of objects) {\n\t\t\t// center to origin\n\t\t\tthis._object_position.copy(object.position);\n\t\t\tobject.position.multiplyScalar(0);\n\t\t\tobject.updateMatrix();\n\t\t\t// apply matrix\n\t\t\tobject.applyMatrix4(matrix);\n\t\t\t// revert to position\n\t\t\tobject.position.add(this._object_position);\n\t\t\tobject.updateMatrix();\n\t\t}\n\t}\n}\n","import {CoreWalker} from '../../../core/Walker';\nimport {DecomposedPath} from '../../../core/DecomposedPath';\nimport {BaseParamType} from '../../params/_Base';\nimport {BaseNodeType} from '../../nodes/_Base';\nimport {MethodDependency} from '../MethodDependency';\nimport {CoreGraphNode} from '../../../core/graph/CoreGraphNode';\nimport {BaseContainer} from '../../containers/_Base';\nimport {ContainerMap} from '../../containers/utils/ContainerMap';\nimport {NodeContext} from '../../poly/NodeContext';\nimport {Poly} from '../../Poly';\nimport {CoreType} from '../../../core/Type';\n\nexport class BaseMethod {\n\tprotected _require_dependency = false;\n\trequire_dependency() {\n\t\treturn this._require_dependency;\n\t}\n\n\tconstructor(public readonly param: BaseParamType) {}\n\t// the node is not fetched from the param in the constructor,\n\t// since the param may not have a node yet, especially when the param's value\n\t// is set on node creation\n\tprivate _node: BaseNodeType | undefined;\n\tprotected node(): BaseNodeType | undefined {\n\t\treturn (this._node = this._node || this.param.node);\n\t}\n\n\tstatic required_arguments(): any[] {\n\t\tconsole.warn('Expression.Method._Base.required_arguments virtual method call. Please override');\n\t\treturn [];\n\t}\n\tstatic optional_arguments(): any[] {\n\t\treturn [];\n\t}\n\tstatic min_allowed_arguments_count() {\n\t\treturn this.required_arguments().length;\n\t}\n\tstatic max_allowed_arguments_count() {\n\t\treturn this.min_allowed_arguments_count() + this.optional_arguments().length;\n\t}\n\tstatic allowed_arguments_count(count: number) {\n\t\treturn count >= this.min_allowed_arguments_count() && count <= this.max_allowed_arguments_count();\n\t}\n\n\tprocess_arguments(args: any): Promise<any> {\n\t\tthrow 'Expression.Method._Base.process_arguments virtual method call. Please override';\n\t}\n\n\tasync get_referenced_node_container(index_or_path: number | string): Promise<BaseContainer> {\n\t\tconst referenced_node = this.get_referenced_node(index_or_path);\n\n\t\tif (referenced_node) {\n\t\t\t// const time_start = performance.now();\n\t\t\tlet container: ContainerMap[NodeContext];\n\t\t\tif (referenced_node.isDirty()) {\n\t\t\t\tcontainer = await referenced_node.requestContainer();\n\t\t\t} else {\n\t\t\t\tcontainer = referenced_node.containerController.container;\n\t\t\t}\n\t\t\tif (container) {\n\t\t\t\tconst core_group = container.coreContent();\n\t\t\t\tif (core_group) {\n\t\t\t\t\treturn container;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthrow `referenced node invalid: ${referenced_node.fullPath()}`;\n\t\t} else {\n\t\t\tthrow `invalid input (${index_or_path})`;\n\t\t}\n\t}\n\n\tget_referenced_param(path: string, decomposed_path?: DecomposedPath): BaseParamType | null {\n\t\tconst node = this.node();\n\t\tif (node) {\n\t\t\treturn CoreWalker.find_param(node, path, decomposed_path);\n\t\t}\n\n\t\t// if (referenced_param != null) {\n\n\t\t// \tif (this.update_dependencies_mode()) {\n\n\t\t// \t\t//param_connect_result = this.param().addGraphInput(referenced_param)\n\t\t// \t\tconst expression_node_connect_result = this.jsep_node()._graph_node.addGraphInput(referenced_param);\n\t\t// \t\t//if !(param_connect_result && expression_node_connect_result)\n\t\t// \t\tif (!expression_node_connect_result) {\n\t\t// \t\t\tthrow \"cannot create infinite graph\";\n\t\t// \t\t}\n\t\t// \t}\n\n\t\t// } else {\n\t\t// \tthrow `no param found for argument ${path}`;\n\t\t// }\n\n\t\treturn null;\n\t}\n\n\tfind_referenced_graph_node(index_or_path: number | string, decomposed_path?: DecomposedPath): CoreGraphNode | null {\n\t\tconst is_index = CoreType.isNumber(index_or_path);\n\t\t// let node\n\t\tif (is_index) {\n\t\t\tconst index = index_or_path as number;\n\t\t\tconst node = this.node();\n\t\t\tif (node) {\n\t\t\t\tconst input_graph_node = node.io.inputs.input_graph_node(index);\n\t\t\t\treturn input_graph_node;\n\t\t\t}\n\t\t} else {\n\t\t\tconst path = index_or_path as string;\n\t\t\treturn this.get_referenced_node(path, decomposed_path);\n\t\t}\n\t\treturn null;\n\t}\n\t// caching the node by path here prevents having expressions such as points_count(0)\n\t// evaluate to an error when the input is disconnected\n\t// private _node_by_path: Map<string | number, BaseNodeType | null | undefined> = new Map();\n\tget_referenced_node(index_or_path: string | number, decomposed_path?: DecomposedPath): BaseNodeType | null {\n\t\t// let node = this._node_by_path.get(index_or_path);\n\t\t// if (node) {\n\t\t// \treturn node;\n\t\t// } else {\n\t\tlet node: BaseNodeType | null = null;\n\t\tconst current_node = this.node();\n\t\tif (CoreType.isString(index_or_path)) {\n\t\t\tif (current_node) {\n\t\t\t\tconst path = index_or_path;\n\t\t\t\tnode = CoreWalker.find_node(current_node, path, decomposed_path);\n\t\t\t}\n\t\t} else {\n\t\t\tif (current_node) {\n\t\t\t\tconst index = index_or_path;\n\t\t\t\tnode = current_node.io.inputs.input(index);\n\t\t\t}\n\t\t}\n\t\t// this._node_by_path.set(index_or_path, node);\n\t\treturn node || null;\n\t\t//}\n\t}\n\n\tfind_dependency(args: any): MethodDependency | null {\n\t\treturn null;\n\t}\n\n\tprotected create_dependency_from_index_or_path(index_or_path: number | string): MethodDependency | null {\n\t\tconst decomposed_path = new DecomposedPath();\n\t\tconst node = this.find_referenced_graph_node(index_or_path, decomposed_path);\n\t\tif (node) {\n\t\t\treturn this.create_dependency(node, index_or_path, decomposed_path);\n\t\t} else {\n\t\t\tPoly.warn('node not found for path', index_or_path);\n\t\t}\n\t\treturn null;\n\t}\n\tprotected create_dependency(\n\t\tnode: CoreGraphNode,\n\t\tindex_or_path: number | string,\n\t\tdecomposed_path?: DecomposedPath\n\t): MethodDependency | null {\n\t\tconst dependency = MethodDependency.create(this.param, index_or_path, node, decomposed_path);\n\t\treturn dependency;\n\t}\n}\n","/**\n * Returns the bbox of a geometry, or a component of the bbox.\n *\n * @remarks\n * It takes 1, 2 or 3 arguments.\n *\n * bbox(<input_index_or_node_path\\>, <bbox_vector\\>, <vector_component\\>)\n *\n * - **<input_index_or_node_path\\>** is a number or a string\n * - **<bbox_vector\\>** is a string, either 'min' or 'max'\n * - **<vector_component\\>** is a string, either 'x', 'y' or 'z'\n *\n * ## Usage\n *\n * - `bbox(0)` - returns the bbox of the input node, as a THREE.Box3\n * - `bbox('/geo1/box')` - returns the bbox of the node /geo1/box, as a THREE.Box3\n * - `bbox('/geo1/box', 'min')` - returns the min vector of the bbox, as a THREE.Vector3\n * - `bbox('/geo1/box', 'min', 'x')` - returns the x component of min vector of the bbox, as a number\n *\n */\nimport {BaseMethod} from './_Base';\nimport {MethodDependency} from '../MethodDependency';\nimport {Vector3} from 'three/src/math/Vector3';\nimport {GeometryContainer} from '../../containers/Geometry';\nimport {Vector3Like} from '../../../types/GlobalTypes';\nimport {Box3} from 'three/src/math/Box3';\n\ninterface BoxComponents {\n\tmin: Vector3;\n\tmax: Vector3;\n\tsize: Vector3;\n\tcenter: Vector3;\n}\n\nconst VECTOR_NAMES: Array<keyof BoxComponents> = ['min', 'max', 'size', 'center'];\nconst COMPONENT_NAMES = ['x', 'y', 'z'];\n\nexport class BboxExpression extends BaseMethod {\n\tprotected _require_dependency = true;\n\tstatic required_arguments() {\n\t\treturn [\n\t\t\t['string', 'path to node'],\n\t\t\t['string', 'vector name, min, max, size or center'],\n\t\t\t['string', 'component_name, x,y or z'],\n\t\t];\n\t}\n\n\tfind_dependency(index_or_path: number | string): MethodDependency | null {\n\t\treturn this.create_dependency_from_index_or_path(index_or_path);\n\t}\n\n\tprocess_arguments(args: any[]): Promise<any> {\n\t\tlet value: number | Vector3 | Box3 = 0;\n\t\treturn new Promise(async (resolve, reject) => {\n\t\t\tif (args.length >= 1) {\n\t\t\t\tconst index_or_path = args[0];\n\t\t\t\tconst vector_name: undefined | keyof BoxComponents = args[1];\n\t\t\t\tconst component_name: undefined | keyof Vector3Like = args[2];\n\n\t\t\t\tlet container: GeometryContainer | null = null;\n\t\t\t\ttry {\n\t\t\t\t\tcontainer = (await this.get_referenced_node_container(index_or_path)) as GeometryContainer;\n\t\t\t\t} catch (e) {\n\t\t\t\t\treject(e);\n\t\t\t\t}\n\t\t\t\tif (container) {\n\t\t\t\t\tvalue = this._get_value_from_container(container, vector_name, component_name);\n\t\t\t\t\tresolve(value);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tresolve(0);\n\t\t\t}\n\t\t});\n\t}\n\n\tprivate _get_value_from_container(\n\t\tcontainer: GeometryContainer,\n\t\tvector_name: undefined | keyof BoxComponents,\n\t\tcomponent_name: undefined | keyof Vector3Like\n\t) {\n\t\tconst bbox = container.boundingBox();\n\t\tif (!vector_name) {\n\t\t\treturn bbox;\n\t\t}\n\t\tif (VECTOR_NAMES.indexOf(vector_name) >= 0) {\n\t\t\tlet vector = new Vector3();\n\t\t\tswitch (vector_name) {\n\t\t\t\tcase 'size':\n\t\t\t\t\tbbox.getSize(vector);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'center':\n\t\t\t\t\tbbox.getCenter(vector);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tvector = bbox[vector_name];\n\t\t\t}\n\n\t\t\tif (!component_name) {\n\t\t\t\treturn vector;\n\t\t\t}\n\n\t\t\tif (COMPONENT_NAMES.indexOf(component_name) >= 0) {\n\t\t\t\treturn vector[component_name];\n\t\t\t} else {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t}\n}\n","/**\n * Returns the centroid of a geometry, or the component of the centroid.\n *\n * @remarks\n * It takes 1 or 2 arguments.\n *\n * centroid(<input_index_or_node_path\\>, <vector_component\\>)\n *\n * - **<input_index_or_node_path\\>** is a number or a string\n * - **<vector_component\\>** is a string, either 'x', 'y' or 'z'\n *\n * ## Usage\n *\n * - `centroid(0)` - returns the centroid of the input node, as a THREE.Box3\n * - `centroid('/geo1/box')` - returns the centroid of the node /geo1/box, as a THREE.Box3\n * - `centroid('/geo1/box', 'x')` - returns the x component of centroid of the bbox, as a number\n *\n */\nimport {BaseMethod} from './_Base';\nimport {MethodDependency} from '../MethodDependency';\nimport {GeometryContainer} from '../../containers/Geometry';\nimport {Vector3Like} from '../../../types/GlobalTypes';\nexport class CentroidExpression extends BaseMethod {\n\tprotected _require_dependency = true;\n\tstatic required_arguments() {\n\t\treturn [\n\t\t\t['string', 'path to node'],\n\t\t\t['string', 'component_name, x,y or z'],\n\t\t];\n\t}\n\n\tfind_dependency(index_or_path: number | string): MethodDependency | null {\n\t\treturn this.create_dependency_from_index_or_path(index_or_path);\n\t}\n\n\tprocess_arguments(args: any[]): Promise<any> {\n\t\treturn new Promise(async (resolve, reject) => {\n\t\t\tif (args.length >= 1) {\n\t\t\t\tconst index_or_path = args[0];\n\t\t\t\tconst component_name: undefined | keyof Vector3Like = args[1];\n\t\t\t\tlet container: GeometryContainer | null = null;\n\t\t\t\ttry {\n\t\t\t\t\tcontainer = (await this.get_referenced_node_container(index_or_path)) as GeometryContainer;\n\t\t\t\t} catch (e) {\n\t\t\t\t\treject(e);\n\t\t\t\t}\n\n\t\t\t\tif (container) {\n\t\t\t\t\tconst bbox = container.boundingBox();\n\t\t\t\t\tconst center = bbox.min.clone().add(bbox.max).multiplyScalar(0.5);\n\n\t\t\t\t\tif (component_name) {\n\t\t\t\t\t\tconst value = center[component_name];\n\t\t\t\t\t\tif (value != null) {\n\t\t\t\t\t\t\tresolve(value);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresolve(0);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresolve(center);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tresolve(0);\n\t\t\t}\n\t\t});\n\t}\n}\n","/**\n * Returns the value of another parameter\n *\n * @remarks\n * It takes 1 argument, the path to the parameter.\n *\n * ch(<param_path\\>)\n *\n * - **<param_path\\>** is a string, which can be the absolute or relative path\n *\n * ## Usage\n *\n * - `ch('./tx')` - returns the value of the parameter tx of the same node\n * - `ch('/geo1/tx')` - returns the value of the tx of the node /geo1\n *\n */\nimport {BaseMethod} from './_Base';\nimport {DecomposedPath} from '../../../core/DecomposedPath';\nimport {MethodDependency} from '../MethodDependency';\n\nexport class ChExpression extends BaseMethod {\n\tprotected _require_dependency = true;\n\n\tstatic required_arguments() {\n\t\treturn [['string', 'path to param']];\n\t}\n\n\tfind_dependency(index_or_path: number | string): MethodDependency | null {\n\t\tconst decomposed_path = new DecomposedPath();\n\t\tconst param = this.get_referenced_param(index_or_path as string, decomposed_path);\n\t\tif (param) {\n\t\t\treturn this.create_dependency(param, index_or_path, decomposed_path);\n\t\t}\n\t\treturn null;\n\t}\n\n\tasync process_arguments(args: any[]): Promise<any> {\n\t\treturn new Promise(async (resolve, reject) => {\n\t\t\tlet val: any = 0;\n\t\t\tif (args.length == 1) {\n\t\t\t\tconst path = args[0];\n\t\t\t\tconst ref = this.get_referenced_param(path);\n\t\t\t\tif (ref) {\n\t\t\t\t\tif (ref.isDirty()) {\n\t\t\t\t\t\tawait ref.compute();\n\t\t\t\t\t}\n\t\t\t\t\tconst result = ref.value;\n\t\t\t\t\tif (result != null) {\n\t\t\t\t\t\t// if (CoreType.isNumber(result)) {\n\t\t\t\t\t\tval = result;\n\t\t\t\t\t\tresolve(val);\n\t\t\t\t\t\t// }\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\treject(0);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n}\n","/**\n * The copy expression allows the copy SOP node to evaluates its input graph multiple times, and vary its result each time.\n *\n * @remarks\n * It takes 2 or 3 arguments\n *\n * copy(<input_index_or_node_path\\>, <default_value/>, <attribute_name/>)\n *\n * - **<input_index_or_node_path\\>** is a number or a string\n * - **<default_value\\>** is a number\n * - **<attribute_name\\>** is the attribute that will be stamped\n *\n * ## Usage\n *\n * - `copy('../copy1', 0, 'i')` - returns the index of each evaluation\n *\n */\nimport {BaseMethod} from './_Base';\nimport {MethodDependency} from '../MethodDependency';\nimport {CoreWalker} from '../../../core/Walker';\nimport {CopySopNode} from '../../nodes/sop/Copy';\nimport {BaseNodeType} from '../../nodes/_Base';\n\nexport class CopyExpression extends BaseMethod {\n\tprotected _require_dependency = true;\n\tstatic required_arguments() {\n\t\treturn [\n\t\t\t['string', 'path to copy'],\n\t\t\t['integer', 'default value'],\n\t\t];\n\t}\n\tstatic optional_arguments() {\n\t\treturn [['string', 'attribute name (optional)']];\n\t}\n\n\tfind_dependency(index_or_path: number | string): MethodDependency | null {\n\t\tconst node = this.find_referenced_graph_node(index_or_path) as BaseNodeType;\n\t\t// I'd prefer testing with if(node instanceof CopySopNode)\n\t\t// but tslib generates an error when doing so\n\t\tif (node && node.type() == 'copy') {\n\t\t\tconst stamp_node = (node as CopySopNode).stamp_node;\n\t\t\treturn this.create_dependency(stamp_node, index_or_path);\n\t\t}\n\t\treturn null;\n\t}\n\t// find_dependencies(index_or_path: number|string): ReferenceSearchResult{\n\t// \t// return this.find_node_dependency_from_index_or_path(index_or_path)\n\t// \tconst node = this.find_dependency_from_index_or_path(index_or_path)\n\t// \treturn this.create_search_result(stamp_node, index_or_path)\n\t// }\n\n\tprocess_arguments(args: any[]): Promise<any> {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tif (args.length == 2 || args.length == 3) {\n\t\t\t\tconst path = args[0];\n\t\t\t\tconst default_value = args[1];\n\t\t\t\tconst attribute_name = args[2];\n\n\t\t\t\tconst current_node = this.node();\n\t\t\t\tconst node = current_node ? CoreWalker.find_node(current_node, path) : null;\n\n\t\t\t\tlet value;\n\t\t\t\tif (node && node.type() == CopySopNode.type()) {\n\t\t\t\t\tvalue = (node as CopySopNode).stamp_value(attribute_name);\n\t\t\t\t}\n\t\t\t\t// if (node && node instanceof CopySopNode) {\n\t\t\t\t// \tvalue = node.stamp_value(attribute_name);\n\t\t\t\t// }\n\n\t\t\t\tif (value == null) {\n\t\t\t\t\tvalue = default_value;\n\t\t\t\t}\n\t\t\t\tresolve(value);\n\t\t\t} else {\n\t\t\t\tresolve(0);\n\t\t\t}\n\t\t});\n\t}\n\t// update_dependencies() {\n\t// \treturn this.jsep_node()._graph_node.addGraphInput( this.copy_sop.stamp_node() );\n\t// }\n\n\t// process_arguments(args, callback){\n\t// \tconst path = args[0];\n\t// \tconst default_value = args[1];\n\t// \tconst attribute_name = args[2];\n\n\t// \tthis.copy_sop = Walker.find_node(this.node(), path);\n\t// \tlet value = (this.copy_sop != null) ?\n\t// \t\tthis.copy_sop.stamp_value(attribute_name) : undefined;\n\n\t// \tif (value == null) { value = default_value; }\n\n\t// \treturn callback(value);\n\t// }\n}\n","/**\n * Returns the resolution of a texture of a COP node.\n *\n * @remarks\n * It takes 1 or 2 arguments\n *\n * copRes(<input_index_or_node_path\\>, <vector_component/>)\n *\n * - **<input_index_or_node_path\\>** is a number or a string\n * - **<vector_component\\>** is a string or number, either 'x', 'y', 0 or 1\n *\n * ## Usage\n *\n * - `copRes('/COP/image1')` - returns the size of the texture, as a THREE.Vector2\n * - `copRes('/COP/image1', 'x')` - returns the x component of the size of the texture, as a number\n *\n */\nimport {BaseMethod} from './_Base';\nimport {MethodDependency} from '../MethodDependency';\nimport {TextureContainer} from '../../containers/Texture';\n\nexport class CopResExpression extends BaseMethod {\n\tprotected _require_dependency = true;\n\tstatic required_arguments() {\n\t\treturn [\n\t\t\t['string', 'path to node'],\n\t\t\t['string', 'component_name: x or y'],\n\t\t];\n\t}\n\n\tfind_dependency(index_or_path: number | string): MethodDependency | null {\n\t\treturn this.create_dependency_from_index_or_path(index_or_path);\n\t}\n\n\tasync process_arguments(args: any[]): Promise<number> {\n\t\tlet value = 0;\n\t\tif (args.length == 2) {\n\t\t\tconst index_or_path = args[0];\n\t\t\tconst component_name = args[1];\n\t\t\tconst container = (await this.get_referenced_node_container(index_or_path)) as TextureContainer;\n\n\t\t\tif (container) {\n\t\t\t\tconst resolution = container.resolution();\n\t\t\t\tif ([0, '0', 'x'].includes(component_name)) {\n\t\t\t\t\tvalue = resolution[0];\n\t\t\t\t} else {\n\t\t\t\t\tif ([1, '1', 'y'].includes(component_name)) {\n\t\t\t\t\t\tvalue = resolution[1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn value;\n\t}\n}\n","/**\n * The js expression allows to execute a javascript expression. This is very useful when you have specific requirements that are not addressed by the expressions available here.\n *\n * @remarks\n * It takes 1 arguments.\n *\n * js(<js_expression\\>)\n *\n * - **<js_expression\\>** is a a string\n *\n * ## Usage\n *\n * - `js('Date.now()')` - returns the current time.\n *\n */\nimport {BaseMethod} from './_Base';\nexport class JsExpression extends BaseMethod {\n\tprivate _function: Function | undefined;\n\n\tstatic required_arguments() {\n\t\treturn [['string', 'javascript expression']];\n\t}\n\n\tasync process_arguments(args: any[]): Promise<any> {\n\t\tlet val: any = 0;\n\t\tif (args.length == 1) {\n\t\t\tconst arg = args[0];\n\t\t\tthis._function = this._function || this._create_function(arg);\n\t\t\tif (this._function) {\n\t\t\t\ttry {\n\t\t\t\t\tval = this._function(this.param.scene(), this.param.node, this.param);\n\t\t\t\t} catch (e) {\n\t\t\t\t\tconsole.warn(`expression error`);\n\t\t\t\t\tconsole.warn(e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn val;\n\t}\n\n\tprivate _create_function(content: string) {\n\t\treturn new Function('scene', 'node', 'param', `return ${content}`);\n\t}\n}\n","/**\n * Returns the value of an object attribute\n *\n * @remarks\n * It takes 3 arguments.\n *\n * object(<input_index_or_node_path\\>, <attrib_name\\>, <object_index\\>)\n *\n * - **<input_index_or_node_path\\>** is a number or a string\n * - **<attrib_name\\>** is a string, the name of the attribute\n * - **<object_index\\>** index of the object to fetch\n *\n * ## Usage\n *\n * - `object(0, 'pscale', 0)` - returns the pscale attribute value of the first object of the first input\n *\n */\nimport {BaseMethod} from './_Base';\nimport {MethodDependency} from '../MethodDependency';\nimport {GeometryContainer} from '../../containers/Geometry';\n\nconst EXPECTED_ARGS_COUNT = 3;\nexport class ObjectExpression extends BaseMethod {\n\tprotected _require_dependency = true;\n\tstatic required_arguments() {\n\t\treturn [\n\t\t\t['string', 'path to node'],\n\t\t\t['string', 'attribute name'],\n\t\t\t['index', 'object index'],\n\t\t];\n\t}\n\n\tfind_dependency(index_or_path: number | string): MethodDependency | null {\n\t\treturn this.create_dependency_from_index_or_path(index_or_path);\n\t}\n\n\tprocess_arguments(args: any[]): Promise<any> {\n\t\treturn new Promise(async (resolve, reject) => {\n\t\t\tif (args.length == EXPECTED_ARGS_COUNT) {\n\t\t\t\tconst index_or_path = args[0];\n\t\t\t\tconst attrib_name = args[1];\n\t\t\t\tconst object_index = args[2];\n\t\t\t\tlet container: GeometryContainer | null = null;\n\t\t\t\ttry {\n\t\t\t\t\tcontainer = (await this.get_referenced_node_container(index_or_path)) as GeometryContainer;\n\t\t\t\t} catch (e) {\n\t\t\t\t\treject(e);\n\t\t\t\t}\n\t\t\t\tif (container) {\n\t\t\t\t\tconst value = this._get_value_from_container(container, attrib_name, object_index);\n\t\t\t\t\tresolve(value);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconsole.warn(`${args.length} given when expected ${EXPECTED_ARGS_COUNT}`);\n\t\t\t\tresolve(0);\n\t\t\t}\n\t\t});\n\t}\n\n\t_get_value_from_container(container: GeometryContainer, attrib_name: string, point_index: number) {\n\t\tconst core_group = container.coreContent();\n\t\tif (core_group) {\n\t\t\tconst coreObject = core_group.coreObjects()[point_index];\n\n\t\t\tif (coreObject) {\n\t\t\t\treturn coreObject.attribValue(attrib_name);\n\t\t\t} else {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n}\n","/**\n * Returns the number of objects in a geometry.\n *\n * @remarks\n * It takes 1 arguments.\n *\n * objectsCount(<input_index_or_node_path\\>)\n *\n * - **<input_index_or_node_path\\>** returns the number of objects, as a number\n *\n * ## Usage\n *\n * - `objectsCount(0)` - returns the number of objects in the input node.\n * - `objectsCount('/geo/merge1')` - returns the number of objects in the node /geo/merge1\n *\n */\nimport {BaseMethod} from './_Base';\nimport {MethodDependency} from '../MethodDependency';\nimport {GeometryContainer} from '../../containers/Geometry';\n\nexport class ObjectsCountExpression extends BaseMethod {\n\tprotected _require_dependency = true;\n\t// npoints(0)\n\t// npoints('../REF_bbox')\n\tstatic required_arguments() {\n\t\treturn [['string', 'path to node']];\n\t}\n\n\tfind_dependency(index_or_path: number | string): MethodDependency | null {\n\t\treturn this.create_dependency_from_index_or_path(index_or_path);\n\t}\n\n\tprocess_arguments(args: any[]): Promise<any> {\n\t\treturn new Promise(async (resolve, reject) => {\n\t\t\tif (args.length == 1) {\n\t\t\t\tconst index_or_path = args[0];\n\t\t\t\tlet container: GeometryContainer;\n\t\t\t\ttry {\n\t\t\t\t\tcontainer = (await this.get_referenced_node_container(index_or_path)) as GeometryContainer;\n\t\t\t\t} catch (e) {\n\t\t\t\t\treject(e);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (container) {\n\t\t\t\t\tconst value = container.objectsCount();\n\t\t\t\t\tresolve(value);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tresolve(0);\n\t\t\t}\n\t\t});\n\t}\n}\n","/**\n * Returns the number at the end of a string\n *\n * @remarks\n * It takes 1 arguments.\n *\n * opdigits(<word\\>)\n *\n * - **<word\\>** returns the number at the end of word\n *\n * ## Usage\n *\n * - `opdigits('/geo1')` - returns 1\n * - `opdigits($OS)` - returns the number at the end of the name of the current node\n *\n */\n\nimport {BaseMethod} from './_Base';\nimport {BaseNodeType} from '../../nodes/_Base';\nimport {MethodDependency} from '../MethodDependency';\nimport {CoreString} from '../../../core/String';\n\nexport class OpdigitsExpression extends BaseMethod {\n\tprotected _require_dependency = true;\n\tstatic required_arguments() {\n\t\treturn [['string', 'path to node']];\n\t}\n\n\tfind_dependency(index_or_path: number | string): MethodDependency | null {\n\t\tconst graph_node = this.find_referenced_graph_node(index_or_path);\n\t\tif (graph_node) {\n\t\t\tconst node = graph_node as BaseNodeType;\n\t\t\tif (node.nameController) {\n\t\t\t\tconst name_node = node.nameController.graph_node;\n\t\t\t\treturn this.create_dependency(name_node, index_or_path);\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tprocess_arguments(args: any[]): Promise<any> {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tif (args.length == 1) {\n\t\t\t\tconst index_or_path = args[0];\n\t\t\t\tconst node = this.get_referenced_node(index_or_path);\n\t\t\t\tif (node) {\n\t\t\t\t\tconst name = node.name();\n\t\t\t\t\tconst value = CoreString.tailDigits(name);\n\t\t\t\t\tresolve(value);\n\t\t\t\t} else {\n\t\t\t\t\tresolve(0);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tresolve(0);\n\t\t\t}\n\t\t});\n\t}\n}\n","/**\n * adds the character 0 at the beginning of a workd\n *\n * @remarks\n * It takes 2 arguments.\n *\n * padzero(<count\\>, <word_or_number\\>)\n *\n * - **<count\\>** - number of character the word will have\n * - **<word_or_number\\>** start of the word\n *\n * ## Usage\n *\n * - `padzero(4, 5)` - returns '0005'\n *\n */\nimport {BaseMethod} from './_Base';\n\nexport class PadzeroExpression extends BaseMethod {\n\tstatic required_arguments() {\n\t\treturn [['string', 'number']];\n\t}\n\n\tprocess_arguments(args: any[]): Promise<string> {\n\t\treturn new Promise((resolve) => {\n\t\t\tconst pad: number = args[0] || 2;\n\t\t\tconst src_number: number = args[1] || 0;\n\t\t\tconst unpadded = `${src_number}`;\n\t\t\tconst padded = unpadded.padStart(pad, '0');\n\t\t\tresolve(padded);\n\t\t});\n\t}\n}\n","/**\n * Returns the value of a vertex attribute\n *\n * @remarks\n * It takes 3 arguments.\n *\n * point(<input_index_or_node_path\\>, <attrib_name\\>, <point_index\\>)\n *\n * - **<input_index_or_node_path\\>** is a number or a string\n * - **<attrib_name\\>** is a string, the name of the attribute\n * - **<point_index\\>** index of the point to fetch\n *\n * ## Usage\n *\n * - `point(0, 'position', 0)` - returns the position of the first point of the first input, as a THREE.Vector3\n *\n */\nimport {BaseMethod} from './_Base';\nimport {MethodDependency} from '../MethodDependency';\nimport {GeometryContainer} from '../../containers/Geometry';\n\nconst EXPECTED_ARGS_COUNT = 3;\nexport class PointExpression extends BaseMethod {\n\tprotected _require_dependency = true;\n\tstatic required_arguments() {\n\t\treturn [\n\t\t\t['string', 'path to node'],\n\t\t\t['string', 'attribute name'],\n\t\t\t['index', 'point index'],\n\t\t];\n\t}\n\n\tfind_dependency(index_or_path: number | string): MethodDependency | null {\n\t\treturn this.create_dependency_from_index_or_path(index_or_path);\n\t}\n\n\tprocess_arguments(args: any[]): Promise<any> {\n\t\treturn new Promise(async (resolve, reject) => {\n\t\t\tif (args.length == EXPECTED_ARGS_COUNT) {\n\t\t\t\tconst index_or_path = args[0];\n\t\t\t\tconst attrib_name = args[1];\n\t\t\t\tconst point_index = args[2];\n\t\t\t\tlet container: GeometryContainer | null = null;\n\t\t\t\ttry {\n\t\t\t\t\tcontainer = (await this.get_referenced_node_container(index_or_path)) as GeometryContainer;\n\t\t\t\t} catch (e) {\n\t\t\t\t\treject(e);\n\t\t\t\t}\n\t\t\t\tif (container) {\n\t\t\t\t\tconst value = this._get_value_from_container(container, attrib_name, point_index);\n\t\t\t\t\tresolve(value);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconsole.warn(`${args.length} given when expected ${EXPECTED_ARGS_COUNT}`);\n\t\t\t\tresolve(0);\n\t\t\t}\n\t\t});\n\t}\n\n\t_get_value_from_container(container: GeometryContainer, attrib_name: string, point_index: number) {\n\t\tconst core_group = container.coreContent();\n\t\tif (core_group) {\n\t\t\tconst point = core_group.points()[point_index];\n\n\t\t\tif (point) {\n\t\t\t\treturn point.attribValue(attrib_name);\n\t\t\t} else {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n}\n","/**\n * Returns the number of points in a geometry.\n *\n * @remarks\n * It takes 1 arguments.\n *\n * pointsCount(<input_index_or_node_path\\>)\n *\n * - **<input_index_or_node_path\\>** returns the number of points, as a number\n *\n * ## Usage\n *\n * - `pointsCount(0)` - returns the number of points in the input node.\n * - `pointsCount('/geo/merge1')` - returns the number of points in the node /geo/merge1\n *\n */\nimport {BaseMethod} from './_Base';\nimport {MethodDependency} from '../MethodDependency';\nimport {GeometryContainer} from '../../containers/Geometry';\n// import {CoreGroup} from '../../../core/Geometry/Group';\n\nexport class PointsCountExpression extends BaseMethod {\n\tprotected _require_dependency = true;\n\t// npoints(0)\n\t// npoints('../REF_bbox')\n\tstatic required_arguments() {\n\t\treturn [['string', 'path to node']];\n\t}\n\n\tfind_dependency(index_or_path: number | string): MethodDependency | null {\n\t\treturn this.create_dependency_from_index_or_path(index_or_path);\n\t}\n\n\tprocess_arguments(args: any[]): Promise<any> {\n\t\treturn new Promise(async (resolve, reject) => {\n\t\t\tif (args.length == 1) {\n\t\t\t\tconst index_or_path = args[0];\n\t\t\t\tlet container: GeometryContainer;\n\t\t\t\ttry {\n\t\t\t\t\tcontainer = (await this.get_referenced_node_container(index_or_path)) as GeometryContainer;\n\t\t\t\t} catch (e) {\n\t\t\t\t\treject(e);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (container) {\n\t\t\t\t\tconst value = container.pointsCount();\n\t\t\t\t\tresolve(value);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tresolve(0);\n\t\t\t}\n\t\t});\n\t}\n}\n","/**\n * returns the number of character of a word\n *\n * @remarks\n * It takes 1 arguments.\n *\n * strCharCount(<word\\>)\n *\n * - **<word\\>** - word to returns the number of characters of\n *\n * ## Usage\n *\n * - `strCharCount('a word')` - returns 6\n *\n */\nimport {BaseMethod} from './_Base';\n// import {MethodDependency} from '../MethodDependency'\n\nexport class StrCharsCountExpression extends BaseMethod {\n\t// str_chars_count('bla') => 3\n\tstatic required_arguments() {\n\t\treturn [['string', 'string to count characters of']];\n\t}\n\n\t// find_dependency(index_or_path: number | string): null {\n\t// \treturn null\n\t// \t// return this.create_dependency_from_index_or_path(index_or_path)\n\t// }\n\n\tasync process_arguments(args: any[]): Promise<number> {\n\t\tlet value = 0;\n\t\tif (args.length == 1) {\n\t\t\tconst string = args[0];\n\t\t\tvalue = string.length;\n\t\t}\n\t\treturn value;\n\t}\n}\n","/**\n * concats 2 strings\n *\n * @remarks\n * It takes 2 or more arguments, converts them to strings and concats them.\n *\n * strConcat(<word1\\>, <word1\\>, ...)\n *\n * - **<word1\\>** - a string or number\n * - **<word2\\>** - a string or number\n *\n * ## Usage\n *\n * - `strConcat('this ', 'is a word')` - returns 'this is a word'\n * - `strConcat(1,2)` - returns '12'\n * - `strConcat(1,\"a\")` - returns '1a'\n * - `strConcat(\"a\",12, \"b\", \" \", 17)` - returns 'a12b 17'\n *\n */\nimport {BaseMethod} from './_Base';\n// import {MethodDependency} from '../MethodDependency'\n\nexport class StrConcatExpression extends BaseMethod {\n\tstatic required_arguments(): any[] {\n\t\treturn [\n\t\t\t// ['string', 'string to get range from'],\n\t\t\t// ['integer', 'range start'],\n\t\t\t// ['integer', 'range size'],\n\t\t];\n\t}\n\n\t// find_dependency(index_or_path: number | string): null {\n\t// \treturn null\n\t// \t// return this.create_dependency_from_index_or_path(index_or_path)\n\t// }\n\n\tasync process_arguments(args: any[]): Promise<string> {\n\t\tlet value = '';\n\n\t\tfor (let arg of args) {\n\t\t\tif (arg == null) {\n\t\t\t\targ = '';\n\t\t\t}\n\t\t\tvalue += `${arg}`;\n\t\t}\n\n\t\treturn value;\n\t}\n}\n","/**\n * returns the index of a character inside a string\n *\n * @remarks\n * It takes 2 arguments\n *\n * strIndex(<word\\>, <character\\>)\n *\n * - **<word\\>** - a string\n * - **<character\\>** - a string\n *\n * ## Usage\n *\n * - `strIndex('abcd ', 'c')` - returns 2\n *\n */\nimport {BaseMethod} from './_Base';\n// import {MethodDependency} from '../MethodDependency'\n\nexport class StrIndexExpression extends BaseMethod {\n\t// str_chars_count('bla') => 3\n\tstatic required_arguments() {\n\t\treturn [\n\t\t\t['string', 'string to get index from'],\n\t\t\t['string', 'char to find index of'],\n\t\t];\n\t}\n\n\t// find_dependency(index_or_path: number | string): null {\n\t// \treturn null\n\t// \t// return this.create_dependency_from_index_or_path(index_or_path)\n\t// }\n\n\tasync process_arguments(args: any[]): Promise<number> {\n\t\tlet value = -1;\n\t\tif (args.length == 2) {\n\t\t\tconst string = args[0];\n\t\t\tconst sub_string = args[1];\n\t\t\tvalue = string.indexOf(sub_string);\n\t\t}\n\t\treturn value;\n\t}\n}\n","/**\n * returns the substr from a larger word\n *\n * @remarks\n * It takes 3 arguments\n *\n * strSub(<word\\>, <start\\>, <size\\>)\n *\n * - **<word\\>** - a string\n * - **<start\\>** - the start position as a number\n * - **<size\\>** - the number of characters to take, as a number\n *\n * ## Usage\n *\n * - `strSub('this is a word', 1, 2)` - returns 'hi'\n *\n */\n\nimport {BaseMethod} from './_Base';\n// import {MethodDependency} from '../MethodDependency'\n\nexport class StrSubExpression extends BaseMethod {\n\t// str_chars_count('bla') => 3\n\tstatic required_arguments() {\n\t\treturn [\n\t\t\t['string', 'string to get range from'],\n\t\t\t['integer', 'range start'],\n\t\t\t['integer', 'range size'],\n\t\t];\n\t}\n\n\t// find_dependency(index_or_path: number | string): MethodDependency | null {\n\t// \treturn null;\n\t// \t// return this.create_dependency_from_index_or_path(index_or_path)\n\t// }\n\n\tasync process_arguments(args: any[]): Promise<string> {\n\t\tlet value = '';\n\t\tconst string = args[0];\n\t\tconst range_start = args[1] || 0;\n\t\tlet range_size = args[2] || 1;\n\t\tif (string) {\n\t\t\tvalue = string.substr(range_start, range_size);\n\t\t}\n\t\treturn value;\n\t}\n}\n","import {BboxExpression} from '../../../expressions/methods/bbox';\nimport {CentroidExpression} from '../../../expressions/methods/centroid';\nimport {ChExpression} from '../../../expressions/methods/ch';\nimport {CopyExpression} from '../../../expressions/methods/copy';\nimport {CopResExpression} from '../../../expressions/methods/copRes';\nimport {JsExpression} from '../../../expressions/methods/js';\nimport {ObjectExpression} from '../../../expressions/methods/object';\nimport {ObjectsCountExpression} from '../../../expressions/methods/objectsCount';\nimport {OpdigitsExpression} from '../../../expressions/methods/opdigits';\nimport {PadzeroExpression} from '../../../expressions/methods/padzero';\nimport {PointExpression} from '../../../expressions/methods/point';\nimport {PointsCountExpression} from '../../../expressions/methods/pointsCount';\nimport {StrCharsCountExpression} from '../../../expressions/methods/strCharsCount';\nimport {StrConcatExpression} from '../../../expressions/methods/strConcat';\nimport {StrIndexExpression} from '../../../expressions/methods/strIndex';\nimport {StrSubExpression} from '../../../expressions/methods/strSub';\n\nimport {BaseMethod} from '../../../expressions/methods/_Base';\nexport interface ExpressionMap extends PolyDictionary<typeof BaseMethod> {\n\tbbox: typeof BboxExpression;\n\tcentroid: typeof CentroidExpression;\n\tch: typeof ChExpression;\n\tcopy: typeof CopyExpression;\n\tcopRes: typeof CopResExpression;\n\tjs: typeof JsExpression;\n\tobject: typeof ObjectExpression;\n\tobjectsCount: typeof ObjectsCountExpression;\n\topdigits: typeof OpdigitsExpression;\n\tpadzero: typeof PadzeroExpression;\n\tpoint: typeof PointExpression;\n\tpointsCount: typeof PointsCountExpression;\n\tstrCharsCount: typeof StrCharsCountExpression;\n\tstrConcat: typeof StrConcatExpression;\n\tstrIndex: typeof StrIndexExpression;\n\tstrSub: typeof StrSubExpression;\n}\n\nimport {PolyEngine} from '../../../Poly';\nimport {PolyDictionary} from '../../../../types/GlobalTypes';\nexport class AllExpressionsRegister {\n\tstatic run(poly: PolyEngine) {\n\t\tpoly.expressionsRegister.register(BboxExpression, 'bbox');\n\t\tpoly.expressionsRegister.register(CentroidExpression, 'centroid');\n\t\tpoly.expressionsRegister.register(ChExpression, 'ch');\n\t\tpoly.expressionsRegister.register(CopyExpression, 'copy');\n\t\tpoly.expressionsRegister.register(CopResExpression, 'copRes');\n\t\tpoly.expressionsRegister.register(JsExpression, 'js');\n\t\tpoly.expressionsRegister.register(ObjectExpression, 'object');\n\t\tpoly.expressionsRegister.register(ObjectsCountExpression, 'objectsCount');\n\t\tpoly.expressionsRegister.register(OpdigitsExpression, 'opdigits');\n\t\tpoly.expressionsRegister.register(PadzeroExpression, 'padzero');\n\t\tpoly.expressionsRegister.register(PointExpression, 'point');\n\t\tpoly.expressionsRegister.register(PointsCountExpression, 'pointsCount');\n\t\tpoly.expressionsRegister.register(StrCharsCountExpression, 'strCharsCount');\n\t\tpoly.expressionsRegister.register(StrConcatExpression, 'strConcat');\n\t\tpoly.expressionsRegister.register(StrIndexExpression, 'strIndex');\n\t\tpoly.expressionsRegister.register(StrSubExpression, 'strSub');\n\t}\n}\n","import {BaseCameraControlsEventNodeType, CameraControls} from '../_BaseCameraControls';\nimport {CoreGraphNodeId} from '../../../../core/graph/CoreGraph';\n\nexport class CameraControlsConfig {\n\tprivate _update_required: boolean;\n\tconstructor(\n\t\tprivate _camera_node_id: CoreGraphNodeId,\n\t\tprivate _controls_node: BaseCameraControlsEventNodeType,\n\t\tprivate _controls: CameraControls\n\t) {\n\t\tthis._update_required = this._controls_node.update_required();\n\t}\n\tupdate_required() {\n\t\treturn this._update_required;\n\t}\n\n\tget camera_node_id() {\n\t\treturn this._camera_node_id;\n\t}\n\t// camera_controls_node_id(){\n\t// \treturn this._camera_controls_node_id\n\t// }\n\tget controls() {\n\t\treturn this._controls;\n\t}\n\tget controls_node() {\n\t\treturn this._controls_node;\n\t}\n\n\tis_equal(other_config: CameraControlsConfig): boolean {\n\t\treturn (\n\t\t\tother_config.camera_node_id == this._camera_node_id &&\n\t\t\tother_config.controls_node.graphNodeId() == this._controls_node.graphNodeId()\n\t\t);\n\t}\n}\n","import {BaseThreejsCameraObjNodeType, UpdateFromControlsMode, UPDATE_FROM_CONTROLS_MODES} from '../../_BaseCamera';\nimport {BaseCameraControlsEventNodeType, CameraControls} from '../../../event/_BaseCameraControls';\nimport {CameraControlsConfig} from '../../../event/utils/CameraControlConfig';\nimport {BaseParamType} from '../../../../params/_Base';\nimport {TypeAssert} from '../../../../poly/Assert';\nimport {CAMERA_CONTROLS_NODE_TYPES} from '../../../../poly/NodeContext';\nimport {BaseViewerType} from '../../../../viewers/_Base';\n\nconst CONTROLS_PARAM_NAME = 'controls';\n\ntype HTMLElementId = string;\ntype ControlsId = string;\ntype AppliedControls = Map<HTMLElementId, Map<ControlsId, BaseCameraControlsEventNodeType>>;\n\nexport class ThreejsCameraControlsController {\n\tprivate _applied_controls_by_element_id: AppliedControls = new Map();\n\tprivate _controls_node: BaseCameraControlsEventNodeType | null = null;\n\t// private controls_start_listener: (() => void) | undefined;\n\tprivate controls_change_listener: (() => void) | undefined;\n\tprivate controls_end_listener: (() => void) | undefined;\n\n\tconstructor(private node: BaseThreejsCameraObjNodeType) {}\n\n\tcontrols_param(): BaseParamType | null {\n\t\tif (this.node.params.has(CONTROLS_PARAM_NAME)) {\n\t\t\treturn this.node.params.get(CONTROLS_PARAM_NAME);\n\t\t}\n\t\treturn null;\n\t}\n\n\tasync controls_node(): Promise<BaseCameraControlsEventNodeType | null> {\n\t\tconst controls_param = this.node.p.controls;\n\t\tconst raw_input = controls_param.rawInput();\n\t\tif (raw_input && raw_input != '') {\n\t\t\tif (controls_param.isDirty()) {\n\t\t\t\tawait controls_param.compute();\n\t\t\t}\n\t\t\tconst node = controls_param.value.node();\n\t\t\tif (node) {\n\t\t\t\tif (CAMERA_CONTROLS_NODE_TYPES.includes(node.type())) {\n\t\t\t\t\treturn node as BaseCameraControlsEventNodeType;\n\t\t\t\t} else {\n\t\t\t\t\tthis.node.states.error.set('found node is not of a camera control type');\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.node.states.error.set('no node has been found');\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tasync update_controls() {\n\t\tconst controls_node = await this.controls_node();\n\t\tif (controls_node) {\n\t\t\tif (this._controls_node != controls_node) {\n\t\t\t\tthis._dispose_control_refs();\n\t\t\t}\n\t\t}\n\n\t\tthis._controls_node = controls_node;\n\t}\n\n\tprivate _controlsEndEventName: string | undefined;\n\tasync apply_controls(viewer: BaseViewerType) {\n\t\tconst canvas = viewer.canvas();\n\t\tif (!canvas) {\n\t\t\treturn;\n\t\t}\n\t\tconst controls_node = await this.controls_node();\n\t\tif (controls_node) {\n\t\t\tthis._controlsEndEventName = controls_node.endEventName();\n\t\t\tconst controls_id = controls_node.controls_id();\n\t\t\tlet controls_aleady_applied = false;\n\n\t\t\tlet map_for_element = this._applied_controls_by_element_id.get(canvas.id);\n\t\t\tif (map_for_element && map_for_element.get(controls_id)) {\n\t\t\t\tcontrols_aleady_applied = true;\n\t\t\t}\n\t\t\tif (!controls_aleady_applied) {\n\t\t\t\t// this._last_control_node_id = controls_id;\n\t\t\t\tmap_for_element = new Map();\n\t\t\t\tthis._applied_controls_by_element_id.set(canvas.id, map_for_element);\n\t\t\t\tmap_for_element.set(controls_id, controls_node);\n\n\t\t\t\t// requestContainer forces a cook\n\t\t\t\t//controls_node.requestContainer (controls_container)=>\n\t\t\t\tconst controls = await controls_node.apply_controls(this.node.object, viewer);\n\t\t\t\tif (!controls) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tconst config = new CameraControlsConfig(this.node.graphNodeId(), controls_node, controls);\n\t\t\t\t// controls_node.set_from_camera_node(controls, this.node);\n\t\t\t\tthis.set_controls_events(controls);\n\t\t\t\treturn config;\n\t\t\t}\n\t\t}\n\t}\n\tprivate _dispose_control_refs() {\n\t\tthis._applied_controls_by_element_id.forEach((map_for_element, element_id) => {\n\t\t\tthis._dispose_controls_for_element_id(element_id);\n\t\t});\n\n\t\tthis._applied_controls_by_element_id.clear();\n\t\tthis._controlsEndEventName = undefined;\n\t}\n\tprivate _dispose_controls_for_element_id(html_element_id: string) {\n\t\tconst map_for_element = this._applied_controls_by_element_id.get(html_element_id);\n\t\tif (map_for_element) {\n\t\t\tmap_for_element.forEach((controls_node, controls_id) => {\n\t\t\t\tcontrols_node.dispose_controls_for_html_element_id(html_element_id);\n\t\t\t});\n\t\t}\n\n\t\tthis._applied_controls_by_element_id.delete(html_element_id);\n\t\t// if (this._applied_controls_by_element_id[html_element.id]) {\n\t\t// \tconst controls_node = await this.controls_node();\n\t\t// \tif (controls_node) {\n\t\t// \t\tconst controls_id = controls_node.controls_id();\n\t\t// \t\tdelete this._applied_controls_by_element_id[html_element.id][controls_id];\n\t\t// \t}\n\t\t// }\n\t\t// @_controls_node?.dispose_controls()\n\t\t// if(this._applied_controls_by_element_id[html_element.id]){\n\t\t// \tdelete this._applied_controls_by_element_id[html_element.id][controls_id]\n\t\t// }\n\t\t// this._last_control_node_id = null\n\t}\n\n\t// calling dispose controls\n\t// ensure that we can set the camera menu to camera1, then camera2 and back to camera1\n\t// and controls will be cleared each time\n\tasync dispose_controls(html_element: HTMLElement) {\n\t\tthis._dispose_controls_for_element_id(html_element.id);\n\t}\n\tset_controls_events(controls: CameraControls) {\n\t\t// restore target (for orbit controls only for now)\n\t\t// to ensure that camera does not reset its target on 0,0,0 on first move\n\t\t// const controls_node = this.controls_node()\n\t\t// if (controls_node){\n\t\t// \tcontrols_node.\n\t\t// }\n\t\t// if(controls.target){\n\t\t// \tcontrols.target.copy(this._param_target) //.clone()\n\t\t// }\n\n\t\t// this.controls_start_listener = () => {\n\t\t// \tthis.on_controls_start(controls);\n\t\t// };\n\t\tconst update_mode = UPDATE_FROM_CONTROLS_MODES[this.node.pv.updateFromControlsMode];\n\t\tswitch (update_mode) {\n\t\t\tcase UpdateFromControlsMode.ON_END:\n\t\t\t\treturn this._set_controls_events_to_update_on_end(controls);\n\t\t\tcase UpdateFromControlsMode.ALWAYS:\n\t\t\t\treturn this._set_controls_events_to_update_always(controls);\n\t\t\tcase UpdateFromControlsMode.NEVER:\n\t\t\t\treturn this._reset(controls);\n\t\t}\n\t\tTypeAssert.unreachable(update_mode);\n\t}\n\tprivate _reset(controls: CameraControls) {\n\t\tif (this.controls_change_listener) {\n\t\t\tcontrols.removeEventListener('change', this.controls_change_listener);\n\t\t\tthis.controls_change_listener = undefined;\n\t\t}\n\t\tif (this.controls_end_listener && this._controlsEndEventName) {\n\t\t\tcontrols.removeEventListener(this._controlsEndEventName, this.controls_end_listener);\n\t\t\tthis.controls_end_listener = undefined;\n\t\t}\n\t}\n\tprivate _set_controls_events_to_update_on_end(controls: CameraControls) {\n\t\tthis._reset(controls);\n\t\tif (!this._controlsEndEventName) {\n\t\t\treturn;\n\t\t}\n\t\tthis.controls_end_listener = () => {\n\t\t\tthis.node.update_transform_params_from_object();\n\t\t};\n\t\tcontrols.addEventListener(this._controlsEndEventName, this.controls_end_listener);\n\t}\n\tprivate _set_controls_events_to_update_always(controls: CameraControls) {\n\t\tthis._reset(controls);\n\t\tthis.controls_change_listener = () => {\n\t\t\tthis.node.update_transform_params_from_object();\n\t\t};\n\t\tcontrols.addEventListener('change', this.controls_change_listener);\n\t}\n\n\t// private _update_camera_params() {\n\t// \tif (this.node.pv.allowUpdateFromControls) {\n\t// \t\tthis.node.update_transform_params_from_object();\n\t// \t}\n\t// }\n}\n","import {Constructor} from '../../../../types/GlobalTypes';\nimport {BaseObjNodeType} from '../_Base';\n\nconst PARAM_NAME = 'layer';\n\nimport {ParamConfig} from '../../utils/params/ParamsConfig';\nexport function LayerParamConfig<TBase extends Constructor>(Base: TBase) {\n\treturn class Mixin extends Base {\n\t\tlayer = ParamConfig.INTEGER(0, {\n\t\t\trange: [0, 31],\n\t\t\trangeLocked: [true, true],\n\t\t});\n\t};\n}\n\nexport class LayersController {\n\tconstructor(private node: BaseObjNodeType) {}\n\n\t// add_params() {\n\t// \tthis.node.add_param(ParamType.INTEGER, PARAM_NAME, 0, {\n\t// \t\trange: [0, 31],\n\t// \t\trangeLocked: [true, true],\n\t// \t});\n\t// }\n\n\tupdate() {\n\t\tconst object = this.node.object;\n\t\t// const affected_objects = [object];\n\t\t// if (object.cloned_cameras != null) {\n\t\t// \tlodash_each(object.cloned_cameras, cloned_camera=> {\n\t\t// \t\taffected_objects.push(cloned_camera);\n\t\t// \t});\n\t\t// }\n\n\t\t// affected_objects.forEach((affected_object)=> {\n\t\tobject.layers.set(0);\n\t\tobject.layers.enable(this.node.params.integer(PARAM_NAME));\n\t\t// });\n\t}\n}\n","import {Constructor, PolyDictionary} from '../../../../../types/GlobalTypes';\nimport {Vector2} from 'three/src/math/Vector2';\nimport {BaseThreejsCameraObjNodeType, BaseThreejsCameraObjNodeClass} from '../../_BaseCamera';\nimport {EffectComposer} from '../../../../../modules/three/examples/jsm/postprocessing/EffectComposer';\nimport {NetworkNodeType} from '../../../../poly/NodeContext';\nimport {BaseNetworkPostProcessNodeType} from '../../../post/utils/EffectsComposerController';\nimport {BaseNodeType} from '../../../_Base';\n\n// interface DisposablePass extends Pass {\n// \tdispose: () => void;\n// }\nconst POST_PROCESS_PARAM_OPTIONS = {\n\tcallback: (node: BaseNodeType) => {\n\t\tBaseThreejsCameraObjNodeClass.PARAM_CALLBACK_reset_effects_composer(node as BaseThreejsCameraObjNodeType);\n\t},\n};\n\nimport {ParamConfig} from '../../../utils/params/ParamsConfig';\nexport function CameraPostProcessParamConfig<TBase extends Constructor>(Base: TBase) {\n\treturn class Mixin extends Base {\n\t\tdoPostProcess = ParamConfig.BOOLEAN(0);\n\t\tpostProcessNode = ParamConfig.NODE_PATH('./postProcess1', {\n\t\t\tvisibleIf: {\n\t\t\t\tdoPostProcess: 1,\n\t\t\t},\n\t\t\tnodeSelection: {\n\t\t\t\ttypes: [NetworkNodeType.POST],\n\t\t\t},\n\t\t\t// cook: false,\n\t\t\t...POST_PROCESS_PARAM_OPTIONS,\n\t\t});\n\t\t// prepend_render_pass = ParamConfig.BOOLEAN(1, {\n\t\t// \tvisibleIf: {\n\t\t// \t\tdoPostProcess: 1,\n\t\t// \t},\n\t\t// });\n\t\t// use_render_target = ParamConfig.BOOLEAN(0, {\n\t\t// \tvisibleIf: {\n\t\t// \t\tdoPostProcess: 1,\n\t\t// \t},\n\t\t// \t...POST_PROCESS_PARAM_OPTIONS,\n\t\t// });\n\t};\n}\n\nexport class PostProcessController {\n\tprivate _composers_by_canvas_id: PolyDictionary<EffectComposer> = {};\n\n\tconstructor(private node: BaseThreejsCameraObjNodeType) {\n\t\tif (this.node.p.postProcessNode) {\n\t\t\tthis._add_param_dirty_hook();\n\t\t} else {\n\t\t\tthis.node.params.onParamsCreated('post process add param dirty hook', () => {\n\t\t\t\tthis._add_param_dirty_hook();\n\t\t\t});\n\t\t}\n\t}\n\tprivate _add_param_dirty_hook() {\n\t\tthis.node.p.postProcessNode.addPostDirtyHook('on_post_node_dirty', () => {\n\t\t\tthis.reset();\n\t\t});\n\t}\n\n\t// private _prev_t = 0;\n\trender(canvas: HTMLCanvasElement, size?: Vector2) {\n\t\tconst composer = this.composer(canvas);\n\t\tif (composer) {\n\t\t\tif (size) {\n\t\t\t\tcomposer.setSize(size.x, size.y);\n\t\t\t}\n\t\t\t// if (this.node.pv.use_render_target) {\n\t\t\t// \tconst renderer = this.node.render_controller.renderer(canvas);\n\t\t\t// \trenderer.clear();\n\t\t\t// }\n\t\t\tcomposer.render();\n\t\t}\n\t}\n\n\treset() {\n\t\tconst ids = Object.keys(this._composers_by_canvas_id);\n\t\tfor (let id of ids) {\n\t\t\tdelete this._composers_by_canvas_id[id];\n\t\t}\n\t}\n\n\t// method could be private, but is public for the test suite\n\tcomposer(canvas: HTMLCanvasElement): EffectComposer {\n\t\treturn (this._composers_by_canvas_id[canvas.id] =\n\t\t\tthis._composers_by_canvas_id[canvas.id] || this._create_composer(canvas));\n\t}\n\n\tprivate _create_composer(canvas: HTMLCanvasElement) {\n\t\tconst renderer = this.node.renderController.renderer(canvas);\n\t\tif (renderer) {\n\t\t\tconst scene = this.node.renderController.resolved_scene || this.node.scene().threejsScene();\n\t\t\tconst camera = this.node.object;\n\n\t\t\tconst found_node = this.node.p.postProcessNode.value.node();\n\t\t\tif (found_node) {\n\t\t\t\tif (found_node.type() == NetworkNodeType.POST) {\n\t\t\t\t\tconst post_process_network = found_node as BaseNetworkPostProcessNodeType;\n\t\t\t\t\tconst resolution = this.node.renderController.canvas_resolution(canvas);\n\n\t\t\t\t\tconst composer = post_process_network.effectsComposerController.createEffectsComposer({\n\t\t\t\t\t\trenderer,\n\t\t\t\t\t\tscene,\n\t\t\t\t\t\tcamera,\n\t\t\t\t\t\tresolution,\n\t\t\t\t\t\trequester: this.node,\n\t\t\t\t\t\tcamera_node: this.node,\n\t\t\t\t\t\t// render_target: render_target,\n\t\t\t\t\t\t// prepend_render_pass: this.node.pv.prepend_render_pass,\n\t\t\t\t\t});\n\t\t\t\t\treturn composer;\n\t\t\t\t} else {\n\t\t\t\t\tthis.node.states.error.set('found node is not a post process node');\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.node.states.error.set('no post node found');\n\t\t\t}\n\t\t}\n\t}\n\n\t// private _clear_render_passes(composer: EffectComposer) {\n\t// \tlet render_pass: Pass | undefined;\n\t// \twhile ((render_pass = composer.passes.pop())) {\n\t// \t\tif (render_pass) {\n\t// \t\t\tconst disposable_pass: DisposablePass = render_pass as DisposablePass;\n\t// \t\t\tif (typeof disposable_pass.dispose === 'function') {\n\t// \t\t\t\ttry {\n\t// \t\t\t\t\tdisposable_pass.dispose();\n\t// \t\t\t\t} catch (e) {\n\t// \t\t\t\t\tconsole.warn(e);\n\t// \t\t\t\t}\n\t// \t\t\t}\n\t// \t\t}\n\t// \t}\n\t// }\n}\n","import {ThreejsViewer} from '../Threejs';\nimport {CameraControls} from '../../nodes/event/_BaseCameraControls';\nimport {CoreGraphNode} from '../../../core/graph/CoreGraphNode';\nimport {CameraControlsConfig} from '../../nodes/event/utils/CameraControlConfig';\n\nexport class ViewerControlsController {\n\tprotected _active: boolean = false;\n\tprotected _config: CameraControlsConfig | undefined;\n\tprotected _controls: CameraControls | null = null;\n\t_bound_on_controls_start: () => void = this._on_controls_start.bind(this);\n\t_bound_on_controls_end: () => void = this._on_controls_end.bind(this);\n\tconstructor(private viewer: ThreejsViewer) {\n\t\tthis._update_graph_node();\n\t}\n\n\tcontrols() {\n\t\treturn this._controls;\n\t}\n\n\tasync create_controls() {\n\t\tthis.dispose_controls();\n\t\tconst canvas = this.viewer.canvas();\n\n\t\tif (!canvas) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._config = await this.viewer.cameraControlsController?.apply_controls(this.viewer);\n\t\tif (this._config) {\n\t\t\tthis._controls = this._config.controls;\n\n\t\t\tif (this._controls) {\n\t\t\t\tif (this.viewer.active()) {\n\t\t\t\t\tthis._controls.addEventListener('start', this._bound_on_controls_start);\n\t\t\t\t\tthis._controls.addEventListener('end', this._bound_on_controls_end);\n\t\t\t\t} else {\n\t\t\t\t\tthis.dispose_controls();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tupdate() {\n\t\tif (this._config && this._controls) {\n\t\t\tif (this._config.update_required()) {\n\t\t\t\tthis._controls.update();\n\t\t\t}\n\t\t}\n\t}\n\n\tdispose() {\n\t\tthis._graph_node?.graphDisconnectPredecessors();\n\t\tthis.dispose_controls();\n\t}\n\tdispose_controls() {\n\t\tif (this._controls) {\n\t\t\tconst canvas = this.viewer.canvas();\n\t\t\tif (canvas) {\n\t\t\t\tthis.viewer?.cameraControlsController.dispose_controls(canvas);\n\t\t\t}\n\n\t\t\tif (this._bound_on_controls_start) {\n\t\t\t\tthis._controls.removeEventListener('start', this._bound_on_controls_start);\n\t\t\t}\n\t\t\tif (this._bound_on_controls_end) {\n\t\t\t\tthis._controls.removeEventListener('end', this._bound_on_controls_end);\n\t\t\t}\n\n\t\t\tthis._controls.dispose();\n\t\t\tthis._controls = null;\n\t\t}\n\t}\n\tprivate _on_controls_start() {\n\t\tthis._active = true;\n\t}\n\tprivate _on_controls_end() {\n\t\tthis._active = false;\n\t}\n\n\tprivate _graph_node: CoreGraphNode | undefined;\n\tprivate _update_graph_node() {\n\t\tconst controls_param = this.viewer.cameraNode().p.controls;\n\t\tthis._graph_node = this._graph_node || this._create_graph_node();\n\t\tif (!this._graph_node) {\n\t\t\treturn;\n\t\t}\n\t\tthis._graph_node.graphDisconnectPredecessors();\n\t\tthis._graph_node.addGraphInput(controls_param);\n\t}\n\tprivate _create_graph_node() {\n\t\tconst node = new CoreGraphNode(this.viewer.cameraNode().scene(), 'viewer-controls');\n\t\tnode.addPostDirtyHook('this.viewer.controls_controller', async () => {\n\t\t\tawait this.viewer.controlsController.create_controls();\n\t\t});\n\t\treturn node;\n\t}\n}\n","// import {Camera} from 'three/src/cameras/Camera';\nimport {Vector2} from 'three/src/math/Vector2';\nimport {BaseViewerType} from '../_Base';\n\nexport class ViewerCamerasController {\n\t// private _is_active: boolean = false;\n\t// private _camera_node: BaseThreejsCameraObjNodeType | undefined;\n\t// private _camera: Camera;\n\n\tprivate _size: Vector2 = new Vector2(100, 100);\n\tprivate _aspect: number = 1;\n\n\tconstructor(private _viewer: BaseViewerType) {}\n\n\tcameraNode() {\n\t\treturn this._viewer.cameraNode();\n\t}\n\tget size() {\n\t\treturn this._size;\n\t}\n\tget aspect() {\n\t\treturn this._aspect;\n\t}\n\n\tcomputeSizeAndAspect() {\n\t\tthis._update_size();\n\t\tthis.cameraNode().scene().uniforms_controller.update_resolution_dependent_uniform_owners(this._size);\n\t\tthis._aspect = this._get_aspect();\n\t}\n\n\tprivate _update_size() {\n\t\tthis._size.x = this._viewer.container().offsetWidth;\n\t\tthis._size.y = this._viewer.container().offsetHeight;\n\t}\n\tprivate _get_aspect(): number {\n\t\treturn this._size.x / this._size.y;\n\t}\n\n\tupdateCameraAspect() {\n\t\tthis.cameraNode().setup_for_aspect_ratio(this._aspect);\n\t}\n\n\tasync prepareCurrentCamera() {\n\t\tawait this.cameraNode().requestContainer(); // ensure the camera is cooked\n\t\tawait this._update_from_camera_container(); //container, graph_node_id)\n\t}\n\n\tasync _update_from_camera_container() {\n\t\tthis.updateCameraAspect();\n\t\tawait this._viewer.controlsController?.create_controls();\n\t}\n}\n","import {BaseViewerType} from '../_Base';\nimport {EventContext, BaseSceneEventsControllerType} from '../../scene/utils/events/_BaseEventsController';\n// import {SceneEventsDispatcher} from '../../scene/utils/events/EventsDispatcher';\n\n// type MouseOrTouchEvent = MouseEvent | TouchEvent;\n// type MouseOrTouchEventCallback = (e: MouseEvent) => void;\ntype EventListener = (e: Event) => void;\ntype ListenerByEventType = Map<string, EventListener>;\n\nexport class ViewerEventsController {\n\tprotected _bound_process_event = this.process_event.bind(this);\n\tprotected _bound_listener_map_by_event_controller_type: Map<string, ListenerByEventType> = new Map();\n\t// protected _registered_events: Map<string, EventCallback> = new Map();\n\t// protected _bound_on_mousedown: MouseOrTouchEventCallback = this.process_event.bind(this);\n\t// protected _bound_on_mousemove: MouseOrTouchEventCallback = this.process_event.bind(this);\n\t// protected _bound_on_mouseup: MouseOrTouchEventCallback = this.process_event.bind(this);\n\n\tconstructor(protected viewer: BaseViewerType) {}\n\n\tupdateEvents(events_controller: BaseSceneEventsControllerType) {\n\t\tconst canvas = this.canvas();\n\t\tif (!canvas) {\n\t\t\treturn;\n\t\t}\n\t\tconst controller_type = events_controller.type();\n\t\tlet map = this._bound_listener_map_by_event_controller_type.get(controller_type);\n\t\tif (!map) {\n\t\t\tmap = new Map();\n\t\t\tthis._bound_listener_map_by_event_controller_type.set(controller_type, map);\n\t\t}\n\t\tmap.forEach((listener, event_type) => {\n\t\t\tcanvas.removeEventListener(event_type, listener);\n\t\t});\n\t\tmap.clear();\n\n\t\tconst listener = (event: Event) => {\n\t\t\tthis.process_event(event, events_controller);\n\t\t};\n\t\tfor (let event_type of events_controller.activeEventTypes()) {\n\t\t\tcanvas.addEventListener(event_type, listener);\n\t\t\tmap.set(event_type, listener);\n\t\t}\n\t}\n\n\tcameraNode() {\n\t\treturn this.viewer.camerasController.cameraNode();\n\t}\n\tcanvas() {\n\t\treturn this.viewer.canvas();\n\t}\n\n\tinit() {\n\t\tif (!this.canvas) {\n\t\t\treturn;\n\t\t}\n\t\tthis.viewer.scene().eventsDispatcher.traverseControllers((controller) => {\n\t\t\tthis.updateEvents(controller);\n\t\t});\n\t}\n\n\tregisteredEventTypes(): string[] {\n\t\tconst list: string[] = [];\n\t\tthis._bound_listener_map_by_event_controller_type.forEach((map) => {\n\t\t\tmap.forEach((listener, event_type) => {\n\t\t\t\tlist.push(event_type);\n\t\t\t});\n\t\t});\n\t\treturn list;\n\t}\n\n\tdispose() {\n\t\tconst canvas = this.canvas();\n\t\tthis._bound_listener_map_by_event_controller_type.forEach((map) => {\n\t\t\tif (canvas) {\n\t\t\t\tmap.forEach((listener, event_type) => {\n\t\t\t\t\tcanvas.removeEventListener(event_type, listener);\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\t}\n\n\tprivate process_event(event: Event, controller: BaseSceneEventsControllerType) {\n\t\tconst canvas = this.canvas();\n\t\tif (!canvas) {\n\t\t\treturn;\n\t\t}\n\t\tconst event_context: EventContext<Event> = {\n\t\t\tviewer: this.viewer,\n\t\t\tevent: event,\n\t\t\tcameraNode: this.cameraNode(),\n\t\t};\n\t\tcontroller.processEvent(event_context);\n\t}\n}\n","import {BaseViewerType} from '../_Base';\n\nexport class WebGLController {\n\tpublic request_animation_frame_id: number | undefined;\n\n\tconstructor(protected viewer: BaseViewerType) {}\n\n\tinit() {\n\t\tconst canvas = this.viewer.canvas();\n\t\tif (canvas) {\n\t\t\tcanvas.onwebglcontextlost = this._on_webglcontextlost.bind(this);\n\t\t\tcanvas.onwebglcontextrestored = this._on_webglcontextrestored.bind(this);\n\t\t}\n\t}\n\n\tprotected _on_webglcontextlost() {\n\t\tconsole.warn('context lost at frame', this.viewer.scene().frame());\n\t\t// event.preventDefault();\n\t\tif (this.request_animation_frame_id) {\n\t\t\tcancelAnimationFrame(this.request_animation_frame_id);\n\t\t} else {\n\t\t\tconsole.warn('request_animation_frame_id not initialized');\n\t\t}\n\t\tconsole.warn('not canceled', this.request_animation_frame_id);\n\t}\n\tprotected _on_webglcontextrestored() {\n\t\tconsole.log('context restored');\n\t}\n}\n","import {PolyScene} from '../scene/PolyScene';\nimport {BaseCameraObjNodeType} from '../nodes/obj/_BaseCamera';\n\n// import {CameraMixin} from './concerns/Camera';\n// import {Capturer} from './concerns/Capturer';\n// import {ContainerClass} from './concerns/ContainerClass';\n// import {Controls} from './concerns/Controls';\n// import {PickerForViewer} from './concerns/Picker';\n\nimport {ViewerCamerasController} from './utils/CamerasController';\nimport {ViewerControlsController} from './utils/ControlsController';\nimport {ViewerEventsController} from './utils/EventsController';\nimport {WebGLController} from './utils/WebglController';\nimport {ThreejsCameraControlsController} from '../nodes/obj/utils/cameras/ControlsController';\n\n// class AbstractViewer {}\n\nconst HOVERED_CLASS_NAME = 'hovered';\n\nexport abstract class TypedViewer<C extends BaseCameraObjNodeType> {\n\t// protected _display_scene: Scene;\n\tprotected _canvas: HTMLCanvasElement | undefined;\n\tprotected _active: boolean = false;\n\tprivate static _next_viewer_id = 0;\n\tprivate _id: Readonly<number>;\n\n\tactive() {\n\t\treturn this._active;\n\t}\n\tactivate() {\n\t\tthis._active = true;\n\t}\n\tdeactivate() {\n\t\tthis._active = false;\n\t}\n\n\tprotected _cameras_controller: ViewerCamerasController | undefined;\n\tget camerasController(): ViewerCamerasController {\n\t\treturn (this._cameras_controller = this._cameras_controller || new ViewerCamerasController(this));\n\t}\n\tprotected _controls_controller: ViewerControlsController | undefined;\n\tget controlsController() {\n\t\treturn this._controls_controller;\n\t}\n\tprotected _events_controller: ViewerEventsController | undefined;\n\tget eventsController(): ViewerEventsController {\n\t\treturn (this._events_controller = this._events_controller || new ViewerEventsController(this));\n\t}\n\tprotected _webgl_controller: WebGLController | undefined;\n\tget webglController(): WebGLController {\n\t\treturn (this._webgl_controller = this._webgl_controller || new WebGLController(this));\n\t}\n\n\tconstructor(protected _container: HTMLElement, protected _scene: PolyScene, protected _camera_node: C) {\n\t\tthis._id = TypedViewer._next_viewer_id++;\n\t\tthis._scene.viewersRegister.registerViewer(this);\n\t}\n\tcontainer() {\n\t\treturn this._container;\n\t}\n\tscene() {\n\t\treturn this._scene;\n\t}\n\tcanvas() {\n\t\treturn this._canvas;\n\t}\n\tcameraNode() {\n\t\treturn this._camera_node;\n\t}\n\tget cameraControlsController(): ThreejsCameraControlsController | undefined {\n\t\treturn undefined;\n\t}\n\tid() {\n\t\treturn this._id;\n\t}\n\n\t// private async _init_from_scene(camera_node: BaseCameraObjNodeType) {\n\t// \t// camera_node || this._scene.cameras_controller.masterCameraNode\n\t// \tawait this.con_controller?.set_camera_node(camera_node);\n\t// \t// await this.update_picker_nodes(); // TODO: typescript\n\t// }\n\t// protected abstract _build(): void;\n\tdispose() {\n\t\tthis._scene.viewersRegister.unregisterViewer(this);\n\t\tthis.eventsController.dispose();\n\t\tlet child: Element;\n\t\twhile ((child = this._container.children[0])) {\n\t\t\tthis._container.removeChild(child);\n\t\t}\n\t}\n\n\t// html container class\n\tresetContainerClass() {\n\t\tthis.container().classList.remove(HOVERED_CLASS_NAME);\n\t}\n\tsetContainerClassHovered() {\n\t\tthis.container().classList.add(HOVERED_CLASS_NAME);\n\t}\n}\n\nexport type BaseViewerType = TypedViewer<BaseCameraObjNodeType>;\n","import {PolyScene} from '../scene/PolyScene';\nimport {Vector2} from 'three/src/math/Vector2';\nimport {ViewerControlsController} from './utils/ControlsController';\nimport {TypedViewer} from './_Base';\nimport {BaseThreejsCameraObjNodeType} from '../nodes/obj/_BaseCamera';\n\nconst CSS_CLASS = 'CoreThreejsViewer';\n\ndeclare global {\n\tinterface HTMLCanvasElement {\n\t\tonwebglcontextlost: () => void;\n\t\tonwebglcontextrestored: () => void;\n\t}\n}\n\nexport interface ThreejsViewerProperties {\n\tautoRender: boolean;\n}\n\ntype onTimeTickHook = () => void;\ntype onRenderHook = () => void;\nexport class ThreejsViewer extends TypedViewer<BaseThreejsCameraObjNodeType> {\n\tprivate _request_animation_frame_id: number | undefined;\n\tprivate _do_render: boolean = true;\n\tprivate _onBeforeTick: onTimeTickHook | undefined;\n\tprivate _onAfterTick: onTimeTickHook | undefined;\n\tprivate _onBeforeRender: onRenderHook | undefined;\n\tprivate _onAfterRender: onRenderHook | undefined;\n\n\tprivate _animate_method: () => void = this.animate.bind(this);\n\n\tconstructor(\n\t\t_container: HTMLElement,\n\t\tprotected _scene: PolyScene,\n\t\tprotected _camera_node: BaseThreejsCameraObjNodeType,\n\t\tprivate _properties?: ThreejsViewerProperties\n\t) {\n\t\tsuper(_container, _scene, _camera_node);\n\n\t\tthis._do_render = this._properties != null ? this._properties.autoRender : true;\n\n\t\tthis._canvas = document.createElement('canvas');\n\t\tthis._canvas.id = `canvas_id_${Math.random()}`.replace('.', '_');\n\t\tthis._canvas.style.display = 'block';\n\t\tthis._canvas.style.outline = 'none';\n\n\t\tthis._container.appendChild(this._canvas);\n\t\tthis._container.classList.add(CSS_CLASS);\n\t\t// this._container.style.height = '100%'; // this should be app specific\n\n\t\tthis._build();\n\t\tthis._set_events();\n\t}\n\tget controlsController(): ViewerControlsController {\n\t\treturn (this._controls_controller = this._controls_controller || new ViewerControlsController(this));\n\t}\n\n\tpublic _build() {\n\t\tthis._init_display();\n\t\tthis.activate();\n\t}\n\n\tonBeforeTick(callback: onTimeTickHook | undefined) {\n\t\tthis._onBeforeTick = callback;\n\t}\n\tonAfterTick(callback: onTimeTickHook | undefined) {\n\t\tthis._onAfterTick = callback;\n\t}\n\tonBeforeRender(callback: onRenderHook | undefined) {\n\t\tthis._onBeforeRender = callback;\n\t}\n\tonAfterRender(callback: onRenderHook | undefined) {\n\t\tthis._onAfterRender = callback;\n\t}\n\n\tdispose() {\n\t\tthis._cancel_animate();\n\t\tthis.controlsController.dispose();\n\t\t// TODO: also dispose the renderer\n\t\tsuper.dispose();\n\t}\n\tget cameraControlsController() {\n\t\treturn this._camera_node.controls_controller;\n\t}\n\n\tprivate _set_events() {\n\t\tthis.eventsController.init();\n\t\tthis.webglController.init();\n\n\t\twindow.onresize = () => {\n\t\t\tthis.onResize();\n\t\t};\n\t}\n\tonResize() {\n\t\tconst canvas = this.canvas();\n\t\tif (!canvas) {\n\t\t\treturn;\n\t\t}\n\t\tthis.camerasController.computeSizeAndAspect();\n\t\tthis._camera_node.renderController.set_renderer_size(canvas, this.camerasController.size);\n\t\tthis.camerasController.updateCameraAspect();\n\t}\n\n\tprivate _init_display() {\n\t\tif (!this._canvas) {\n\t\t\tconsole.warn('no canvas found for viewer');\n\t\t\treturn;\n\t\t}\n\t\tthis.camerasController.computeSizeAndAspect();\n\t\tconst size: Vector2 = this.camerasController.size;\n\n\t\tthis._camera_node.renderController.createRenderer(this._canvas, size);\n\t\t// this.canvas_context = canvas.getContext('2d')\n\n\t\t// init renderer\n\t\t// renderer = new THREE.WebGLRenderer\n\t\t// \tcanvas: canvas\n\t\t// \tantialias: true\n\t\t// \talpha: true\n\n\t\t// renderer.shadowMap.enabled = true\n\t\t// this.compute_size_and_aspect()\n\n\t\t//\n\t\t// https://stackoverflow.com/questions/31407778/display-scene-at-lower-resolution-in-three-js\n\t\t// TODO: this article mentions that setSize should be called after\n\t\t// renderer.setSize(this._size[0], this._size[1])\n\t\t// renderer.setPixelRatio(window.devicePixelRatio)\n\t\t// renderer.setSize(size[0]*1.5, size[1]*1.5)\n\t\t// canvas.width = \"//{size[0]}px\"\n\t\t// canvas.height = \"//{size[1]}px\"\n\t\t// canvas.style.width = \"//{size[0]}px\"\n\t\t// canvas.style.height = \"//{size[1]}px\"\n\n\t\t// TODO: ensure the renderers get added to a list\n\t\t//if !this.player_mode\n\t\t//\tconsole.log(\"set window.viewer_renderer from Threejs.vue component\")\n\t\t// window.viewer_renderer = renderer\n\t\t// POLY.renderers_controller.register_renderer(renderer)\n\n\t\tthis.camerasController.prepareCurrentCamera();\n\n\t\tthis.animate();\n\t}\n\n\tsetAutoRender(state = true) {\n\t\tthis._do_render = state;\n\t\tif (this._do_render) {\n\t\t\tthis.animate();\n\t\t}\n\t}\n\n\tanimate() {\n\t\tif (this._do_render) {\n\t\t\tthis._request_animation_frame_id = requestAnimationFrame(this._animate_method);\n\t\t\tif (this._onBeforeTick) {\n\t\t\t\tthis._onBeforeTick();\n\t\t\t}\n\t\t\tthis._scene.timeController.incrementTimeIfPlaying();\n\t\t\tif (this._onAfterTick) {\n\t\t\t\tthis._onAfterTick();\n\t\t\t}\n\t\t\tthis.render();\n\t\t\tthis._controls_controller?.update();\n\t\t}\n\t}\n\n\tprivate _cancel_animate() {\n\t\tthis._do_render = false;\n\t\tif (this._request_animation_frame_id) {\n\t\t\tcancelAnimationFrame(this._request_animation_frame_id);\n\t\t}\n\t\tif (this._canvas) {\n\t\t\tthis._camera_node.renderController.delete_renderer(this._canvas);\n\t\t}\n\t}\n\n\trender() {\n\t\tif (this.camerasController.cameraNode && this._canvas) {\n\t\t\tif (this._onBeforeRender) {\n\t\t\t\tthis._onBeforeRender();\n\t\t\t}\n\t\t\tconst size = this.camerasController.size;\n\t\t\tconst aspect = this.camerasController.aspect;\n\t\t\tthis._camera_node.renderController.render(this._canvas, size, aspect);\n\t\t\tif (this._onAfterRender) {\n\t\t\t\tthis._onAfterRender();\n\t\t\t}\n\t\t} else {\n\t\t\tconsole.warn('no camera to render with');\n\t\t}\n\t}\n\n\trenderer() {\n\t\tif (this._canvas) {\n\t\t\treturn this._camera_node.renderController.renderer(this._canvas);\n\t\t}\n\t}\n}\n","import {Constructor, valueof} from '../../../types/GlobalTypes';\nimport {Camera} from 'three/src/cameras/Camera';\nimport {CoreTransform} from '../../../core/Transform';\nimport {ObjNodeRenderOrder} from './_Base';\nimport {ThreejsCameraControlsController} from './utils/cameras/ControlsController';\nimport {LayersController, LayerParamConfig} from './utils/LayersController';\nimport {PostProcessController, CameraPostProcessParamConfig} from './utils/cameras/PostProcessController';\nimport {RenderController, CameraRenderParamConfig} from './utils/cameras/RenderController';\nimport {TransformedParamConfig, TransformController} from './utils/TransformController';\nimport {ChildrenDisplayController} from './utils/ChildrenDisplayController';\nimport {DisplayNodeController} from '../utils/DisplayNodeController';\nimport {NodeContext} from '../../poly/NodeContext';\nimport {ThreejsViewer, ThreejsViewerProperties} from '../../viewers/Threejs';\nimport {FlagsControllerD} from '../utils/FlagsController';\nimport {BaseParamType} from '../../params/_Base';\nimport {BaseNodeType} from '../_Base';\nimport {BaseSopNodeType} from '../sop/_Base';\nimport {TypedObjNode} from './_Base';\nimport {BaseViewerType} from '../../viewers/_Base';\nimport {HierarchyController} from './utils/HierarchyController';\nimport {GeoNodeChildrenMap} from '../../poly/registers/nodes/Sop';\nimport {ParamsInitData} from '../utils/io/IOController';\nimport {Raycaster} from 'three/src/core/Raycaster';\nimport {Vector2} from 'three/src/math/Vector2';\nimport {CoreType} from '../../../core/Type';\nexport interface OrthoOrPerspCamera extends Camera {\n\tnear: number;\n\tfar: number;\n\tupdateProjectionMatrix: () => void;\n\tgetFocalLength?: () => void;\n}\n\nconst EVENT_CHANGE = {type: 'change'};\n\nexport const BASE_CAMERA_DEFAULT = {\n\tnear: 1.0,\n\tfar: 100.0,\n};\n\nexport enum UpdateFromControlsMode {\n\tON_END = 'on move end',\n\tALWAYS = 'always',\n\tNEVER = 'never',\n}\nexport const UPDATE_FROM_CONTROLS_MODES: UpdateFromControlsMode[] = [\n\tUpdateFromControlsMode.ON_END,\n\tUpdateFromControlsMode.ALWAYS,\n\tUpdateFromControlsMode.NEVER,\n];\n\nimport {ParamConfig, NodeParamsConfig} from '../utils/params/ParamsConfig';\n\nexport function CameraMasterCameraParamConfig<TBase extends Constructor>(Base: TBase) {\n\treturn class Mixin extends Base {\n\t\tsetMasterCamera = ParamConfig.BUTTON(null, {\n\t\t\tcallback: (node: BaseNodeType, param: BaseParamType) => {\n\t\t\t\tBaseCameraObjNodeClass.PARAM_CALLBACK_setMasterCamera(node as BaseCameraObjNodeType);\n\t\t\t},\n\t\t});\n\t};\n}\n\nexport function ThreejsCameraTransformParamConfig<TBase extends Constructor>(Base: TBase) {\n\treturn class Mixin extends Base {\n\t\tcamera = ParamConfig.FOLDER();\n\t\t/** @param controls node to allow the camera to be moved by user input */\n\t\tcontrols = ParamConfig.NODE_PATH('', {\n\t\t\tnodeSelection: {\n\t\t\t\tcontext: NodeContext.EVENT,\n\t\t\t},\n\t\t});\n\t\t/** @param define when the camera node transform parameters are updated after the controls have moved the internal camera object */\n\t\tupdateFromControlsMode = ParamConfig.INTEGER(\n\t\t\tUPDATE_FROM_CONTROLS_MODES.indexOf(UpdateFromControlsMode.ON_END),\n\t\t\t{\n\t\t\t\tmenu: {\n\t\t\t\t\tentries: UPDATE_FROM_CONTROLS_MODES.map((name, value) => {\n\t\t\t\t\t\treturn {name, value};\n\t\t\t\t\t}),\n\t\t\t\t},\n\t\t\t}\n\t\t);\n\t\t// allowUpdateFromControls = ParamConfig.BOOLEAN(1);\n\n\t\t/** @param near */\n\t\tnear = ParamConfig.FLOAT(BASE_CAMERA_DEFAULT.near, {\n\t\t\trange: [0, 100],\n\t\t\tcook: false,\n\t\t\tcomputeOnDirty: true,\n\t\t\tcallback: (node: BaseNodeType, param: BaseParamType) => {\n\t\t\t\tBaseThreejsCameraObjNodeClass.PARAM_CALLBACK_update_near_far_from_param(\n\t\t\t\t\tnode as BaseThreejsCameraObjNodeType,\n\t\t\t\t\tparam\n\t\t\t\t);\n\t\t\t},\n\t\t});\n\t\t/** @param far */\n\t\tfar = ParamConfig.FLOAT(BASE_CAMERA_DEFAULT.far, {\n\t\t\trange: [0, 100],\n\t\t\tcook: false,\n\t\t\tcomputeOnDirty: true,\n\t\t\tcallback: (node: BaseNodeType, param: BaseParamType) => {\n\t\t\t\tBaseThreejsCameraObjNodeClass.PARAM_CALLBACK_update_near_far_from_param(\n\t\t\t\t\tnode as BaseThreejsCameraObjNodeType,\n\t\t\t\t\tparam\n\t\t\t\t);\n\t\t\t},\n\t\t});\n\t\t// aspect = ParamConfig.FLOAT(1);\n\t\t// lock_width = ParamConfig.BOOLEAN(1);\n\t\t// look_at = ParamConfig.OPERATOR_PATH('');\n\t\t/** @param display */\n\t\tdisplay = ParamConfig.BOOLEAN(1);\n\t};\n}\n\nexport class BaseCameraObjParamsConfig extends CameraMasterCameraParamConfig(NodeParamsConfig) {}\nexport class BaseThreejsCameraObjParamsConfig extends CameraPostProcessParamConfig(\n\tCameraRenderParamConfig(\n\t\tTransformedParamConfig(\n\t\t\tLayerParamConfig(ThreejsCameraTransformParamConfig(CameraMasterCameraParamConfig(NodeParamsConfig)))\n\t\t)\n\t)\n) {}\n\nexport abstract class TypedCameraObjNode<\n\tO extends OrthoOrPerspCamera,\n\tK extends BaseCameraObjParamsConfig\n> extends TypedObjNode<O, K> {\n\t// public readonly flags: FlagsControllerD = new FlagsControllerD(this);\n\tpublic readonly renderOrder: number = ObjNodeRenderOrder.CAMERA;\n\tprotected _object!: O;\n\tprotected _aspect: number = -1;\n\tget object() {\n\t\treturn this._object;\n\t}\n\n\tasync cook() {\n\t\tthis.update_camera();\n\t\tthis._object.dispatchEvent(EVENT_CHANGE);\n\t\tthis.cookController.end_cook();\n\t}\n\n\ton_create() {}\n\ton_delete() {}\n\n\tprepare_raycaster(mouse: Vector2, raycaster: Raycaster) {}\n\n\tcamera() {\n\t\treturn this._object;\n\t}\n\tupdate_camera() {}\n\n\tstatic PARAM_CALLBACK_setMasterCamera(node: BaseCameraObjNodeType) {\n\t\tnode.set_as_master_camera();\n\t}\n\tset_as_master_camera() {\n\t\tthis.scene().camerasController.setMasterCameraNodePath(this.fullPath());\n\t}\n\n\tsetup_for_aspect_ratio(aspect: number) {}\n\tprotected _update_for_aspect_ratio(): void {}\n\n\tupdate_transform_params_from_object() {\n\t\t// CoreTransform.set_params_from_matrix(this._object.matrix, this, {scale: false})\n\t\tCoreTransform.set_params_from_object(this._object, this);\n\t}\n\tabstract createViewer(element: HTMLElement): BaseViewerType;\n\n\tstatic PARAM_CALLBACK_update_from_param(node: BaseCameraObjNodeType, param: BaseParamType) {\n\t\t(node.object as any)[param.name()] = (node.pv as any)[param.name()];\n\t}\n}\n\nexport class TypedThreejsCameraObjNode<\n\tO extends OrthoOrPerspCamera,\n\tK extends BaseThreejsCameraObjParamsConfig\n> extends TypedCameraObjNode<O, K> {\n\tpublic readonly flags: FlagsControllerD = new FlagsControllerD(this);\n\treadonly hierarchyController: HierarchyController = new HierarchyController(this);\n\treadonly transformController: TransformController = new TransformController(this);\n\tprotected _controls_controller: ThreejsCameraControlsController | undefined;\n\tget controls_controller(): ThreejsCameraControlsController {\n\t\treturn (this._controls_controller = this._controls_controller || new ThreejsCameraControlsController(this));\n\t}\n\tprotected _layers_controller: LayersController | undefined;\n\tget layers_controller() {\n\t\treturn (this._layers_controller = this._layers_controller || new LayersController(this));\n\t}\n\tprotected _render_controller: RenderController | undefined;\n\tget renderController(): RenderController {\n\t\treturn (this._render_controller = this._render_controller || new RenderController(this));\n\t}\n\tprotected _post_process_controller: PostProcessController | undefined;\n\tget postProcessController(): PostProcessController {\n\t\treturn (this._post_process_controller = this._post_process_controller || new PostProcessController(this));\n\t}\n\n\t// display_node and children_display controllers\n\tpublic readonly childrenDisplayController: ChildrenDisplayController = new ChildrenDisplayController(this);\n\tpublic readonly displayNodeController: DisplayNodeController = new DisplayNodeController(\n\t\tthis,\n\t\tthis.childrenDisplayController.displayNodeControllerCallbacks()\n\t);\n\t//\n\tprotected _children_controller_context = NodeContext.SOP;\n\n\tinitializeBaseNode() {\n\t\tsuper.initializeBaseNode();\n\t\tthis.io.outputs.set_has_one_output();\n\t\tthis.hierarchyController.initializeNode();\n\t\tthis.transformController.initializeNode();\n\n\t\tthis.childrenDisplayController.initializeNode();\n\t}\n\n\tcreateNode<S extends keyof GeoNodeChildrenMap>(\n\t\tnode_class: S,\n\t\tparams_init_value_overrides?: ParamsInitData\n\t): GeoNodeChildrenMap[S];\n\tcreateNode<K extends valueof<GeoNodeChildrenMap>>(\n\t\tnode_class: Constructor<K>,\n\t\tparams_init_value_overrides?: ParamsInitData\n\t): K;\n\tcreateNode<K extends valueof<GeoNodeChildrenMap>>(\n\t\tnode_class: Constructor<K>,\n\t\tparams_init_value_overrides?: ParamsInitData\n\t): K {\n\t\treturn super.createNode(node_class, params_init_value_overrides) as K;\n\t}\n\tchildren() {\n\t\treturn super.children() as BaseSopNodeType[];\n\t}\n\tnodesByType<K extends keyof GeoNodeChildrenMap>(type: K): GeoNodeChildrenMap[K][] {\n\t\treturn super.nodesByType(type) as GeoNodeChildrenMap[K][];\n\t}\n\n\tprepare_raycaster(mouse: Vector2, raycaster: Raycaster) {\n\t\traycaster.setFromCamera(mouse, this._object);\n\t}\n\n\tasync cook() {\n\t\tthis.transformController.update();\n\t\tthis.layers_controller.update();\n\t\t// await this.background_controller.update();\n\n\t\tthis.update_near_far();\n\n\t\tthis.renderController.update();\n\t\tthis.update_camera();\n\t\tthis.controls_controller.update_controls();\n\n\t\t// TODO: ideally the update transform and update camera\n\t\t// can both return if the camera has changed\n\t\t// and we can run this here instead of inside the update_transform and update_camera\n\t\t// this._object.dispatchEvent( EVENT_CHANGE )\n\t\tthis._object.dispatchEvent(EVENT_CHANGE);\n\t\tthis.cookController.end_cook();\n\t}\n\n\tstatic PARAM_CALLBACK_update_near_far_from_param(node: BaseThreejsCameraObjNodeType, param: BaseParamType) {\n\t\tnode.update_near_far();\n\t}\n\tupdate_near_far() {\n\t\tif (this._object.near != this.pv.near || this._object.far != this.pv.far) {\n\t\t\tthis._object.near = this.pv.near;\n\t\t\tthis._object.far = this.pv.far;\n\t\t\tthis._object.updateProjectionMatrix();\n\t\t}\n\t}\n\n\tsetup_for_aspect_ratio(aspect: number) {\n\t\tif (CoreType.isNaN(aspect)) {\n\t\t\treturn;\n\t\t}\n\t\tif (aspect && this._aspect != aspect) {\n\t\t\tthis._aspect = aspect;\n\t\t\tthis._update_for_aspect_ratio();\n\t\t}\n\t}\n\n\tcreateViewer(element: HTMLElement, viewer_properties?: ThreejsViewerProperties): ThreejsViewer {\n\t\treturn new ThreejsViewer(element, this.scene(), this, viewer_properties);\n\t}\n\tstatic PARAM_CALLBACK_reset_effects_composer(node: BaseThreejsCameraObjNodeType) {\n\t\tnode.postProcessController.reset();\n\t}\n}\n\nexport type BaseCameraObjNodeType = TypedCameraObjNode<OrthoOrPerspCamera, BaseCameraObjParamsConfig>;\nexport abstract class BaseCameraObjNodeClass extends TypedCameraObjNode<\n\tOrthoOrPerspCamera,\n\tBaseCameraObjParamsConfig\n> {}\n\nexport type BaseThreejsCameraObjNodeType = TypedThreejsCameraObjNode<\n\tOrthoOrPerspCamera,\n\tBaseThreejsCameraObjParamsConfig\n>;\nexport class BaseThreejsCameraObjNodeClass extends TypedThreejsCameraObjNode<\n\tOrthoOrPerspCamera,\n\tBaseThreejsCameraObjParamsConfig\n> {\n\tPARAM_CALLBACK_update_effects_composer(node: BaseNodeType) {}\n}\n","/**\n * Creates a perspective camera.\n *\n *\n */\nimport {Constructor} from '../../../types/GlobalTypes';\nimport {PerspectiveCamera} from 'three/src/cameras/PerspectiveCamera';\nimport {\n\tTypedThreejsCameraObjNode,\n\tBASE_CAMERA_DEFAULT,\n\tThreejsCameraTransformParamConfig,\n\tCameraMasterCameraParamConfig,\n} from './_BaseCamera';\n\nconst DEFAULT = {\n\tfov: 50,\n};\n\n// const EVENT_CHANGE = { type: 'change' };\nimport {ParamConfig, NodeParamsConfig} from '../utils/params/ParamsConfig';\nimport {CameraRenderParamConfig} from './utils/cameras/RenderController';\nimport {CameraPostProcessParamConfig} from './utils/cameras/PostProcessController';\nimport {LayerParamConfig} from './utils/LayersController';\nimport {TransformedParamConfig} from './utils/TransformController';\nimport {CameraNodeType} from '../../poly/NodeContext';\n\nexport function PerspectiveCameraObjParamConfigMixin<TBase extends Constructor>(Base: TBase) {\n\treturn class Mixin extends Base {\n\t\t/** @param field of view */\n\t\tfov = ParamConfig.FLOAT(DEFAULT.fov, {range: [0, 100]});\n\t\t// vertical_fov_range = ParamConfig.VECTOR2([0, 100], {visibleIf: {lock_width: 1}});\n\t\t// horizontal_fov_range = ParamConfig.VECTOR2([0, 100], {visibleIf: {lock_width: 0}});\n\t};\n}\nclass PerspectiveCameraObjParamConfig extends CameraPostProcessParamConfig(\n\tCameraRenderParamConfig(\n\t\tLayerParamConfig(\n\t\t\tCameraMasterCameraParamConfig(\n\t\t\t\tPerspectiveCameraObjParamConfigMixin(\n\t\t\t\t\tThreejsCameraTransformParamConfig(\n\t\t\t\t\t\tTransformedParamConfig(NodeParamsConfig, {matrixAutoUpdate: true})\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t)\n\t\t)\n\t)\n) {}\nconst ParamsConfig = new PerspectiveCameraObjParamConfig();\n\nexport class PerspectiveCameraObjNode extends TypedThreejsCameraObjNode<\n\tPerspectiveCamera,\n\tPerspectiveCameraObjParamConfig\n> {\n\tparams_config = ParamsConfig;\n\tstatic type(): Readonly<CameraNodeType.PERSPECTIVE> {\n\t\treturn CameraNodeType.PERSPECTIVE;\n\t}\n\n\tcreate_object() {\n\t\treturn new PerspectiveCamera(DEFAULT.fov, 1, BASE_CAMERA_DEFAULT.near, BASE_CAMERA_DEFAULT.far);\n\t}\n\n\tupdate_camera() {\n\t\tif (this._object.fov != this.pv.fov) {\n\t\t\tthis._object.fov = this.pv.fov;\n\t\t\tthis._object.updateProjectionMatrix();\n\t\t}\n\t\tthis._update_for_aspect_ratio();\n\t}\n\n\tprotected _update_for_aspect_ratio() {\n\t\tif (this._aspect) {\n\t\t\t// let lock_width = true;//this.pv.lock_width;\n\n\t\t\tthis._object.aspect = this._aspect;\n\t\t\t// if (lock_width) {\n\t\t\t// \tconst other_fov = this.pv.fov / this._aspect;\n\t\t\t// \tthis._object.zoom = this.get_zoom(this._aspect, other_fov, this.pv.vertical_fov_range);\n\t\t\t// } else {\n\t\t\t// \tthis._object.zoom = 1;\n\t\t\t// }\n\t\t\tthis._object.updateProjectionMatrix();\n\t\t}\n\t}\n\t// private get_zoom(start_zoom: number, other_fov: number, range: Vector2) {\n\t// \tlet zoom = start_zoom;\n\t// \tif (range) {\n\t// \t\tif (other_fov < range.x || other_fov > range.y) {\n\t// \t\t\tconst new_other_fov = lodash_clamp(other_fov, range.x, range.y);\n\t// \t\t\tzoom = start_zoom * (other_fov / new_other_fov);\n\t// \t\t\t// zoom = Math.min(start_zoom, zoom)\n\t// \t\t}\n\t// \t}\n\t// \treturn zoom;\n\t// }\n}\n","import {TypedNode} from '../_Base';\nimport {Texture} from 'three/src/textures/Texture';\nimport {NodeParamsConfig} from '../utils/params/ParamsConfig';\nimport {NodeContext} from '../../poly/NodeContext';\nimport {PolyScene} from '../../scene/PolyScene';\nimport {FlagsControllerBO} from '../utils/FlagsController';\nimport {DataTexture} from 'three/src/textures/DataTexture';\nimport {LuminanceFormat, HalfFloatType} from 'three/src/constants';\n\nconst INPUT_COP_NAME = 'input texture';\nconst DEFAULT_INPUT_NAMES = [INPUT_COP_NAME, INPUT_COP_NAME, INPUT_COP_NAME, INPUT_COP_NAME];\n\nvar size = 32;\nvar data = new Uint16Array(size);\nfor (var i = 0; i < size; i++) {\n\tdata[i] = 0x70e2; // Half float 10000\n}\nconst EMPTY_DATA_TEXTURE = new DataTexture(data, size, 1, LuminanceFormat, HalfFloatType);\n\nexport class TypedCopNode<K extends NodeParamsConfig> extends TypedNode<NodeContext.COP, K> {\n\tpublic readonly flags: FlagsControllerBO = new FlagsControllerBO(this);\n\t// private _typed_array = new Uint8ClampedArray(512 * 512 * 4);\n\t// protected _texture: Texture = new DataTexture(this._typed_array, 512, 512, RGBFormat);\n\t// get texture() {\n\t// \treturn this._data_texture;\n\t// }\n\n\tstatic nodeContext(): NodeContext {\n\t\treturn NodeContext.COP;\n\t}\n\tstatic displayedInputNames(): string[] {\n\t\treturn DEFAULT_INPUT_NAMES;\n\t}\n\n\tconstructor(scene: PolyScene) {\n\t\tsuper(scene, 'BaseCopNode');\n\t}\n\n\tinitializeBaseNode() {\n\t\t// this.flags.add_bypass();\n\n\t\t// this.flags.add_display();\n\t\t// if (this.flags.display) {\n\t\t// \tthis.flags.display.set(false);\n\t\t// }\n\t\tthis.io.outputs.set_has_one_output();\n\t\t// this.containerController.init(CONTAINER_CLASS);\n\t}\n\n\tset_texture(texture: Texture) {\n\t\t// this._copy_texture(texture);\n\t\ttexture.name = this.fullPath();\n\t\tthis.setContainer(texture);\n\t}\n\tclear_texture() {\n\t\tthis.setContainer(EMPTY_DATA_TEXTURE);\n\t}\n\n\t// private _copy_texture(texture: Texture) {\n\t// \tconsole.log('_copy_texture', texture);\n\t// \tif (texture instanceof DataTexture) {\n\t// \t\tthis._data_texture.image = texture.image;\n\t// \t} else {\n\t// \t\tconst canvas = document.createElement('canvas');\n\t// \t\t// document.body.appendChild(canvas);\n\t// \t\tconst width = texture.image.width;\n\t// \t\tconst height = texture.image.height;\n\t// \t\tcanvas.width = width;\n\t// \t\tcanvas.height = height;\n\t// \t\tconst context = canvas.getContext('2d') as CanvasRenderingContext2D;\n\t// \t\tcontext.drawImage(texture.image, 0, 0);\n\t// \t\tconst image_data = context.getImageData(0, 0, width, height);\n\t// \t\tconsole.log(this._typed_array.length, image_data.data.length, image_data);\n\t// \t\tthis._data_texture.image = image_data;\n\t// \t}\n\t// \tthis._data_texture.format = texture.format;\n\t// \t// this._data_texture.mapping = texture.mapping;\n\t// \t// this._data_texture.wrapS = texture.wrapS;\n\t// \t// this._data_texture.wrapT = texture.wrapT;\n\t// \t// this._data_texture.minFilter = texture.minFilter;\n\t// \t// this._data_texture.magFilter = texture.magFilter;\n\t// \tthis._data_texture.needsUpdate = true;\n\t// \tconsole.log('updated data tex', this._data_texture);\n\n\t// \t// if (!this._texture || this._texture.uuid != texture.uuid) {\n\t// \t// \tif (!this._texture) {\n\t// \t// \t\tconsole.log('assign');\n\t// \t// \t\tthis._texture = texture.clone();\n\t// \t// \t\t// this._texture.name = this.fullPath();\n\t// \t// \t} else {\n\t// \t// \t\tconsole.log('copy');\n\t// \t// \t\tconst keys = Object.keys(texture) as Array<keyof Texture>;\n\t// \t// \t\tconst protected_keys = ['uuid', 'name', 'node'];\n\t// \t// \t\tfor (let key of keys) {\n\t// \t// \t\t\tif (!protected_keys.includes(key)) {\n\t// \t// \t\t\t\tthis._texture[key] = texture[key] as never; // but why is 'never' needed?!\n\t// \t// \t\t\t}\n\t// \t// \t\t}\n\t// \t// \t}\n\t// \t// }\n\t// }\n}\n\nexport type BaseCopNodeType = TypedCopNode<any>;\nexport class BaseCopNodeClass extends TypedCopNode<any> {}\n","export const ASSETS_ROOT = 'https://raw.githubusercontent.com/polygonjs/polygonjs-assets/master/';\n","import {VideoTexture} from 'three/src/textures/VideoTexture';\nimport {TextureLoader} from 'three/src/loaders/TextureLoader';\nimport {Texture} from 'three/src/textures/Texture';\nimport {CoreWalker} from '../Walker';\nimport {BaseNodeType} from '../../engine/nodes/_Base';\nimport {BaseParamType} from '../../engine/params/_Base';\nimport {BaseCopNodeClass} from '../../engine/nodes/cop/_Base';\nimport {TextureContainer} from '../../engine/containers/Texture';\nimport {Poly} from '../../engine/Poly';\nimport {ModuleName} from '../../engine/poly/registers/modules/_BaseRegister';\nimport {CoreUserAgent} from '../UserAgent';\nimport {ASSETS_ROOT} from './AssetsUtils';\ninterface VideoSourceTypeByExt {\n\togg: string;\n\togv: string;\n\tmp4: string;\n}\n// interface ImageScriptUrlByExt {\n// \texr: string;\n// \tbasis: string;\n// }\ninterface ThreeLoaderByExt {\n\texr: string;\n\tbasis: string;\n\thdr: string;\n}\n\nenum Extension {\n\tJPG = 'jpg',\n\tJPEG = 'jpeg',\n\tPNG = 'png',\n\tEXR = 'exr',\n\tBASIS = 'basis',\n\tHDR = 'hdr',\n}\nexport const TEXTURE_IMAGE_EXTENSIONS: Extension[] = [\n\tExtension.JPEG,\n\tExtension.JPG,\n\tExtension.PNG,\n\tExtension.EXR,\n\tExtension.BASIS,\n\tExtension.HDR,\n];\nexport const TEXTURE_VIDEO_EXTENSIONS: string[] = ['ogg', 'ogv', 'mp4'];\n\ninterface TextureLoadOptions {\n\ttdataType: boolean;\n\tdataType: number;\n}\nexport class CoreTextureLoader {\n\tstatic PARAM_DEFAULT = `${ASSETS_ROOT}/textures/uv.jpg`;\n\tstatic PARAM_ENV_DEFAULT = `${ASSETS_ROOT}/textures/piz_compressed.exr`;\n\n\tstatic VIDEO_EXTENSIONS = ['mp4', 'webm', 'ogv'];\n\tstatic VIDEO_SOURCE_TYPE_BY_EXT: VideoSourceTypeByExt = {\n\t\togg: 'video/ogg; codecs=\"theora, vorbis\"',\n\t\togv: 'video/ogg; codecs=\"theora, vorbis\"',\n\t\tmp4: 'video/mp4; codecs=\"avc1.42E01E, mp4a.40.2\"',\n\t};\n\n\tconstructor(private _node: BaseNodeType, private _param: BaseParamType) {}\n\n\tasync load_texture_from_url_or_op(\n\t\turl: string,\n\t\toptions: TextureLoadOptions\n\t): Promise<Texture | VideoTexture | null> {\n\t\tlet texture: Texture | null = null;\n\t\tlet found_node;\n\n\t\tif (url.substring(0, 3) == 'op:') {\n\t\t\tconst node_path = url.substring(3);\n\t\t\tfound_node = CoreWalker.find_node(this._node, node_path);\n\t\t\tif (found_node) {\n\t\t\t\tif (found_node instanceof BaseCopNodeClass) {\n\t\t\t\t\tconst container: TextureContainer = await found_node.requestContainer();\n\t\t\t\t\ttexture = container.texture();\n\t\t\t\t} else {\n\t\t\t\t\tthis._node.states.error.set(`found node is not a texture node`);\n\t\t\t\t}\n\n\t\t\t\t// this._assign_texture(attrib, texture)\n\t\t\t} else {\n\t\t\t\tthis._node.states.error.set(`no node found in path '${node_path}'`);\n\t\t\t}\n\t\t} else {\n\t\t\ttexture = await this.load_url(url, options);\n\t\t\tif (texture) {\n\t\t\t\t// param.mark_as_referencing_asset(url)\n\t\t\t\tif (this._param.options.texture_as_env()) {\n\t\t\t\t\t// texture = await CoreTextureLoader.set_texture_for_env(texture, this._node);\n\t\t\t\t} else {\n\t\t\t\t\ttexture = CoreTextureLoader.set_texture_for_mapping(texture);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis._node.states.error.set(`could not load texture ${url}`);\n\t\t\t}\n\t\t}\n\n\t\t// NOTE: if this._param gets its value from an expression like `ch('/CONTROL/photo_url')`\n\t\t// then found_node will be null, so the graph should not be changed\n\t\tif (found_node && this._param.graphPredecessors()[0] != found_node) {\n\t\t\tthis._param.graphDisconnectPredecessors();\n\t\t\tthis._param.addGraphInput(found_node);\n\t\t}\n\n\t\t// this._assign_texture(attrib, texture)\n\t\treturn texture;\n\t}\n\n\tasync load_url(url: string, options: TextureLoadOptions): Promise<Texture> {\n\t\treturn new Promise(async (resolve, reject) => {\n\t\t\t// url = this._resolve_url(url)\n\t\t\tconst ext = CoreTextureLoader.get_extension(url);\n\t\t\tif (url[0] != 'h') {\n\t\t\t\tconst assets_root = this._node.scene().assets.root();\n\t\t\t\tif (assets_root) {\n\t\t\t\t\turl = `${assets_root}${url}`;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (CoreTextureLoader.VIDEO_EXTENSIONS.includes(ext)) {\n\t\t\t\tconst texture: VideoTexture = await this._load_as_video(url);\n\t\t\t\tresolve(texture);\n\t\t\t} else {\n\t\t\t\tthis.loader_for_ext(ext, options).then(async (loader) => {\n\t\t\t\t\tif (loader) {\n\t\t\t\t\t\tCoreTextureLoader.increment_in_progress_loads_count();\n\t\t\t\t\t\tawait CoreTextureLoader.wait_for_max_concurrent_loads_queue_freed();\n\t\t\t\t\t\tloader.load(\n\t\t\t\t\t\t\turl,\n\t\t\t\t\t\t\t(texture: Texture) => {\n\t\t\t\t\t\t\t\tCoreTextureLoader.decrement_in_progress_loads_count();\n\t\t\t\t\t\t\t\tresolve(texture);\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tundefined,\n\t\t\t\t\t\t\t(error: any) => {\n\t\t\t\t\t\t\t\tCoreTextureLoader.decrement_in_progress_loads_count();\n\t\t\t\t\t\t\t\tPoly.warn('error', error);\n\t\t\t\t\t\t\t\treject();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t);\n\t\t\t\t\t} else {\n\t\t\t\t\t\treject();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\t}\n\n\tstatic module_names(ext: string): ModuleName[] | void {\n\t\tswitch (ext) {\n\t\t\tcase Extension.EXR:\n\t\t\t\treturn [ModuleName.EXRLoader];\n\t\t\tcase Extension.HDR:\n\t\t\t\treturn [ModuleName.RGBELoader];\n\t\t\tcase Extension.BASIS:\n\t\t\t\treturn [ModuleName.BasisTextureLoader];\n\t\t}\n\t}\n\n\tasync loader_for_ext(ext: string, options: TextureLoadOptions) {\n\t\tconst ext_lowercase = ext.toLowerCase() as keyof ThreeLoaderByExt;\n\t\tswitch (ext_lowercase) {\n\t\t\tcase Extension.EXR: {\n\t\t\t\treturn await this._exr_loader(options);\n\t\t\t}\n\t\t\tcase Extension.HDR: {\n\t\t\t\treturn await this._hdr_loader(options);\n\t\t\t}\n\t\t\tcase Extension.BASIS: {\n\t\t\t\treturn await this._basis_loader();\n\t\t\t}\n\t\t}\n\t\treturn new TextureLoader();\n\t}\n\n\tprivate async _exr_loader(options: TextureLoadOptions) {\n\t\tconst module = await Poly.modulesRegister.module(ModuleName.EXRLoader);\n\t\tif (module) {\n\t\t\tconst loader = new module.EXRLoader();\n\t\t\tif (options.tdataType) {\n\t\t\t\tloader.setDataType(options.dataType);\n\t\t\t}\n\t\t\treturn loader;\n\t\t}\n\t}\n\tprivate async _hdr_loader(options: TextureLoadOptions) {\n\t\tconst module = await Poly.modulesRegister.module(ModuleName.RGBELoader);\n\t\tif (module) {\n\t\t\tconst loader = new module.RGBELoader();\n\t\t\tif (options.tdataType) {\n\t\t\t\tloader.setDataType(options.dataType);\n\t\t\t}\n\t\t\treturn loader;\n\t\t}\n\t}\n\tprivate async _basis_loader() {\n\t\tconst module = await Poly.modulesRegister.module(ModuleName.BasisTextureLoader);\n\t\tif (module) {\n\t\t\tconst loader = new module.BasisTextureLoader();\n\t\t\tloader.setTranscoderPath('/three/js/libs/basis/');\n\t\t\tconst renderer = await Poly.renderersController.waitForRenderer();\n\t\t\tif (renderer) {\n\t\t\t\tloader.detectSupport(renderer);\n\t\t\t} else {\n\t\t\t\tPoly.warn('texture loader found no renderer for basis texture loader');\n\t\t\t}\n\t\t\treturn loader;\n\t\t}\n\t}\n\n\t_load_as_video(url: string): Promise<VideoTexture> {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tconst video = document.createElement('video');\n\t\t\t// document.body.appendChild(video)\n\t\t\t// video.id = 'video'\n\t\t\tvideo.setAttribute('crossOrigin', 'anonymous');\n\t\t\tvideo.setAttribute('autoplay', `${true}`); // to ensure it loads\n\t\t\tvideo.setAttribute('loop', `${true}`);\n\n\t\t\t// wait for onloadedmetadata to ensure that we have a duration\n\t\t\tvideo.onloadedmetadata = function () {\n\t\t\t\tvideo.pause();\n\t\t\t\tconst texture = new VideoTexture(video);\n\t\t\t\tresolve(texture);\n\t\t\t};\n\t\t\t// video.setAttribute('controls', true)\n\t\t\t// video.style=\"display:none\"\n\n\t\t\t// add source as is\n\t\t\tconst original_source = document.createElement('source');\n\t\t\tconst original_ext = CoreTextureLoader.get_extension(url) as keyof VideoSourceTypeByExt;\n\t\t\tlet type: string = CoreTextureLoader.VIDEO_SOURCE_TYPE_BY_EXT[original_ext];\n\t\t\ttype = type || CoreTextureLoader._default_video_source_type(url);\n\t\t\toriginal_source.setAttribute('type', type);\n\t\t\toriginal_source.setAttribute('src', url);\n\t\t\tvideo.appendChild(original_source);\n\n\t\t\t// add secondary source, either mp4 or ogv depending on the first url\n\t\t\tlet secondary_url = url;\n\t\t\tif (original_ext == 'mp4') {\n\t\t\t\t// add ogv\n\t\t\t\tsecondary_url = CoreTextureLoader.replace_extension(url, 'ogv');\n\t\t\t} else {\n\t\t\t\t// add mp4\n\t\t\t\tsecondary_url = CoreTextureLoader.replace_extension(url, 'mp4');\n\t\t\t}\n\t\t\tconst secondary_source = document.createElement('source');\n\t\t\tconst secondary_ext = CoreTextureLoader.get_extension(secondary_url) as keyof VideoSourceTypeByExt;\n\t\t\ttype = CoreTextureLoader.VIDEO_SOURCE_TYPE_BY_EXT[secondary_ext];\n\t\t\ttype = type || CoreTextureLoader._default_video_source_type(url);\n\t\t\tsecondary_source.setAttribute('type', type);\n\t\t\tsecondary_source.setAttribute('src', url);\n\t\t\tvideo.appendChild(secondary_source);\n\t\t});\n\t}\n\tstatic _default_video_source_type(url: string) {\n\t\tconst ext = this.get_extension(url);\n\t\treturn `video/${ext}`;\n\t}\n\n\tstatic pixel_data(texture: Texture) {\n\t\tconst img = texture.image;\n\t\tconst canvas = document.createElement('canvas');\n\t\tcanvas.width = img.width;\n\t\tcanvas.height = img.height;\n\t\tconst context = canvas.getContext('2d');\n\t\tif (context) {\n\t\t\tcontext.drawImage(img, 0, 0, img.width, img.height);\n\t\t\treturn context.getImageData(0, 0, img.width, img.height);\n\t\t}\n\t}\n\n\t// TODO: typescript: check what type the pixel_data is\n\t// static pixel_data_to_attribute(pixel_data: Pixel, geometry: BufferGeometry, attrib_name_with_component:string, convert_method: (x:number, y:number, z:number, w:number)=>number) {\n\t// \tconst {data} = pixel_data;\n\t// \tconst core_geometry = new CoreGeometry(geometry);\n\t// \t// TODO: add error if no uvs\n\t// \tconst values = [];\n\t// \tconst points = core_geometry.points();\n\t// \tfor (let point of points) {\n\t// \t\tconst uv = point.attribValue('uv');\n\t// \t\tconst x = Math.floor((pixel_data.width - 1) * uv.x);\n\t// \t\tconst y = Math.floor((pixel_data.height - 1) * (1 - uv.y));\n\t// \t\tconst i = y * pixel_data.width + x;\n\t// \t\t// const val = data[4*i] / 255.0;\n\t// \t\tif (convert_method) {\n\t// \t\t\tconst val = convert_method(data[4 * i + 0], data[4 * i + 1], data[4 * i + 2], data[4 * i + 3]);\n\t// \t\t\tvalues.push(val);\n\t// \t\t} else {\n\t// \t\t\tvalues.push([data[4 * i + 0], data[4 * i + 1], data[4 * i + 2]]);\n\t// \t\t}\n\t// \t}\n\n\t// \tconst attrib_name_elements = attrib_name_with_component.split('.');\n\t// \tlet attrib_name = attrib_name_elements[0];\n\t// \tlet component_offset = null;\n\t// \tif (attrib_name_elements.length > 1) {\n\t// \t\tconst component = attrib_name_elements[1] as keyof Vector4Like\n\t// \t\tcomponent_offset = {x: 0, y: 1, z: 2, w: 3}[component];\n\t// \t}\n\n\t// \tlet attrib = geometry.attributes[attrib_name];\n\t// \tif (attrib) {\n\t// \t\tconst array = attrib.array;\n\t// \t\tlet index = 0;\n\t// \t\tlet is_array = null;\n\t// \t\tfor (let value of values) {\n\t// \t\t\tif (is_array || CoreType.isArray(value)) {\n\t// \t\t\t\tis_array = true;\n\t// \t\t\t\tlet component_index = 0;\n\t// \t\t\t\tfor (let value_c of value) {\n\t// \t\t\t\t\tarray[attrib.itemSize * index + component_index] = value_c;\n\t// \t\t\t\t\tcomponent_index++;\n\t// \t\t\t\t}\n\t// \t\t\t} else {\n\t// \t\t\t\tarray[attrib.itemSize * index + component_offset] = value;\n\t// \t\t\t}\n\t// \t\t\tindex++;\n\t// \t\t}\n\t// \t} else {\n\t// \t\tattrib = geometry.setAttribute(attrib_name, new Float32BufferAttribute(values, 1));\n\t// \t}\n\t// \tattrib.needsUpdate = true;\n\t// }\n\n\tstatic get_extension(url: string) {\n\t\tconst url_without_params = url.split('?')[0];\n\t\tconst elements = url_without_params.split('.');\n\t\treturn elements[elements.length - 1].toLowerCase();\n\t}\n\tstatic replace_extension(url: string, new_extension: string) {\n\t\tconst elements = url.split('?');\n\t\tconst url_without_params = elements[0];\n\t\tconst url_elements = url_without_params.split('.');\n\t\turl_elements.pop();\n\t\turl_elements.push(new_extension);\n\t\treturn [url_elements.join('.'), elements[1]].join('?');\n\t}\n\t// static private _resolve_url(url: string):string{\n\t// \tif(url[0] == '/'){\n\t// \t\tconst root_url = POLY.env_is_production() ? 'https://polygonjs.com' : 'http://localhost:5000'\n\t// \t\turl = `${root_url}${url}`\n\t// \t}\n\t// \treturn url\n\t// }\n\n\tstatic set_texture_for_mapping(texture: Texture) {\n\t\t// let val = texture['wrapS']\n\t\t// Object.defineProperty(texture, 'wrapS', {\n\t\t// \tget () {\n\t\t// \t\treturn val // Simply return the cached value\n\t\t// \t},\n\t\t// \tset (newVal) {\n\t\t// \t\tval = newVal // Save the newVal\n\t\t// \t}\n\t\t// })\n\n\t\t// texture.wrapS = RepeatWrapping\n\t\t// texture.wrapT = RepeatWrapping\n\t\treturn texture;\n\t}\n\n\t// static async set_texture_for_env(texture: Texture, registerer: BaseNode) {\n\t// \tif (registerer._registered_env_map) {\n\t// \t\tPOLY.renderers_controller.deregister_env_map(registerer._registered_env_map);\n\t// \t}\n\t// \tregisterer._registered_env_map = await POLY.renderers_controller.register_env_map(texture);\n\t// \treturn registerer._registered_env_map;\n\t// }\n\n\t//\n\t//\n\t// CONCURRENT LOADS\n\t//\n\t//\n\tprivate static MAX_CONCURRENT_LOADS_COUNT: number = CoreTextureLoader._init_max_concurrent_loads_count();\n\tprivate static CONCURRENT_LOADS_DELAY: number = CoreTextureLoader._init_concurrent_loads_delay();\n\tprivate static in_progress_loads_count: number = 0;\n\tprivate static _queue: Array<() => void> = [];\n\tprivate static _init_max_concurrent_loads_count(): number {\n\t\treturn CoreUserAgent.isChrome() ? 10 : 4;\n\t\t// const parser = new UAParser();\n\t\t// const name = parser.getBrowser().name;\n\t\t// // limit to 4 for non chrome,\n\t\t// // as firefox was seen hanging trying to load multiple glb files\n\t\t// // limit to 1 for safari,\n\t\t// if (name) {\n\t\t// \tconst loads_count_by_browser: PolyDictionary<number> = {\n\t\t// \t\tChrome: 10,\n\t\t// \t\tFirefox: 4,\n\t\t// \t};\n\t\t// \tconst loads_count = loads_count_by_browser[name];\n\t\t// \tif (loads_count != null) {\n\t\t// \t\treturn loads_count;\n\t\t// \t}\n\t\t// }\n\t\t// return 1;\n\t}\n\tprivate static _init_concurrent_loads_delay(): number {\n\t\treturn CoreUserAgent.isChrome() ? 0 : 10;\n\t\t// const parser = new UAParser();\n\t\t// const name = parser.getBrowser().name;\n\t\t// // add a delay for browsers other than Chrome and Firefox\n\t\t// if (name) {\n\t\t// \tconst delay_by_browser: PolyDictionary<number> = {\n\t\t// \t\tChrome: 0,\n\t\t// \t\tFirefox: 10,\n\t\t// \t};\n\t\t// \tconst delay = delay_by_browser[name];\n\t\t// \tif (delay != null) {\n\t\t// \t\treturn delay;\n\t\t// \t}\n\t\t// }\n\t\t// return 100;\n\t}\n\tpublic static override_max_concurrent_loads_count(count: number) {\n\t\tthis.MAX_CONCURRENT_LOADS_COUNT = count;\n\t}\n\n\tprivate static increment_in_progress_loads_count() {\n\t\tthis.in_progress_loads_count++;\n\t}\n\tprivate static decrement_in_progress_loads_count() {\n\t\tthis.in_progress_loads_count--;\n\n\t\tconst queued_resolve = this._queue.pop();\n\t\tif (queued_resolve) {\n\t\t\tconst delay = this.CONCURRENT_LOADS_DELAY;\n\t\t\tsetTimeout(() => {\n\t\t\t\tqueued_resolve();\n\t\t\t}, delay);\n\t\t}\n\t}\n\n\tprivate static async wait_for_max_concurrent_loads_queue_freed() {\n\t\tif (this.in_progress_loads_count <= this.MAX_CONCURRENT_LOADS_COUNT) {\n\t\t\treturn;\n\t\t} else {\n\t\t\treturn new Promise((resolve) => {\n\t\t\t\tthis._queue.push(resolve);\n\t\t\t});\n\t\t}\n\t}\n}\n","import {WebGLRenderer} from 'three/src/renderers/WebGLRenderer';\nimport {LinearToneMapping} from 'three/src/constants';\nimport {TypedCopNode} from '../_Base';\n\nimport {NodeParamsConfig, ParamConfig} from '../../utils/params/ParamsConfig';\nimport {Poly} from '../../../Poly';\nimport {isBooleanTrue} from '../../../../core/BooleanValue';\nclass BaseCopRendererCopParamsConfig extends NodeParamsConfig {\n\tuseCameraRenderer = ParamConfig.BOOLEAN(0);\n}\nconst ParamsConfig = new BaseCopRendererCopParamsConfig();\nexport class BaseCopRendererCopNode extends TypedCopNode<BaseCopRendererCopParamsConfig> {\n\tparams_config = ParamsConfig;\n}\n\nexport class CopRendererController {\n\tprivate _renderer: WebGLRenderer | undefined;\n\n\tconstructor(private node: BaseCopRendererCopNode) {}\n\n\tasync renderer() {\n\t\tif (isBooleanTrue(this.node.pv.useCameraRenderer)) {\n\t\t\treturn await this.camera_renderer();\n\t\t} else {\n\t\t\treturn (this._renderer = this._renderer || this._create_renderer());\n\t\t}\n\t}\n\treset() {\n\t\tthis._renderer?.dispose();\n\t\tthis._renderer = undefined;\n\t}\n\n\tasync camera_renderer() {\n\t\tlet renderer = Poly.renderersController.firstRenderer();\n\t\tif (renderer) {\n\t\t\treturn renderer;\n\t\t} else {\n\t\t\treturn await Poly.renderersController.waitForRenderer();\n\t\t}\n\t}\n\n\tsave_state() {\n\t\t// const prev_target = renderer.getRenderTarget();\n\t\t// renderer.getSize(this._prev_renderer_size);\n\t\t// console.log('texture', texture);\n\t\t// const prev_pixel_aspect_ratio = renderer.getPixelRatio();\n\t\t// const prev_auto_clear: boolean = renderer.autoClear;\n\t\t// renderer.toneMappingExposure = 1;\n\t\t// renderer.outputEncoding = sRGBEncoding; // should be linear\n\n\t\tthis.make_linear();\n\t}\n\n\tmake_linear() {\n\t\t// renderer.outputEncoding = LinearEncoding\n\t}\n\n\trestore_state() {\n\t\t// renderer.setRenderTarget(prev_target);\n\t\t// renderer.setSize(this._prev_renderer_size.x, this._prev_renderer_size.y);\n\t\t// renderer.setPixelRatio(prev_pixel_aspect_ratio);\n\t\t// renderer.autoClear = prev_auto_clear;\n\t}\n\n\tprivate _create_renderer() {\n\t\tconst renderer = new WebGLRenderer();\n\t\trenderer.toneMapping = LinearToneMapping;\n\t\trenderer.setPixelRatio(1);\n\t\treturn renderer;\n\t}\n}\n","import {Constructor, PolyDictionary} from '../../../../types/GlobalTypes';\nimport {TypedCopNode} from '../_Base';\nimport {Texture} from 'three/src/textures/Texture';\nimport {\n\t// formats\n\tAlphaFormat,\n\tRedFormat,\n\tRedIntegerFormat,\n\tRGFormat,\n\tRGIntegerFormat,\n\tRGBFormat,\n\tRGBIntegerFormat,\n\tRGBAFormat,\n\tRGBAIntegerFormat,\n\tLuminanceFormat,\n\tLuminanceAlphaFormat,\n\t// RGBEFormat, //  removing as it is set to same value as RGBAFormat, so can be confusing\n\tDepthFormat,\n\tDepthStencilFormat,\n\n\t// types\n\tUnsignedByteType,\n\tByteType,\n\tShortType,\n\tUnsignedShortType,\n\tIntType,\n\tUnsignedIntType,\n\tFloatType,\n\tHalfFloatType,\n\tUnsignedShort4444Type,\n\tUnsignedShort5551Type,\n\tUnsignedShort565Type,\n\tUnsignedInt248Type,\n\n\t// encodings\n\tLinearEncoding,\n\tsRGBEncoding,\n\tGammaEncoding,\n\tRGBEEncoding,\n\tLogLuvEncoding,\n\tRGBM7Encoding,\n\tRGBM16Encoding,\n\tRGBDEncoding,\n\tBasicDepthPacking,\n\tRGBADepthPacking,\n\t// other\n\tUVMapping,\n\tCubeReflectionMapping,\n\tCubeRefractionMapping,\n\tEquirectangularReflectionMapping,\n\tEquirectangularRefractionMapping,\n\tCubeUVReflectionMapping,\n\tCubeUVRefractionMapping,\n\tClampToEdgeWrapping,\n\tRepeatWrapping,\n\tMirroredRepeatWrapping,\n} from 'three/src/constants';\nimport {\n\tMAG_FILTER_DEFAULT_VALUE,\n\tMAG_FILTER_MENU_ENTRIES,\n\tMIN_FILTER_DEFAULT_VALUE,\n\tMIN_FILTER_MENU_ENTRIES,\n} from '../../../../core/cop/ConstantFilter';\n\nconst FORMATS = [\n\t{AlphaFormat},\n\t{RedFormat},\n\t{RedIntegerFormat},\n\t{RGFormat},\n\t{RGIntegerFormat},\n\t{RGBFormat},\n\t{RGBIntegerFormat},\n\t{RGBAFormat},\n\t{RGBAIntegerFormat},\n\t{LuminanceFormat},\n\t{LuminanceAlphaFormat},\n\t// {RGBEFormat},\n\t{DepthFormat},\n\t{DepthStencilFormat},\n];\nconst TYPES = [\n\t{UnsignedByteType},\n\t{ByteType},\n\t{ShortType},\n\t{UnsignedShortType},\n\t{IntType},\n\t{UnsignedIntType},\n\t{FloatType},\n\t{HalfFloatType},\n\t{UnsignedShort4444Type},\n\t{UnsignedShort5551Type},\n\t{UnsignedShort565Type},\n\t{UnsignedInt248Type},\n];\n\nconst MAPPINGS = [\n\t{UVMapping},\n\t{CubeReflectionMapping},\n\t{CubeRefractionMapping},\n\t{EquirectangularReflectionMapping},\n\t{EquirectangularRefractionMapping},\n\t{CubeUVReflectionMapping},\n\t{CubeUVRefractionMapping},\n];\n\nconst ENCODINGS = [\n\t{LinearEncoding},\n\t{sRGBEncoding},\n\t{GammaEncoding},\n\t{RGBEEncoding},\n\t{LogLuvEncoding},\n\t{RGBM7Encoding},\n\t{RGBM16Encoding},\n\t{RGBDEncoding},\n\t{BasicDepthPacking},\n\t{RGBADepthPacking},\n];\nconst WRAPPINGS: PolyDictionary<number>[] = [{ClampToEdgeWrapping}, {RepeatWrapping}, {MirroredRepeatWrapping}];\n\nimport {NodeParamsConfig, ParamConfig} from '../../utils/params/ParamsConfig';\nimport {CopRendererController} from './RendererController';\nimport {BaseNodeType} from '../../_Base';\nimport {isBooleanTrue} from '../../../../core/BooleanValue';\n\nexport function TextureParamConfig<TBase extends Constructor>(Base: TBase) {\n\treturn class Mixin extends Base {\n\t\t/** @param toggle on to allow updating the texture encoding */\n\t\ttencoding = ParamConfig.BOOLEAN(0);\n\t\t/** @param sets the texture encoding */\n\t\tencoding = ParamConfig.INTEGER(LinearEncoding, {\n\t\t\tvisibleIf: {tencoding: 1},\n\t\t\tmenu: {\n\t\t\t\tentries: ENCODINGS.map((m) => {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tname: Object.keys(m)[0],\n\t\t\t\t\t\tvalue: Object.values(m)[0] as number,\n\t\t\t\t\t};\n\t\t\t\t}),\n\t\t\t},\n\t\t});\n\n\t\t/** @param toggle on to allow updating the texture mapping */\n\t\ttmapping = ParamConfig.BOOLEAN(0);\n\t\t/** @param sets the texture mapping */\n\t\tmapping = ParamConfig.INTEGER(UVMapping, {\n\t\t\tvisibleIf: {tmapping: 1},\n\t\t\tmenu: {\n\t\t\t\tentries: MAPPINGS.map((m) => {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tname: Object.keys(m)[0],\n\t\t\t\t\t\tvalue: Object.values(m)[0] as number,\n\t\t\t\t\t};\n\t\t\t\t}),\n\t\t\t},\n\t\t});\n\t\t/** @param toggle on to allow updating the texture wrap */\n\t\ttwrap = ParamConfig.BOOLEAN(0);\n\t\t/** @param sets the texture wrapS */\n\t\twrapS = ParamConfig.INTEGER(Object.values(WRAPPINGS[0])[0], {\n\t\t\tvisibleIf: {twrap: 1},\n\t\t\tmenu: {\n\t\t\t\tentries: WRAPPINGS.map((m) => {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tname: Object.keys(m)[0],\n\t\t\t\t\t\tvalue: Object.values(m)[0] as number,\n\t\t\t\t\t};\n\t\t\t\t}),\n\t\t\t},\n\t\t});\n\t\t/** @param sets the texture wrapT */\n\t\twrapT = ParamConfig.INTEGER(Object.values(WRAPPINGS[0])[0], {\n\t\t\tvisibleIf: {twrap: 1},\n\t\t\tmenu: {\n\t\t\t\tentries: WRAPPINGS.map((m) => {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tname: Object.keys(m)[0],\n\t\t\t\t\t\tvalue: Object.values(m)[0] as number,\n\t\t\t\t\t};\n\t\t\t\t}),\n\t\t\t},\n\t\t});\n\t\twrapSep = ParamConfig.SEPARATOR(null, {\n\t\t\tvisibleIf: {twrap: 1},\n\t\t});\n\t\t/** @param toggle on to allow updating the texture min filter */\n\t\ttminFilter = ParamConfig.BOOLEAN(0);\n\t\t/** @param sets the texture min filter */\n\t\tminFilter = ParamConfig.INTEGER(MIN_FILTER_DEFAULT_VALUE, {\n\t\t\tvisibleIf: {tminFilter: 1},\n\t\t\tmenu: {\n\t\t\t\tentries: MIN_FILTER_MENU_ENTRIES,\n\t\t\t},\n\t\t});\n\t\t/** @param toggle on to allow updating the texture mag filter */\n\t\ttmagFilter = ParamConfig.BOOLEAN(0);\n\t\t/** @param sets the texture mag filter */\n\t\tmagFilter = ParamConfig.INTEGER(MAG_FILTER_DEFAULT_VALUE, {\n\t\t\tvisibleIf: {tmagFilter: 1},\n\t\t\tmenu: {\n\t\t\t\tentries: MAG_FILTER_MENU_ENTRIES,\n\t\t\t},\n\t\t});\n\t\t/** @param toggle on to allow updating the texture anisotropy */\n\t\ttanisotropy = ParamConfig.BOOLEAN(0);\n\t\t/** @param sets the anisotropy from the max value allowed by the renderer */\n\t\tuseRendererMaxAnisotropy = ParamConfig.BOOLEAN(1, {\n\t\t\tvisibleIf: {tanisotropy: 1},\n\t\t});\n\t\t/** @param sets the anisotropy manually */\n\t\tanisotropy = ParamConfig.INTEGER(1, {\n\t\t\tvisibleIf: {tanisotropy: 1, useRendererMaxAnisotropy: 0},\n\t\t\trange: [0, 32],\n\t\t\trangeLocked: [true, false],\n\t\t});\n\t\t/** @param TBD */\n\t\tuseCameraRenderer = ParamConfig.BOOLEAN(0, {\n\t\t\tvisibleIf: {tanisotropy: 1, useRendererMaxAnisotropy: 1},\n\t\t});\n\t\tanisotropySep = ParamConfig.SEPARATOR(null, {\n\t\t\tvisibleIf: {tanisotropy: 1},\n\t\t});\n\t\t/** @param Toggle on to update the flipY */\n\t\ttflipY = ParamConfig.BOOLEAN(0);\n\t\t/** @param sets the flipY */\n\t\tflipY = ParamConfig.BOOLEAN(0, {visibleIf: {tflipY: 1}});\n\n\t\t/** @param toggle on to update the texture transform */\n\t\tttransform = ParamConfig.BOOLEAN(0);\n\t\t/** @param updates the texture offset */\n\t\toffset = ParamConfig.VECTOR2([0, 0], {\n\t\t\tvisibleIf: {ttransform: 1},\n\t\t\tcook: false,\n\t\t\tcallback: (node: BaseNodeType) => {\n\t\t\t\tTextureParamsController.PARAM_CALLBACK_update_offset(node as TextureCopNode);\n\t\t\t},\n\t\t});\n\t\t/** @param updates the texture repeat */\n\t\trepeat = ParamConfig.VECTOR2([1, 1], {\n\t\t\tvisibleIf: {ttransform: 1},\n\t\t\tcook: false,\n\t\t\tcallback: (node: BaseNodeType) => {\n\t\t\t\tTextureParamsController.PARAM_CALLBACK_update_repeat(node as TextureCopNode);\n\t\t\t},\n\t\t});\n\t\t/** @param updates the texture rotation */\n\t\trotation = ParamConfig.FLOAT(0, {\n\t\t\trange: [-1, 1],\n\t\t\tvisibleIf: {ttransform: 1},\n\t\t\tcook: false,\n\t\t\tcallback: (node: BaseNodeType) => {\n\t\t\t\tTextureParamsController.PARAM_CALLBACK_update_rotation(node as TextureCopNode);\n\t\t\t},\n\t\t});\n\t\t/** @param updates the texture center */\n\t\tcenter = ParamConfig.VECTOR2([0, 0], {\n\t\t\tvisibleIf: {ttransform: 1},\n\t\t\tcook: false,\n\t\t\tcallback: (node: BaseNodeType) => {\n\t\t\t\tTextureParamsController.PARAM_CALLBACK_update_center(node as TextureCopNode);\n\t\t\t},\n\t\t});\n\n\t\t/** @param toggle on to display advanced parameters */\n\t\ttadvanced = ParamConfig.BOOLEAN(0);\n\t\t/** @param toggle on to allow overriding the texture format */\n\t\ttformat = ParamConfig.BOOLEAN(0, {\n\t\t\tvisibleIf: {tadvanced: 1},\n\t\t});\n\t\t/** @param sets the texture format */\n\t\tformat = ParamConfig.INTEGER(RGBAFormat, {\n\t\t\tvisibleIf: {tadvanced: 1, tformat: 1},\n\t\t\tmenu: {\n\t\t\t\tentries: FORMATS.map((m) => {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tname: Object.keys(m)[0],\n\t\t\t\t\t\tvalue: Object.values(m)[0] as number,\n\t\t\t\t\t};\n\t\t\t\t}),\n\t\t\t},\n\t\t});\n\n\t\t/** @param toggle on to allow overriding the texture type */\n\t\tttype = ParamConfig.BOOLEAN(0, {\n\t\t\tvisibleIf: {tadvanced: 1},\n\t\t});\n\t\t/** @param sets the texture ty[e] */\n\t\ttype = ParamConfig.INTEGER(UnsignedByteType, {\n\t\t\tvisibleIf: {tadvanced: 1, ttype: 1},\n\t\t\tmenu: {\n\t\t\t\tentries: TYPES.map((m) => {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tname: Object.keys(m)[0],\n\t\t\t\t\t\tvalue: Object.values(m)[0] as number,\n\t\t\t\t\t};\n\t\t\t\t}),\n\t\t\t},\n\t\t});\n\t};\n}\n\nclass TextureParamsConfig extends TextureParamConfig(NodeParamsConfig) {}\nconst ParamsConfig = new TextureParamsConfig();\nclass TextureCopNode extends TypedCopNode<TextureParamsConfig> {\n\tparams_config = ParamsConfig;\n\tpublic readonly texture_params_controller = new TextureParamsController(this);\n}\n\nexport class TextureParamsController {\n\tconstructor(protected node: TextureCopNode) {}\n\tupdate(texture: Texture) {\n\t\tconst pv = this.node.pv;\n\t\tif (isBooleanTrue(pv.tencoding)) {\n\t\t\ttexture.encoding = pv.encoding;\n\t\t}\n\t\tif (isBooleanTrue(pv.tadvanced)) {\n\t\t\tif (isBooleanTrue(pv.tformat)) {\n\t\t\t\ttexture.format = pv.format;\n\t\t\t}\n\t\t\tif (isBooleanTrue(pv.ttype)) {\n\t\t\t\ttexture.type = pv.type;\n\t\t\t}\n\t\t}\n\t\tif (isBooleanTrue(pv.tmapping)) {\n\t\t\ttexture.mapping = pv.mapping;\n\t\t}\n\t\tif (isBooleanTrue(pv.twrap)) {\n\t\t\ttexture.wrapS = pv.wrapS;\n\t\t\ttexture.wrapT = pv.wrapT;\n\t\t}\n\t\tif (isBooleanTrue(pv.tminFilter)) {\n\t\t\ttexture.minFilter = pv.minFilter;\n\t\t}\n\t\tif (isBooleanTrue(pv.tminFilter)) {\n\t\t\ttexture.magFilter = pv.magFilter;\n\t\t}\n\t\tthis._update_anisotropy(texture);\n\n\t\t// do not have this in an if block,\n\t\t// as to be sure this is set to false in case it is set to true\n\t\t// by the texture loader\n\t\ttexture.flipY = pv.tflipY && pv.flipY;\n\t\tthis._update_texture_transform(texture);\n\t}\n\tprivate _renderer_controller: CopRendererController | undefined;\n\tprivate async _update_anisotropy(texture: Texture) {\n\t\tconst pv = this.node.pv;\n\t\tif (!isBooleanTrue(pv.tanisotropy)) {\n\t\t\treturn;\n\t\t}\n\t\tthis._renderer_controller = this._renderer_controller || new CopRendererController(this.node);\n\t\tconst renderer = await this._renderer_controller.renderer();\n\t\tconst max_anisotropy = renderer.capabilities.getMaxAnisotropy();\n\n\t\tif (isBooleanTrue(pv.useRendererMaxAnisotropy)) {\n\t\t\ttexture.anisotropy = max_anisotropy;\n\t\t} else {\n\t\t\ttexture.anisotropy = Math.min(pv.anisotropy, max_anisotropy);\n\t\t}\n\t}\n\n\tprivate _update_texture_transform(texture: Texture) {\n\t\tif (!isBooleanTrue(this.node.pv.ttransform)) {\n\t\t\treturn;\n\t\t}\n\t\tthis._update_offset(texture, false);\n\t\tthis._update_repeat(texture, false);\n\t\tthis._update_rotation(texture, false);\n\t\tthis._update_center(texture, false);\n\t\ttexture.updateMatrix();\n\t}\n\tprivate _update_offset(texture: Texture, update_matrix: boolean) {\n\t\ttexture.offset.copy(this.node.pv.offset);\n\t\tif (update_matrix) {\n\t\t\ttexture.updateMatrix();\n\t\t}\n\t}\n\tprivate _update_repeat(texture: Texture, update_matrix: boolean) {\n\t\ttexture.repeat.copy(this.node.pv.repeat);\n\t\tif (update_matrix) {\n\t\t\ttexture.updateMatrix();\n\t\t}\n\t}\n\tprivate _update_rotation(texture: Texture, update_matrix: boolean) {\n\t\ttexture.rotation = this.node.pv.rotation;\n\t\tif (update_matrix) {\n\t\t\ttexture.updateMatrix();\n\t\t}\n\t}\n\tprivate _update_center(texture: Texture, update_matrix: boolean) {\n\t\ttexture.center.copy(this.node.pv.center);\n\t\tif (update_matrix) {\n\t\t\ttexture.updateMatrix();\n\t\t}\n\t}\n\tstatic PARAM_CALLBACK_update_offset(node: TextureCopNode) {\n\t\tconst texture = node.containerController.container.texture();\n\t\tnode.texture_params_controller._update_offset(texture, true);\n\t}\n\tstatic PARAM_CALLBACK_update_repeat(node: TextureCopNode) {\n\t\tconst texture = node.containerController.container.texture();\n\t\tnode.texture_params_controller._update_repeat(texture, true);\n\t}\n\tstatic PARAM_CALLBACK_update_rotation(node: TextureCopNode) {\n\t\tconst texture = node.containerController.container.texture();\n\t\tnode.texture_params_controller._update_rotation(texture, true);\n\t}\n\tstatic PARAM_CALLBACK_update_center(node: TextureCopNode) {\n\t\tconst texture = node.containerController.container.texture();\n\t\tnode.texture_params_controller._update_center(texture, true);\n\t}\n}\n","const VIDEO_EXTENSIONS = ['mp4', 'ogv'];\nexport class CopFileTypeController {\n\tstatic is_static_image_url(url: string) {\n\t\tconst url_without_query_params = url.split('?')[0];\n\t\tconst url_elements = url_without_query_params.split('.');\n\t\tconst ext = url_elements[url_elements.length - 1];\n\t\treturn !VIDEO_EXTENSIONS.includes(ext);\n\t}\n}\n","/**\n * Imports an image file.\n *\n * @remarks\n * Performance tip: If possible, try to set min filter to LinearFilter in order to avoid the generation of mipmaps.\n * [https://discourse.threejs.org/t/threejs-app-performance-point-click-game/18491](https://discourse.threejs.org/t/threejs-app-performance-point-click-game/18491)\n */\nimport {Constructor} from '../../../types/GlobalTypes';\nimport {VideoTexture} from 'three/src/textures/VideoTexture';\nimport {Texture} from 'three/src/textures/Texture';\nimport {TypedCopNode} from './_Base';\nimport {CoreTextureLoader} from '../../../core/loader/Texture';\nimport {BaseNodeType} from '../_Base';\nimport {BaseParamType} from '../../params/_Base';\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {FileType} from '../../params/utils/OptionsController';\nimport {TextureParamsController, TextureParamConfig} from './utils/TextureParamsController';\nimport {CopFileTypeController} from './utils/FileTypeController';\n\nexport function ImageCopParamConfig<TBase extends Constructor>(Base: TBase) {\n\treturn class Mixin extends Base {\n\t\t/** @param url to fetch the image from */\n\t\turl = ParamConfig.STRING(CoreTextureLoader.PARAM_DEFAULT, {\n\t\t\tfileBrowse: {type: [FileType.TEXTURE_IMAGE]},\n\t\t});\n\t\t/** @param reload the image */\n\t\treload = ParamConfig.BUTTON(null, {\n\t\t\tcallback: (node: BaseNodeType, param: BaseParamType) => {\n\t\t\t\tImageCopNode.PARAM_CALLBACK_reload(node as ImageCopNode, param);\n\t\t\t},\n\t\t});\n\t};\n}\nclass ImageCopParamsConfig extends TextureParamConfig(ImageCopParamConfig(NodeParamsConfig)) {}\n\nconst ParamsConfig = new ImageCopParamsConfig();\n\nexport class ImageCopNode extends TypedCopNode<ImageCopParamsConfig> {\n\tparams_config = ParamsConfig;\n\tstatic type() {\n\t\treturn 'image';\n\t}\n\tasync requiredModules() {\n\t\tif (this.p.url.isDirty()) {\n\t\t\tawait this.p.url.compute();\n\t\t}\n\t\tconst ext = CoreTextureLoader.get_extension(this.pv.url || '');\n\t\treturn CoreTextureLoader.module_names(ext);\n\t}\n\n\tprivate _texture_loader: CoreTextureLoader | undefined;\n\tpublic readonly texture_params_controller: TextureParamsController = new TextureParamsController(this);\n\n\tinitializeNode() {\n\t\tthis.scene().dispatchController.onAddListener(() => {\n\t\t\tthis.params.onParamsCreated('params_label', () => {\n\t\t\t\tthis.params.label.init([this.p.url], () => {\n\t\t\t\t\tconst url = this.pv.url;\n\t\t\t\t\tif (url) {\n\t\t\t\t\t\tconst elements = url.split('/');\n\t\t\t\t\t\treturn elements[elements.length - 1];\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn '';\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t}\n\tasync cook() {\n\t\tif (CopFileTypeController.is_static_image_url(this.pv.url)) {\n\t\t\tawait this.cook_for_image();\n\t\t} else {\n\t\t\tthis.states.error.set('input is not an image');\n\t\t}\n\t}\n\n\tprivate async cook_for_image() {\n\t\tconst texture = await this._load_texture(this.pv.url);\n\n\t\tif (texture) {\n\t\t\tthis.texture_params_controller.update(texture);\n\t\t\tthis.set_texture(texture);\n\t\t} else {\n\t\t\tthis.clear_texture();\n\t\t}\n\t}\n\n\tresolved_url() {\n\t\treturn this.pv.url;\n\t}\n\n\t//\n\t//\n\t// UTILS\n\t//\n\t//\n\tstatic PARAM_CALLBACK_reload(node: ImageCopNode, param: BaseParamType) {\n\t\tnode.param_callback_reload();\n\t}\n\tprivate param_callback_reload() {\n\t\t// set the param dirty is preferable to just the successors, in case the expression result needs to be updated\n\t\t// this.p.url.set_successors_dirty();\n\t\tthis.p.url.setDirty();\n\t}\n\n\tprivate async _load_texture(url: string) {\n\t\tlet texture: Texture | VideoTexture | null = null;\n\t\tconst url_param = this.p.url;\n\t\tthis._texture_loader = this._texture_loader || new CoreTextureLoader(this, url_param);\n\t\ttry {\n\t\t\ttexture = await this._texture_loader.load_texture_from_url_or_op(url, {\n\t\t\t\ttdataType: this.pv.ttype && this.pv.tadvanced,\n\t\t\t\tdataType: this.pv.type,\n\t\t\t});\n\t\t\tif (texture) {\n\t\t\t\ttexture.matrixAutoUpdate = false;\n\t\t\t}\n\t\t} catch (e) {}\n\t\tif (!texture) {\n\t\t\tthis.states.error.set(`could not load texture '${url}'`);\n\t\t}\n\t\treturn texture;\n\t}\n}\n","import {Constructor} from '../../../../types/GlobalTypes';\nimport {BaseController} from './_BaseController';\nimport {TypedMatNode} from '../_Base';\nimport {Material} from 'three/src/materials/Material';\nimport {NodeParamsConfig, ParamConfig} from '../../utils/params/ParamsConfig';\nimport {IUniforms} from '../../../../core/geometry/Material';\nimport {isBooleanTrue} from '../../../../core/BooleanValue';\n\nexport function ColorParamConfig<TBase extends Constructor>(Base: TBase) {\n\treturn class Mixin extends Base {\n\t\t/** @param sets the material to transparent */\n\t\ttransparent = ParamConfig.BOOLEAN(0);\n\t\t/** @param sets the material opacity */\n\t\topacity = ParamConfig.FLOAT(1);\n\t\t/** @param sets the min alpha below which the material is invisible */\n\t\talphaTest = ParamConfig.FLOAT(0);\n\t\t/** @param toggle on if you have a fog in the scene and the material should be affected by it */\n\t\tuseFog = ParamConfig.BOOLEAN(0);\n\t};\n}\n\nclass ColoredMaterial extends Material {\n\tvertexColors!: boolean;\n\ttransparent!: boolean;\n\tdepthTest!: boolean;\n\talphaTest!: number;\n\tfog!: boolean;\n\tuniforms!: IUniforms;\n}\nclass ColorParamsConfig extends ColorParamConfig(NodeParamsConfig) {}\n\nclass ColoredMatNode extends TypedMatNode<ColoredMaterial, ColorParamsConfig> {\n\tcreateMaterial() {\n\t\treturn new ColoredMaterial();\n\t}\n}\n\nexport class ColorsController extends BaseController {\n\tconstructor(protected node: ColoredMatNode) {\n\t\tsuper(node);\n\t}\n\tstatic update(node: ColoredMatNode) {\n\t\tconst material = node.material;\n\t\tconst pv = node.pv;\n\n\t\tif (material.uniforms.opacity) {\n\t\t\tmaterial.uniforms.opacity.value = pv.opacity;\n\t\t}\n\t\tmaterial.transparent = isBooleanTrue(pv.transparent) || pv.opacity < 1;\n\t\tmaterial.depthTest = true;\n\t\tmaterial.alphaTest = pv.alphaTest;\n\t\tmaterial.fog = isBooleanTrue(pv.useFog);\n\t}\n}\n","import {BaseNodeType} from '../_Base';\nimport {ShaderMaterial} from 'three/src/materials/ShaderMaterial';\nimport {Texture} from 'three/src/textures/Texture';\nimport {Matrix3} from 'three/src/math/Matrix3';\nimport {IUniform} from 'three/src/renderers/shaders/UniformsLib';\nimport {ShaderMaterialWithCustomMaterials} from '../../../core/geometry/Material';\nimport {MaterialLoader} from 'three/src/loaders/MaterialLoader';\ninterface MaterialData {\n\tcolor?: boolean;\n\tlights?: boolean;\n}\n\nconst POSSIBLE_MAP_NAMES = ['map', 'alphaMap', 'envMap'];\nexport class BasePersistedConfig {\n\tconstructor(protected node: BaseNodeType) {}\n\ttoJSON(): object | void {}\n\tload(data: object) {}\n\n\t//\n\t//\n\t// SAVE MAT\n\t//\n\t//\n\tprotected _material_to_json(material: ShaderMaterial): object | undefined {\n\t\tthis._unassign_textures(material);\n\n\t\tlet material_data: object | undefined = undefined;\n\t\ttry {\n\t\t\tmaterial_data = material.toJSON({});\n\t\t} catch (err) {\n\t\t\tconsole.error('failed to save material data');\n\t\t\tconsole.log(material);\n\t\t}\n\t\tif (material_data && material.lights != null) {\n\t\t\t(material_data as any).lights = material.lights;\n\t\t}\n\n\t\tthis._reassign_textures(material);\n\t\treturn material_data;\n\t}\n\n\tprivate _found_uniform_texture_by_id: Map<string, Texture> = new Map();\n\tprivate _found_uniform_textures_id_by_uniform_name: Map<string, string> = new Map();\n\tprivate _found_param_texture_by_id: Map<string, Texture> = new Map();\n\tprivate _found_param_textures_id_by_uniform_name: Map<string, string> = new Map();\n\tprivate _unassign_textures(material: ShaderMaterial) {\n\t\tthis._found_uniform_texture_by_id.clear();\n\t\tthis._found_uniform_textures_id_by_uniform_name.clear();\n\t\tthis._found_param_texture_by_id.clear();\n\t\tthis._found_param_textures_id_by_uniform_name.clear();\n\t\tconst uniforms = material.uniforms;\n\t\tconst names = Object.keys(uniforms);\n\t\tfor (let name of names) {\n\t\t\tconst value = uniforms[name].value;\n\t\t\tif (value && value.uuid) {\n\t\t\t\tconst texture = value as Texture;\n\t\t\t\tthis._found_uniform_texture_by_id.set(texture.uuid, value);\n\t\t\t\tthis._found_uniform_textures_id_by_uniform_name.set(name, texture.uuid);\n\t\t\t\tuniforms[name].value = null;\n\t\t\t}\n\t\t}\n\t\tfor (let name of POSSIBLE_MAP_NAMES) {\n\t\t\tconst texture = (material as any)[name] as Texture;\n\t\t\tif (texture) {\n\t\t\t\tthis._found_param_texture_by_id.set(texture.uuid, texture);\n\t\t\t\tthis._found_param_textures_id_by_uniform_name.set(name, texture.uuid);\n\t\t\t\t(material as any)[name] = null;\n\t\t\t}\n\t\t}\n\t}\n\tprivate _reassign_textures(material: ShaderMaterial) {\n\t\tconst uniform_names_needing_reassignment: string[] = [];\n\t\tconst param_names_needing_reassignment: string[] = [];\n\t\tthis._found_uniform_textures_id_by_uniform_name.forEach((texture_id, name) => {\n\t\t\tuniform_names_needing_reassignment.push(name);\n\t\t});\n\t\tthis._found_param_textures_id_by_uniform_name.forEach((texture_id, name) => {\n\t\t\tparam_names_needing_reassignment.push(name);\n\t\t});\n\t\tconst uniforms = material.uniforms;\n\t\tfor (let name of uniform_names_needing_reassignment) {\n\t\t\tconst texture_id = this._found_uniform_textures_id_by_uniform_name.get(name);\n\t\t\tif (texture_id) {\n\t\t\t\tconst texture = this._found_uniform_texture_by_id.get(texture_id);\n\t\t\t\tif (texture) {\n\t\t\t\t\tuniforms[name].value = texture;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (let name of param_names_needing_reassignment) {\n\t\t\tconst texture_id = this._found_param_textures_id_by_uniform_name.get(name);\n\t\t\tif (texture_id) {\n\t\t\t\tconst texture = this._found_param_texture_by_id.get(texture_id);\n\t\t\t\tif (texture) {\n\t\t\t\t\t(material as any)[name] = texture;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t//\n\t//\n\t// LOAD MAT\n\t//\n\t//\n\tprotected _load_material(data: MaterialData): ShaderMaterialWithCustomMaterials | undefined {\n\t\t// if (2 > 1) {\n\t\t// \treturn;\n\t\t// }\n\n\t\t// hack fix for properties that are assumed to be on normal materials\n\t\t// but are not on ShaderMaterial\n\t\tdata.color = undefined;\n\n\t\tconst loader = new MaterialLoader();\n\t\tconst material = loader.parse(data) as ShaderMaterialWithCustomMaterials;\n\n\t\t// compensates for lights not being saved (and therefore cannot be loaded correctly)\n\t\tif (data.lights != null) {\n\t\t\tmaterial.lights = data.lights;\n\t\t}\n\n\t\t// fix matrix that may be loaded as a mat4 instead of a mat3\n\t\tconst uv2Transform = material.uniforms.uv2Transform;\n\t\tif (uv2Transform) {\n\t\t\tthis.mat4_to_mat3(uv2Transform);\n\t\t}\n\t\tconst uvTransform = material.uniforms.uvTransform;\n\t\tif (uvTransform) {\n\t\t\tthis.mat4_to_mat3(uvTransform);\n\t\t}\n\n\t\treturn material as ShaderMaterialWithCustomMaterials;\n\t}\n\tprivate mat4_to_mat3(uniform: IUniform) {\n\t\tconst mat4 = uniform.value;\n\t\tconst last_element = mat4.elements[mat4.elements.length - 1];\n\t\tif (last_element == null) {\n\t\t\tconst mat3 = new Matrix3();\n\t\t\tfor (let i = 0; i < mat3.elements.length; i++) {\n\t\t\t\tmat3.elements[i] = mat4.elements[i];\n\t\t\t}\n\t\t\tuniform.value = mat3;\n\t\t}\n\t}\n}\n","import {ParamType} from '../../../../poly/ParamType';\nimport {ParamInitValuesTypeMap} from '../../../../params/types/ParamInitValuesTypeMap';\n\nimport {TypedParam, BaseParamType} from '../../../../params/_Base';\nimport {NodeContext} from '../../../../poly/NodeContext';\nimport {BaseNodeType} from '../../../_Base';\nimport {ParamOptions} from '../../../../params/utils/OptionsController';\n\n// import {ParamValueComparer} from '../../params/ParamValueComparer';\n// import {ParamValueCloner} from '../../params/ParamValueCloner';\n// import {CoreTextureLoader} from '../../../../../Core/Loader/Texture'\n\nexport class ParamConfig<T extends ParamType> {\n\t// private _texture_loader: CoreTextureLoader\n\n\tconstructor(protected _type: T, protected _name: string, protected _default_value: ParamInitValuesTypeMap[T]) {}\n\n\tstatic from_param<K extends ParamType>(param: TypedParam<K>): ParamConfig<K> {\n\t\treturn new ParamConfig<K>(param.type(), param.name(), param.defaultValue());\n\t}\n\n\ttype() {\n\t\treturn this._type;\n\t}\n\tname() {\n\t\treturn this._name;\n\t}\n\tget default_value() {\n\t\treturn this._default_value;\n\t}\n\n\tget param_options(): ParamOptions {\n\t\tconst callback_bound = this._callback.bind(this);\n\t\tswitch (this._type) {\n\t\t\tcase ParamType.OPERATOR_PATH:\n\t\t\t\treturn {callback: callback_bound, nodeSelection: {context: NodeContext.COP}};\n\t\t\tdefault:\n\t\t\t\treturn {callback: callback_bound};\n\t\t}\n\t}\n\tprotected _callback(node: BaseNodeType, param: BaseParamType) {}\n}\n","import {Vector4} from 'three/src/math/Vector4';\nimport {Vector3} from 'three/src/math/Vector3';\nimport {Vector2} from 'three/src/math/Vector2';\nimport {Color} from 'three/src/math/Color';\nimport {ParamType} from '../../../../poly/ParamType';\nimport {ParamInitValuesTypeMap} from '../../../../params/types/ParamInitValuesTypeMap';\nimport {BaseNodeType} from '../../../_Base';\nimport {BaseParamType} from '../../../../params/_Base';\nimport {TypeAssert} from '../../../../poly/Assert';\nimport {IUniform} from 'three/src/renderers/shaders/UniformsLib';\nimport {RampParam} from '../../../../params/Ramp';\nimport {OperatorPathParam} from '../../../../params/OperatorPath';\nimport {ParamConfig} from '../../../utils/code/configs/ParamConfig';\n\nexport class GlParamConfig<T extends ParamType> extends ParamConfig<T> {\n\tprivate _uniform: IUniform | undefined;\n\n\tconstructor(_type: T, _name: string, _default_value: ParamInitValuesTypeMap[T], private _uniform_name: string) {\n\t\tsuper(_type, _name, _default_value);\n\t}\n\n\tget uniform_name() {\n\t\treturn this._uniform_name;\n\t}\n\n\tget uniform() {\n\t\treturn (this._uniform = this._uniform || this._create_uniform());\n\t}\n\n\tprivate _create_uniform() {\n\t\treturn GlParamConfig.uniform_by_type(this._type);\n\t}\n\n\texecute_callback(node: BaseNodeType, param: BaseParamType) {\n\t\tthis._callback(node, param);\n\t}\n\n\tprotected _callback(node: BaseNodeType, param: BaseParamType) {\n\t\tGlParamConfig.callback(param, this.uniform);\n\t\t// switch (param.type) {\n\t\t// \tcase ParamType.RAMP:\n\t\t// \t\tthis.uniform.value = (param as RampParam).ramp_texture();\n\t\t// \t\treturn;\n\t\t// \tcase ParamType.OPERATOR_PATH:\n\t\t// \t\tGlParamConfig.set_uniform_value_from_texture(param as OperatorPathParam, this.uniform);\n\t\t// \t\treturn;\n\t\t// \tdefault:\n\t\t// \t\tthis.uniform.value = param.value;\n\t\t// }\n\t}\n\n\tstatic callback(param: BaseParamType, uniform: IUniform) {\n\t\tswitch (param.type()) {\n\t\t\tcase ParamType.RAMP:\n\t\t\t\tuniform.value = (param as RampParam).ramp_texture();\n\t\t\t\treturn;\n\t\t\tcase ParamType.OPERATOR_PATH:\n\t\t\t\tGlParamConfig.set_uniform_value_from_texture(param as OperatorPathParam, uniform);\n\t\t\t\treturn;\n\t\t\tdefault:\n\t\t\t\tuniform.value = param.value;\n\t\t}\n\t}\n\n\t// TODO: refactor that to use the default values map?\n\tstatic uniform_by_type(type: ParamType): IUniform {\n\t\tswitch (type) {\n\t\t\tcase ParamType.BOOLEAN:\n\t\t\t\treturn {value: 0};\n\t\t\tcase ParamType.BUTTON:\n\t\t\t\treturn {value: 0};\n\t\t\tcase ParamType.COLOR:\n\t\t\t\treturn {value: new Color(0, 0, 0)};\n\t\t\tcase ParamType.FLOAT:\n\t\t\t\treturn {value: 0};\n\t\t\tcase ParamType.FOLDER:\n\t\t\t\treturn {value: 0};\n\t\t\tcase ParamType.INTEGER:\n\t\t\t\treturn {value: 0};\n\t\t\tcase ParamType.OPERATOR_PATH:\n\t\t\t\treturn {value: 0};\n\t\t\tcase ParamType.NODE_PATH:\n\t\t\t\treturn {value: 0};\n\t\t\tcase ParamType.PARAM_PATH:\n\t\t\t\treturn {value: 0};\n\t\t\t// case ParamType.STRING: return {type: 't', value: null} // new Texture()}\n\t\t\tcase ParamType.RAMP:\n\t\t\t\treturn {value: null}; // new Texture()}\n\t\t\tcase ParamType.SEPARATOR:\n\t\t\t\treturn {value: 0};\n\t\t\tcase ParamType.STRING:\n\t\t\t\treturn {value: null};\n\t\t\tcase ParamType.VECTOR2:\n\t\t\t\treturn {value: new Vector2(0, 0)};\n\t\t\tcase ParamType.VECTOR3:\n\t\t\t\treturn {value: new Vector3(0, 0, 0)};\n\t\t\tcase ParamType.VECTOR4:\n\t\t\t\treturn {value: new Vector4(0, 0, 0, 0)};\n\t\t}\n\t\tTypeAssert.unreachable(type);\n\t}\n\n\tstatic set_uniform_value_from_texture(param: OperatorPathParam, uniform: IUniform) {\n\t\tconst found_node = param.found_node();\n\t\tif (found_node) {\n\t\t\tif (found_node.isDirty()) {\n\t\t\t\tfound_node.requestContainer().then((container) => {\n\t\t\t\t\tconst texture = container.texture();\n\t\t\t\t\tuniform.value = texture;\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tconst container = found_node.containerController.container;\n\t\t\t\tconst texture = container.texture();\n\t\t\t\tuniform.value = texture;\n\t\t\t}\n\t\t} else {\n\t\t\tuniform.value = null;\n\t\t}\n\t}\n\n\tset_uniform_value_from_ramp(param: RampParam, uniform: IUniform) {\n\t\tuniform.value = param.ramp_texture();\n\t}\n}\n","import {BasePersistedConfig} from '../../../../utils/PersistedConfig';\nimport {BaseBuilderMatNodeType} from '../../../../mat/_BaseBuilder';\nimport {CustomMaterialName} from './_BaseMaterial';\nimport {ShaderMaterialWithCustomMaterials} from '../../../../../../core/geometry/Material';\nimport {IUniformsWithTime, IUniformsWithResolution} from '../../../../../scene/utils/UniformsController';\nimport {GlParamConfig} from '../../utils/ParamConfig';\nimport {Poly} from '../../../../../Poly';\nimport {PolyDictionary} from '../../../../../../types/GlobalTypes';\n\nexport interface PersistedConfigBaseMaterialData {\n\tmaterial: object;\n\tparam_uniform_pairs: [string, string][];\n\tuniforms_time_dependent?: boolean;\n\tuniforms_resolution_dependent?: boolean;\n\tcustom_materials?: PolyDictionary<object>;\n}\n\n// potential bug with Material Loader\n// - 1. a uniform with a mat3, such as uvTransform, will be reloaded with a mat4\n// - 2. the boolean lights property is not saved\n// - 3. if a color property is added on the material itself, it should not be saved\n// - 4. for the volume shader, a uniform with an array of vector can be saved, but not loaded again as a vector (but only as an {x,y,z} object)\nexport class MaterialPersistedConfig extends BasePersistedConfig {\n\tprivate _material: ShaderMaterialWithCustomMaterials | undefined;\n\tconstructor(protected node: BaseBuilderMatNodeType) {\n\t\tsuper(node);\n\t}\n\ttoJSON(): PersistedConfigBaseMaterialData | undefined {\n\t\tconst assemblerController = this.node.assemblerController;\n\t\tif (!assemblerController) {\n\t\t\treturn;\n\t\t}\n\n\t\t// custom materials\n\t\tconst custom_materials_data: PolyDictionary<object> = {};\n\t\tconst custom_materials = this.node.material.custom_materials;\n\t\tif (custom_materials) {\n\t\t\tconst custom_material_names: CustomMaterialName[] = Object.keys(custom_materials) as CustomMaterialName[];\n\t\t\tfor (let name of custom_material_names) {\n\t\t\t\tconst custom_material = custom_materials[name];\n\t\t\t\tif (custom_material) {\n\t\t\t\t\tconst material_data = this._material_to_json(custom_material);\n\t\t\t\t\tif (material_data) {\n\t\t\t\t\t\tcustom_materials_data[name] = material_data;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// params updating uniforms\n\t\tconst param_uniform_pairs: [string, string][] = [];\n\t\tconst param_configs = assemblerController.assembler.param_configs();\n\t\tfor (let param_config of param_configs) {\n\t\t\tparam_uniform_pairs.push([param_config.name(), param_config.uniform_name]);\n\t\t}\n\n\t\tconst material_data = this._material_to_json(this.node.material);\n\t\tif (!material_data) {\n\t\t\tconsole.warn('failed to save material from node', this.node.fullPath());\n\t\t}\n\n\t\tconst data = {\n\t\t\tmaterial: material_data || {},\n\t\t\tuniforms_time_dependent: assemblerController.assembler.uniforms_time_dependent(),\n\t\t\tuniforms_resolution_dependent: assemblerController.assembler.resolution_dependent(),\n\t\t\tparam_uniform_pairs: param_uniform_pairs,\n\t\t\tcustom_materials: custom_materials_data,\n\t\t};\n\t\treturn data;\n\t}\n\tload(data: PersistedConfigBaseMaterialData) {\n\t\tthis._material = this._load_material(data.material);\n\t\tif (!this._material) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._material.custom_materials = this._material.custom_materials || {};\n\t\tif (data.custom_materials) {\n\t\t\tconst names: CustomMaterialName[] = Object.keys(data.custom_materials) as CustomMaterialName[];\n\t\t\tfor (let name of names) {\n\t\t\t\tconst custom_mat_data = data.custom_materials[name];\n\t\t\t\tconst custom_mat = this._load_material(custom_mat_data);\n\t\t\t\tif (custom_mat) {\n\t\t\t\t\tthis._material.custom_materials[name] = custom_mat;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (data.uniforms_time_dependent) {\n\t\t\tthis.node\n\t\t\t\t.scene()\n\t\t\t\t.uniforms_controller.add_time_dependent_uniform_owner(\n\t\t\t\t\tthis._material.uuid,\n\t\t\t\t\tthis._material.uniforms as IUniformsWithTime\n\t\t\t\t);\n\t\t}\n\t\tif (data.uniforms_resolution_dependent) {\n\t\t\tthis.node\n\t\t\t\t.scene()\n\t\t\t\t.uniforms_controller.add_resolution_dependent_uniform_owner(\n\t\t\t\t\tthis._material.uuid,\n\t\t\t\t\tthis._material.uniforms as IUniformsWithResolution\n\t\t\t\t);\n\t\t}\n\t\tif (data.param_uniform_pairs) {\n\t\t\tfor (let pair of data.param_uniform_pairs) {\n\t\t\t\tconst param = this.node.params.get(pair[0]);\n\t\t\t\tconst uniform = this._material.uniforms[pair[1]];\n\t\t\t\tif (param && uniform) {\n\t\t\t\t\tparam.options.set_option('callback', () => {\n\t\t\t\t\t\tGlParamConfig.callback(param, uniform);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tmaterial(): ShaderMaterialWithCustomMaterials | undefined {\n\t\tif (Poly.playerMode()) {\n\t\t\treturn this._material;\n\t\t}\n\t}\n}\n","import {Constructor, valueof} from '../../../types/GlobalTypes';\nimport {TypedMatNode} from './_Base';\nimport {GlAssemblerController} from '../gl/code/Controller';\nimport {NodeParamsConfig} from '../utils/params/ParamsConfig';\nimport {ShaderAssemblerMaterial} from '../gl/code/assemblers/materials/_BaseMaterial';\nimport {MaterialPersistedConfig} from '../gl/code/assemblers/materials/PersistedConfig';\nimport {GlNodeChildrenMap} from '../../poly/registers/nodes/Gl';\nimport {BaseGlNodeType} from '../gl/_Base';\nimport {ShaderMaterialWithCustomMaterials} from '../../../core/geometry/Material';\nimport {NodeContext} from '../../poly/NodeContext';\nimport {ParamsInitData} from '../utils/io/IOController';\n\nexport abstract class TypedBuilderMatNode<\n\tA extends ShaderAssemblerMaterial,\n\tK extends NodeParamsConfig\n> extends TypedMatNode<ShaderMaterialWithCustomMaterials, K> {\n\tprotected _assembler_controller: GlAssemblerController<A> | undefined;\n\tprotected _children_controller_context = NodeContext.GL;\n\treadonly persisted_config: MaterialPersistedConfig = new MaterialPersistedConfig(this);\n\n\t//\n\t//\n\t// MATERIAL\n\t//\n\t//\n\tcreateMaterial() {\n\t\tlet material: ShaderMaterialWithCustomMaterials | undefined;\n\t\tif (this.persisted_config) {\n\t\t\tmaterial = this.persisted_config.material();\n\t\t}\n\t\tif (!material) {\n\t\t\tmaterial = this.assemblerController?.assembler.createMaterial() as ShaderMaterialWithCustomMaterials;\n\t\t}\n\t\treturn material;\n\t}\n\t//\n\t//\n\t// ASSEMBLER\n\t//\n\t//\n\tget assemblerController() {\n\t\treturn (this._assembler_controller = this._assembler_controller || this._create_assembler_controller());\n\t}\n\tprotected abstract _create_assembler_controller(): GlAssemblerController<A> | undefined;\n\n\tcreateNode<S extends keyof GlNodeChildrenMap>(\n\t\tnode_class: S,\n\t\tparams_init_value_overrides?: ParamsInitData\n\t): GlNodeChildrenMap[S];\n\tcreateNode<K extends valueof<GlNodeChildrenMap>>(\n\t\tnode_class: Constructor<K>,\n\t\tparams_init_value_overrides?: ParamsInitData\n\t): K;\n\tcreateNode<K extends valueof<GlNodeChildrenMap>>(\n\t\tnode_class: Constructor<K>,\n\t\tparams_init_value_overrides?: ParamsInitData\n\t): K {\n\t\treturn super.createNode(node_class, params_init_value_overrides) as K;\n\t}\n\tchildren() {\n\t\treturn super.children() as BaseGlNodeType[];\n\t}\n\tnodesByType<K extends keyof GlNodeChildrenMap>(type: K): GlNodeChildrenMap[K][] {\n\t\treturn super.nodesByType(type) as GlNodeChildrenMap[K][];\n\t}\n\tchildrenAllowed() {\n\t\tif (this.assemblerController) {\n\t\t\treturn super.childrenAllowed();\n\t\t}\n\t\tthis.scene().markAsReadOnly(this);\n\t\treturn false;\n\t}\n\n\t//\n\t//\n\t// COMPILATION\n\t//\n\t//\n\tcompile_if_required() {\n\t\t/* if we recompile while in player mode, there will not be any children gl node created.\n\t\tSo any recompilation will be flawed. A quick way to realise this is with a time dependent material.\n\t\tAnd while a scene export would not have an assembler and therefore not recompile,\n\t\ta temporary display of a scene will the whole engine player will have an assembler and will therefore recompile.\n\t\tUPDATE: the creation of children is not tied to the player mode anymore, only to the presence of the assembler.\n\t\t*/\n\t\t// if (Poly.playerMode()) {\n\t\t// \treturn;\n\t\t// }\n\t\tif (this.assemblerController?.compile_required()) {\n\t\t\tthis._compile();\n\t\t}\n\t}\n\tprotected _compile() {\n\t\tconst assemblerController = this.assemblerController;\n\t\tif (this.material && assemblerController) {\n\t\t\tassemblerController.assembler.compile_material(this.material);\n\t\t\tassemblerController.post_compile();\n\t\t}\n\t}\n}\n\nexport type BaseBuilderMatNodeType = TypedBuilderMatNode<ShaderAssemblerMaterial, NodeParamsConfig>;\n","/**\n * Creates a Mesh Basic Material, which can be extended with GL nodes.\n *\n * @remarks\n * This node can create children, which will be GL nodes. The GLSL code generated by the nodes will extend the Material.\n *\n */\n\nimport {NodeParamsConfig} from '../utils/params/ParamsConfig';\nimport {ColorParamConfig, ColorsController} from './utils/UniformsColorsController';\nimport {SideParamConfig, SideController} from './utils/SideController';\nimport {DepthController, DepthParamConfig} from './utils/DepthController';\nimport {SkinningParamConfig, SkinningController} from './utils/SkinningController';\nimport {TextureMapParamConfig, TextureMapController} from './utils/TextureMapController';\nimport {TextureAlphaMapParamConfig, TextureAlphaMapController} from './utils/TextureAlphaMapController';\nimport {ShaderAssemblerBasic} from '../gl/code/assemblers/materials/Basic';\nimport {TypedBuilderMatNode} from './_BaseBuilder';\nimport {Poly} from '../../Poly';\nimport {AssemblerName} from '../../poly/registers/assemblers/_BaseRegister';\nclass MeshBasicMatParamsConfig extends TextureAlphaMapParamConfig(\n\tTextureMapParamConfig(SkinningParamConfig(DepthParamConfig(SideParamConfig(ColorParamConfig(NodeParamsConfig)))))\n) {}\nconst ParamsConfig = new MeshBasicMatParamsConfig();\n\nexport class MeshBasicBuilderMatNode extends TypedBuilderMatNode<ShaderAssemblerBasic, MeshBasicMatParamsConfig> {\n\tparams_config = ParamsConfig;\n\tstatic type() {\n\t\treturn 'meshBasicBuilder';\n\t}\n\tpublic usedAssembler(): Readonly<AssemblerName.GL_MESH_BASIC> {\n\t\treturn AssemblerName.GL_MESH_BASIC;\n\t}\n\tprotected _create_assembler_controller() {\n\t\treturn Poly.assemblersRegister.assembler(this, this.usedAssembler());\n\t}\n\n\treadonly texture_map_controller: TextureMapController = new TextureMapController(this, {uniforms: true});\n\treadonly texture_alpha_map_controller: TextureAlphaMapController = new TextureAlphaMapController(this, {\n\t\tuniforms: true,\n\t});\n\treadonly depth_controller: DepthController = new DepthController(this);\n\tinitializeNode() {\n\t\tthis.params.onParamsCreated('init controllers', () => {\n\t\t\tthis.texture_map_controller.initializeNode();\n\t\t\tthis.texture_alpha_map_controller.initializeNode();\n\t\t});\n\t}\n\n\tasync cook() {\n\t\tthis.compile_if_required();\n\n\t\tColorsController.update(this);\n\t\tSideController.update(this);\n\t\tSkinningController.update(this);\n\t\tTextureMapController.update(this);\n\t\tTextureAlphaMapController.update(this);\n\t\tthis.depth_controller.update();\n\n\t\tthis.set_material(this.material);\n\t}\n}\n","import {DeleteSopNode} from '../../Delete';\n\nimport {CoreEntity} from '../../../../../core/geometry/Entity';\nimport {isBooleanTrue} from '../../../../../core/BooleanValue';\n\nexport class EntitySelectionHelper {\n\tpublic readonly selected_state: Map<CoreEntity, boolean> = new Map();\n\tprivate _entities_count: number = 0;\n\tprivate _selected_entities_count: number = 0;\n\tconstructor(protected node: DeleteSopNode) {}\n\n\tinit(entities: CoreEntity[]) {\n\t\tthis.selected_state.clear();\n\t\tfor (let entity of entities) {\n\t\t\tthis.selected_state.set(entity, false);\n\t\t}\n\t\tthis._entities_count = entities.length;\n\t\tthis._selected_entities_count = 0;\n\t}\n\tselect(entity: CoreEntity) {\n\t\tconst state = this.selected_state.get(entity);\n\t\tif (state != null) {\n\t\t\tif (state == false) {\n\t\t\t\tthis.selected_state.set(entity, true);\n\t\t\t\tthis._selected_entities_count++;\n\t\t\t}\n\t\t}\n\t}\n\tentities_to_keep(): CoreEntity[] {\n\t\treturn this._entities_for_state(isBooleanTrue(this.node.pv.invert));\n\t}\n\tentities_to_delete(): CoreEntity[] {\n\t\treturn this._entities_for_state(!isBooleanTrue(this.node.pv.invert));\n\t}\n\tprivate _entities_for_state(state: boolean): CoreEntity[] {\n\t\tconst required_state = state ? true : false;\n\t\tconst array_size = state ? this._selected_entities_count : this._entities_count - this._selected_entities_count;\n\n\t\tif (array_size == 0) {\n\t\t\treturn [];\n\t\t} else {\n\t\t\tconst array: CoreEntity[] = new Array(array_size);\n\t\t\tlet i = 0;\n\t\t\tthis.selected_state.forEach((state, entity) => {\n\t\t\t\tif (state == required_state) {\n\t\t\t\t\tarray[i] = entity;\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn array;\n\t\t}\n\t}\n}\n","import {DeleteSopNode} from '../../Delete';\nimport {ATTRIBUTE_TYPES, AttribType, AttribSize, ATTRIBUTE_SIZES} from '../../../../../core/geometry/Constant';\nimport {TypeAssert} from '../../../../poly/Assert';\nimport {Vector2} from 'three/src/math/Vector2';\nimport {Vector3} from 'three/src/math/Vector3';\nimport {Vector4} from 'three/src/math/Vector4';\nimport {CoreEntity} from '../../../../../core/geometry/Entity';\n\nexport enum ComparisonOperator {\n\tEQUAL = '==',\n\tLESS_THAN = '<',\n\tEQUAL_OR_LESS_THAN = '<=',\n\tEQUAL_OR_GREATER_THAN = '>=',\n\tGREATER_THAN = '>',\n\tDIFFERENT = '!=',\n}\nexport const COMPARISON_OPERATORS: Array<ComparisonOperator> = [\n\tComparisonOperator.EQUAL,\n\tComparisonOperator.LESS_THAN,\n\tComparisonOperator.EQUAL_OR_LESS_THAN,\n\tComparisonOperator.EQUAL_OR_GREATER_THAN,\n\tComparisonOperator.GREATER_THAN,\n\tComparisonOperator.DIFFERENT,\n];\n\ntype CompareMethodFloat = {[key in ComparisonOperator]: (n1: number, n2: number) => boolean};\nconst COMPARE_METHOD_FLOAT: CompareMethodFloat = {\n\t[ComparisonOperator.EQUAL]: (n1: number, n2: number) => {\n\t\treturn n1 == n2;\n\t},\n\t[ComparisonOperator.LESS_THAN]: (n1: number, n2: number) => {\n\t\treturn n1 < n2;\n\t},\n\t[ComparisonOperator.EQUAL_OR_LESS_THAN]: (n1: number, n2: number) => {\n\t\treturn n1 <= n2;\n\t},\n\t[ComparisonOperator.EQUAL_OR_GREATER_THAN]: (n1: number, n2: number) => {\n\t\treturn n1 >= n2;\n\t},\n\t[ComparisonOperator.GREATER_THAN]: (n1: number, n2: number) => {\n\t\treturn n1 > n2;\n\t},\n\t[ComparisonOperator.DIFFERENT]: (n1: number, n2: number) => {\n\t\treturn n1 != n2;\n\t},\n};\n\nexport const ComparisonOperatorMenuEntries = COMPARISON_OPERATORS.map((name, value) => {\n\treturn {name, value};\n});\n\nexport class ByAttributeHelper {\n\tconstructor(private node: DeleteSopNode) {}\n\n\teval_for_entities(entities: CoreEntity[]) {\n\t\tconst attribType = ATTRIBUTE_TYPES[this.node.pv.attribType];\n\t\tswitch (attribType) {\n\t\t\tcase AttribType.NUMERIC: {\n\t\t\t\tthis._eval_for_numeric(entities);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tcase AttribType.STRING: {\n\t\t\t\tthis._eval_for_string(entities);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tTypeAssert.unreachable(attribType);\n\t}\n\tprivate _eval_for_string(entities: CoreEntity[]) {\n\t\tlet value: string | undefined;\n\t\tfor (let entity of entities) {\n\t\t\tvalue = entity.stringAttribValue(this.node.pv.attribName);\n\t\t\tif (value == this.node.pv.attrib_string) {\n\t\t\t\tthis.node.entity_selection_helper.select(entity);\n\t\t\t}\n\t\t}\n\t}\n\tprivate _eval_for_numeric(entities: CoreEntity[]) {\n\t\tconst attribSize: AttribSize = ATTRIBUTE_SIZES[this.node.pv.attribSize - 1];\n\t\tswitch (attribSize) {\n\t\t\tcase AttribSize.FLOAT: {\n\t\t\t\treturn this._eval_for_points_numeric_float(entities);\n\t\t\t}\n\t\t\tcase AttribSize.VECTOR2: {\n\t\t\t\treturn this._eval_for_points_numeric_vector2(entities);\n\t\t\t}\n\t\t\tcase AttribSize.VECTOR3: {\n\t\t\t\treturn this._eval_for_points_numeric_vector3(entities);\n\t\t\t}\n\t\t\tcase AttribSize.VECTOR4: {\n\t\t\t\treturn this._eval_for_points_numeric_vector4(entities);\n\t\t\t}\n\t\t}\n\t\tTypeAssert.unreachable(attribSize);\n\t}\n\n\tprivate _eval_for_points_numeric_float(entities: CoreEntity[]) {\n\t\tlet attribName = this.node.pv.attribName;\n\t\tconst compared_value = this.node.pv.attribValue1;\n\t\tlet value: number;\n\t\tconst comparison_operator: ComparisonOperator = COMPARISON_OPERATORS[this.node.pv.attribComparisonOperator];\n\t\tconst compare_method = COMPARE_METHOD_FLOAT[comparison_operator];\n\t\tfor (let entity of entities) {\n\t\t\tvalue = entity.attribValue(attribName) as number;\n\t\t\tif (compare_method(value, compared_value)) {\n\t\t\t\tthis.node.entity_selection_helper.select(entity);\n\t\t\t}\n\t\t}\n\t}\n\tprivate _eval_for_points_numeric_vector2(entities: CoreEntity[]) {\n\t\tlet attribName = this.node.pv.attribName;\n\t\tconst compared_value = this.node.pv.attribValue2;\n\t\tlet target = new Vector2();\n\t\tfor (let entity of entities) {\n\t\t\tconst value = entity.attribValue(attribName, target) as Vector2;\n\t\t\tif (compared_value.equals(value)) {\n\t\t\t\tthis.node.entity_selection_helper.select(entity);\n\t\t\t}\n\t\t}\n\t}\n\tprivate _eval_for_points_numeric_vector3(entities: CoreEntity[]) {\n\t\tlet attribName = this.node.pv.attribName;\n\t\tconst compared_value = this.node.pv.attribValue3;\n\t\tlet target = new Vector3();\n\t\tfor (let entity of entities) {\n\t\t\tconst value = entity.attribValue(attribName, target) as Vector3;\n\t\t\tif (compared_value.equals(value)) {\n\t\t\t\tthis.node.entity_selection_helper.select(entity);\n\t\t\t}\n\t\t}\n\t}\n\tprivate _eval_for_points_numeric_vector4(entities: CoreEntity[]) {\n\t\tlet attribName = this.node.pv.attribName;\n\t\tconst compared_value = this.node.pv.attribValue4;\n\t\tlet target = new Vector4();\n\t\tfor (let entity of entities) {\n\t\t\tconst value = entity.attribValue(attribName, target) as Vector4;\n\t\t\tif (compared_value.equals(value)) {\n\t\t\t\tthis.node.entity_selection_helper.select(entity);\n\t\t\t}\n\t\t}\n\t}\n}\n","import {DeleteSopNode} from '../../Delete';\nimport {CoreEntity} from '../../../../../core/geometry/Entity';\nimport {isBooleanTrue} from '../../../../../core/BooleanValue';\n\nexport class ByExpressionHelper {\n\tconstructor(private node: DeleteSopNode) {}\n\tasync eval_for_entities(entities: CoreEntity[]) {\n\t\tconst param = this.node.p.expression;\n\t\tif (this.node.p.expression.hasExpression() && param.expressionController) {\n\t\t\tawait this.eval_expressions_for_points_with_expression(entities);\n\t\t} else {\n\t\t\tthis.eval_expressions_without_expression(entities);\n\t\t}\n\t}\n\n\tprivate async eval_expressions_for_points_with_expression(entities: CoreEntity[]) {\n\t\tconst param = this.node.p.expression;\n\t\tif (param.expressionController) {\n\t\t\tawait param.expressionController.compute_expression_for_entities(entities, (entity, value) => {\n\t\t\t\tif (value) {\n\t\t\t\t\tthis.node.entity_selection_helper.select(entity);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\tprivate eval_expressions_without_expression(entities: CoreEntity[]) {\n\t\tconst value = isBooleanTrue(this.node.pv.expression);\n\t\tif (value) {\n\t\t\tfor (let entity of entities) {\n\t\t\t\tthis.node.entity_selection_helper.select(entity);\n\t\t\t}\n\t\t}\n\t}\n}\n","import {DeleteSopNode} from '../../Delete';\nimport {CorePoint} from '../../../../../core/geometry/Point';\nimport {Box3} from 'three/src/math/Box3';\nimport {Vector3} from 'three/src/math/Vector3';\n\nexport class ByBboxHelper {\n\tprivate _bbox_cache: Box3 | undefined;\n\tprivate _point_position = new Vector3();\n\tconstructor(private node: DeleteSopNode) {}\n\teval_for_points(points: CorePoint[]) {\n\t\tfor (let point of points) {\n\t\t\tconst in_bbox = this._bbox.containsPoint(point.getPosition(this._point_position));\n\n\t\t\tif (in_bbox) {\n\t\t\t\tthis.node.entity_selection_helper.select(point);\n\t\t\t}\n\t\t}\n\t}\n\tprivate get _bbox() {\n\t\treturn this._bbox_cache != null\n\t\t\t? this._bbox_cache\n\t\t\t: (this._bbox_cache = new Box3(\n\t\t\t\t\tthis.node.pv.bboxCenter.clone().sub(this.node.pv.bboxSize.clone().multiplyScalar(0.5)),\n\t\t\t\t\tthis.node.pv.bboxCenter.clone().add(this.node.pv.bboxSize.clone().multiplyScalar(0.5))\n\t\t\t  ));\n\t}\n}\n","import {DeleteSopNode} from '../../Delete';\nimport {CoreObject} from '../../../../../core/geometry/Object';\nimport {ObjectTypes, objectTypeFromConstructor} from '../../../../../core/geometry/Constant';\n\nexport class ByObjectTypeHelper {\n\tconstructor(private node: DeleteSopNode) {}\n\n\teval_for_objects(core_objects: CoreObject[]) {\n\t\tconst object_type = ObjectTypes[this.node.pv.objectType];\n\n\t\tfor (let core_object of core_objects) {\n\t\t\tconst object = core_object.object();\n\n\t\t\tif (objectTypeFromConstructor(object.constructor) == object_type) {\n\t\t\t\tthis.node.entity_selection_helper.select(core_object);\n\t\t\t}\n\t\t}\n\t}\n}\n","/**\n * Delete parts of the input geometry\n *\n * @remarks\n * This can be used in many ways to delete points or objects from the input.\n *\n */\nimport {TypedSopNode} from './_Base';\nimport {\n\tAttribClass,\n\tAttribClassMenuEntries,\n\tObjectType,\n\tObjectTypeMenuEntries,\n\tObjectTypes,\n\tobjectTypeFromConstructor,\n\tAttribType,\n\tAttribTypeMenuEntries,\n\tATTRIBUTE_TYPES,\n\tAttribSize,\n\tATTRIBUTE_CLASSES,\n\tATTRIBUTE_SIZE_RANGE,\n} from '../../../core/geometry/Constant';\nimport {CoreGroup, Object3DWithGeometry} from '../../../core/geometry/Group';\nimport {CoreGeometry} from '../../../core/geometry/Geometry';\nimport {InputCloneMode} from '../../poly/InputCloneMode';\nimport {CorePoint} from '../../../core/geometry/Point';\nimport {CoreObject} from '../../../core/geometry/Object';\n\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {EntitySelectionHelper} from './utils/delete/EntitySelectionHelper';\nimport {\n\tByAttributeHelper,\n\tComparisonOperatorMenuEntries,\n\tComparisonOperator,\n\tCOMPARISON_OPERATORS,\n} from './utils/delete/ByAttributeHelper';\nimport {ByExpressionHelper} from './utils/delete/ByExpressionHelper';\nimport {ByBboxHelper} from './utils/delete/ByBboxHelper';\nimport {Object3D} from 'three/src/core/Object3D';\nimport {ByObjectTypeHelper} from './utils/delete/ByObjectTypeHelper';\nimport {isBooleanTrue} from '../../../core/BooleanValue';\nclass DeleteSopParamsConfig extends NodeParamsConfig {\n\t/** @param defines the class that should be deleted (objects or vertices) */\n\tclass = ParamConfig.INTEGER(ATTRIBUTE_CLASSES.indexOf(AttribClass.VERTEX), {\n\t\tmenu: {\n\t\t\tentries: AttribClassMenuEntries,\n\t\t},\n\t});\n\t/** @param invert the selection created in the parameters below */\n\tinvert = ParamConfig.BOOLEAN(0);\n\t// hide_objects = ParamConfig.BOOLEAN(0, {\n\t// \tvisibleIf: {class: ATTRIBUTE_CLASSES.indexOf(AttribClass.OBJECT)},\n\t// });\n\n\t// byObjectType\n\t/** @param deletes objects by object type */\n\tbyObjectType = ParamConfig.BOOLEAN(0, {\n\t\tvisibleIf: {class: ATTRIBUTE_CLASSES.indexOf(AttribClass.OBJECT)},\n\t});\n\t/** @param sets which object types should be deleted */\n\tobjectType = ParamConfig.INTEGER(ObjectTypes.indexOf(ObjectType.MESH), {\n\t\tmenu: {\n\t\t\tentries: ObjectTypeMenuEntries,\n\t\t},\n\t\tvisibleIf: {\n\t\t\tclass: ATTRIBUTE_CLASSES.indexOf(AttribClass.OBJECT),\n\t\t\tbyObjectType: true,\n\t\t},\n\t});\n\tseparatorObjectType = ParamConfig.SEPARATOR(null, {\n\t\tvisibleIf: {class: ATTRIBUTE_CLASSES.indexOf(AttribClass.OBJECT)},\n\t});\n\n\t// byExpression\n\t/** @param deletes objects by an expression */\n\tbyExpression = ParamConfig.BOOLEAN(0);\n\t/** @param sets the expression to select what should be deleted */\n\texpression = ParamConfig.BOOLEAN('@ptnum==0', {\n\t\tvisibleIf: {byExpression: true},\n\t\texpression: {forEntities: true},\n\t});\n\tseparatorExpression = ParamConfig.SEPARATOR();\n\n\t// byAttrib\n\t/** @param deletes objects by an attribute */\n\tbyAttrib = ParamConfig.BOOLEAN(0);\n\t/** @param sets the type of the attribute for which items should be deleted */\n\tattribType = ParamConfig.INTEGER(ATTRIBUTE_TYPES.indexOf(AttribType.NUMERIC), {\n\t\tmenu: {\n\t\t\tentries: AttribTypeMenuEntries,\n\t\t},\n\t\tvisibleIf: {byAttrib: 1},\n\t});\n\t/** @param name of the attribute used */\n\tattribName = ParamConfig.STRING('', {\n\t\tvisibleIf: {byAttrib: 1},\n\t});\n\t/** @param size of the attribute used */\n\tattribSize = ParamConfig.INTEGER(1, {\n\t\trange: ATTRIBUTE_SIZE_RANGE,\n\t\trangeLocked: [true, true],\n\t\tvisibleIf: {byAttrib: 1, attribType: ATTRIBUTE_TYPES.indexOf(AttribType.NUMERIC)},\n\t});\n\t/** @param comparison operator */\n\tattribComparisonOperator = ParamConfig.INTEGER(COMPARISON_OPERATORS.indexOf(ComparisonOperator.EQUAL), {\n\t\tmenu: {\n\t\t\tentries: ComparisonOperatorMenuEntries,\n\t\t},\n\t\tvisibleIf: {\n\t\t\tbyAttrib: true,\n\t\t\tattribType: ATTRIBUTE_TYPES.indexOf(AttribType.NUMERIC),\n\t\t\tattribSize: AttribSize.FLOAT,\n\t\t},\n\t});\n\t/** @param value of the attribute to compare with (when using float attribute) */\n\tattribValue1 = ParamConfig.FLOAT(0, {\n\t\tvisibleIf: {byAttrib: 1, attribType: ATTRIBUTE_TYPES.indexOf(AttribType.NUMERIC), attribSize: 1},\n\t});\n\t/** @param value of the attribute to compare with (when using vector2 attribute) */\n\tattribValue2 = ParamConfig.VECTOR2([0, 0], {\n\t\tvisibleIf: {byAttrib: 1, attribType: ATTRIBUTE_TYPES.indexOf(AttribType.NUMERIC), attribSize: 2},\n\t});\n\t/** @param value of the attribute to compare with (when using vector3 attribute) */\n\tattribValue3 = ParamConfig.VECTOR3([0, 0, 0], {\n\t\tvisibleIf: {byAttrib: 1, attribType: ATTRIBUTE_TYPES.indexOf(AttribType.NUMERIC), attribSize: 3},\n\t});\n\t/** @param value of the attribute to compare with (when using vector4 attribute) */\n\tattribValue4 = ParamConfig.VECTOR4([0, 0, 0, 0], {\n\t\tvisibleIf: {byAttrib: 1, attribType: ATTRIBUTE_TYPES.indexOf(AttribType.NUMERIC), attribSize: 4},\n\t});\n\t/** @param value of the attribute to compare with (when using string attribute) */\n\tattribString = ParamConfig.STRING('', {\n\t\tvisibleIf: {byAttrib: 1, attribType: ATTRIBUTE_TYPES.indexOf(AttribType.STRING)},\n\t});\n\tseparatorAttrib = ParamConfig.SEPARATOR();\n\n\t// byBbox\n\t/** @param deletes objects that are inside a bounding box */\n\tbyBbox = ParamConfig.BOOLEAN(0, {\n\t\tvisibleIf: {\n\t\t\tclass: ATTRIBUTE_CLASSES.indexOf(AttribClass.VERTEX),\n\t\t},\n\t});\n\t/** @param the bounding box size */\n\tbboxSize = ParamConfig.VECTOR3([1, 1, 1], {\n\t\tvisibleIf: {\n\t\t\tclass: ATTRIBUTE_CLASSES.indexOf(AttribClass.VERTEX),\n\t\t\tbyBbox: true,\n\t\t},\n\t});\n\t/** @param the bounding box center */\n\tbboxCenter = ParamConfig.VECTOR3([0, 0, 0], {\n\t\tvisibleIf: {\n\t\t\tclass: ATTRIBUTE_CLASSES.indexOf(AttribClass.VERTEX),\n\t\t\tbyBbox: true,\n\t\t},\n\t});\n\tseparatorBbox = ParamConfig.SEPARATOR(null, {\n\t\tvisibleIf: {\n\t\t\tclass: ATTRIBUTE_CLASSES.indexOf(AttribClass.VERTEX),\n\t\t},\n\t});\n\t//this.add_param( ParamType.STRING, 'index_mode', Core.Geometry.Geometry.INDEX_MODE_FACES )\n\n\t// by_visible\n\t// by_visible = ParamConfig.BOOLEAN(0, {\n\t// \tvisibleIf: {class: ATTRIBUTE_CLASSES.indexOf(AttribClass.OBJECT)},\n\t// });\n\t/** @param keeps points */\n\tkeepPoints = ParamConfig.BOOLEAN(0, {\n\t\tvisibleIf: {class: ATTRIBUTE_CLASSES.indexOf(AttribClass.OBJECT)},\n\t});\n}\nconst ParamsConfig = new DeleteSopParamsConfig();\n\nexport class DeleteSopNode extends TypedSopNode<DeleteSopParamsConfig> {\n\tparams_config = ParamsConfig;\n\tstatic type() {\n\t\treturn 'delete';\n\t}\n\n\tprivate _marked_for_deletion_per_object_index: Map<number, boolean> = new Map();\n\tpublic readonly entity_selection_helper = new EntitySelectionHelper(this);\n\tpublic readonly byBbox_helper = new ByBboxHelper(this);\n\tpublic readonly byExpression_helper = new ByExpressionHelper(this);\n\tpublic readonly byAttribute_helper = new ByAttributeHelper(this);\n\tpublic readonly byObjectType_helper = new ByObjectTypeHelper(this);\n\n\tstatic displayedInputNames(): string[] {\n\t\treturn ['geometry to delete from'];\n\t}\n\n\tinitializeNode() {\n\t\tthis.io.inputs.setCount(1);\n\t\tthis.io.inputs.initInputsClonedState(InputCloneMode.FROM_NODE);\n\t}\n\n\tasync cook(input_contents: CoreGroup[]) {\n\t\tconst core_group = input_contents[0];\n\n\t\tswitch (this.pv.class) {\n\t\t\tcase AttribClass.VERTEX:\n\t\t\t\tawait this._eval_for_points(core_group);\n\t\t\t\tbreak;\n\t\t\tcase AttribClass.OBJECT:\n\t\t\t\tawait this._eval_for_objects(core_group);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tset_class(attrib_class: AttribClass) {\n\t\tthis.p.class.set(attrib_class);\n\t}\n\n\tprivate async _eval_for_objects(core_group: CoreGroup) {\n\t\tconst core_objects = core_group.coreObjects();\n\t\tthis.entity_selection_helper.init(core_objects);\n\n\t\tthis._marked_for_deletion_per_object_index = new Map();\n\t\tfor (let core_object of core_objects) {\n\t\t\tthis._marked_for_deletion_per_object_index.set(core_object.index(), false);\n\t\t}\n\n\t\tif (isBooleanTrue(this.pv.byExpression)) {\n\t\t\tawait this.byExpression_helper.eval_for_entities(core_objects);\n\t\t}\n\n\t\tif (isBooleanTrue(this.pv.byObjectType)) {\n\t\t\tthis.byObjectType_helper.eval_for_objects(core_objects);\n\t\t}\n\n\t\tif (isBooleanTrue(this.pv.byAttrib) && this.pv.attribName != '') {\n\t\t\tthis.byAttribute_helper.eval_for_entities(core_objects);\n\t\t}\n\n\t\tconst core_objects_to_keep = this.entity_selection_helper.entities_to_keep() as CoreObject[];\n\t\tconst objects_to_keep = core_objects_to_keep.map((co) => co.object());\n\n\t\tif (isBooleanTrue(this.pv.keepPoints)) {\n\t\t\tconst core_objects_to_delete = this.entity_selection_helper.entities_to_delete() as CoreObject[];\n\t\t\tfor (let core_object_to_delete of core_objects_to_delete) {\n\t\t\t\tconst point_object = this._point_object(core_object_to_delete);\n\t\t\t\tif (point_object) {\n\t\t\t\t\tobjects_to_keep.push(point_object);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis.setObjects(objects_to_keep);\n\t}\n\n\tprivate async _eval_for_points(core_group: CoreGroup) {\n\t\tconst core_objects = core_group.coreObjects();\n\t\tlet core_object;\n\t\tlet objects: Object3D[] = [];\n\t\tfor (let i = 0; i < core_objects.length; i++) {\n\t\t\tcore_object = core_objects[i];\n\t\t\tlet core_geometry = core_object.coreGeometry();\n\t\t\tif (core_geometry) {\n\t\t\t\tconst object = core_object.object() as Object3DWithGeometry;\n\t\t\t\tconst points = core_geometry.pointsFromGeometry();\n\t\t\t\tthis.entity_selection_helper.init(points);\n\n\t\t\t\tconst init_points_count = points.length;\n\t\t\t\tif (isBooleanTrue(this.pv.byExpression)) {\n\t\t\t\t\tawait this.byExpression_helper.eval_for_entities(points);\n\t\t\t\t}\n\t\t\t\t// TODO: the helpers do not yet take into account if an entity has been selected or not.\n\t\t\t\t// This could really speed up iterating through them, as I could skip the ones that have already been\n\t\t\t\tif (isBooleanTrue(this.pv.byAttrib) && this.pv.attribName != '') {\n\t\t\t\t\tthis.byAttribute_helper.eval_for_entities(points);\n\t\t\t\t}\n\t\t\t\tif (isBooleanTrue(this.pv.byBbox)) {\n\t\t\t\t\tthis.byBbox_helper.eval_for_points(points);\n\t\t\t\t}\n\t\t\t\tconst kept_points = this.entity_selection_helper.entities_to_keep() as CorePoint[];\n\n\t\t\t\tif (kept_points.length == init_points_count) {\n\t\t\t\t\tobjects.push(object);\n\t\t\t\t} else {\n\t\t\t\t\tcore_geometry.geometry().dispose();\n\t\t\t\t\tif (kept_points.length > 0) {\n\t\t\t\t\t\tconst new_geo = CoreGeometry.geometryFromPoints(\n\t\t\t\t\t\t\tkept_points,\n\t\t\t\t\t\t\tobjectTypeFromConstructor(object.constructor)\n\t\t\t\t\t\t);\n\t\t\t\t\t\tif (new_geo) {\n\t\t\t\t\t\t\tobject.geometry = new_geo;\n\t\t\t\t\t\t\tobjects.push(object);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthis.setObjects(objects);\n\t}\n\n\tprivate _point_object(core_object: CoreObject) {\n\t\tconst core_points = core_object.points();\n\t\tconst geometry = CoreGeometry.geometryFromPoints(core_points, ObjectType.POINTS);\n\t\tif (geometry) return this.create_object(geometry, ObjectType.POINTS);\n\t}\n}\n","import {Camera} from 'three/src/cameras/Camera';\n\nimport {TypedEventNode} from './_Base';\n// import {BaseCameraObjNodeType} from '../obj/_BaseCamera';\n\n// import {OrbitControls} from '../../../../modules/three/examples/jsm/controls/OrbitControls';\nimport {NodeParamsConfig} from '../utils/params/ParamsConfig';\nimport {BaseViewerType} from '../../viewers/_Base';\n\nexport interface CameraControls {\n\tname?: string;\n\tenabled?: boolean;\n\tdispose: () => void;\n\tupdate: () => void;\n\taddEventListener: (eventName: string, callback: () => void) => void;\n\tremoveEventListener: (eventName: string, callback: () => void) => void;\n}\n// export interface CameraControls extends OrbitControls {\n// \tname?: string;\n// \t// this_is_a_control: any;\n// \t// name: string;\n// }\n\nexport abstract class TypedCameraControlsEventNode<K extends NodeParamsConfig> extends TypedEventNode<K> {\n\t// controls() {\n\t// \treturn this._controls;\n\t// }\n\tprivate _controls_by_viewer: Map<BaseViewerType, CameraControls> = new Map();\n\n\tasync apply_controls(camera: Camera, viewer: BaseViewerType) {\n\t\t// I don't think I can just assign the camera at the moment\n\t\t// so the controls may need to be re-created everytime\n\t\t// TODO: the controls should be created (and disposed?) by the viewer\n\t\t//this.dispose_controls()\n\t\tviewer.controlsController?.dispose_controls();\n\t\tconst canvas = viewer.canvas();\n\t\tif (!canvas) {\n\t\t\treturn;\n\t\t}\n\t\tconst controls = await this.create_controls_instance(camera, canvas);\n\t\tconst current_controls = this._controls_by_viewer.get(viewer);\n\t\tif (current_controls) {\n\t\t\tcurrent_controls.dispose();\n\t\t}\n\t\tthis._controls_by_viewer.set(viewer, controls);\n\t\tconst timestamp = performance.now();\n\t\tcontrols.name = `${this.fullPath()}:${camera.name}:${timestamp}:${this.controls_id()}`;\n\t\tawait this.params.eval_all();\n\t\tthis.setup_controls(controls);\n\t\treturn controls;\n\t}\n\tcontrols_id() {\n\t\treturn JSON.stringify(this.params.all.map((p) => p.valueSerialized()));\n\t}\n\tabstract update_required(): boolean;\n\t//this.cook()\n\n\t// dispose_controls: (controls_instance)->\n\t// \tif controls_instance?\n\t// \t\tcontrols_instance.dispose()\n\n\tabstract setup_controls(controls: CameraControls): void;\n\t//\n\tabstract dispose_controls_for_html_element_id(html_element_id: string): void;\n\n\tabstract async create_controls_instance(camera: Camera, element: HTMLElement): Promise<CameraControls>;\n\t// abstract set_from_camera_node(controls: CameraControls, camera_node: BaseCameraObjNodeType): void;\n\tabstract endEventName(): string;\n}\n\nexport type BaseCameraControlsEventNodeType = TypedCameraControlsEventNode<any>;\n","import {EventDispatcher} from 'three/src/core/EventDispatcher';\nimport {MOUSE} from 'three/src/constants';\nimport {Quaternion} from 'three/src/math/Quaternion';\nimport {Spherical} from 'three/src/math/Spherical';\nimport {TOUCH} from 'three/src/constants';\nimport {Vector2} from 'three/src/math/Vector2';\nimport {Vector3} from 'three/src/math/Vector3';\n\n// This set of controls performs orbiting, dollying (zooming), and panning.\n// Unlike TrackballControls, it maintains the \"up\" direction object.up (+Y by default).\n//\n//    Orbit - left mouse / touch: one-finger move\n//    Zoom - middle mouse, or mousewheel / touch: two-finger spread or squish\n//    Pan - right mouse, or left mouse + ctrl/meta/shiftKey, or arrow keys / touch: two-finger move\n\nvar OrbitControls = function (object, domElement) {\n\tif (domElement === undefined)\n\t\tconsole.warn('THREE.OrbitControls: The second parameter \"domElement\" is now mandatory.');\n\tif (domElement === document)\n\t\tconsole.error(\n\t\t\t'THREE.OrbitControls: \"document\" should not be used as the target \"domElement\". Please use \"renderer.domElement\" instead.'\n\t\t);\n\n\tthis.object = object;\n\tthis.domElement = domElement;\n\n\t// Set to false to disable this control\n\tthis.enabled = true;\n\n\t// \"target\" sets the location of focus, where the object orbits around\n\tthis.target = new Vector3();\n\n\t// How far you can dolly in and out ( PerspectiveCamera only )\n\tthis.minDistance = 0;\n\tthis.maxDistance = Infinity;\n\n\t// How far you can zoom in and out ( OrthographicCamera only )\n\tthis.minZoom = 0;\n\tthis.maxZoom = Infinity;\n\n\t// How far you can orbit vertically, upper and lower limits.\n\t// Range is 0 to Math.PI radians.\n\tthis.minPolarAngle = 0; // radians\n\tthis.maxPolarAngle = Math.PI; // radians\n\n\t// How far you can orbit horizontally, upper and lower limits.\n\t// If set, the interval [ min, max ] must be a sub-interval of [ - 2 PI, 2 PI ], with ( max - min < 2 PI )\n\tthis.minAzimuthAngle = -Infinity; // radians\n\tthis.maxAzimuthAngle = Infinity; // radians\n\n\t// Set to true to enable damping (inertia)\n\t// If damping is enabled, you must call controls.update() in your animation loop\n\tthis.enableDamping = false;\n\tthis.dampingFactor = 0.05;\n\n\t// This option actually enables dollying in and out; left as \"zoom\" for backwards compatibility.\n\t// Set to false to disable zooming\n\tthis.enableZoom = true;\n\tthis.zoomSpeed = 1.0;\n\n\t// Set to false to disable rotating\n\tthis.enableRotate = true;\n\tthis.rotateSpeed = 1.0;\n\n\t// Set to false to disable panning\n\tthis.enablePan = true;\n\tthis.panSpeed = 1.0;\n\tthis.screenSpacePanning = true; // if false, pan orthogonal to world-space direction camera.up\n\tthis.keyPanSpeed = 7.0; // pixels moved per arrow key push\n\n\t// Set to true to automatically rotate around the target\n\t// If auto-rotate is enabled, you must call controls.update() in your animation loop\n\tthis.autoRotate = false;\n\tthis.autoRotateSpeed = 2.0; // 30 seconds per round when fps is 60\n\n\t// Set to false to disable use of the keys\n\tthis.enableKeys = true;\n\tthis.keyMode = 'pan';\n\tthis.keyRotateSpeedVertical = 1.0;\n\tthis.keyRotateSpeedHorizontal = 1.0;\n\n\t// The four arrow keys\n\tthis.keys = {LEFT: 37, UP: 38, RIGHT: 39, BOTTOM: 40};\n\n\t// Mouse buttons\n\tthis.mouseButtons = {LEFT: MOUSE.ROTATE, MIDDLE: MOUSE.DOLLY, RIGHT: MOUSE.PAN};\n\n\t// Touch fingers\n\tthis.touches = {ONE: TOUCH.ROTATE, TWO: TOUCH.DOLLY_PAN};\n\n\t// for reset\n\tthis.target0 = this.target.clone();\n\tthis.position0 = this.object.position.clone();\n\tthis.zoom0 = this.object.zoom;\n\n\t//\n\t// public methods\n\t//\n\n\tthis.getPolarAngle = function () {\n\t\treturn spherical.phi;\n\t};\n\n\tthis.getAzimuthalAngle = function () {\n\t\treturn spherical.theta;\n\t};\n\n\tthis.saveState = function () {\n\t\tscope.target0.copy(scope.target);\n\t\tscope.position0.copy(scope.object.position);\n\t\tscope.zoom0 = scope.object.zoom;\n\t};\n\n\tthis.reset = function () {\n\t\tscope.target.copy(scope.target0);\n\t\tscope.object.position.copy(scope.position0);\n\t\tscope.object.zoom = scope.zoom0;\n\n\t\tscope.object.updateProjectionMatrix();\n\t\tscope.dispatchEvent(changeEvent);\n\n\t\tscope.update();\n\n\t\tstate = STATE.NONE;\n\t};\n\n\t// this method is exposed, but perhaps it would be better if we can make it private...\n\tthis.update = (function () {\n\t\tvar offset = new Vector3();\n\n\t\t// so camera.up is the orbit axis\n\t\tvar quat = new Quaternion().setFromUnitVectors(object.up, new Vector3(0, 1, 0));\n\t\tvar quatInverse = quat.clone().invert();\n\n\t\tvar lastPosition = new Vector3();\n\t\tvar lastQuaternion = new Quaternion();\n\n\t\tvar twoPI = 2 * Math.PI;\n\t\tvar dampingEndEventSent = false;\n\n\t\treturn function update() {\n\t\t\tvar position = scope.object.position;\n\n\t\t\toffset.copy(position).sub(scope.target);\n\n\t\t\t// rotate offset to \"y-axis-is-up\" space\n\t\t\toffset.applyQuaternion(quat);\n\n\t\t\t// angle from z-axis around y-axis\n\t\t\tspherical.setFromVector3(offset);\n\n\t\t\tif (scope.autoRotate && state === STATE.NONE) {\n\t\t\t\trotateLeft(getAutoRotationAngle());\n\t\t\t}\n\n\t\t\tif (scope.enableDamping) {\n\t\t\t\t// when the damping has done moving the camera, we send another endEvent.\n\t\t\t\t// so that cameras using it can again update their transform params\n\t\t\t\t// UPDATE:\n\t\t\t\t// if using a return statement, this has actually side effects, where it seems that the controls\n\t\t\t\t// stops working on some occasion.\n\t\t\t\tconst thetaDelta = sphericalDelta.theta * scope.dampingFactor;\n\t\t\t\tconst phiDelta = sphericalDelta.phi * scope.dampingFactor;\n\t\t\t\tif (thetaDelta < EPS && phiDelta < EPS) {\n\t\t\t\t\tif (!dampingEndEventSent) {\n\t\t\t\t\t\tscope.dispatchEvent(endEvent);\n\t\t\t\t\t\tdampingEndEventSent = true;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tdampingEndEventSent = false;\n\t\t\t\t}\n\t\t\t\tspherical.theta += thetaDelta;\n\t\t\t\tspherical.phi += phiDelta;\n\t\t\t} else {\n\t\t\t\tspherical.theta += sphericalDelta.theta;\n\t\t\t\tspherical.phi += sphericalDelta.phi;\n\t\t\t}\n\n\t\t\t// restrict theta to be between desired limits\n\n\t\t\tvar min = scope.minAzimuthAngle;\n\t\t\tvar max = scope.maxAzimuthAngle;\n\n\t\t\tif (isFinite(min) && isFinite(max)) {\n\t\t\t\tif (min < -Math.PI) min += twoPI;\n\t\t\t\telse if (min > Math.PI) min -= twoPI;\n\n\t\t\t\tif (max < -Math.PI) max += twoPI;\n\t\t\t\telse if (max > Math.PI) max -= twoPI;\n\n\t\t\t\tif (min < max) {\n\t\t\t\t\tspherical.theta = Math.max(min, Math.min(max, spherical.theta));\n\t\t\t\t} else {\n\t\t\t\t\tspherical.theta =\n\t\t\t\t\t\tspherical.theta > (min + max) / 2\n\t\t\t\t\t\t\t? Math.max(min, spherical.theta)\n\t\t\t\t\t\t\t: Math.min(max, spherical.theta);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// restrict phi to be between desired limits\n\t\t\tspherical.phi = Math.max(scope.minPolarAngle, Math.min(scope.maxPolarAngle, spherical.phi));\n\n\t\t\tspherical.makeSafe();\n\n\t\t\tspherical.radius *= scale;\n\n\t\t\t// restrict radius to be between desired limits\n\t\t\tspherical.radius = Math.max(scope.minDistance, Math.min(scope.maxDistance, spherical.radius));\n\n\t\t\t// move target to panned location\n\n\t\t\tif (scope.enableDamping === true) {\n\t\t\t\tscope.target.addScaledVector(panOffset, scope.dampingFactor);\n\t\t\t} else {\n\t\t\t\tscope.target.add(panOffset);\n\t\t\t}\n\n\t\t\toffset.setFromSpherical(spherical);\n\n\t\t\t// rotate offset back to \"camera-up-vector-is-up\" space\n\t\t\toffset.applyQuaternion(quatInverse);\n\n\t\t\tposition.copy(scope.target).add(offset);\n\n\t\t\tscope.object.lookAt(scope.target);\n\n\t\t\tif (scope.enableDamping === true) {\n\t\t\t\tsphericalDelta.theta *= 1 - scope.dampingFactor;\n\t\t\t\tsphericalDelta.phi *= 1 - scope.dampingFactor;\n\n\t\t\t\tpanOffset.multiplyScalar(1 - scope.dampingFactor);\n\t\t\t} else {\n\t\t\t\tsphericalDelta.set(0, 0, 0);\n\n\t\t\t\tpanOffset.set(0, 0, 0);\n\t\t\t}\n\n\t\t\tscale = 1;\n\n\t\t\t// update condition is:\n\t\t\t// min(camera displacement, camera rotation in radians)^2 > EPS\n\t\t\t// using small-angle approximation cos(x/2) = 1 - x^2 / 8\n\n\t\t\tif (\n\t\t\t\tzoomChanged ||\n\t\t\t\tlastPosition.distanceToSquared(scope.object.position) > EPS ||\n\t\t\t\t8 * (1 - lastQuaternion.dot(scope.object.quaternion)) > EPS\n\t\t\t) {\n\t\t\t\tscope.dispatchEvent(changeEvent);\n\n\t\t\t\tlastPosition.copy(scope.object.position);\n\t\t\t\tlastQuaternion.copy(scope.object.quaternion);\n\t\t\t\tzoomChanged = false;\n\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\treturn false;\n\t\t};\n\t})();\n\n\tthis.dispose = function () {\n\t\tscope.domElement.removeEventListener('contextmenu', onContextMenu, false);\n\n\t\tscope.domElement.removeEventListener('pointerdown', onPointerDown, false);\n\t\tscope.domElement.removeEventListener('wheel', onMouseWheel, false);\n\n\t\tscope.domElement.removeEventListener('touchstart', onTouchStart, false);\n\t\tscope.domElement.removeEventListener('touchend', onTouchEnd, false);\n\t\tscope.domElement.removeEventListener('touchmove', onTouchMove, false);\n\n\t\tscope.domElement.ownerDocument.removeEventListener('pointermove', onPointerMove, false);\n\t\tscope.domElement.ownerDocument.removeEventListener('pointerup', onPointerUp, false);\n\n\t\tscope.domElement.removeEventListener('keydown', onKeyDown, false);\n\n\t\t//scope.dispatchEvent( { type: 'dispose' } ); // should this be added here?\n\t};\n\n\t//\n\t// internals\n\t//\n\n\tvar scope = this;\n\n\tvar changeEvent = {type: 'change'};\n\tvar startEvent = {type: 'start'};\n\tvar endEvent = {type: 'end'};\n\n\tvar STATE = {\n\t\tNONE: -1,\n\t\tROTATE: 0,\n\t\tDOLLY: 1,\n\t\tPAN: 2,\n\t\tTOUCH_ROTATE: 3,\n\t\tTOUCH_PAN: 4,\n\t\tTOUCH_DOLLY_PAN: 5,\n\t\tTOUCH_DOLLY_ROTATE: 6,\n\t};\n\n\tvar state = STATE.NONE;\n\n\tvar EPS = 0.000001;\n\n\t// current position in spherical coordinates\n\tvar spherical = new Spherical();\n\tvar sphericalDelta = new Spherical();\n\n\tvar scale = 1;\n\tvar panOffset = new Vector3();\n\tvar zoomChanged = false;\n\n\tvar rotateStart = new Vector2();\n\tvar rotateEnd = new Vector2();\n\tvar rotateDelta = new Vector2();\n\n\tvar panStart = new Vector2();\n\tvar panEnd = new Vector2();\n\tvar panDelta = new Vector2();\n\n\tvar dollyStart = new Vector2();\n\tvar dollyEnd = new Vector2();\n\tvar dollyDelta = new Vector2();\n\n\tfunction getAutoRotationAngle() {\n\t\treturn ((2 * Math.PI) / 60 / 60) * scope.autoRotateSpeed;\n\t}\n\n\tfunction getZoomScale() {\n\t\treturn Math.pow(0.95, scope.zoomSpeed);\n\t}\n\n\tfunction rotateLeft(angle) {\n\t\tsphericalDelta.theta -= angle;\n\t}\n\n\tfunction rotateUp(angle) {\n\t\tsphericalDelta.phi -= angle;\n\t}\n\n\tvar panLeft = (function () {\n\t\tvar v = new Vector3();\n\n\t\treturn function panLeft(distance, objectMatrix) {\n\t\t\tv.setFromMatrixColumn(objectMatrix, 0); // get X column of objectMatrix\n\t\t\tv.multiplyScalar(-distance);\n\n\t\t\tpanOffset.add(v);\n\t\t};\n\t})();\n\n\tvar panUp = (function () {\n\t\tvar v = new Vector3();\n\n\t\treturn function panUp(distance, objectMatrix) {\n\t\t\tif (scope.screenSpacePanning === true) {\n\t\t\t\tv.setFromMatrixColumn(objectMatrix, 1);\n\t\t\t} else {\n\t\t\t\tv.setFromMatrixColumn(objectMatrix, 0);\n\t\t\t\tv.crossVectors(scope.object.up, v);\n\t\t\t}\n\n\t\t\tv.multiplyScalar(distance);\n\n\t\t\tpanOffset.add(v);\n\t\t};\n\t})();\n\n\t// deltaX and deltaY are in pixels; right and down are positive\n\tvar pan = (function () {\n\t\tvar offset = new Vector3();\n\n\t\treturn function pan(deltaX, deltaY) {\n\t\t\tvar element = scope.domElement;\n\n\t\t\tif (scope.object.isPerspectiveCamera) {\n\t\t\t\t// perspective\n\t\t\t\tvar position = scope.object.position;\n\t\t\t\toffset.copy(position).sub(scope.target);\n\t\t\t\tvar targetDistance = offset.length();\n\n\t\t\t\t// half of the fov is center to top of screen\n\t\t\t\ttargetDistance *= Math.tan(((scope.object.fov / 2) * Math.PI) / 180.0);\n\n\t\t\t\t// we use only clientHeight here so aspect ratio does not distort speed\n\t\t\t\tpanLeft((2 * deltaX * targetDistance) / element.clientHeight, scope.object.matrix);\n\t\t\t\tpanUp((2 * deltaY * targetDistance) / element.clientHeight, scope.object.matrix);\n\t\t\t} else if (scope.object.isOrthographicCamera) {\n\t\t\t\t// orthographic\n\t\t\t\tpanLeft(\n\t\t\t\t\t(deltaX * (scope.object.right - scope.object.left)) / scope.object.zoom / element.clientWidth,\n\t\t\t\t\tscope.object.matrix\n\t\t\t\t);\n\t\t\t\tpanUp(\n\t\t\t\t\t(deltaY * (scope.object.top - scope.object.bottom)) / scope.object.zoom / element.clientHeight,\n\t\t\t\t\tscope.object.matrix\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\t// camera neither orthographic nor perspective\n\t\t\t\tconsole.warn('WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.');\n\t\t\t\tscope.enablePan = false;\n\t\t\t}\n\t\t};\n\t})();\n\n\tfunction dollyOut(dollyScale) {\n\t\tif (scope.object.isPerspectiveCamera) {\n\t\t\tscale /= dollyScale;\n\t\t} else if (scope.object.isOrthographicCamera) {\n\t\t\tscope.object.zoom = Math.max(scope.minZoom, Math.min(scope.maxZoom, scope.object.zoom * dollyScale));\n\t\t\tscope.object.updateProjectionMatrix();\n\t\t\tzoomChanged = true;\n\t\t} else {\n\t\t\tconsole.warn('WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.');\n\t\t\tscope.enableZoom = false;\n\t\t}\n\t}\n\n\tfunction dollyIn(dollyScale) {\n\t\tif (scope.object.isPerspectiveCamera) {\n\t\t\tscale *= dollyScale;\n\t\t} else if (scope.object.isOrthographicCamera) {\n\t\t\tscope.object.zoom = Math.max(scope.minZoom, Math.min(scope.maxZoom, scope.object.zoom / dollyScale));\n\t\t\tscope.object.updateProjectionMatrix();\n\t\t\tzoomChanged = true;\n\t\t} else {\n\t\t\tconsole.warn('WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.');\n\t\t\tscope.enableZoom = false;\n\t\t}\n\t}\n\n\t//\n\t// event callbacks - update the object state\n\t//\n\n\tfunction handleMouseDownRotate(event) {\n\t\trotateStart.set(event.clientX, event.clientY);\n\t}\n\n\tfunction handleMouseDownDolly(event) {\n\t\tdollyStart.set(event.clientX, event.clientY);\n\t}\n\n\tfunction handleMouseDownPan(event) {\n\t\tpanStart.set(event.clientX, event.clientY);\n\t}\n\n\tfunction handleMouseMoveRotate(event) {\n\t\trotateEnd.set(event.clientX, event.clientY);\n\n\t\trotateDelta.subVectors(rotateEnd, rotateStart).multiplyScalar(scope.rotateSpeed);\n\n\t\tvar element = scope.domElement;\n\n\t\trotateLeft((2 * Math.PI * rotateDelta.x) / element.clientHeight); // yes, height\n\n\t\trotateUp((2 * Math.PI * rotateDelta.y) / element.clientHeight);\n\n\t\trotateStart.copy(rotateEnd);\n\n\t\tscope.update();\n\t}\n\n\tfunction handleMouseMoveDolly(event) {\n\t\tdollyEnd.set(event.clientX, event.clientY);\n\n\t\tdollyDelta.subVectors(dollyEnd, dollyStart);\n\n\t\tif (dollyDelta.y > 0) {\n\t\t\tdollyOut(getZoomScale());\n\t\t} else if (dollyDelta.y < 0) {\n\t\t\tdollyIn(getZoomScale());\n\t\t}\n\n\t\tdollyStart.copy(dollyEnd);\n\n\t\tscope.update();\n\t}\n\n\tfunction handleMouseMovePan(event) {\n\t\tpanEnd.set(event.clientX, event.clientY);\n\n\t\tpanDelta.subVectors(panEnd, panStart).multiplyScalar(scope.panSpeed);\n\n\t\tpan(panDelta.x, panDelta.y);\n\n\t\tpanStart.copy(panEnd);\n\n\t\tscope.update();\n\t}\n\n\tfunction handleMouseUp(/*event*/) {\n\t\t// no-op\n\t}\n\n\tfunction handleMouseWheel(event) {\n\t\tif (event.deltaY < 0) {\n\t\t\tdollyIn(getZoomScale());\n\t\t} else if (event.deltaY > 0) {\n\t\t\tdollyOut(getZoomScale());\n\t\t}\n\n\t\tscope.update();\n\t}\n\n\tfunction handleKeyDown(event) {\n\t\tvar needsUpdate = false;\n\n\t\tif (scope.keyMode == 'pan') {\n\t\t\tswitch (event.keyCode) {\n\t\t\t\tcase scope.keys.UP:\n\t\t\t\t\tpan(0, scope.keyPanSpeed);\n\t\t\t\t\tneedsUpdate = true;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase scope.keys.BOTTOM:\n\t\t\t\t\tpan(0, -scope.keyPanSpeed);\n\t\t\t\t\tneedsUpdate = true;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase scope.keys.LEFT:\n\t\t\t\t\tpan(scope.keyPanSpeed, 0);\n\t\t\t\t\tneedsUpdate = true;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase scope.keys.RIGHT:\n\t\t\t\t\tpan(-scope.keyPanSpeed, 0);\n\t\t\t\t\tneedsUpdate = true;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tswitch (event.keyCode) {\n\t\t\t\tcase scope.keys.UP:\n\t\t\t\t\trotateUp(scope.keyRotateSpeedVertical);\n\t\t\t\t\tneedsUpdate = true;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase scope.keys.BOTTOM:\n\t\t\t\t\trotateUp(-scope.keyRotateSpeedVertical);\n\t\t\t\t\tneedsUpdate = true;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase scope.keys.LEFT:\n\t\t\t\t\trotateLeft(scope.keyRotateSpeedHorizontal);\n\t\t\t\t\tneedsUpdate = true;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase scope.keys.RIGHT:\n\t\t\t\t\trotateLeft(-scope.keyRotateSpeedHorizontal);\n\t\t\t\t\tneedsUpdate = true;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (needsUpdate) {\n\t\t\t// prevent the browser from scrolling on cursor keys\n\t\t\tevent.preventDefault();\n\n\t\t\tscope.update();\n\t\t}\n\t}\n\n\tfunction handleTouchStartRotate(event) {\n\t\tif (event.touches.length == 1) {\n\t\t\trotateStart.set(event.touches[0].pageX, event.touches[0].pageY);\n\t\t} else {\n\t\t\tvar x = 0.5 * (event.touches[0].pageX + event.touches[1].pageX);\n\t\t\tvar y = 0.5 * (event.touches[0].pageY + event.touches[1].pageY);\n\n\t\t\trotateStart.set(x, y);\n\t\t}\n\t}\n\n\tfunction handleTouchStartPan(event) {\n\t\tif (event.touches.length == 1) {\n\t\t\tpanStart.set(event.touches[0].pageX, event.touches[0].pageY);\n\t\t} else {\n\t\t\tvar x = 0.5 * (event.touches[0].pageX + event.touches[1].pageX);\n\t\t\tvar y = 0.5 * (event.touches[0].pageY + event.touches[1].pageY);\n\n\t\t\tpanStart.set(x, y);\n\t\t}\n\t}\n\n\tfunction handleTouchStartDolly(event) {\n\t\tvar dx = event.touches[0].pageX - event.touches[1].pageX;\n\t\tvar dy = event.touches[0].pageY - event.touches[1].pageY;\n\n\t\tvar distance = Math.sqrt(dx * dx + dy * dy);\n\n\t\tdollyStart.set(0, distance);\n\t}\n\n\tfunction handleTouchStartDollyPan(event) {\n\t\tif (scope.enableZoom) handleTouchStartDolly(event);\n\n\t\tif (scope.enablePan) handleTouchStartPan(event);\n\t}\n\n\tfunction handleTouchStartDollyRotate(event) {\n\t\tif (scope.enableZoom) handleTouchStartDolly(event);\n\n\t\tif (scope.enableRotate) handleTouchStartRotate(event);\n\t}\n\n\tfunction handleTouchMoveRotate(event) {\n\t\tif (event.touches.length == 1) {\n\t\t\trotateEnd.set(event.touches[0].pageX, event.touches[0].pageY);\n\t\t} else {\n\t\t\tvar x = 0.5 * (event.touches[0].pageX + event.touches[1].pageX);\n\t\t\tvar y = 0.5 * (event.touches[0].pageY + event.touches[1].pageY);\n\n\t\t\trotateEnd.set(x, y);\n\t\t}\n\n\t\trotateDelta.subVectors(rotateEnd, rotateStart).multiplyScalar(scope.rotateSpeed);\n\n\t\tvar element = scope.domElement;\n\n\t\trotateLeft((2 * Math.PI * rotateDelta.x) / element.clientHeight); // yes, height\n\n\t\trotateUp((2 * Math.PI * rotateDelta.y) / element.clientHeight);\n\n\t\trotateStart.copy(rotateEnd);\n\t}\n\n\tfunction handleTouchMovePan(event) {\n\t\tif (event.touches.length == 1) {\n\t\t\tpanEnd.set(event.touches[0].pageX, event.touches[0].pageY);\n\t\t} else {\n\t\t\tvar x = 0.5 * (event.touches[0].pageX + event.touches[1].pageX);\n\t\t\tvar y = 0.5 * (event.touches[0].pageY + event.touches[1].pageY);\n\n\t\t\tpanEnd.set(x, y);\n\t\t}\n\n\t\tpanDelta.subVectors(panEnd, panStart).multiplyScalar(scope.panSpeed);\n\n\t\tpan(panDelta.x, panDelta.y);\n\n\t\tpanStart.copy(panEnd);\n\t}\n\n\tfunction handleTouchMoveDolly(event) {\n\t\tvar dx = event.touches[0].pageX - event.touches[1].pageX;\n\t\tvar dy = event.touches[0].pageY - event.touches[1].pageY;\n\n\t\tvar distance = Math.sqrt(dx * dx + dy * dy);\n\n\t\tdollyEnd.set(0, distance);\n\n\t\tdollyDelta.set(0, Math.pow(dollyEnd.y / dollyStart.y, scope.zoomSpeed));\n\n\t\tdollyOut(dollyDelta.y);\n\n\t\tdollyStart.copy(dollyEnd);\n\t}\n\n\tfunction handleTouchMoveDollyPan(event) {\n\t\tif (scope.enableZoom) handleTouchMoveDolly(event);\n\n\t\tif (scope.enablePan) handleTouchMovePan(event);\n\t}\n\n\tfunction handleTouchMoveDollyRotate(event) {\n\t\tif (scope.enableZoom) handleTouchMoveDolly(event);\n\n\t\tif (scope.enableRotate) handleTouchMoveRotate(event);\n\t}\n\n\tfunction handleTouchEnd(/*event*/) {\n\t\t// no-op\n\t}\n\n\t//\n\t// event handlers - FSM: listen for events and reset state\n\t//\n\n\tfunction onPointerDown(event) {\n\t\tif (scope.enabled === false) return;\n\n\t\tswitch (event.pointerType) {\n\t\t\tcase 'mouse':\n\t\t\tcase 'pen':\n\t\t\t\tonMouseDown(event);\n\t\t\t\tbreak;\n\n\t\t\t// TODO touch\n\t\t}\n\t}\n\n\tfunction onPointerMove(event) {\n\t\tif (scope.enabled === false) return;\n\n\t\tswitch (event.pointerType) {\n\t\t\tcase 'mouse':\n\t\t\tcase 'pen':\n\t\t\t\tonMouseMove(event);\n\t\t\t\tbreak;\n\n\t\t\t// TODO touch\n\t\t}\n\t}\n\n\tfunction onPointerUp(event) {\n\t\tif (scope.enabled === false) return;\n\n\t\tswitch (event.pointerType) {\n\t\t\tcase 'mouse':\n\t\t\tcase 'pen':\n\t\t\t\tonMouseUp(event);\n\t\t\t\tbreak;\n\n\t\t\t// TODO touch\n\t\t}\n\t}\n\n\tfunction onMouseDown(event) {\n\t\t// Prevent the browser from scrolling.\n\t\tevent.preventDefault();\n\n\t\t// Manually set the focus since calling preventDefault above\n\t\t// prevents the browser from setting it automatically.\n\n\t\tscope.domElement.focus ? scope.domElement.focus() : window.focus();\n\n\t\tvar mouseAction;\n\n\t\tswitch (event.button) {\n\t\t\tcase 0:\n\t\t\t\tmouseAction = scope.mouseButtons.LEFT;\n\t\t\t\tbreak;\n\n\t\t\tcase 1:\n\t\t\t\tmouseAction = scope.mouseButtons.MIDDLE;\n\t\t\t\tbreak;\n\n\t\t\tcase 2:\n\t\t\t\tmouseAction = scope.mouseButtons.RIGHT;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tmouseAction = -1;\n\t\t}\n\n\t\tswitch (mouseAction) {\n\t\t\tcase MOUSE.DOLLY:\n\t\t\t\tif (scope.enableZoom === false) return;\n\n\t\t\t\thandleMouseDownDolly(event);\n\n\t\t\t\tstate = STATE.DOLLY;\n\n\t\t\t\tbreak;\n\n\t\t\tcase MOUSE.ROTATE:\n\t\t\t\tif (event.ctrlKey || event.metaKey || event.shiftKey) {\n\t\t\t\t\tif (scope.enablePan === false) return;\n\n\t\t\t\t\thandleMouseDownPan(event);\n\n\t\t\t\t\tstate = STATE.PAN;\n\t\t\t\t} else {\n\t\t\t\t\tif (scope.enableRotate === false) return;\n\n\t\t\t\t\thandleMouseDownRotate(event);\n\n\t\t\t\t\tstate = STATE.ROTATE;\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase MOUSE.PAN:\n\t\t\t\tif (event.ctrlKey || event.metaKey || event.shiftKey) {\n\t\t\t\t\tif (scope.enableRotate === false) return;\n\n\t\t\t\t\thandleMouseDownRotate(event);\n\n\t\t\t\t\tstate = STATE.ROTATE;\n\t\t\t\t} else {\n\t\t\t\t\tif (scope.enablePan === false) return;\n\n\t\t\t\t\thandleMouseDownPan(event);\n\n\t\t\t\t\tstate = STATE.PAN;\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tstate = STATE.NONE;\n\t\t}\n\n\t\tif (state !== STATE.NONE) {\n\t\t\tscope.domElement.ownerDocument.addEventListener('pointermove', onPointerMove, false);\n\t\t\tscope.domElement.ownerDocument.addEventListener('pointerup', onPointerUp, false);\n\n\t\t\tscope.dispatchEvent(startEvent);\n\t\t}\n\t}\n\n\tfunction onMouseMove(event) {\n\t\tif (scope.enabled === false) return;\n\n\t\tevent.preventDefault();\n\n\t\tswitch (state) {\n\t\t\tcase STATE.ROTATE:\n\t\t\t\tif (scope.enableRotate === false) return;\n\n\t\t\t\thandleMouseMoveRotate(event);\n\n\t\t\t\tbreak;\n\n\t\t\tcase STATE.DOLLY:\n\t\t\t\tif (scope.enableZoom === false) return;\n\n\t\t\t\thandleMouseMoveDolly(event);\n\n\t\t\t\tbreak;\n\n\t\t\tcase STATE.PAN:\n\t\t\t\tif (scope.enablePan === false) return;\n\n\t\t\t\thandleMouseMovePan(event);\n\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tfunction onMouseUp(event) {\n\t\tif (scope.enabled === false) return;\n\n\t\thandleMouseUp(event);\n\n\t\tscope.domElement.ownerDocument.removeEventListener('pointermove', onPointerMove, false);\n\t\tscope.domElement.ownerDocument.removeEventListener('pointerup', onPointerUp, false);\n\n\t\tscope.dispatchEvent(endEvent);\n\n\t\tstate = STATE.NONE;\n\t}\n\n\tfunction onMouseWheel(event) {\n\t\tif (scope.enabled === false || scope.enableZoom === false || (state !== STATE.NONE && state !== STATE.ROTATE))\n\t\t\treturn;\n\n\t\tevent.preventDefault();\n\t\tevent.stopPropagation();\n\n\t\tscope.dispatchEvent(startEvent);\n\n\t\thandleMouseWheel(event);\n\n\t\tscope.dispatchEvent(endEvent);\n\t}\n\n\tfunction onKeyDown(event) {\n\t\t// if (scope.enabled === false || scope.enableKeys === false || scope.enablePan === false) return;\n\t\tif (scope.enabled === false || scope.enableKeys === false) return;\n\t\tif (scope.keyMode == 'pan' && scope.enablePan === false) return;\n\t\tif (scope.keyMode != 'pan' && scope.enableRotate === false) return;\n\n\t\thandleKeyDown(event);\n\t}\n\n\tfunction onTouchStart(event) {\n\t\tif (scope.enabled === false) return;\n\n\t\tevent.preventDefault(); // prevent scrolling\n\n\t\tswitch (event.touches.length) {\n\t\t\tcase 1:\n\t\t\t\tswitch (scope.touches.ONE) {\n\t\t\t\t\tcase TOUCH.ROTATE:\n\t\t\t\t\t\tif (scope.enableRotate === false) return;\n\n\t\t\t\t\t\thandleTouchStartRotate(event);\n\n\t\t\t\t\t\tstate = STATE.TOUCH_ROTATE;\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase TOUCH.PAN:\n\t\t\t\t\t\tif (scope.enablePan === false) return;\n\n\t\t\t\t\t\thandleTouchStartPan(event);\n\n\t\t\t\t\t\tstate = STATE.TOUCH_PAN;\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tstate = STATE.NONE;\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase 2:\n\t\t\t\tswitch (scope.touches.TWO) {\n\t\t\t\t\tcase TOUCH.DOLLY_PAN:\n\t\t\t\t\t\tif (scope.enableZoom === false && scope.enablePan === false) return;\n\n\t\t\t\t\t\thandleTouchStartDollyPan(event);\n\n\t\t\t\t\t\tstate = STATE.TOUCH_DOLLY_PAN;\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase TOUCH.DOLLY_ROTATE:\n\t\t\t\t\t\tif (scope.enableZoom === false && scope.enableRotate === false) return;\n\n\t\t\t\t\t\thandleTouchStartDollyRotate(event);\n\n\t\t\t\t\t\tstate = STATE.TOUCH_DOLLY_ROTATE;\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tstate = STATE.NONE;\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tstate = STATE.NONE;\n\t\t}\n\n\t\tif (state !== STATE.NONE) {\n\t\t\tscope.dispatchEvent(startEvent);\n\t\t}\n\t}\n\n\tfunction onTouchMove(event) {\n\t\tif (scope.enabled === false) return;\n\n\t\tevent.preventDefault(); // prevent scrolling\n\t\tevent.stopPropagation();\n\n\t\tswitch (state) {\n\t\t\tcase STATE.TOUCH_ROTATE:\n\t\t\t\tif (scope.enableRotate === false) return;\n\n\t\t\t\thandleTouchMoveRotate(event);\n\n\t\t\t\tscope.update();\n\n\t\t\t\tbreak;\n\n\t\t\tcase STATE.TOUCH_PAN:\n\t\t\t\tif (scope.enablePan === false) return;\n\n\t\t\t\thandleTouchMovePan(event);\n\n\t\t\t\tscope.update();\n\n\t\t\t\tbreak;\n\n\t\t\tcase STATE.TOUCH_DOLLY_PAN:\n\t\t\t\tif (scope.enableZoom === false && scope.enablePan === false) return;\n\n\t\t\t\thandleTouchMoveDollyPan(event);\n\n\t\t\t\tscope.update();\n\n\t\t\t\tbreak;\n\n\t\t\tcase STATE.TOUCH_DOLLY_ROTATE:\n\t\t\t\tif (scope.enableZoom === false && scope.enableRotate === false) return;\n\n\t\t\t\thandleTouchMoveDollyRotate(event);\n\n\t\t\t\tscope.update();\n\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tstate = STATE.NONE;\n\t\t}\n\t}\n\n\tfunction onTouchEnd(event) {\n\t\tif (scope.enabled === false) return;\n\n\t\thandleTouchEnd(event);\n\n\t\tscope.dispatchEvent(endEvent);\n\n\t\tstate = STATE.NONE;\n\t}\n\n\tfunction onContextMenu(event) {\n\t\tif (scope.enabled === false) return;\n\n\t\tevent.preventDefault();\n\t}\n\n\t//\n\n\tscope.domElement.addEventListener('contextmenu', onContextMenu, false);\n\n\tscope.domElement.addEventListener('pointerdown', onPointerDown, false);\n\tscope.domElement.addEventListener('wheel', onMouseWheel, false);\n\n\tscope.domElement.addEventListener('touchstart', onTouchStart, false);\n\tscope.domElement.addEventListener('touchend', onTouchEnd, false);\n\tscope.domElement.addEventListener('touchmove', onTouchMove, false);\n\n\tscope.domElement.addEventListener('keydown', onKeyDown, false);\n\n\t// make sure element can receive keys.\n\n\tif (scope.domElement.tabIndex === -1) {\n\t\tscope.domElement.tabIndex = 0;\n\t}\n\n\t// force an update at start\n\n\tthis.update();\n};\n\nOrbitControls.prototype = Object.create(EventDispatcher.prototype);\nOrbitControls.prototype.constructor = OrbitControls;\n\n// This set of controls performs orbiting, dollying (zooming), and panning.\n// Unlike TrackballControls, it maintains the \"up\" direction object.up (+Y by default).\n// This is very similar to OrbitControls, another set of touch behavior\n//\n//    Orbit - right mouse, or left mouse + ctrl/meta/shiftKey / touch: two-finger rotate\n//    Zoom - middle mouse, or mousewheel / touch: two-finger spread or squish\n//    Pan - left mouse, or arrow keys / touch: one-finger move\n\nvar MapControls = function (object, domElement) {\n\tOrbitControls.call(this, object, domElement);\n\n\tthis.screenSpacePanning = false; // pan orthogonal to world-space direction camera.up\n\n\tthis.mouseButtons.LEFT = MOUSE.PAN;\n\tthis.mouseButtons.RIGHT = MOUSE.ROTATE;\n\n\tthis.touches.ONE = TOUCH.PAN;\n\tthis.touches.TWO = TOUCH.DOLLY_ROTATE;\n};\n\nMapControls.prototype = Object.create(EventDispatcher.prototype);\nMapControls.prototype.constructor = MapControls;\n\nexport {OrbitControls, MapControls};\n","/**\n * Creates a THREE OrbitControls\n *\n * @remarks\n * This can be linked to a camera's controls parameter\n *\n */\nimport {Number3} from '../../../types/GlobalTypes';\nimport {Camera} from 'three/src/cameras/Camera';\nimport {TypedCameraControlsEventNode} from './_BaseCameraControls';\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {EventConnectionPoint, EventConnectionPointType} from '../utils/io/connections/Event';\nimport {BaseNodeType} from '../_Base';\n// import {OrbitControls} from '../../../../modules/three/examples/jsm/controls/OrbitControls';\nimport {OrbitControls} from '../../../modules/core/controls/OrbitControls';\nimport {CameraControlsNodeType} from '../../poly/NodeContext';\nimport {isBooleanTrue} from '../../../core/BooleanValue';\n\nconst OUTPUT_START = 'start';\nconst OUTPUT_CHANGE = 'change';\nconst OUTPUT_END = 'end';\n\nenum KeysMode {\n\tPAN = 'pan',\n\tROTATE = 'rotate',\n}\nconst KEYS_MODES: KeysMode[] = [KeysMode.PAN, KeysMode.ROTATE];\n\nclass CameraOrbitEventParamsConfig extends NodeParamsConfig {\n\t/** @param enable/disable */\n\tenabled = ParamConfig.BOOLEAN(1);\n\t/** @param toggle on to allow pan */\n\tallowPan = ParamConfig.BOOLEAN(1);\n\t/** @param toggle on to allow rotate */\n\tallowRotate = ParamConfig.BOOLEAN(1);\n\t/** @param toggle on to allow zoom */\n\tallowZoom = ParamConfig.BOOLEAN(1);\n\t/** @param toggle on to have damping */\n\ttdamping = ParamConfig.BOOLEAN(1);\n\t/** @param damping value */\n\tdamping = ParamConfig.FLOAT(0.1, {\n\t\tvisibleIf: {tdamping: true},\n\t});\n\t/** @param toggle on to have the pan in screen space */\n\tscreenSpacePanning = ParamConfig.BOOLEAN(1);\n\t/** @param rotation speed */\n\trotateSpeed = ParamConfig.FLOAT(0.5);\n\t/** @param smallest distance the camera can go to the target */\n\tminDistance = ParamConfig.FLOAT(1, {\n\t\trange: [0, 100],\n\t\trangeLocked: [true, false],\n\t});\n\t/** @param max distance the camera can go away the target */\n\tmaxDistance = ParamConfig.FLOAT(50, {\n\t\trange: [0, 100],\n\t\trangeLocked: [true, false],\n\t});\n\t/** @param toggle on to limit the azimuth (up-down) angle */\n\tlimitAzimuthAngle = ParamConfig.BOOLEAN(0);\n\t/** @param azimuth angle range */\n\tazimuthAngleRange = ParamConfig.VECTOR2(['-2*$PI', '2*$PI'], {\n\t\tvisibleIf: {limitAzimuthAngle: 1},\n\t});\n\t/** @param polar (left-right) angle range */\n\tpolarAngleRange = ParamConfig.VECTOR2([0, '$PI']);\n\t/** @param target position. This is updated automatically as the camera is controlled by user events */\n\ttarget = ParamConfig.VECTOR3([0, 0, 0], {\n\t\tcook: false,\n\t\tcomputeOnDirty: true,\n\t\tcallback: (node: BaseNodeType) => {\n\t\t\tCameraOrbitControlsEventNode.PARAM_CALLBACK_update_target(node as CameraOrbitControlsEventNode);\n\t\t},\n\t});\n\t/** @param toggle on to enable keys */\n\tenableKeys = ParamConfig.BOOLEAN(0);\n\t/** @param key modes (pan or rotate) */\n\tkeysMode = ParamConfig.INTEGER(KEYS_MODES.indexOf(KeysMode.PAN), {\n\t\tvisibleIf: {enableKeys: 1},\n\t\tmenu: {\n\t\t\tentries: KEYS_MODES.map((name, value) => {\n\t\t\t\treturn {name, value};\n\t\t\t}),\n\t\t},\n\t});\n\t/** @param keys pan speed */\n\tkeysPanSpeed = ParamConfig.FLOAT(7, {\n\t\trange: [0, 10],\n\t\trangeLocked: [false, false],\n\t\tvisibleIf: {enableKeys: 1, keysMode: KEYS_MODES.indexOf(KeysMode.PAN)},\n\t});\n\t/** @param keys rotate speed vertical */\n\tkeysRotateSpeedVertical = ParamConfig.FLOAT(1, {\n\t\trange: [0, 1],\n\t\trangeLocked: [false, false],\n\t\tvisibleIf: {enableKeys: 1, keysMode: KEYS_MODES.indexOf(KeysMode.ROTATE)},\n\t});\n\t/** @param keys rotate speed horizontal */\n\tkeysRotateSpeedHorizontal = ParamConfig.FLOAT(1, {\n\t\trange: [0, 1],\n\t\trangeLocked: [false, false],\n\t\tvisibleIf: {enableKeys: 1, keysMode: KEYS_MODES.indexOf(KeysMode.ROTATE)},\n\t});\n}\nconst ParamsConfig = new CameraOrbitEventParamsConfig();\n\nexport class CameraOrbitControlsEventNode extends TypedCameraControlsEventNode<CameraOrbitEventParamsConfig> {\n\tparams_config = ParamsConfig;\n\tstatic type() {\n\t\treturn CameraControlsNodeType.ORBIT;\n\t}\n\tendEventName() {\n\t\treturn 'end';\n\t}\n\tinitializeNode() {\n\t\tthis.io.outputs.setNamedOutputConnectionPoints([\n\t\t\tnew EventConnectionPoint(OUTPUT_START, EventConnectionPointType.BASE),\n\t\t\tnew EventConnectionPoint(OUTPUT_CHANGE, EventConnectionPointType.BASE),\n\t\t\tnew EventConnectionPoint(OUTPUT_END, EventConnectionPointType.BASE),\n\t\t]);\n\t}\n\n\tprivate _controls_by_element_id: Map<string, OrbitControls> = new Map();\n\n\tasync create_controls_instance(camera: Camera, element: HTMLElement) {\n\t\tconst controls = new OrbitControls(camera, element);\n\t\tcontrols.addEventListener('end', () => {\n\t\t\tthis._on_controls_end(controls);\n\t\t});\n\n\t\tthis._controls_by_element_id.set(element.id, controls);\n\t\tthis._bind_listeners_to_controls_instance(controls);\n\t\treturn controls;\n\t}\n\tprotected _bind_listeners_to_controls_instance(controls: OrbitControls) {\n\t\tcontrols.addEventListener('start', () => {\n\t\t\tthis.dispatch_event_to_output(OUTPUT_START, {});\n\t\t});\n\t\tcontrols.addEventListener('change', () => {\n\t\t\tthis.dispatch_event_to_output(OUTPUT_CHANGE, {});\n\t\t});\n\t\tcontrols.addEventListener('end', () => {\n\t\t\tthis.dispatch_event_to_output(OUTPUT_END, {});\n\t\t});\n\t}\n\n\tsetup_controls(controls: OrbitControls) {\n\t\tcontrols.enabled = isBooleanTrue(this.pv.enabled);\n\n\t\tcontrols.enablePan = isBooleanTrue(this.pv.allowPan);\n\t\tcontrols.enableRotate = isBooleanTrue(this.pv.allowRotate);\n\t\tcontrols.enableZoom = isBooleanTrue(this.pv.allowZoom);\n\n\t\tcontrols.enableDamping = isBooleanTrue(this.pv.tdamping);\n\t\tcontrols.dampingFactor = this.pv.damping;\n\n\t\tcontrols.rotateSpeed = this.pv.rotateSpeed;\n\n\t\tcontrols.screenSpacePanning = isBooleanTrue(this.pv.screenSpacePanning);\n\n\t\tcontrols.minDistance = this.pv.minDistance;\n\t\tcontrols.maxDistance = this.pv.maxDistance;\n\n\t\tthis._set_azimuth_angle(controls);\n\t\tcontrols.minPolarAngle = this.pv.polarAngleRange.x;\n\t\tcontrols.maxPolarAngle = this.pv.polarAngleRange.y;\n\t\tcontrols.target.copy(this.pv.target);\n\t\tif (controls.enabled) {\n\t\t\tcontrols.update(); // necessary if target is not 0,0,0\n\t\t}\n\n\t\tcontrols.enableKeys = isBooleanTrue(this.pv.enableKeys);\n\t\tif (controls.enableKeys) {\n\t\t\tcontrols.keyMode = KEYS_MODES[this.pv.keysMode];\n\t\t\tcontrols.keyRotateSpeedVertical = this.pv.keysRotateSpeedVertical;\n\t\t\tcontrols.keyRotateSpeedHorizontal = this.pv.keysRotateSpeedHorizontal;\n\t\t\tcontrols.keyPanSpeed = this.pv.keysPanSpeed;\n\t\t}\n\t}\n\tprivate _set_azimuth_angle(controls: OrbitControls) {\n\t\tif (isBooleanTrue(this.pv.limitAzimuthAngle)) {\n\t\t\tcontrols.minAzimuthAngle = this.pv.azimuthAngleRange.x;\n\t\t\tcontrols.maxAzimuthAngle = this.pv.azimuthAngleRange.y;\n\t\t} else {\n\t\t\tcontrols.minAzimuthAngle = Infinity;\n\t\t\tcontrols.maxAzimuthAngle = Infinity;\n\t\t}\n\t}\n\n\tupdate_required(): boolean {\n\t\treturn isBooleanTrue(this.pv.tdamping);\n\t}\n\n\t// set_from_camera_node(controls: CameraControls, camera_node: BaseCameraObjNodeType): void {\n\t// \tconst target = camera_node.params.vector3('target');\n\t// \tcontrols.target.copy(target);\n\t// \tconsole.warn('set from camera node');\n\t// }\n\n\tprivate _target_array: Number3 = [0, 0, 0];\n\tprivate _on_controls_end(controls: OrbitControls) {\n\t\tif (!isBooleanTrue(this.pv.allowPan)) {\n\t\t\t// target should not be updated if pan is not allowed\n\t\t\treturn;\n\t\t}\n\t\tcontrols.target.toArray(this._target_array);\n\t\tthis.p.target.set(this._target_array);\n\t}\n\n\tstatic PARAM_CALLBACK_update_target(node: CameraOrbitControlsEventNode) {\n\t\tnode._update_target();\n\t}\n\tprivate _update_target() {\n\t\tconst src_target = this.pv.target;\n\t\tthis._controls_by_element_id.forEach((control, element_id) => {\n\t\t\tconst dest_target = control.target;\n\t\t\tif (!dest_target.equals(src_target)) {\n\t\t\t\tdest_target.copy(src_target);\n\t\t\t\tcontrol.update();\n\t\t\t}\n\t\t});\n\t}\n\n\tdispose_controls_for_html_element_id(html_element_id: string) {\n\t\t// this method is important so that we can do the following steps:\n\t\t// 1. assign an orbit_controls to the camera\n\t\t// 2. remove the controls\n\t\t// 3. update the target param of the controls, and this doesn't affect the camera (nor should it!)\n\t\tconst controls = this._controls_by_element_id.get(html_element_id);\n\t\tif (controls) {\n\t\t\t// controls.dispose(); // no need to dispose here, as it is done by the viewer for now\n\t\t\tthis._controls_by_element_id.delete(html_element_id);\n\t\t}\n\t}\n}\n","import {TypedLightObjNode} from './_BaseLight';\nimport {Light} from 'three/src/lights/Light';\n// import {CoreTransform} from '../../../core/Transform';\nimport {NodeParamsConfig} from '../utils/params/ParamsConfig';\nimport {TransformController, TransformedParamConfig} from './utils/TransformController';\nimport {FlagsControllerD} from '../utils/FlagsController';\nimport {HierarchyController} from './utils/HierarchyController';\n\n// import {Transformed} from './Concerns/Transformed';\nclass TransformedObjParamConfig extends TransformedParamConfig(NodeParamsConfig) {}\n\nexport abstract class BaseLightTransformedObjNode<\n\tL extends Light,\n\tK extends TransformedObjParamConfig\n> extends TypedLightObjNode<L, K> {\n\tpublic readonly flags: FlagsControllerD = new FlagsControllerD(this);\n\treadonly hierarchyController: HierarchyController = new HierarchyController(this);\n\treadonly transformController: TransformController = new TransformController(this);\n\n\tinitializeBaseNode() {\n\t\tsuper.initializeBaseNode();\n\t\tthis.hierarchyController.initializeNode();\n\t\tthis.transformController.initializeNode();\n\t}\n\n\tcook() {\n\t\tthis.transformController.update();\n\t\tthis.update_light_params();\n\t\tthis.update_shadow_params();\n\t\tthis.cookController.end_cook();\n\t}\n}\n","import {SpotLightObjNode} from '../../SpotLight';\nimport {BaseLightHelper} from './_BaseLightHelper';\nimport {SpotLight} from 'three/src/lights/SpotLight';\nimport {BufferGeometry} from 'three/src/core/BufferGeometry';\nimport {Float32BufferAttribute} from 'three/src/core/BufferAttribute';\nimport {LineBasicMaterial} from 'three/src/materials/LineBasicMaterial';\nimport {LineSegments} from 'three/src/objects/LineSegments';\nimport {Vector3} from 'three/src/math/Vector3';\nimport {Mesh} from 'three/src/objects/Mesh';\n\nexport class SpotLightHelper extends BaseLightHelper<Mesh, SpotLight, SpotLightObjNode> {\n\tcreateObject() {\n\t\treturn new Mesh();\n\t}\n\tprivate _cone = new LineSegments();\n\tprivate _line_material = new LineBasicMaterial({fog: false});\n\tprotected buildHelper() {\n\t\tconst geometry = new BufferGeometry();\n\n\t\tconst positions = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1];\n\n\t\tfor (let i = 0, j = 1, l = 32; i < l; i++, j++) {\n\t\t\tconst p1 = (i / l) * Math.PI * 2;\n\t\t\tconst p2 = (j / l) * Math.PI * 2;\n\n\t\t\tpositions.push(Math.cos(p1), Math.sin(p1), 1, Math.cos(p2), Math.sin(p2), 1);\n\t\t}\n\n\t\tgeometry.setAttribute('position', new Float32BufferAttribute(positions, 3));\n\t\tthis._cone.geometry = geometry;\n\n\t\tthis._cone.material = this._line_material;\n\t\t// this._cone.rotateX(Math.PI * 0.5);\n\t\t// this._cone.updateMatrix()\n\t\tthis._cone.matrixAutoUpdate = false;\n\n\t\tthis.object.add(this._cone);\n\t}\n\n\tprivate _matrix_scale = new Vector3();\n\tupdate() {\n\t\tconst coneLength = (this.node.light.distance ? this.node.light.distance : 1000) * this.node.pv.helperSize;\n\t\tconst coneWidth = coneLength * Math.tan(this.node.light.angle);\n\n\t\tthis._matrix_scale.set(coneWidth, coneWidth, coneLength);\n\t\tthis._cone.matrix.identity();\n\t\tthis._cone.matrix.makeRotationX(Math.PI * 0.5);\n\t\tthis._cone.matrix.scale(this._matrix_scale);\n\t\t// this._cone.scale.set(coneWidth, coneWidth, coneLength);\n\n\t\tthis._line_material.color.copy(this.node.light.color);\n\t}\n}\n","/**\n * Creates a spot light.\n *\n *\n */\nimport {SpotLight} from 'three/src/lights/SpotLight';\nimport {BaseLightTransformedObjNode} from './_BaseLightTransformed';\nimport {TransformedParamConfig} from './utils/TransformController';\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {HelperController, HelperConstructor} from './utils/HelperController';\nimport {SpotLightHelper} from './utils/helpers/SpotLightHelper';\nimport {Object3D} from 'three/src/core/Object3D';\nimport {Mesh} from 'three/src/objects/Mesh';\nimport {ColorConversion} from '../../../core/Color';\nimport {isBooleanTrue} from '../../../core/BooleanValue';\nclass SpotLightObjParamsConfig extends TransformedParamConfig(NodeParamsConfig) {\n\tlight = ParamConfig.FOLDER();\n\t/** @param light color */\n\tcolor = ParamConfig.COLOR([1, 1, 1], {\n\t\tconversion: ColorConversion.SRGB_TO_LINEAR,\n\t});\n\t/** @param light intensity */\n\tintensity = ParamConfig.FLOAT(1);\n\t/** @param angle */\n\tangle = ParamConfig.FLOAT(45, {range: [0, 180]});\n\t/** @param penumbra */\n\tpenumbra = ParamConfig.FLOAT(0.1);\n\t/** @param decay */\n\tdecay = ParamConfig.FLOAT(0.1, {range: [0, 1]});\n\t/** @param distance */\n\tdistance = ParamConfig.FLOAT(100, {range: [0, 100]});\n\t// target = ParamConfig.OPERATOR_PATH('');\n\n\t// helper\n\t/** @param toggle on to show helper */\n\tshowHelper = ParamConfig.BOOLEAN(0);\n\t/** @param helper size */\n\thelperSize = ParamConfig.FLOAT(1, {visibleIf: {showHelper: 1}});\n\n\t// shadows\n\tshadow = ParamConfig.FOLDER();\n\t/** @param toggle on to cast shadows */\n\tcastShadow = ParamConfig.BOOLEAN(1);\n\t/** @param toggle off if the shadows do not need to be regenerated */\n\tshadowAutoUpdate = ParamConfig.BOOLEAN(1, {\n\t\tvisibleIf: {castShadow: 1},\n\t});\n\t/** @param press button to update the shadows on next render */\n\tshadowUpdateOnNextRender = ParamConfig.BOOLEAN(0, {\n\t\tvisibleIf: {castShadow: 1, shadowAutoUpdate: 0},\n\t});\n\t/** @param shadows res */\n\tshadowRes = ParamConfig.VECTOR2([256, 256], {\n\t\tvisibleIf: {castShadow: 1},\n\t});\n\t/** @param shadows bias */\n\tshadowBias = ParamConfig.FLOAT(0.001, {\n\t\tvisibleIf: {castShadow: 1},\n\t\trange: [-0.01, 0.01],\n\t\trangeLocked: [false, false],\n\t});\n\tshadowNear = ParamConfig.FLOAT(0.1, {\n\t\tvisibleIf: {castShadow: 1},\n\t\trange: [0, 100],\n\t\trangeLocked: [true, false],\n\t});\n\tshadowFar = ParamConfig.FLOAT(100, {\n\t\tvisibleIf: {castShadow: 1},\n\t\trange: [0, 100],\n\t\trangeLocked: [true, false],\n\t});\n}\nconst ParamsConfig = new SpotLightObjParamsConfig();\n\nexport class SpotLightObjNode extends BaseLightTransformedObjNode<SpotLight, SpotLightObjParamsConfig> {\n\tparams_config = ParamsConfig;\n\tstatic type() {\n\t\treturn 'spotLight';\n\t}\n\tprivate _target_target!: Object3D;\n\tprivate _helper_controller = new HelperController<Mesh, SpotLight>(\n\t\tthis,\n\t\t(<unknown>SpotLightHelper) as HelperConstructor<Mesh, SpotLight>,\n\t\t'SpotLightHelper'\n\t);\n\tinitializeNode() {\n\t\t// this.io.inputs.setCount(0, 1);\n\t\tthis._helper_controller.initializeNode();\n\t}\n\n\tcreate_light() {\n\t\tconst light = new SpotLight();\n\t\tlight.matrixAutoUpdate = false;\n\n\t\tlight.castShadow = true;\n\t\t// light.shadow.focus = 1;\n\t\tlight.shadow.bias = -0.001;\n\t\tlight.shadow.mapSize.x = 256;\n\t\tlight.shadow.mapSize.y = 256;\n\t\tlight.shadow.camera.near = 0.1;\n\n\t\tthis._target_target = light.target;\n\t\tthis._target_target.name = 'SpotLight Default Target';\n\t\tthis._target_target.matrixAutoUpdate = false;\n\t\tthis.object.add(this._target_target);\n\n\t\treturn light;\n\t}\n\n\tupdate_light_params() {\n\t\tthis.light.color = this.pv.color;\n\t\tthis.light.intensity = this.pv.intensity;\n\t\tthis.light.angle = this.pv.angle * (Math.PI / 180);\n\t\tthis.light.penumbra = this.pv.penumbra;\n\t\tthis.light.decay = this.pv.decay;\n\t\tthis.light.distance = this.pv.distance;\n\t\t// TODO: consider allow power to be edited\n\t\t// (maybe it will need a setting to toggle physicallyCorrect, which would then show the power param)\n\t\t// this.light.power = 1;\n\n\t\tthis._helper_controller.update();\n\t}\n\tupdate_shadow_params() {\n\t\tthis.light.castShadow = isBooleanTrue(this.pv.castShadow);\n\t\tthis.light.shadow.autoUpdate = isBooleanTrue(this.pv.shadowAutoUpdate);\n\t\tthis.light.shadow.needsUpdate = isBooleanTrue(this.pv.shadowUpdateOnNextRender);\n\n\t\tthis.light.shadow.mapSize.copy(this.pv.shadowRes);\n\t\t// near/far don't seem to have any effect\n\t\tthis.light.shadow.camera.near = this.pv.shadowNear;\n\t\tthis.light.shadow.camera.far = this.pv.shadowFar;\n\t\tthis.light.shadow.bias = this.pv.shadowBias;\n\t}\n}\n","import {CoreType} from '../Type';\nimport {AttribType} from './Constant';\n\nexport class CoreAttributeData {\n\tconstructor(private _size: number, private _type: AttribType) {}\n\n\tsize() {\n\t\treturn this._size;\n\t}\n\ttype() {\n\t\treturn this._type;\n\t}\n\n\tstatic from_value(attrib_value: any) {\n\t\tconst type = CoreType.isString(attrib_value) ? AttribType.STRING : AttribType.NUMERIC;\n\t\tconst size = CoreType.isArray(attrib_value) ? attrib_value.length : 1;\n\n\t\treturn new this(size, type);\n\t}\n}\n","// import {Core} from '../../_Module';\nimport {Points} from 'three/src/objects/Points';\nimport {Float32BufferAttribute} from 'three/src/core/BufferAttribute';\nimport {BufferGeometry} from 'three/src/core/BufferGeometry';\nconst THREE = {BufferGeometry, Float32BufferAttribute, Points};\n\nimport {CoreString} from '../../String';\nimport {CoreGeometry} from '../../geometry/Geometry';\nimport {AttribType} from '../../geometry/Constant';\nimport {CoreAttributeData} from '../../geometry/AttributeData';\nimport {CoreAttribute} from '../../geometry/Attribute';\nimport {Poly} from '../../../engine/Poly';\nimport {CoreType} from '../../Type';\nimport {PolyDictionary, StringOrNumber} from '../../../types/GlobalTypes';\n\nconst DEEP_ATTRIB_SEPARATOR = ':';\n\nexport interface JsonDataLoaderOptions {\n\tdataKeysPrefix?: string;\n\tskipEntries?: string;\n\tdoConvert?: boolean;\n\tconvertToNumeric?: string;\n}\n\nexport class JsonDataLoader {\n\t_json: any[] | undefined;\n\t_attribute_datas_by_name: PolyDictionary<CoreAttributeData> = {};\n\tprivate _options: JsonDataLoaderOptions = {};\n\n\tconstructor(options: JsonDataLoaderOptions = {}) {\n\t\tthis._options.dataKeysPrefix = options.dataKeysPrefix;\n\t\tthis._options.skipEntries = options.skipEntries;\n\t\tthis._options.doConvert = options.doConvert || false;\n\t\tthis._options.convertToNumeric = options.convertToNumeric;\n\t}\n\t//\n\n\tload(\n\t\turl: string,\n\t\tsuccess_callback: (geometry: BufferGeometry) => void,\n\t\tprogress_callback: (() => void) | undefined,\n\t\terror_callback: (error: ErrorEvent) => void | undefined\n\t) {\n\t\t// const url_loader = new UrlLoader();\n\t\t// const start_time = performance.now();\n\t\t// const config = {\n\t\t// \tcrossdomain: true\n\t\t// }\n\t\tfetch(url)\n\t\t\t.then(async (response) => {\n\t\t\t\t// const end_time = performance.now();\n\n\t\t\t\tthis._json = await response.json();\n\t\t\t\tif (this._options.dataKeysPrefix != null && this._options.dataKeysPrefix != '') {\n\t\t\t\t\tthis._json = this.get_prefixed_json(this._json, this._options.dataKeysPrefix.split('.'));\n\t\t\t\t}\n\t\t\t\tconst object = this.create_object();\n\t\t\t\tsuccess_callback(object);\n\t\t\t})\n\t\t\t.catch((error: ErrorEvent) => {\n\t\t\t\tPoly.error('error', error);\n\t\t\t\terror_callback(error);\n\t\t\t});\n\t}\n\n\tget_prefixed_json(json: any, prefixes: string[]): any[] {\n\t\tif (prefixes.length == 0) {\n\t\t\treturn json;\n\t\t} else {\n\t\t\tconst first_prefix = prefixes.shift();\n\t\t\tif (first_prefix) {\n\t\t\t\treturn this.get_prefixed_json(json[first_prefix], prefixes);\n\t\t\t}\n\t\t}\n\t\treturn [];\n\t}\n\n\tset_json(json: any) {\n\t\treturn (this._json = json);\n\t}\n\n\tcreate_object() {\n\t\tconst geometry = new THREE.BufferGeometry();\n\t\tconst core_geo = new CoreGeometry(geometry);\n\n\t\tif (this._json != null) {\n\t\t\tconst points_count = this._json.length;\n\t\t\tcore_geo.initPositionAttribute(points_count);\n\n\t\t\tthis._find_attributes();\n\t\t\t// for(let attrib_name of Object.keys(this._attribute_names)){\n\t\t\t// \tconst attrib_data = this._attribute_datas_by_name[attrib_name];\n\t\t\t// \treturn core_geo.addAttribute(attrib_name, attrib_data);\n\t\t\t// }\n\n\t\t\tconst convert_to_numeric_masks = CoreString.attribNames(this._options.convertToNumeric || '');\n\n\t\t\t// set values\n\t\t\tfor (let attrib_name of Object.keys(this._attribute_datas_by_name)) {\n\t\t\t\tconst geo_attrib_name = CoreAttribute.remap_name(attrib_name);\n\t\t\t\tlet attrib_values = this._attribute_values_for_name(attrib_name).flat();\n\n\t\t\t\tconst data = this._attribute_datas_by_name[attrib_name];\n\t\t\t\tconst size = data.size();\n\n\t\t\t\tif (data.type() === AttribType.STRING) {\n\t\t\t\t\t// const index_data = CoreAttribute.array_to_indexed_arrays(\n\t\t\t\t\t// \tattrib_values as string[]\n\t\t\t\t\t// )\n\n\t\t\t\t\tif (this._options.doConvert && CoreString.matchesOneMask(attrib_name, convert_to_numeric_masks)) {\n\t\t\t\t\t\tconst numerical_attrib_values: number[] = attrib_values.map((v) => {\n\t\t\t\t\t\t\tif (CoreType.isString(v)) {\n\t\t\t\t\t\t\t\treturn parseFloat(v) || 0;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\treturn v;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t\tgeometry.setAttribute(\n\t\t\t\t\t\t\tgeo_attrib_name,\n\t\t\t\t\t\t\tnew THREE.Float32BufferAttribute(numerical_attrib_values, size)\n\t\t\t\t\t\t);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst index_data = CoreAttribute.array_to_indexed_arrays(attrib_values as string[]);\n\t\t\t\t\t\tcore_geo.setIndexedAttribute(geo_attrib_name, index_data['values'], index_data['indices']);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tconst numerical_attrib_values = attrib_values as number[];\n\t\t\t\t\tgeometry.setAttribute(\n\t\t\t\t\t\tgeo_attrib_name,\n\t\t\t\t\t\tnew THREE.Float32BufferAttribute(numerical_attrib_values, size)\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn geometry;\n\t\t// return new THREE.Points(geometry, CoreConstant.MATERIALS[THREE.Points.name]);\n\t}\n\n\tprivate _find_attributes() {\n\t\tlet first_pt;\n\n\t\tconst masks = CoreString.attribNames(this._options.skipEntries || '');\n\n\t\tif (this._json) {\n\t\t\tif ((first_pt = this._json[0]) != null) {\n\t\t\t\tfor (let attrib_name of Object.keys(first_pt)) {\n\t\t\t\t\tconst attrib_value = first_pt[attrib_name];\n\n\t\t\t\t\tif (this._value_has_subentries(attrib_value)) {\n\t\t\t\t\t\tfor (let key of Object.keys(attrib_value)) {\n\t\t\t\t\t\t\tconst deep_attrib_name = [attrib_name, key].join(DEEP_ATTRIB_SEPARATOR);\n\t\t\t\t\t\t\tconst deep_attrib_value = attrib_value[attrib_name];\n\n\t\t\t\t\t\t\tif (!CoreString.matchesOneMask(deep_attrib_name, masks)) {\n\t\t\t\t\t\t\t\tthis._attribute_datas_by_name[deep_attrib_name] = CoreAttributeData.from_value(\n\t\t\t\t\t\t\t\t\tdeep_attrib_value\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (!CoreString.matchesOneMask(attrib_name, masks)) {\n\t\t\t\t\t\t\tthis._attribute_datas_by_name[attrib_name] = CoreAttributeData.from_value(attrib_value);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate _attribute_values_for_name(attrib_name: string): StringOrNumber[] {\n\t\tif (this._json) {\n\t\t\treturn this._json.map((json_element: PolyDictionary<any>) => {\n\t\t\t\tconst prefix = attrib_name.split(DEEP_ATTRIB_SEPARATOR)[0];\n\t\t\t\tconst value = json_element[prefix];\n\t\t\t\tif (this._value_has_subentries(value)) {\n\t\t\t\t\tconst deep_attrib_name = attrib_name.substring(prefix.length + 1);\n\t\t\t\t\treturn value[deep_attrib_name] || 0;\n\t\t\t\t} else {\n\t\t\t\t\treturn value || 0;\n\t\t\t\t}\n\t\t\t});\n\t\t} else {\n\t\t\treturn [];\n\t\t}\n\t}\n\n\t_value_has_subentries(value: any): boolean {\n\t\treturn CoreType.isObject(value) && !CoreType.isArray(value);\n\t}\n}\n","/**\n * Create points from a an array of json dictionaries\n *\n * @remarks\n * The number of points created will be equal to the number of elements in the array.\n * Each element of the array must be a dictionary. It can look like:\n * `[{position: [1,2,3]}]`\n * which will create a single point at the position x=1,y=2,z=3.\n *\n * In order to create 2 points with attributes `position` and `amp`, you would have:\n * `[{position: [1,2,3], amp: 1},{position: [7,2,1], amp: 3}]`\n *\n */\nimport {TypedSopNode} from './_Base';\nimport {JsonDataLoader} from '../../../core/loader/geometry/JsonData';\n\nconst DEFAULT_DATA = [\n\t{value: -40},\n\t{value: -30},\n\t{value: -20},\n\t{value: -10},\n\t{value: 0},\n\t{value: 10},\n\t{value: 20},\n\t{value: 30},\n\t{value: 40},\n\t{value: 50},\n\t{value: 60},\n\t{value: 70},\n\t{value: 80},\n];\nconst DEFAULT_DATA_STR = JSON.stringify(DEFAULT_DATA);\n\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {ObjectType} from '../../../core/geometry/Constant';\nclass DataSopParamsConfig extends NodeParamsConfig {\n\t/** @param json object used to create the geometry */\n\tdata = ParamConfig.STRING(DEFAULT_DATA_STR);\n}\nconst ParamsConfig = new DataSopParamsConfig();\n\nexport class DataSopNode extends TypedSopNode<DataSopParamsConfig> {\n\tparams_config = ParamsConfig;\n\tstatic type() {\n\t\treturn 'data';\n\t}\n\n\tcook() {\n\t\tlet json = null;\n\t\ttry {\n\t\t\tjson = JSON.parse(this.pv.data);\n\t\t} catch (e) {\n\t\t\tthis.states.error.set('could not parse json');\n\t\t}\n\n\t\tif (json) {\n\t\t\ttry {\n\t\t\t\tconst loader = new JsonDataLoader();\n\t\t\t\tloader.set_json(json);\n\t\t\t\tconst geometry = loader.create_object();\n\t\t\t\tthis.setGeometry(geometry, ObjectType.POINTS);\n\t\t\t} catch (e) {\n\t\t\t\tthis.states.error.set('could not build geometry from json');\n\t\t\t}\n\t\t} else {\n\t\t\tthis.cookController.end_cook();\n\t\t}\n\t}\n}\n","import {BufferGeometry} from 'three/src/core/BufferGeometry';\nimport {BufferAttribute} from 'three/src/core/BufferAttribute';\nimport {CoreImage} from '../../Image';\nimport {Texture} from 'three/src/textures/Texture';\nimport {DataTexture} from 'three/src/textures/DataTexture';\nimport {CoreAttribute} from '../../geometry/Attribute';\nimport {CoreMath} from '../../math/_Module';\n\ninterface AttribFromTextureParams {\n\tgeometry: BufferGeometry;\n\ttexture: Texture;\n\tuvAttribName: string;\n\ttargetAttribName: string;\n\ttargetAttribSize: number;\n\tadd: number;\n\tmult: number;\n}\n\nexport class AttribFromTexture {\n\t// currently assumes we read the red channel and create a 1-dimension (float) attribute\n\tset_attrib(params: AttribFromTextureParams) {\n\t\tconst geometry = params.geometry;\n\t\tconst targetAttribSize = params.targetAttribSize;\n\t\tif (targetAttribSize < 1 || targetAttribSize > 4) {\n\t\t\treturn;\n\t\t}\n\t\tconst add = params.add;\n\t\tconst mult = params.mult; // / 255.0;\n\t\tconst texture_data = this._data_from_texture(params.texture);\n\t\tif (!texture_data) {\n\t\t\treturn;\n\t\t}\n\t\tconst {data, resx, resy} = texture_data;\n\t\tconst texture_component_size = data.length / (resx * resy);\n\n\t\tconst uv_attrib = geometry.getAttribute(params.uvAttribName);\n\t\tconst uvs = uv_attrib.array;\n\n\t\tconst points_count = uvs.length / 2;\n\t\tconst values: number[] = new Array(points_count * targetAttribSize);\n\n\t\tlet uv_stride: number,\n\t\t\tuvx: number,\n\t\t\tuvy: number,\n\t\t\tx: number,\n\t\t\ty: number,\n\t\t\ti: number,\n\t\t\tj: number,\n\t\t\tval: number,\n\t\t\tc: number;\n\t\tconst clamp = CoreMath.clamp;\n\n\t\tfor (i = 0; i < points_count; i++) {\n\t\t\tuv_stride = i * 2;\n\t\t\tuvx = clamp(uvs[uv_stride], 0, 1);\n\t\t\tuvy = clamp(uvs[uv_stride + 1], 0, 1);\n\t\t\tx = Math.floor((resx - 1) * uvx);\n\t\t\ty = Math.floor((resy - 1) * (1 - uvy));\n\t\t\tj = y * resx + x;\n\n\t\t\tfor (c = 0; c < targetAttribSize; c++) {\n\t\t\t\tval = data[texture_component_size * j + c];\n\n\t\t\t\t// index = i * targetAttribSize;\n\t\t\t\tvalues[i * targetAttribSize + c] = mult * val + add;\n\t\t\t}\n\t\t}\n\n\t\tconst attribName = CoreAttribute.remap_name(params.targetAttribName);\n\t\tconst array = new Float32Array(values);\n\t\tgeometry.setAttribute(attribName, new BufferAttribute(array, targetAttribSize));\n\t}\n\n\tprivate _data_from_texture(texture: Texture) {\n\t\tif (texture.image) {\n\t\t\tif (texture.image.data) {\n\t\t\t\treturn this._data_from_data_texture(texture as DataTexture);\n\t\t\t}\n\t\t\treturn this._data_from_default_texture(texture);\n\t\t}\n\t}\n\tprivate _data_from_default_texture(texture: Texture) {\n\t\tconst resx = texture.image.width;\n\t\tconst resy = texture.image.height;\n\t\tconst image_data = CoreImage.data_from_image(texture.image);\n\t\tconst data = image_data.data;\n\t\treturn {\n\t\t\tdata,\n\t\t\tresx,\n\t\t\tresy,\n\t\t};\n\t}\n\tprivate _data_from_data_texture(texture: DataTexture) {\n\t\tconst data = texture.image.data;\n\t\tconst resx = texture.image.width;\n\t\tconst resy = texture.image.height;\n\t\treturn {\n\t\t\tdata,\n\t\t\tresx,\n\t\t\tresy,\n\t\t};\n\t}\n}\n","// import jimp from 'jimp';\n// jimp.js is now async,\n// and created via packs/jimp.ts\n\n// import {Texture} from 'three/src/textures/Texture'\n// import {Color} from 'three/src/math/Color'\n\nexport class CoreImage {\n\t// constructor() {}\n\n\t// https://stackoverflow.com/questions/6765370/merge-image-using-javascript\n\tstatic overlay(img0: HTMLImageElement, img1: HTMLImageElement): Promise<HTMLImageElement> {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tlet canvas = document.createElement('canvas');\n\t\t\tcanvas.width = Math.max(img0.width, img1.width);\n\t\t\tcanvas.height = Math.max(img0.height, img1.height);\n\t\t\tlet context = canvas.getContext('2d') as CanvasRenderingContext2D;\n\n\t\t\tcontext.drawImage(img0, 0, 0, img0.width, img0.height);\n\t\t\tcontext.drawImage(img1, 0, 0, img1.width, img1.height);\n\t\t\tconst datauri = canvas.toDataURL('image/png');\n\t\t\tconst img = new Image();\n\t\t\timg.onload = () => {\n\t\t\t\tresolve(img);\n\t\t\t};\n\t\t\timg.src = datauri;\n\t\t});\n\t}\n\n\t// static image_from_path(url: string): Promise<HTMLImageElement> {\n\t// \treturn new Promise((resolve, reject) => {\n\t// \t\tconst img = new Image();\n\n\t// \t\timg.onload = function() {\n\t// \t\t\tresolve(img);\n\t// \t\t};\n\n\t// \t\timg.src = url;\n\t// \t});\n\t// }\n\t// static image_from_color(color: THREE.Color, width: number, height: number): Promise<HTMLImageElement> {\n\t// \treturn new Promise((resolve, reject) => {\n\t// \t\tconst image = new Image();\n\n\t// \t\tconst canvas = document.createElement('canvas');\n\t// \t\tcanvas.width = width;\n\t// \t\tcanvas.height = height;\n\t// \t\tconst context = canvas.getContext('2d') as CanvasRenderingContext2D;\n\t// \t\tcontext.fillStyle = color.getStyle();\n\t// \t\tcontext.fillRect(0, 0, canvas.width, canvas.height);\n\t// \t\tconst data_url = canvas.toDataURL();\n\t// \t\timage.onload = () => {\n\t// \t\t\tresolve(image);\n\t// \t\t};\n\t// \t\timage.src = data_url;\n\t// \t});\n\t// }\n\t// static image_from_texture(texture: THREE.Texture): Promise<HTMLImageElement | null> {\n\t// \treturn new Promise((resolve, reject) => {\n\t// \t\tif (texture.image) {\n\t// \t\t\tif (texture.image.data) {\n\t// \t\t\t\tconst image = new Image();\n\t// \t\t\t\timage.width = texture.image.width;\n\t// \t\t\t\timage.height = texture.image.height;\n\t// \t\t\t\tconst datauri = this.image_data_to_data_uri(texture.image);\n\t// \t\t\t\timage.onload = () => {\n\t// \t\t\t\t\tresolve(image);\n\t// \t\t\t\t};\n\t// \t\t\t\timage.src = datauri;\n\t// \t\t\t} else {\n\t// \t\t\t\tresolve(texture.image);\n\t// \t\t\t}\n\t// \t\t} else {\n\t// \t\t\tresolve(null);\n\t// \t\t}\n\t// \t});\n\t// }\n\t// static image_to_datauri(image: HTMLImageElement): string {\n\t// \tconst canvas = document.createElement('canvas');\n\t// \tcanvas.width = image.width;\n\t// \tcanvas.height = image.height;\n\t// \tconst context = canvas.getContext('2d') as CanvasRenderingContext2D;\n\t// \t// context.fillRect(0, 0, canvas.width, canvas.height)\n\t// \tcontext.drawImage(image, 0, 0);\n\t// \treturn canvas.toDataURL();\n\t// }\n\t// static image_data_to_data_uri(image_data: ImageData): string {\n\t// \tconst canvas = document.createElement('canvas');\n\t// \tconst context = canvas.getContext('2d') as CanvasRenderingContext2D;\n\t// \tcanvas.width = image_data.width;\n\t// \tcanvas.height = image_data.height;\n\n\t// \t// let stride\n\t// \t// let color\n\t// \t// lodash_times(canvas.width, (w)=>{\n\t// \t// \tlodash_times(canvas.height, (h)=>{\n\t// \t// \t\tstride = 4 * (w + h*w)\n\t// \t// \t\tcolor = new THREE.Color(\n\t// \t// \t\t\timage_data.data[stride],\n\t// \t// \t\t\timage_data.data[stride+1],\n\t// \t// \t\t\timage_data.data[stride+2]\n\t// \t// \t\t)\n\t// \t// \t\tcontext.fillStyle = color.getStyle()\n\t// \t// \t\tcontext.fillRect(w, h, 1, 1)\n\t// \t// \t})\n\t// \t// })\n\n\t// \t// const color = new THREE.Color(0,1,1)\n\t// \t// context.fillStyle = color.getStyle()\n\t// \t// context.fillRect(0, 0, canvas.width, canvas.height)\n\t// \t// // context.putImageData(image_data.data, 0, 0)\n\t// \tconst context_imaged_data = context.getImageData(0, 0, canvas.width, canvas.height);\n\t// \t// image_data.data = image_data.data.map(d=>d*255)\n\t// \tcontext_imaged_data.data.set(image_data.data.map((d) => d * 255));\n\t// \tcontext.putImageData(context_imaged_data, 0, 0);\n\t// \t// document.body.appendChild(canvas)\n\t// \t// document.body.style.overflow = 'auto'\n\t// \treturn canvas.toDataURL();\n\t// }\n\t// static datauri_from_texture(texture: THREE.Texture): string | null {\n\t// \tif (texture.image) {\n\t// \t\tif (texture.image.data) {\n\t// \t\t\treturn this.image_data_to_data_uri(texture.image);\n\t// \t\t} else {\n\t// \t\t\treturn this.image_to_datauri(texture.image);\n\t// \t\t}\n\t// \t} else {\n\t// \t\tconsole.warn(texture);\n\t// \t\treturn null;\n\t// \t}\n\t// }\n\n\tstatic create_white_image(width: number, height: number): Promise<HTMLImageElement> {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tlet canvas = document.createElement('canvas');\n\t\t\tcanvas.width = width;\n\t\t\tcanvas.height = height;\n\t\t\tlet context = canvas.getContext('2d') as CanvasRenderingContext2D;\n\t\t\tcontext.beginPath();\n\t\t\tcontext.rect(0, 0, width, height);\n\t\t\tcontext.fillStyle = 'white';\n\t\t\tcontext.fill();\n\t\t\tconst datauri = canvas.toDataURL('image/png');\n\t\t\tconst img = new Image();\n\t\t\timg.onload = () => {\n\t\t\t\tresolve(img);\n\t\t\t};\n\t\t\timg.src = datauri;\n\t\t});\n\t}\n\tstatic make_square(src_img: HTMLImageElement): Promise<HTMLImageElement> {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tlet canvas = document.createElement('canvas');\n\t\t\tconst size = Math.min(src_img.width, src_img.height);\n\t\t\tconst ratio = src_img.width / src_img.height;\n\t\t\tcanvas.width = size;\n\t\t\tcanvas.height = size;\n\t\t\tlet context = canvas.getContext('2d') as CanvasRenderingContext2D;\n\n\t\t\tconst is_landscape = ratio > 1;\n\t\t\tconst margin = is_landscape ? (src_img.width - size) / 2 : (src_img.height - size) / 2;\n\n\t\t\tif (is_landscape) {\n\t\t\t\tcontext.drawImage(src_img, margin, 0, size, size, 0, 0, size, size);\n\t\t\t} else {\n\t\t\t\tcontext.drawImage(src_img, 0, margin, size, size, 0, 0, size, size);\n\t\t\t}\n\n\t\t\tconst datauri = canvas.toDataURL('image/png');\n\t\t\tconst img = new Image();\n\t\t\timg.onload = () => {\n\t\t\t\tresolve(img);\n\t\t\t};\n\t\t\timg.src = datauri;\n\t\t});\n\t}\n\n\t// static async cover(img: HTMLImageElement, width: number, height: number){\n\t// \tawait CoreScriptLoader.load_jimp()\n\t// \tconst jimp_img = await self.jimp.read(img.src)\n\t// \treturn jimp_img.cover(width, height)\n\t// }\n\n\t// static async jimp_to_img(jimp_img): Promise<HTMLImageElement>{\n\t// \treturn new Promise(async (resolve, reject)=>{\n\t// \t\tawait CoreScriptLoader.load_jimp()\n\t// \t\tjimp_img.getBase64(self.jimp.MIME_PNG, (err, src) => {\n\t// \t\t\tconst img = document.createElement('img');\n\t// \t\t\timg.onload = ()=>{\n\t// \t\t\t\tresolve(img)\n\t// \t\t\t}\n\t// \t\t\timg.src = src\n\t// \t\t})\n\t// \t})\n\t// }\n\n\tstatic async image_to_blob(img: HTMLImageElement): Promise<Blob> {\n\t\treturn new Promise(function (resolve, reject) {\n\t\t\ttry {\n\t\t\t\tlet xhr = new XMLHttpRequest();\n\t\t\t\txhr.open('GET', img.src);\n\t\t\t\txhr.responseType = 'blob';\n\t\t\t\txhr.onerror = function () {\n\t\t\t\t\treject('Network error.');\n\t\t\t\t};\n\t\t\t\txhr.onload = function () {\n\t\t\t\t\tif (xhr.status === 200) {\n\t\t\t\t\t\tresolve(xhr.response);\n\t\t\t\t\t} else {\n\t\t\t\t\t\treject('Loading error:' + xhr.statusText);\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\txhr.send();\n\t\t\t} catch (err) {\n\t\t\t\treject(err.message);\n\t\t\t}\n\t\t});\n\t}\n\n\tstatic data_from_url(url: string): Promise<ImageData> {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tconst img = new Image();\n\t\t\timg.crossOrigin = 'Anonymous';\n\t\t\timg.onload = () => {\n\t\t\t\tconst data = this.data_from_image(img);\n\t\t\t\tresolve(data);\n\t\t\t};\n\t\t\timg.src = url;\n\t\t});\n\t}\n\tstatic data_from_image(img: HTMLImageElement): ImageData {\n\t\tconst canvas = document.createElement('canvas');\n\t\tcanvas.width = img.width;\n\t\tcanvas.height = img.height;\n\t\tconst context = canvas.getContext('2d') as CanvasRenderingContext2D;\n\t\tcontext.drawImage(img, 0, 0, img.width, img.height);\n\t\t// canvas.style.width = `${img.width}px`;\n\t\t// canvas.style.height = `${img.height}px`;\n\t\t// document.body.appendChild(canvas);\n\t\t// document.body.style.overflow = 'auto';\n\t\treturn context.getImageData(0, 0, img.width, img.height);\n\t}\n}\n","import {BaseSopOperation} from './_Base';\nimport {DefaultOperationParams} from '../_Base';\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {TypedNodePathParamValue, NODE_PATH_DEFAULT} from '../../../core/Walker';\nimport {NodeContext} from '../../../engine/poly/NodeContext';\nimport {AttribFromTexture} from '../../../core/geometry/operation/AttribFromTexture';\nimport {CoreObject} from '../../../core/geometry/Object';\nimport {Texture} from 'three/src/textures/Texture';\nimport {InputCloneMode} from '../../../engine/poly/InputCloneMode';\n\ninterface AttribFromTextureSopParams extends DefaultOperationParams {\n\ttexture: TypedNodePathParamValue;\n\tuvAttrib: string;\n\tattrib: string;\n\tattribSize: number;\n\tadd: number;\n\tmult: number;\n}\n\nexport class AttribFromTextureSopOperation extends BaseSopOperation {\n\tstatic readonly DEFAULT_PARAMS: AttribFromTextureSopParams = {\n\t\ttexture: new TypedNodePathParamValue(NODE_PATH_DEFAULT.NODE.UV),\n\t\tuvAttrib: 'uv',\n\t\tattrib: 'pscale',\n\t\tattribSize: 1,\n\t\tadd: 0,\n\t\tmult: 1,\n\t};\n\tstatic readonly INPUT_CLONED_STATE = InputCloneMode.FROM_NODE;\n\tstatic type(): Readonly<'attribFromTexture'> {\n\t\treturn 'attribFromTexture';\n\t}\n\n\tasync cook(input_contents: CoreGroup[], params: AttribFromTextureSopParams) {\n\t\tconst core_group = input_contents[0];\n\n\t\tconst texture_node = params.texture.ensure_node_context(NodeContext.COP, this.states?.error);\n\t\tif (!texture_node) {\n\t\t\treturn core_group;\n\t\t}\n\t\tconst container = await texture_node.requestContainer();\n\t\tconst texture = container.texture();\n\t\tfor (let core_object of core_group.coreObjects()) {\n\t\t\tthis._set_position_from_data_texture(core_object, texture, params);\n\t\t}\n\n\t\treturn core_group;\n\t}\n\tprivate _set_position_from_data_texture(\n\t\tcore_object: CoreObject,\n\t\ttexture: Texture,\n\t\tparams: AttribFromTextureSopParams\n\t) {\n\t\tconst geometry = core_object.coreGeometry()?.geometry();\n\t\tif (!geometry) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst uvAttrib = geometry.getAttribute(params.uvAttrib);\n\n\t\tif (uvAttrib == null) {\n\t\t\tthis.states?.error.set(`param '${params.uvAttrib} not found'`);\n\t\t\treturn;\n\t\t}\n\t\tconst operation = new AttribFromTexture();\n\t\toperation.set_attrib({\n\t\t\tgeometry: geometry,\n\t\t\ttexture: texture,\n\t\t\tuvAttribName: params.uvAttrib,\n\t\t\ttargetAttribName: params.attrib,\n\t\t\ttargetAttribSize: params.attribSize,\n\t\t\tadd: params.add,\n\t\t\tmult: params.mult,\n\t\t});\n\t}\n}\n","import {BufferGeometry} from 'three/src/core/BufferGeometry';\nimport {Float32BufferAttribute} from 'three/src/core/BufferAttribute';\nimport {Vector3} from 'three/src/math/Vector3';\n// import {Vector2} from 'three/src/math/Vector2';\n\ninterface PolyHedronBufferGeometryParameters {\n\tvertices: number[];\n\tindices: number[];\n\tradius: number;\n\tdetail: number;\n}\n\n// Angle around the Y axis, counter-clockwise when looking from above.\nfunction azimuth(vector: Vector3) {\n\treturn Math.atan2(vector.z, -vector.x);\n}\n\n// Angle above the XZ plane.\nfunction inclination(vector: Vector3) {\n\treturn Math.atan2(-vector.y, Math.sqrt(vector.x * vector.x + vector.z * vector.z));\n}\n\n// from three/src/geometries/PolyhedronGeometry\nexport class PolyhedronBufferGeometry extends BufferGeometry {\n\tparameters: PolyHedronBufferGeometryParameters;\n\tconstructor(vertices: number[], indices: number[], radius: number, detail: number, points_only: boolean) {\n\t\tsuper();\n\n\t\tthis.type = 'PolyhedronBufferGeometry';\n\n\t\tthis.parameters = {\n\t\t\tvertices: vertices,\n\t\t\tindices: indices,\n\t\t\tradius: radius,\n\t\t\tdetail: detail,\n\t\t};\n\n\t\tradius = radius || 1;\n\t\tdetail = detail || 0;\n\n\t\t// default buffer data\n\n\t\tconst vertexBuffer: number[] = [];\n\t\tconst uvBuffer: number[] = [];\n\t\tconst vertices_by_pos: Map<number, Map<number, Set<number>>> = new Map();\n\n\t\t// the subdivision creates the vertex buffer data\n\n\t\tsubdivide(detail);\n\n\t\t// all vertices should lie on a conceptual sphere with a given radius\n\n\t\tapplyRadius(radius);\n\n\t\t// finally, create the uv data\n\n\t\tgenerateUVs();\n\n\t\t// build non-indexed geometry\n\n\t\tthis.setAttribute('position', new Float32BufferAttribute(vertexBuffer, 3));\n\t\tthis.setAttribute('uv', new Float32BufferAttribute(uvBuffer, 2));\n\n\t\tif (!points_only) {\n\t\t\tthis.setAttribute('normal', new Float32BufferAttribute(vertexBuffer.slice(), 3));\n\t\t\tif (detail === 0) {\n\t\t\t\tthis.computeVertexNormals(); // flat normals\n\t\t\t} else {\n\t\t\t\tthis.normalizeNormals(); // smooth normals\n\t\t\t}\n\t\t}\n\t\t// helper functions\n\n\t\tfunction subdivide(detail: number) {\n\t\t\tconst a = new Vector3();\n\t\t\tconst b = new Vector3();\n\t\t\tconst c = new Vector3();\n\n\t\t\t// iterate over all faces and apply a subdivison with the given detail value\n\n\t\t\tfor (let i = 0; i < indices.length; i += 3) {\n\t\t\t\t// get the vertices of the face\n\n\t\t\t\tgetVertexByIndex(indices[i + 0], a);\n\t\t\t\tgetVertexByIndex(indices[i + 1], b);\n\t\t\t\tgetVertexByIndex(indices[i + 2], c);\n\n\t\t\t\t// perform subdivision\n\n\t\t\t\tsubdivideFace(a, b, c, detail);\n\t\t\t}\n\t\t}\n\n\t\tfunction subdivideFace(a: Vector3, b: Vector3, c: Vector3, detail: number) {\n\t\t\tconst cols = detail + 1;\n\n\t\t\t// we use this multidimensional array as a data structure for creating the subdivision\n\n\t\t\tconst v: Vector3[][] = [];\n\n\t\t\t// construct all of the vertices for this subdivision\n\n\t\t\tfor (let i = 0; i <= cols; i++) {\n\t\t\t\tv[i] = [];\n\n\t\t\t\tconst aj = a.clone().lerp(c, i / cols);\n\t\t\t\tconst bj = b.clone().lerp(c, i / cols);\n\n\t\t\t\tconst rows = cols - i;\n\n\t\t\t\tfor (let j = 0; j <= rows; j++) {\n\t\t\t\t\tif (j === 0 && i === cols) {\n\t\t\t\t\t\tv[i][j] = aj;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tv[i][j] = aj.clone().lerp(bj, j / rows);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// construct all of the faces\n\n\t\t\tfor (let i = 0; i < cols; i++) {\n\t\t\t\tfor (let j = 0; j < 2 * (cols - i) - 1; j++) {\n\t\t\t\t\tconst k = Math.floor(j / 2);\n\n\t\t\t\t\tif (j % 2 === 0) {\n\t\t\t\t\t\tpushVertex(v[i][k + 1]);\n\t\t\t\t\t\tpushVertex(v[i + 1][k]);\n\t\t\t\t\t\tpushVertex(v[i][k]);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpushVertex(v[i][k + 1]);\n\t\t\t\t\t\tpushVertex(v[i + 1][k + 1]);\n\t\t\t\t\t\tpushVertex(v[i + 1][k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunction applyRadius(radius: number) {\n\t\t\tconst vertex = new Vector3();\n\n\t\t\t// iterate over the entire buffer and apply the radius to each vertex\n\n\t\t\tfor (let i = 0; i < vertexBuffer.length; i += 3) {\n\t\t\t\tvertex.x = vertexBuffer[i + 0];\n\t\t\t\tvertex.y = vertexBuffer[i + 1];\n\t\t\t\tvertex.z = vertexBuffer[i + 2];\n\n\t\t\t\tvertex.normalize().multiplyScalar(radius);\n\n\t\t\t\tvertexBuffer[i + 0] = vertex.x;\n\t\t\t\tvertexBuffer[i + 1] = vertex.y;\n\t\t\t\tvertexBuffer[i + 2] = vertex.z;\n\t\t\t}\n\t\t}\n\n\t\tfunction generateUVs() {\n\t\t\tconst vertex = new Vector3();\n\n\t\t\tfor (let i = 0; i < vertexBuffer.length; i += 3) {\n\t\t\t\tvertex.x = vertexBuffer[i + 0];\n\t\t\t\tvertex.y = vertexBuffer[i + 1];\n\t\t\t\tvertex.z = vertexBuffer[i + 2];\n\n\t\t\t\tconst u = azimuth(vertex) / 2 / Math.PI + 0.5;\n\t\t\t\tconst v = inclination(vertex) / Math.PI + 0.5;\n\t\t\t\tuvBuffer.push(u, 1 - v);\n\t\t\t}\n\n\t\t\t// correctUVs and correctSeam are currently not used\n\t\t\t// as they seem to create incorrect uvs when using points only\n\t\t\t// correctUVs();\n\t\t\t// correctSeam();\n\t\t}\n\n\t\t// function correctSeam() {\n\t\t// \t// handle case when face straddles the seam, see #3269\n\n\t\t// \tfor (let i = 0; i < uvBuffer.length; i += 6) {\n\t\t// \t\t// uv data of a single face\n\n\t\t// \t\tconst x0 = uvBuffer[i + 0];\n\t\t// \t\tconst x1 = uvBuffer[i + 2];\n\t\t// \t\tconst x2 = uvBuffer[i + 4];\n\n\t\t// \t\tconst max = Math.max(x0, x1, x2);\n\t\t// \t\tconst min = Math.min(x0, x1, x2);\n\n\t\t// \t\t// 0.9 is somewhat arbitrary\n\n\t\t// \t\tif (max > 0.9 && min < 0.1) {\n\t\t// \t\t\tif (x0 < 0.2) uvBuffer[i + 0] += 1;\n\t\t// \t\t\tif (x1 < 0.2) uvBuffer[i + 2] += 1;\n\t\t// \t\t\tif (x2 < 0.2) uvBuffer[i + 4] += 1;\n\t\t// \t\t}\n\t\t// \t}\n\t\t// }\n\n\t\tfunction pushVertex(vertex: Vector3) {\n\t\t\tif (points_only) {\n\t\t\t\tlet mx = vertices_by_pos.get(vertex.x);\n\t\t\t\tif (mx) {\n\t\t\t\t\tconst my = mx.get(vertex.y);\n\t\t\t\t\tif (my && my.has(vertex.z)) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!mx) {\n\t\t\t\t\tmx = new Map();\n\t\t\t\t\tvertices_by_pos.set(vertex.x, mx);\n\t\t\t\t}\n\t\t\t\tlet my = mx.get(vertex.y);\n\t\t\t\tif (!my) {\n\t\t\t\t\tmy = new Set();\n\t\t\t\t\tmx.set(vertex.y, my);\n\t\t\t\t}\n\t\t\t\tmy.add(vertex.z);\n\t\t\t}\n\t\t\tvertexBuffer.push(vertex.x, vertex.y, vertex.z);\n\t\t}\n\n\t\tfunction getVertexByIndex(index: number, vertex: Vector3) {\n\t\t\tconst stride = index * 3;\n\n\t\t\tvertex.x = vertices[stride + 0];\n\t\t\tvertex.y = vertices[stride + 1];\n\t\t\tvertex.z = vertices[stride + 2];\n\t\t}\n\n\t\t// function correctUVs() {\n\t\t// \tconst a = new Vector3();\n\t\t// \tconst b = new Vector3();\n\t\t// \tconst c = new Vector3();\n\n\t\t// \tconst centroid = new Vector3();\n\n\t\t// \tconst uvA = new Vector2();\n\t\t// \tconst uvB = new Vector2();\n\t\t// \tconst uvC = new Vector2();\n\n\t\t// \tfor (let i = 0, j = 0; i < vertexBuffer.length; i += 9, j += 6) {\n\t\t// \t\ta.set(vertexBuffer[i + 0], vertexBuffer[i + 1], vertexBuffer[i + 2]);\n\t\t// \t\tb.set(vertexBuffer[i + 3], vertexBuffer[i + 4], vertexBuffer[i + 5]);\n\t\t// \t\tc.set(vertexBuffer[i + 6], vertexBuffer[i + 7], vertexBuffer[i + 8]);\n\n\t\t// \t\tuvA.set(uvBuffer[j + 0], uvBuffer[j + 1]);\n\t\t// \t\tuvB.set(uvBuffer[j + 2], uvBuffer[j + 3]);\n\t\t// \t\tuvC.set(uvBuffer[j + 4], uvBuffer[j + 5]);\n\n\t\t// \t\tcentroid.copy(a).add(b).add(c).divideScalar(3);\n\n\t\t// \t\tconst azi = azimuth(centroid);\n\n\t\t// \t\tcorrectUV(uvA, j + 0, a, azi);\n\t\t// \t\tcorrectUV(uvB, j + 2, b, azi);\n\t\t// \t\tcorrectUV(uvC, j + 4, c, azi);\n\t\t// \t}\n\t\t// }\n\n\t\t// function correctUV(uv: Vector2, stride: number, vector: Vector3, azimuth: number) {\n\t\t// \tif (azimuth < 0 && uv.x === 1) {\n\t\t// \t\tuvBuffer[stride] = uv.x - 1;\n\t\t// \t}\n\n\t\t// \tif (vector.x === 0 && vector.z === 0) {\n\t\t// \t\tuvBuffer[stride] = azimuth / 2 / Math.PI + 0.5;\n\t\t// \t}\n\t\t// }\n\t}\n}\n","import {PolyhedronBufferGeometry} from './Polyhedron';\n\n// from three/src/geometries/IcosahedronGeometry\nexport class IcosahedronBufferGeometry extends PolyhedronBufferGeometry {\n\tparameters: any; //{radius: number, detail:number}\n\tconstructor(radius: number, detail: number, points_only: boolean) {\n\t\tconst t = (1 + Math.sqrt(5)) / 2;\n\n\t\tconst vertices = [\n\t\t\t-1,\n\t\t\tt,\n\t\t\t0,\n\t\t\t1,\n\t\t\tt,\n\t\t\t0,\n\t\t\t-1,\n\t\t\t-t,\n\t\t\t0,\n\t\t\t1,\n\t\t\t-t,\n\t\t\t0,\n\t\t\t0,\n\t\t\t-1,\n\t\t\tt,\n\t\t\t0,\n\t\t\t1,\n\t\t\tt,\n\t\t\t0,\n\t\t\t-1,\n\t\t\t-t,\n\t\t\t0,\n\t\t\t1,\n\t\t\t-t,\n\t\t\tt,\n\t\t\t0,\n\t\t\t-1,\n\t\t\tt,\n\t\t\t0,\n\t\t\t1,\n\t\t\t-t,\n\t\t\t0,\n\t\t\t-1,\n\t\t\t-t,\n\t\t\t0,\n\t\t\t1,\n\t\t];\n\n\t\tconst indices = [\n\t\t\t0,\n\t\t\t11,\n\t\t\t5,\n\t\t\t0,\n\t\t\t5,\n\t\t\t1,\n\t\t\t0,\n\t\t\t1,\n\t\t\t7,\n\t\t\t0,\n\t\t\t7,\n\t\t\t10,\n\t\t\t0,\n\t\t\t10,\n\t\t\t11,\n\t\t\t1,\n\t\t\t5,\n\t\t\t9,\n\t\t\t5,\n\t\t\t11,\n\t\t\t4,\n\t\t\t11,\n\t\t\t10,\n\t\t\t2,\n\t\t\t10,\n\t\t\t7,\n\t\t\t6,\n\t\t\t7,\n\t\t\t1,\n\t\t\t8,\n\t\t\t3,\n\t\t\t9,\n\t\t\t4,\n\t\t\t3,\n\t\t\t4,\n\t\t\t2,\n\t\t\t3,\n\t\t\t2,\n\t\t\t6,\n\t\t\t3,\n\t\t\t6,\n\t\t\t8,\n\t\t\t3,\n\t\t\t8,\n\t\t\t9,\n\t\t\t4,\n\t\t\t9,\n\t\t\t5,\n\t\t\t2,\n\t\t\t4,\n\t\t\t11,\n\t\t\t6,\n\t\t\t2,\n\t\t\t10,\n\t\t\t8,\n\t\t\t6,\n\t\t\t7,\n\t\t\t9,\n\t\t\t8,\n\t\t\t1,\n\t\t];\n\n\t\tsuper(vertices, indices, radius, detail, points_only);\n\n\t\tthis.type = 'IcosahedronBufferGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\tdetail: detail,\n\t\t};\n\t}\n}\n","import {BaseSopOperation} from './_Base';\nimport {DefaultOperationParams} from '../_Base';\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {Vector3} from 'three/src/math/Vector3';\nimport {IcosahedronBufferGeometry} from '../../../core/geometry/operation/Icosahedron';\nimport {ObjectType} from '../../../core/geometry/Constant';\nimport {isBooleanTrue} from '../../../core/BooleanValue';\n\ninterface IcosahedronSopParams extends DefaultOperationParams {\n\tradius: number;\n\tdetail: number;\n\tpointsOnly: boolean;\n\tcenter: Vector3;\n}\n\nexport class IcosahedronSopOperation extends BaseSopOperation {\n\tstatic readonly DEFAULT_PARAMS: IcosahedronSopParams = {\n\t\tradius: 1,\n\t\tdetail: 0,\n\t\tpointsOnly: false,\n\t\tcenter: new Vector3(0, 0, 0),\n\t};\n\tstatic type(): Readonly<'icosahedron'> {\n\t\treturn 'icosahedron';\n\t}\n\n\tcook(input_contents: CoreGroup[], params: IcosahedronSopParams) {\n\t\tconst pointsOnly = isBooleanTrue(params.pointsOnly);\n\t\tconst geometry = new IcosahedronBufferGeometry(params.radius, params.detail, pointsOnly);\n\t\tgeometry.translate(params.center.x, params.center.y, params.center.z);\n\t\tif (pointsOnly) {\n\t\t\tconst object = this.create_object(geometry, ObjectType.POINTS);\n\t\t\treturn this.create_core_group_from_objects([object]);\n\t\t} else {\n\t\t\tgeometry.computeVertexNormals();\n\t\t\treturn this.create_core_group_from_geometry(geometry);\n\t\t}\n\t}\n}\n","import {Constructor} from '../../../../types/GlobalTypes';\nimport {BaseController} from './_BaseController';\nimport {TypedMatNode} from '../_Base';\nimport {Material} from 'three/src/materials/Material';\n\nimport {NodeParamsConfig, ParamConfig} from '../../utils/params/ParamsConfig';\nimport {isBooleanTrue} from '../../../../core/BooleanValue';\n\nenum LineCapType {\n\tROUND = 'round',\n\tBUTT = 'butt',\n\tSQUARE = 'square',\n}\nconst LINE_CAP_TYPES: LineCapType[] = [LineCapType.ROUND, LineCapType.BUTT, LineCapType.SQUARE];\n\nenum LineJoinType {\n\tROUND = 'round',\n\tBEVEL = 'bevel',\n\tMITER = 'miter',\n}\nconst LINE_JOIN_TYPES: LineJoinType[] = [LineJoinType.ROUND, LineJoinType.BEVEL, LineJoinType.MITER];\n\nexport function WireframeParamConfig<TBase extends Constructor>(Base: TBase) {\n\treturn class Mixin extends Base {\n\t\t/** @param toggle on to set material to wireframe */\n\t\twireframe = ParamConfig.BOOLEAN(0);\n\t\t/** @param define appearance of line ends */\n\t\twireframeLinecap = ParamConfig.INTEGER(0, {\n\t\t\tmenu: {\n\t\t\t\tentries: LINE_CAP_TYPES.map((name, value) => {\n\t\t\t\t\treturn {name, value};\n\t\t\t\t}),\n\t\t\t},\n\t\t\tvisibleIf: {wireframe: 1},\n\t\t});\n\t\t/** @param Define appearance of line joints */\n\t\twireframeLinejoin = ParamConfig.INTEGER(0, {\n\t\t\tmenu: {\n\t\t\t\tentries: LINE_JOIN_TYPES.map((name, value) => {\n\t\t\t\t\treturn {name, value};\n\t\t\t\t}),\n\t\t\t},\n\t\t\tvisibleIf: {wireframe: 1},\n\t\t});\n\t};\n}\n\nclass WireframedMaterial extends Material {\n\twireframe!: boolean;\n\twireframeLinecap!: string;\n\twireframeLinejoin!: string;\n}\nclass WireframeParamsConfig extends WireframeParamConfig(NodeParamsConfig) {}\nclass WireframedMatNode extends TypedMatNode<WireframedMaterial, WireframeParamsConfig> {\n\tcreateMaterial() {\n\t\treturn new WireframedMaterial();\n\t}\n}\n\nexport class WireframeController extends BaseController {\n\tconstructor(protected node: WireframedMatNode) {\n\t\tsuper(node);\n\t}\n\tstatic update(node: WireframedMatNode) {\n\t\tconst material = node.material;\n\t\tconst pv = node.pv;\n\n\t\tmaterial.wireframe = isBooleanTrue(pv.wireframe);\n\t\tmaterial.wireframeLinecap = LINE_CAP_TYPES[pv.wireframeLinecap];\n\t\tmaterial.wireframeLinejoin = LINE_JOIN_TYPES[pv.wireframeLinejoin];\n\t\tmaterial.needsUpdate = true;\n\t}\n}\n","/**\n * Creates a Mesh Basic Material\n *\n * @remarks\n * This material only emits a color and does not react to light. It is therefore the less resource intensive material.\n *\n */\n\nimport {MeshBasicMaterial} from 'three/src/materials/MeshBasicMaterial';\nimport {FrontSide} from 'three/src/constants';\nimport {TypedMatNode} from './_Base';\n\nimport {NodeParamsConfig} from '../utils/params/ParamsConfig';\nimport {ColorsController, ColorParamConfig} from './utils/ColorsController';\nimport {SideController, SideParamConfig} from './utils/SideController';\nimport {DepthController, DepthParamConfig} from './utils/DepthController';\nimport {SkinningController, SkinningParamConfig} from './utils/SkinningController';\nimport {TextureMapController, TextureMapParamConfig} from './utils/TextureMapController';\nimport {TextureAlphaMapController, TextureAlphaMapParamConfig} from './utils/TextureAlphaMapController';\nimport {WireframeController, WireframeParamConfig} from './utils/WireframeController';\nclass MeshBasicMatParamsConfig extends WireframeParamConfig(\n\tTextureAlphaMapParamConfig(\n\t\tTextureMapParamConfig(\n\t\t\tSkinningParamConfig(DepthParamConfig(SideParamConfig(ColorParamConfig(NodeParamsConfig))))\n\t\t)\n\t)\n) {}\nconst ParamsConfig = new MeshBasicMatParamsConfig();\n\nexport class MeshBasicMatNode extends TypedMatNode<MeshBasicMaterial, MeshBasicMatParamsConfig> {\n\tparams_config = ParamsConfig;\n\tstatic type() {\n\t\treturn 'meshBasic';\n\t}\n\n\tcreateMaterial() {\n\t\treturn new MeshBasicMaterial({\n\t\t\tvertexColors: false,\n\t\t\tside: FrontSide,\n\t\t\tcolor: 0xffffff,\n\t\t\topacity: 1,\n\t\t});\n\t}\n\treadonly texture_map_controller: TextureMapController = new TextureMapController(this, {direct_params: true});\n\treadonly texture_alpha_map_controller: TextureAlphaMapController = new TextureAlphaMapController(this, {\n\t\tdirect_params: true,\n\t});\n\treadonly depth_controller: DepthController = new DepthController(this);\n\tinitializeNode() {\n\t\tthis.params.onParamsCreated('init controllers', () => {\n\t\t\tthis.texture_map_controller.initializeNode();\n\t\t\tthis.texture_alpha_map_controller.initializeNode();\n\t\t});\n\t}\n\tasync cook() {\n\t\tColorsController.update(this);\n\t\tSideController.update(this);\n\t\tSkinningController.update(this);\n\t\tthis.texture_map_controller.update();\n\t\tthis.texture_alpha_map_controller.update();\n\t\tthis.depth_controller.update();\n\t\tWireframeController.update(this);\n\n\t\tthis.set_material(this.material);\n\t}\n}\n","import {Color} from 'three/src/math/Color';\nimport {OctahedronBufferGeometry} from 'three/src/geometries/OctahedronGeometry';\nimport {BufferAttribute} from 'three/src/core/BufferAttribute';\n\nimport {HemisphereLightObjNode} from '../../HemisphereLight';\nimport {Quaternion} from 'three/src/math/Quaternion';\nimport {Vector3} from 'three/src/math/Vector3';\nimport {BaseLightHelper} from './_BaseLightHelper';\nimport {HemisphereLight} from 'three/src/lights/HemisphereLight';\nimport {Mesh} from 'three/src/objects/Mesh';\n\nexport class HemisphereLightHelper extends BaseLightHelper<Mesh, HemisphereLight, HemisphereLightObjNode> {\n\tcreateObject() {\n\t\treturn new Mesh();\n\t}\n\tprivate _geometry = new OctahedronBufferGeometry(1);\n\n\tprotected buildHelper() {\n\t\tthis._geometry.rotateZ(Math.PI * 0.5);\n\n\t\tthis._material.vertexColors = true;\n\n\t\tconst position = this._geometry.getAttribute('position');\n\t\tconst colors = new Float32Array(position.count * 3);\n\n\t\tthis._geometry.setAttribute('color', new BufferAttribute(colors, 3));\n\t\tthis._object.geometry = this._geometry;\n\t\tthis._object.material = this._material;\n\t\tthis._object.matrixAutoUpdate = false;\n\t}\n\n\t// private _inverse_position = new Vector3();\n\tprivate _quat = new Quaternion();\n\tprivate _default_position = new Vector3(0, 1, 0);\n\tprivate _color1 = new Color();\n\tprivate _color2 = new Color();\n\tupdate() {\n\t\tif (!this.node.pv.position) {\n\t\t\treturn;\n\t\t}\n\t\t// this._inverse_position.copy(this.node.pv.position).multiplyScalar(-1)\n\t\tthis._object.position.copy(this.node.pv.position).multiplyScalar(-1);\n\t\tthis._quat.setFromUnitVectors(this._default_position, this.node.pv.position);\n\t\tthis._object.setRotationFromQuaternion(this._quat);\n\t\tthis._object.scale.setScalar(this.node.pv.helperSize);\n\t\tthis._object.updateMatrix();\n\n\t\tconst colors = this._geometry.getAttribute('color') as BufferAttribute;\n\n\t\tthis._color1.copy(this.node.light.color);\n\t\tthis._color2.copy(this.node.light.groundColor);\n\n\t\tfor (let i = 0, l = colors.count; i < l; i++) {\n\t\t\tconst color = i < l / 2 ? this._color1 : this._color2;\n\n\t\t\tcolors.setXYZ(i, color.r, color.g, color.b);\n\t\t}\n\n\t\tcolors.needsUpdate = true;\n\t}\n}\n","/**\n * Creates a hemisphere light.\n *\n *\n */\nimport {HemisphereLight} from 'three/src/lights/HemisphereLight';\nimport {HemisphereLightHelper} from './utils/helpers/HemisphereLightHelper';\nimport {TypedLightObjNode} from './_BaseLight';\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {HelperController, HelperConstructor} from './utils/HelperController';\nimport {ColorConversion} from '../../../core/Color';\nimport {Color} from 'three/src/math/Color';\nimport {Mesh} from 'three/src/objects/Mesh';\n\nconst DEFAULT = {\n\tskyColor: new Color(1, 1, 1),\n\tgroundColor: new Color(0, 0, 0),\n};\nclass HemisphereLightObjParamsConfig extends NodeParamsConfig {\n\t/** @param sky color */\n\tskyColor = ParamConfig.COLOR(DEFAULT.skyColor, {\n\t\tconversion: ColorConversion.SRGB_TO_LINEAR,\n\t});\n\t/** @param ground color */\n\tgroundColor = ParamConfig.COLOR(DEFAULT.groundColor, {\n\t\tconversion: ColorConversion.SRGB_TO_LINEAR,\n\t});\n\t/** @param light intensity */\n\tintensity = ParamConfig.FLOAT(1);\n\t/** @param light position */\n\tposition = ParamConfig.VECTOR3([0, 1, 0]);\n\t/** @param toggle to show helper */\n\tshowHelper = ParamConfig.BOOLEAN(0);\n\t/** @param helper size */\n\thelperSize = ParamConfig.FLOAT(1, {visibleIf: {showHelper: 1}});\n}\nconst ParamsConfig = new HemisphereLightObjParamsConfig();\n\nexport class HemisphereLightObjNode extends TypedLightObjNode<HemisphereLight, HemisphereLightObjParamsConfig> {\n\tparams_config = ParamsConfig;\n\tstatic type() {\n\t\treturn 'hemisphereLight';\n\t}\n\tprivate _helper_controller = new HelperController<Mesh, HemisphereLight>(\n\t\tthis,\n\t\t(<unknown>HemisphereLightHelper) as HelperConstructor<Mesh, HemisphereLight>,\n\t\t'HemisphereLightHelper'\n\t);\n\n\tcreate_light() {\n\t\tconst light = new HemisphereLight();\n\t\tlight.matrixAutoUpdate = false;\n\t\t// make sure the light is initialized with same defaults as the node parameters\n\t\tlight.color.copy(DEFAULT.skyColor);\n\t\tlight.groundColor.copy(DEFAULT.groundColor);\n\t\treturn light;\n\t}\n\tinitializeNode() {\n\t\tthis.io.inputs.setCount(0, 1);\n\t\tthis._helper_controller.initializeNode();\n\t}\n\n\tupdate_light_params() {\n\t\tthis.light.color = this.pv.skyColor;\n\t\tthis.light.groundColor = this.pv.groundColor;\n\t\tthis.light.position.copy(this.pv.position);\n\t\tthis.light.intensity = this.pv.intensity;\n\n\t\tthis._helper_controller.update();\n\t}\n}\n","import {Vector3} from 'three/src/math/Vector3';\nimport {BufferGeometry} from 'three/src/core/BufferGeometry';\nimport {BufferAttribute} from 'three/src/core/BufferAttribute';\nimport {TypeAssert} from '../../../engine/poly/Assert';\n\nexport enum PointsCountMode {\n\tSEGMENTS_COUNT = 'segments count',\n\tSEGMENTS_LENGTH = 'segments length',\n}\nexport const POINTS_COUNT_MODE: PointsCountMode[] = [PointsCountMode.SEGMENTS_COUNT, PointsCountMode.SEGMENTS_LENGTH];\nexport enum JoinMode {\n\tABC = 'abc',\n\tACB = 'acb',\n\tAB = 'ab',\n\tBC = 'bc',\n\tAC = 'ac',\n}\nexport const JOIN_MODES: JoinMode[] = [JoinMode.ABC, JoinMode.ACB, JoinMode.AB, JoinMode.AC, JoinMode.BC];\n\ninterface Circle3PointsParameters {\n\tarc: boolean;\n\tcenter: boolean;\n\tpointsCountMode: PointsCountMode;\n\tsegmentsLength: number;\n\tsegmentsCount: number;\n\tfull: boolean;\n\tjoinMode: JoinMode;\n\taddIdAttribute: boolean;\n\taddIdnAttribute: boolean;\n}\ninterface CreatedGeometries {\n\tarc?: BufferGeometry;\n\tcenter?: BufferGeometry;\n}\n\nexport class Circle3Points {\n\tprivate a: Vector3 = new Vector3();\n\tprivate b: Vector3 = new Vector3();\n\tprivate c: Vector3 = new Vector3();\n\tprivate an: Vector3 = new Vector3();\n\tprivate bn: Vector3 = new Vector3();\n\tprivate cn: Vector3 = new Vector3();\n\tprivate ac: Vector3 = new Vector3();\n\tprivate ab: Vector3 = new Vector3();\n\tprivate ab_x_ac: Vector3 = new Vector3();\n\tprivate part0: Vector3 = new Vector3();\n\tprivate part1: Vector3 = new Vector3();\n\tprivate divider: number = 1;\n\tprivate a_center: Vector3 = new Vector3();\n\tprivate center: Vector3 = new Vector3();\n\tprivate normal: Vector3 = new Vector3();\n\tprivate radius: number = 1;\n\tprivate x: Vector3 = new Vector3();\n\tprivate y: Vector3 = new Vector3();\n\tprivate z: Vector3 = new Vector3();\n\tprivate angle_ab: number = 1;\n\tprivate angle_ac: number = 1;\n\tprivate angle_bc: number = 1;\n\tprivate angle: number = 2 * Math.PI;\n\tprivate x_rotated: Vector3 = new Vector3();\n\n\tprivate _created_geometries: CreatedGeometries = {};\n\n\tconstructor(private params: Circle3PointsParameters) {}\n\n\tcreated_geometries() {\n\t\treturn this._created_geometries;\n\t}\n\n\tcreate(a: Vector3, b: Vector3, c: Vector3) {\n\t\tthis.a.copy(a);\n\t\tthis.b.copy(b);\n\t\tthis.c.copy(c);\n\t\tthis._compute_axis();\n\t\tthis._create_arc();\n\t\tthis._create_center();\n\t}\n\n\tprivate _create_arc() {\n\t\tthis._compute_angle();\n\t\tconst points_count = this._points_count();\n\t\tconst positions: number[] = new Array(points_count * 3);\n\t\tconst indices: number[] = new Array(points_count);\n\n\t\tconst angle_increment = this.angle / (points_count - 1);\n\t\tthis.x_rotated.copy(this.x).multiplyScalar(this.radius);\n\t\tlet i = 0;\n\t\tfor (i = 0; i < points_count; i++) {\n\t\t\tthis.x_rotated\n\t\t\t\t.copy(this.x)\n\t\t\t\t.applyAxisAngle(this.normal, angle_increment * i)\n\t\t\t\t.multiplyScalar(this.radius)\n\t\t\t\t.add(this.center);\n\t\t\tthis.x_rotated.toArray(positions, i * 3);\n\n\t\t\tif (i > 0) {\n\t\t\t\tindices[(i - 1) * 2] = i - 1;\n\t\t\t\tindices[(i - 1) * 2 + 1] = i;\n\t\t\t}\n\t\t}\n\t\tif (this.params.full) {\n\t\t\t// also add the last segment\n\t\t\tindices.push(i - 1);\n\t\t\tindices.push(0);\n\t\t}\n\t\tconst geometry = new BufferGeometry();\n\t\tgeometry.setAttribute('position', new BufferAttribute(new Float32Array(positions), 3));\n\t\tgeometry.setIndex(indices);\n\t\tif (this.params.addIdAttribute || this.params.addIdnAttribute) {\n\t\t\tconst ids: number[] = new Array(points_count);\n\t\t\tfor (let i = 0; i < ids.length; i++) {\n\t\t\t\tids[i] = i;\n\t\t\t}\n\t\t\tif (this.params.addIdAttribute) {\n\t\t\t\tgeometry.setAttribute('id', new BufferAttribute(new Float32Array(ids), 1));\n\t\t\t}\n\t\t\tconst idns = ids.map((id) => id / (points_count - 1));\n\t\t\tif (this.params.addIdnAttribute) {\n\t\t\t\tgeometry.setAttribute('idn', new BufferAttribute(new Float32Array(idns), 1));\n\t\t\t}\n\t\t}\n\t\tthis._created_geometries.arc = geometry;\n\t}\n\tprivate _create_center() {\n\t\tif (!this.params.center) {\n\t\t\treturn;\n\t\t}\n\t\tconst geometry = new BufferGeometry();\n\t\tconst positions = [this.center.x, this.center.y, this.center.z];\n\t\tgeometry.setAttribute('position', new BufferAttribute(new Float32Array(positions), 3));\n\t\tthis._created_geometries.center = geometry;\n\t}\n\n\tprivate _compute_axis() {\n\t\tthis.ac.copy(this.c).sub(this.a);\n\t\tthis.ab.copy(this.b).sub(this.a);\n\t\tthis.ab_x_ac.copy(this.ab).cross(this.ac);\n\t\tthis.divider = 2.0 * this.ab_x_ac.lengthSq();\n\t\tthis.part0.copy(this.ab_x_ac).cross(this.ab).multiplyScalar(this.ac.lengthSq());\n\t\tthis.part1.copy(this.ac).cross(this.ab_x_ac).multiplyScalar(this.ab.lengthSq());\n\t\tthis.a_center.copy(this.part0).add(this.part1).divideScalar(this.divider);\n\t\tthis.radius = this.a_center.length();\n\t\tthis.normal.copy(this.ab_x_ac).normalize();\n\t\tthis.center.copy(this.a).add(this.a_center);\n\t}\n\tprivate _compute_angle() {\n\t\tif (!this.params.arc) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (this.params.full) {\n\t\t\tthis.x.copy(this.a).sub(this.center).normalize();\n\t\t\tthis.angle = 2 * Math.PI;\n\t\t} else {\n\t\t\tthis.an.copy(this.a).sub(this.center).normalize();\n\t\t\tthis.bn.copy(this.b).sub(this.center).normalize();\n\t\t\tthis.cn.copy(this.c).sub(this.center).normalize();\n\n\t\t\tthis._set_x_from_joinMode();\n\t\t\tthis.y.copy(this.normal);\n\t\t\tthis.z.copy(this.x).cross(this.y).normalize();\n\n\t\t\tthis.angle_ab = this.an.angleTo(this.bn);\n\t\t\tthis.angle_ac = this.an.angleTo(this.cn);\n\t\t\tthis.angle_bc = this.bn.angleTo(this.cn);\n\n\t\t\tthis._set_angle_from_joinMode();\n\t\t}\n\t}\n\n\tprivate _points_count() {\n\t\tconst mode = this.params.pointsCountMode;\n\t\tswitch (mode) {\n\t\t\tcase PointsCountMode.SEGMENTS_COUNT: {\n\t\t\t\treturn this.params.segmentsCount + 1;\n\t\t\t}\n\t\t\tcase PointsCountMode.SEGMENTS_LENGTH: {\n\t\t\t\tlet perimeter = Math.PI * this.radius * this.radius;\n\t\t\t\tif (!this.params.full) {\n\t\t\t\t\tperimeter *= Math.abs(this.angle) / (Math.PI * 2);\n\t\t\t\t}\n\t\t\t\treturn Math.ceil(perimeter / this.params.segmentsLength);\n\t\t\t}\n\t\t}\n\t\tTypeAssert.unreachable(mode);\n\t}\n\tprivate _set_x_from_joinMode() {\n\t\tconst joinMode = this.params.joinMode;\n\t\tthis.x.copy(this.a).sub(this.center).normalize();\n\t\tswitch (joinMode) {\n\t\t\tcase JoinMode.ABC: {\n\t\t\t\treturn this.x.copy(this.an);\n\t\t\t}\n\t\t\tcase JoinMode.ACB: {\n\t\t\t\treturn this.x.copy(this.an);\n\t\t\t}\n\t\t\tcase JoinMode.AB: {\n\t\t\t\treturn this.x.copy(this.an);\n\t\t\t}\n\t\t\tcase JoinMode.AC: {\n\t\t\t\treturn this.x.copy(this.an);\n\t\t\t}\n\t\t\tcase JoinMode.BC: {\n\t\t\t\treturn this.x.copy(this.bn);\n\t\t\t}\n\t\t}\n\t\tTypeAssert.unreachable(joinMode);\n\t}\n\tprivate _set_angle_from_joinMode(): void {\n\t\tconst joinMode = this.params.joinMode;\n\t\tswitch (joinMode) {\n\t\t\tcase JoinMode.ABC: {\n\t\t\t\tthis.angle = this.angle_ab + this.angle_bc;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tcase JoinMode.ACB: {\n\t\t\t\tthis.angle = this.angle_ac + this.angle_bc;\n\t\t\t\tthis.angle *= -1;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tcase JoinMode.AB: {\n\t\t\t\tthis.angle = this.angle_ab;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tcase JoinMode.AC: {\n\t\t\t\tthis.angle = this.angle_ac;\n\t\t\t\tthis.angle *= -1;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tcase JoinMode.BC: {\n\t\t\t\tthis.angle = this.angle_bc;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tTypeAssert.unreachable(joinMode);\n\t}\n}\n","/**\n * Creates a circle from 3 points.\n *\n *\n */\nimport {TypedSopNode} from './_Base';\nimport {InputCloneMode} from '../../poly/InputCloneMode';\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {CorePoint} from '../../../core/geometry/Point';\nimport {Vector3} from 'three/src/math/Vector3';\nimport {ObjectType} from '../../../core/geometry/Constant';\nimport {Object3D} from 'three/src/core/Object3D';\n\nimport {\n\tPointsCountMode,\n\tPOINTS_COUNT_MODE,\n\tJoinMode,\n\tJOIN_MODES,\n\tCircle3Points,\n} from '../../../core/geometry/operation/Circle3Points';\n\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {isBooleanTrue} from '../../../core/BooleanValue';\nclass Circle3PointsSopParamsConfig extends NodeParamsConfig {\n\t/** @param toggle on to create the arc */\n\tarc = ParamConfig.BOOLEAN(1);\n\t/** @param sets the mode how the points count is computed */\n\tpointsCountMode = ParamConfig.INTEGER(POINTS_COUNT_MODE.indexOf(PointsCountMode.SEGMENTS_COUNT), {\n\t\tvisibleIf: {arc: 1},\n\t\tmenu: {\n\t\t\tentries: POINTS_COUNT_MODE.map((name, value) => {\n\t\t\t\treturn {value, name};\n\t\t\t}),\n\t\t},\n\t});\n\t/** @param length of each segment */\n\tsegmentsLength = ParamConfig.FLOAT(0.1, {\n\t\tvisibleIf: {arc: 1, pointsCountMode: POINTS_COUNT_MODE.indexOf(PointsCountMode.SEGMENTS_LENGTH)},\n\t\trange: [0, 1],\n\t\trangeLocked: [true, false],\n\t});\n\t/** @param count of the number of segments */\n\tsegmentsCount = ParamConfig.INTEGER(100, {\n\t\tvisibleIf: {arc: 1, pointsCountMode: POINTS_COUNT_MODE.indexOf(PointsCountMode.SEGMENTS_COUNT)},\n\t\trange: [1, 100],\n\t\trangeLocked: [true, false],\n\t});\n\t/** @param toggle on to create a full circle */\n\tfull = ParamConfig.BOOLEAN(1, {\n\t\tvisibleIf: {arc: 1},\n\t});\n\t/** @param TBD */\n\tjoinMode = ParamConfig.INTEGER(JOIN_MODES.indexOf(JoinMode.ABC), {\n\t\tvisibleIf: {arc: 1, full: 0},\n\t\tmenu: {\n\t\t\tentries: JOIN_MODES.map((name, value) => {\n\t\t\t\treturn {value, name};\n\t\t\t}),\n\t\t},\n\t});\n\t/** @param add an id attribute for the generated points */\n\taddIdAttribute = ParamConfig.BOOLEAN(1);\n\t/** @param add an idn attribute (same as id attribute, but normalized between 0 and 1) */\n\taddIdnAttribute = ParamConfig.BOOLEAN(1);\n\t/** @param toggle on to create a point in the center */\n\tcenter = ParamConfig.BOOLEAN(0);\n}\nconst ParamsConfig = new Circle3PointsSopParamsConfig();\n\nexport class Circle3PointsSopNode extends TypedSopNode<Circle3PointsSopParamsConfig> {\n\tparams_config = ParamsConfig;\n\tstatic type() {\n\t\treturn 'circle3Points';\n\t}\n\n\tinitializeNode() {\n\t\tthis.io.inputs.setCount(1);\n\t\tthis.io.inputs.initInputsClonedState([InputCloneMode.NEVER]);\n\t}\n\n\tcook(input_contents: CoreGroup[]) {\n\t\tconst core_group = input_contents[0];\n\t\tconst points = core_group.points();\n\t\tif (points.length < 3) {\n\t\t\tthis.states.error.set(`only ${points.length} points found, when 3 are required`);\n\t\t} else {\n\t\t\tthis._create_circle(points);\n\t\t}\n\t}\n\n\tprivate a: Vector3 = new Vector3();\n\tprivate b: Vector3 = new Vector3();\n\tprivate c: Vector3 = new Vector3();\n\n\tprivate _create_circle(points: CorePoint[]) {\n\t\tconst circle3points = new Circle3Points({\n\t\t\tarc: isBooleanTrue(this.pv.arc),\n\t\t\tcenter: isBooleanTrue(this.pv.center),\n\t\t\tpointsCountMode: POINTS_COUNT_MODE[this.pv.pointsCountMode],\n\t\t\tsegmentsLength: this.pv.segmentsLength,\n\t\t\tsegmentsCount: this.pv.segmentsCount,\n\t\t\tfull: isBooleanTrue(this.pv.full),\n\t\t\tjoinMode: JOIN_MODES[this.pv.joinMode],\n\t\t\taddIdAttribute: isBooleanTrue(this.pv.addIdAttribute),\n\t\t\taddIdnAttribute: isBooleanTrue(this.pv.addIdnAttribute),\n\t\t});\n\t\tpoints[0].getPosition(this.a);\n\t\tpoints[1].getPosition(this.b);\n\t\tpoints[2].getPosition(this.c);\n\t\tcircle3points.create(this.a, this.b, this.c);\n\n\t\tconst objects: Object3D[] = [];\n\t\tconst created_geometries = circle3points.created_geometries();\n\t\tif (created_geometries.arc) {\n\t\t\tobjects.push(this.create_object(created_geometries.arc, ObjectType.LINE_SEGMENTS));\n\t\t}\n\t\tif (created_geometries.center) {\n\t\t\tobjects.push(this.create_object(created_geometries.center, ObjectType.POINTS));\n\t\t}\n\n\t\tthis.setObjects(objects);\n\t}\n}\n","import {BaseSopOperation} from './_Base';\nimport {DefaultOperationParams} from '../_Base';\nimport {CoreGroup} from '../../../core/geometry/Group';\nimport {Vector3} from 'three/src/math/Vector3';\nimport {CoreGeometryUtilCircle} from '../../../core/geometry/util/Circle';\nimport {ObjectType} from '../../../core/geometry/Constant';\nimport {CoreTransform} from '../../../core/Transform';\nimport {CircleBufferGeometry} from 'three/src/geometries/CircleGeometry';\nimport {isBooleanTrue} from '../../../core/BooleanValue';\n\ninterface CircleSopParams extends DefaultOperationParams {\n\tradius: number;\n\tsegments: number;\n\topen: boolean;\n\tarcAngle: number;\n\tdirection: Vector3;\n}\nconst DEFAULT_UP = new Vector3(0, 0, 1);\n\nexport class CircleSopOperation extends BaseSopOperation {\n\tstatic readonly DEFAULT_PARAMS: CircleSopParams = {\n\t\tradius: 1,\n\t\tsegments: 12,\n\t\topen: true,\n\t\tarcAngle: 360,\n\t\tdirection: new Vector3(0, 1, 0),\n\t};\n\tstatic type(): Readonly<'circle'> {\n\t\treturn 'circle';\n\t}\n\n\tprivate _core_transform = new CoreTransform();\n\tcook(input_contents: CoreGroup[], params: CircleSopParams) {\n\t\tif (isBooleanTrue(params.open)) {\n\t\t\treturn this._create_circle(params);\n\t\t} else {\n\t\t\treturn this._create_disk(params);\n\t\t}\n\t}\n\tprivate _create_circle(params: CircleSopParams) {\n\t\tconst geometry = CoreGeometryUtilCircle.create(params.radius, params.segments, params.arcAngle);\n\n\t\tthis._core_transform.rotate_geometry(geometry, DEFAULT_UP, params.direction);\n\n\t\treturn this.create_core_group_from_geometry(geometry, ObjectType.LINE_SEGMENTS);\n\t}\n\n\tprivate _create_disk(params: CircleSopParams) {\n\t\tconst geometry = new CircleBufferGeometry(params.radius, params.segments);\n\n\t\tthis._core_transform.rotate_geometry(geometry, DEFAULT_UP, params.direction);\n\n\t\treturn this.create_core_group_from_geometry(geometry);\n\t}\n}\n","import {CoreMath} from '../../math/_Module'\nimport {Vector2} from 'three/src/math/Vector2'\nimport {Float32BufferAttribute} from 'three/src/core/BufferAttribute'\nimport {BufferGeometry} from 'three/src/core/BufferGeometry'\n\nexport class CoreGeometryUtilCircle {\n\tstatic positions(\n\t\tradius: number,\n\t\tsegments_count: number,\n\t\tarc_angle: number = 360\n\t) {\n\t\tconst radian_per_segment =\n\t\t\tCoreMath.degrees_to_radians(arc_angle) / segments_count\n\n\t\tconst positions = []\n\t\tfor (let i = 0; i < segments_count; i++) {\n\t\t\tconst point_radian = radian_per_segment * i\n\t\t\tconst x = radius * Math.cos(point_radian)\n\t\t\tconst y = radius * Math.sin(point_radian)\n\n\t\t\tpositions.push(new Vector2(x, y))\n\t\t}\n\n\t\treturn positions\n\t}\n\n\tstatic create(\n\t\tradius: number,\n\t\tsegments_count: number,\n\t\tarc_angle: number = 360\n\t) {\n\t\tconst positions_2d = this.positions(radius, segments_count, arc_angle)\n\n\t\tconst positions = []\n\t\tconst indices = []\n\t\tlet position_2d\n\t\tfor (let i = 0; i < positions_2d.length; i++) {\n\t\t\tposition_2d = positions_2d[i]\n\n\t\t\tpositions.push(position_2d.x)\n\t\t\tpositions.push(position_2d.y)\n\t\t\tpositions.push(0)\n\n\t\t\tif (i > 0) {\n\t\t\t\tindices.push(i - 1)\n\t\t\t\tindices.push(i)\n\t\t\t}\n\t\t}\n\n\t\t// also add the last segment\n\t\tindices.push(segments_count - 1)\n\t\tindices.push(0)\n\n\t\tconst geometry = new BufferGeometry()\n\t\tgeometry.setAttribute(\n\t\t\t'position',\n\t\t\tnew Float32BufferAttribute(positions, 3)\n\t\t)\n\t\tgeometry.setIndex(indices)\n\n\t\treturn geometry\n\t}\n}\n"],"sourceRoot":""}